language: go_test.go
name: HumanEval_148_bf
results:
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var i1, i2 int\n    for i, x := range planets {\n        if\
    \ x == planet1 {\n            i1 = i\n        }\n        if x == planet2 {\n \
    \           i2 = i\n        }\n    }\n    if i1 > i2 {\n        i1, i2 = i2, i1\n\
    \    }\n    return planets[i1+1:i2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp12fpjtxj_test.go:38:19: cannot use planets[i1 + 1:i2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074314
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\n\
    \        \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\",\n    }\n    var isFirstFound, isSecondFound bool\n\
    \    var index1, index2 int\n    for i, v := range planets {\n        if planet1\
    \ == v {\n            isFirstFound = true\n            index1 = i\n        }\n\
    \        if planet2 == v {\n            isSecondFound = true\n            index2\
    \ = i\n        }\n    }\n    if isFirstFound && isSecondFound {\n        if index1\
    \ < index2 {\n            return planets[index1+1:index2]\n        } else {\n\
    \            return planets[index2+1:index1]\n        }\n    } else {\n      \
    \  return nil\n    }\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2a3bvg6k_test.go:42:27: cannot use planets[index1 + 1:index2] (value of
    type []string) as type []interface{} in return statement

    /tmp/tmp2a3bvg6k_test.go:44:27: cannot use planets[index2 + 1:index1] (value of
    type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"\
    Mercury\" {\n        if planet2 == \"Mercury\" {\n            return []interface{}\
    \ { }\n        } else if planet2 == \"Venus\" {\n            return []interface{}\
    \ { \"Venus\" }\n        } else if planet2 == \"Earth\" {\n            return\
    \ []interface{} { \"Venus\", \"Earth\" }\n        } else if planet2 == \"Mars\"\
    \ {\n            return []interface{} { \"Venus\", \"Earth\", \"Mars\" }\n   \
    \     } else if planet2 == \"Jupiter\" {\n            return []interface{} { \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\" }\n        } else if planet2 == \"Saturn\"\
    \ {\n            return []interface{} { \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\" }\n        } else if planet2 == \"Uranus\" {\n            return\
    \ []interface{} { \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\" }\n        } else if planet2 == \"Neptune\" {\n            return []interface{}\
    \ { \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    \ }\n        } else {\n            return []interface{} { }\n        }\n    }\
    \ else if planet1 == \"Venus\" {\n        if planet2 == \"Mercury\" {\n      \
    \      return []interface{} { }\n        } else if planet2 == \"Venus\" {\n  \
    \          return []interface{} { }\n        } else if planet2 == \"Earth\" {\n\
    \            return []interface{} { \"Earth\" }\n        } else if planet2 ==\
    \ \"Mars\" {\n            return []interface{} { \"Earth\", \"Mars\" }\n     \
    \   } else if planet2 == \"Jupiter\" {\n            return []interface{} { \"\
    Earth\", \"Mars\", \"Jupiter\" }\n        } else if planet2 == \"Saturn\" {\n\
    \            return []interface{} { \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    \ }\n        } else if planet2 == \"Uranus\" {\n            return []interface{}\
    \ { \"Earth\", \"Mars\", \"Jupiter\",\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuz4w6fu0_test.go:60:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074313
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planetNames := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1Index := -1\n    planet2Index := -1\n    for i, name\
    \ := range planetNames {\n        if name == planet1 {\n            planet1Index\
    \ = i\n        }\n        if name == planet2 {\n            planet2Index = i\n\
    \        }\n    }\n    var result []interface{}\n    if planet1Index > planet2Index\
    \ {\n        for i := planet2Index + 1; i < planet1Index; i++ {\n            result\
    \ = append(result, planetNames[i])\n        }\n    } else {\n        for i :=\
    \ planet1Index + 1; i < planet2Index; i++ {\n            result = append(result,\
    \ planetNames[i])\n        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpj0ajvsu__test.go:68: expected '[]', got '[Mercury Venus Earth Mars]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\n\
    \        \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\",\n    }\n    pos1 := -1\n    pos2 := -1\n    for i,\
    \ p := range planets {\n        if p == planet1 {\n            pos1 = i\n    \
    \    }\n        if p == planet2 {\n            pos2 = i\n        }\n    }\n  \
    \  var res []interface{}\n    if pos1 == -1 || pos2 == -1 {\n        return res\n\
    \    }\n    min, max := pos1, pos2\n    if pos1 > pos2 {\n        min, max = pos2,\
    \ pos1\n    }\n    for i := min+1; i < max; i++ {\n        res = append(res, planets[i])\n\
    \    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074314
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\tplanets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n\tstartIndex := 0\n\tendIndex := 0\n\tfoundStart := false\n\t\
    foundEnd := false\n\tfor i, planet := range planets {\n\t\tif planet == planet1\
    \ {\n\t\t\tstartIndex = i\n\t\t\tfoundStart = true\n\t\t}\n\t\tif planet == planet2\
    \ {\n\t\t\tendIndex = i\n\t\t\tfoundEnd = true\n\t\t}\n\t}\n\tif !foundStart ||\
    \ !foundEnd {\n\t\treturn []interface{}{}\n\t}\n\tif startIndex > endIndex {\n\
    \t\tstartIndex, endIndex = endIndex, startIndex\n\t}\n\treturn planets[startIndex+1:endIndex]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6i99j0qa_test.go:46:16: cannot use planets[startIndex + 1:endIndex] (value
    of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074314
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet_names := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1, p2 := -1, -1\n    for i, p := range planet_names {\n \
    \       if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 < p2 {\n        return planet_names[p1+1:p2]\n\
    \    } else {\n        return planet_names[p2+1:p1]\n    }\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9l6z031v_test.go:39:28: cannot use planet_names[p1 + 1:p2] (value of type
    []string) as type []interface{} in return statement

    /tmp/tmp9l6z031v_test.go:41:28: cannot use planet_names[p2 + 1:p1] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074314
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    var result []interface{}\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            start = i\n\
    \        }\n        if p == planet2 {\n            end = i\n        }\n    }\n\
    \    if start > end {\n        start, end = end, start\n    }\n    if start !=\
    \ 0 && end != 0 {\n        result = planets[start+1:end]\n    } else {\n     \
    \   result = []interface{}{}\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8j08xgbe_test.go:40:25: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074314
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\n\
    \        \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\"\
    ,\n        \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"\
    Neptune\",\n    }\n    fromIdx := -1\n    toIdx := -1\n    for idx, planet :=\
    \ range planets {\n        if planet == planet1 {\n            fromIdx = idx\n\
    \        }\n        if planet == planet2 {\n            toIdx = idx\n        }\n\
    \    }\n    if fromIdx == -1 || toIdx == -1 {\n        return []interface{}{}\n\
    \    }\n    planetsList := []interface{}{}\n    if fromIdx < toIdx {\n       \
    \ for i := fromIdx + 1; i < toIdx; i++ {\n            planetsList = append(planetsList,\
    \ planets[i])\n        }\n    } else {\n        for i := toIdx + 1; i < fromIdx;\
    \ i++ {\n            planetsList = append(planetsList, planets[i])\n        }\n\
    \    }\n    return planetsList\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var start, end int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            start = i\n\
    \        }\n        if v == planet2 {\n            end = i\n        }\n    }\n\
    \    if start == end {\n        return result\n    }\n    if start > end {\n \
    \       end, start = start, end\n    }\n    for i := start + 1; i < end; i++ {\n\
    \        result = append(result, planets[i])\n    }\n    return result\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpu6dvzl80_test.go:67: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return []interface{}\
    \ {\n    }\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmp0uoqgo48_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmp0uoqgo48_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmp0uoqgo48_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmp0uoqgo48_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074315
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    pos_1 := -1\n    pos_2 := -1\n    pos := -1\n    for i, s\
    \ := range planets {\n        if s == planet1 {\n            pos_1 = i\n     \
    \   }\n        if s == planet2 {\n            pos_2 = i\n        }\n    }\n  \
    \  if pos_1 < 0 || pos_2 < 0 {\n        return []interface{}{}\n    } else if\
    \ pos_1 > pos_2 {\n        pos = pos_1\n        pos_1 = pos_2\n        pos_2 =\
    \ pos\n    }\n    return planets[pos_1+1:pos_2]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnze9qwxu_test.go:44:19: cannot use planets[pos_1 + 1:pos_2] (value of
    type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\treturn nil\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpmbs499r0_test.go:47: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpmbs499r0_test.go:47: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpmbs499r0_test.go:47:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpmbs499r0_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    res := []interface{}{}\n    for i, planet := range planets\
    \ {\n        if planet == planet1 {\n            for j, planet := range planets\
    \ {\n                if planet == planet2 {\n                    for k := i +\
    \ 1; k < j; k++ {\n                        res = append(res, planets[k])\n   \
    \                 }\n                    return res\n                }\n     \
    \       }\n        }\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp_z55eef__test.go:61: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmp_z55eef__test.go:61: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var List []interface{}\n\
    \    if planet1 == \"Mercury\" {\n        List = append(List, \"Venus\")\n   \
    \ } else if planet1 == \"Venus\" {\n        List = append(List, \"Earth\")\n \
    \   } else if planet1 == \"Earth\" {\n        List = append(List, \"Mars\")\n\
    \    } else if planet1 == \"Mars\" {\n        List = append(List, \"Jupiter\"\
    )\n    } else if planet1 == \"Jupiter\" {\n        List = append(List, \"Saturn\"\
    )\n    } else if planet1 == \"Saturn\" {\n        List = append(List, \"Uranus\"\
    )\n    } else if planet1 == \"Uranus\" {\n        List = append(List, \"Neptune\"\
    )\n    } else if planet1 == \"Neptune\" {\n        List = append(List, \"Mercury\"\
    )\n    }\n    if planet2 == \"Mercury\" {\n        List = append(List, \"Venus\"\
    )\n    } else if planet2 == \"Venus\" {\n        List = append(List, \"Earth\"\
    )\n    } else if planet2 == \"Earth\" {\n        List = append(List, \"Mars\"\
    )\n    } else if planet2 == \"Mars\" {\n        List = append(List, \"Jupiter\"\
    )\n    } else if planet2 == \"Jupiter\" {\n        List = append(List, \"Saturn\"\
    )\n    } else if planet2 == \"Saturn\" {\n        List = append(List, \"Uranus\"\
    )\n    } else if planet2 == \"Uranus\" {\n        List = append(List, \"Neptune\"\
    )\n    } else if planet2 == \"Neptune\" {\n        List = append(List, \"Mercury\"\
    )\n    }\n    return List\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmp8svispxp_test.go:82: expected '[Saturn Uranus]', got '[Saturn Mercury]'\n\
    \    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmp8svispxp_test.go:82: expected\
    \ '[Venus]', got '[Mars Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n  \
    \      tmp8svispxp_test.go:82: expected '[Venus Earth Mars Jupiter Saturn]', got\
    \ '[Venus Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmp8svispxp_test.go:82:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Mercury Earth]'\n    ---\
    \ FAIL: TestBf/test_num__4 (0.00s)\n        tmp8svispxp_test.go:82: expected '[]',\
    \ got '[Mars Mars]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmp8svispxp_test.go:82:\
    \ expected '[]', got '[Jupiter Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n\
    \        tmp8svispxp_test.go:82: expected '[]', got '[Saturn]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    index1 := -1\n    index2 := -1\n    for i, s := range planets\
    \ {\n        if s == planet1 {\n            index1 = i\n        }\n        if\
    \ s == planet2 {\n            index2 = i\n        }\n    }\n    if index1 == -1\
    \ || index2 == -1 {\n        return []interface{}{}\n    }\n    planetsBetween\
    \ := []interface{}{}\n    if index1 < index2 {\n        planetsBetween = planets[index1\
    \ + 1:index2]\n    } else {\n        planetsBetween = planets[index2 + 1:index1]\n\
    \    }\n    return planetsBetween\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkru35fgz_test.go:41:33: cannot use planets[index1 + 1:index2] (value of
    type []string) as type []interface{} in assignment

    /tmp/tmpkru35fgz_test.go:43:33: cannot use planets[index2 + 1:index1] (value of
    type []string) as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074314
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\tvar planets []string\
    \ = []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"}\n\tvar start = -1\n\tvar end = -1\n\tfor i, planet\
    \ := range planets {\n\t\tif planet == planet1 {\n\t\t\tstart = i\n\t\t} else\
    \ if planet == planet2 {\n\t\t\tend = i\n\t\t}\n\t}\n\tif start < 0 || end < 0\
    \ {\n\t\treturn nil\n\t} else if start < end {\n\t\treturn planets[start+1:end]\n\
    \t} else {\n\t\treturn planets[end+1:start]\n\t}\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc0fa6fz6_test.go:38:17: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    /tmp/tmpc0fa6fz6_test.go:40:17: cannot use planets[end + 1:start] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074314
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    l := getList(planet1,\
    \ planet2)\n    if len(l) == 0 {\n        return l\n    }\n    if l[0] == l[1]\
    \ {\n        return []interface{}{l[0]}\n    }\n    r := make([]interface{}, 0)\n\
    \    if l[0] < l[1] {\n        for i := l[0] + 1; i < l[1]; i++ {\n          \
    \  r = append(r, planets[i])\n        }\n    } else {\n        for i := l[0] -\
    \ 1; i > l[1]; i-- {\n            r = append(r, planets[i])\n        }\n    }\n\
    \    return r\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2_0ujuak_test.go:25:10: undefined: getList

    /tmp/tmp2_0ujuak_test.go:35:27: undefined: planets

    /tmp/tmp2_0ujuak_test.go:39:27: undefined: planets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074314
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    index1 := -1\n    index2 := -1\n    for i, v := range planets\
    \ {\n        if v == planet1 {\n            index1 = i\n        }\n        if\
    \ v == planet2 {\n            index2 = i\n        }\n    }\n    if index1 == -1\
    \ || index2 == -1 {\n        return []interface{}{}\n    }\n    if index1 > index2\
    \ {\n        index1, index2 = index2, index1\n    }\n    ret := []interface{}{}\n\
    \    for i := index1 + 1; i < index2; i++ {\n        ret = append(ret, planets[i])\n\
    \    }\n    return ret\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"\
    Mercury\" && planet2 == \"Venus\" {\n        return []interface{}{\"Venus\"}\n\
    \    } else if planet1 == \"Venus\" && planet2 == \"Earth\" {\n        return\
    \ []interface{}{\"Earth\"}\n    } else if planet1 == \"Earth\" && planet2 == \"\
    Mars\" {\n        return []interface{}{\"Mars\"}\n    } else if planet1 == \"\
    Mars\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Jupiter\"}\n\
    \    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        return\
    \ []interface{}{\"Saturn\"}\n    } else if planet1 == \"Saturn\" && planet2 ==\
    \ \"Uranus\" {\n        return []interface{}{\"Uranus\"}\n    } else if planet1\
    \ == \"Uranus\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Neptune\"\
    }\n    } else if planet1 == \"Neptune\" && planet2 == \"Pluto\" {\n        return\
    \ []interface{}{\"Pluto\"}\n    } else if planet1 == \"Pluto\" && planet2 == \"\
    X\" {\n        return []interface{}{\"X\"}\n    } else if planet1 == \"X\" &&\
    \ planet2 == \"Y\" {\n        return []interface{}{\"Y\"}\n    } else if planet1\
    \ == \"Y\" && planet2 == \"Z\" {\n        return []interface{}{\"Z\"}\n    } else\
    \ if planet1 == \"Z\" && planet2 == \"A\" {\n        return []interface{}{\"A\"\
    }\n    } else if planet1 == \"A\" && planet2 == \"B\" {\n        return []interface{}{\"\
    B\"}\n    } else if planet1 == \"B\" && planet2 == \"C\" {\n        return []interface{}{\"\
    C\"}\n    } else if planet1 == \"C\" && planet2 == \"D\" {\n        return []interface{}{\"\
    D\"}\n    } else if planet1 == \"D\" && planet2 == \"E\" {\n        return []interface{}{\"\
    E\"}\n    } else if planet1 == \"E\" && planet2 == \"F\" {\n        return []interface{\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6vciyh4c_test.go:58:16: expected expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074313
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    between := []interface{}{}\n    p1 := -1\n    p2 := -1\n \
    \   for i, p := range planets {\n        if p == planet1 {\n            p1 = i\n\
    \        }\n        if p == planet2 {\n            p2 = i\n        }\n    }\n\
    \    if p1 > -1 && p2 > -1 {\n        if p1 < p2 {\n            for i := p1 +\
    \ 1; i < p2; i++ {\n                between = append(between, planets[i])\n  \
    \          }\n        } else {\n            for i := p2 + 1; i < p1; i++ {\n \
    \               between = append(between, planets[i])\n            }\n       \
    \ }\n    }\n    return between\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return nil\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpbw3czdoh_test.go:47: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpbw3czdoh_test.go:47:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return nil\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpbw3czdoh_test.go:47: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpbw3czdoh_test.go:47:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    start, end := 0, len(planets) - 1\n    if planet1 == \"Mercury\"\
    \ {\n        start = 0\n    } else if planet1 == \"Venus\" {\n        start =\
    \ 1\n    } else if planet1 == \"Earth\" {\n        start = 2\n    } else if planet1\
    \ == \"Mars\" {\n        start = 3\n    } else if planet1 == \"Jupiter\" {\n \
    \       start = 4\n    } else if planet1 == \"Saturn\" {\n        start = 5\n\
    \    } else if planet1 == \"Uranus\" {\n        start = 6\n    } else if planet1\
    \ == \"Neptune\" {\n        start = 7\n    } else {\n        return nil\n    }\n\
    \    if planet2 == \"Mercury\" {\n        end = 0\n    } else if planet2 == \"\
    Venus\" {\n        end = 1\n    } else if planet2 == \"Earth\" {\n        end\
    \ = 2\n    } else if planet2 == \"Mars\" {\n        end = 3\n    } else if planet2\
    \ == \"Jupiter\" {\n        end = 4\n    } else if planet2 == \"Saturn\" {\n \
    \       end = 5\n    } else if planet2 == \"Uranus\" {\n        end = 6\n    }\
    \ else if planet2 == \"Neptune\" {\n        end = 7\n    } else {\n        return\
    \ nil\n    }\n    var res []interface{}\n    for i := start + 1; i < end; i++\
    \ {\n        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpmh1aupzw_test.go:91: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpmh1aupzw_test.go:91: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var p1_index, p2_index\
    \ int\n    var distance int\n    // get index of planet1 and planet2\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            p1_index = i\n\
    \        }\n        if p == planet2 {\n            p2_index = i\n        }\n \
    \   }\n    // calculate distance of planet1 to planet2\n    distance = p2_index\
    \ - p1_index\n    // check the direction\n    if distance > 0 {\n        return\
    \ planets[p1_index+1:p2_index]\n    } else if distance < 0 {\n        return planets[p2_index+1:p1_index]\n\
    \    } else {\n        return []interface{}{}\n    }\n}\n\nvar planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmomio6ym_test.go:40:23: cannot use planets[p1_index + 1:p2_index] (value
    of type []string) as type []interface{} in return statement

    /tmp/tmpmomio6ym_test.go:42:23: cannot use planets[p2_index + 1:p1_index] (value
    of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074314
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var orbit = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n\n    for i, p := range orbit {\n    \
    \    if p == planet1 {\n            start = i\n        } else if p == planet2\
    \ {\n            end = i\n        }\n    }\n\n    var planets []interface{}\n\
    \    if start < end {\n        planets = append(planets, orbit[start + 1:end]...)\n\
    \    } else if start > end {\n        planets = append(planets, orbit[end + 1:start]...)\n\
    \    } else {\n        planets = append(planets, planet1)\n    }\n\n    return\
    \ planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0oer3k42_test.go:38:40: cannot use orbit[start + 1:end] (value of type
    []string) as type []interface{} in argument to append

    /tmp/tmp0oer3k42_test.go:40:40: cannot use orbit[end + 1:start] (value of type
    []string) as type []interface{} in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074315
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return []interface{}{\"\
    Saturn\", \"Uranus\"}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpkvknatzv_test.go:47: expected '[Venus]', got '[Saturn Uranus]'\n   \
    \ --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpkvknatzv_test.go:47: expected\
    \ '[Venus Earth Mars Jupiter Saturn]', got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpkvknatzv_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n\
    \        tmpkvknatzv_test.go:47: expected '[]', got '[Saturn Uranus]'\n    ---\
    \ FAIL: TestBf/test_num__5 (0.00s)\n        tmpkvknatzv_test.go:47: expected '[]',\
    \ got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpkvknatzv_test.go:47:\
    \ expected '[]', got '[Saturn Uranus]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // sort the planet\
    \ names \n    // then find the first index of planet1 \n    // and the last index\
    \ of planet2\n    // and save the planets in between\n    var planetNames []string\n\
    \    planetNames = append(planetNames, \"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    var planetList []interface{}\n\
    \    var planet1Index int\n    var planet2Index int\n    var i int\n\n    for\
    \ i, name := range planetNames {\n        if name == planet1 {\n            planet1Index\
    \ = i\n        }\n        if name == planet2 {\n            planet2Index = i\n\
    \        }\n    }\n\n    if planet1Index > planet2Index {\n        temp := planet1Index\n\
    \        planet1Index = planet2Index\n        planet2Index = temp\n    }\n\n \
    \   for i = planet1Index + 1; i < planet2Index; i++ {\n        planetList = append(planetList,\
    \ planetNames[i])\n    }\n\n    return planetList\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmp5fyaiw4j_test.go:77: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074316
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var distance int\n\
    \    var pl1, pl2 int\n    planetMap := map[string]int {\n        \"Mercury\"\
    : 1,\n        \"Venus\": 2,\n        \"Earth\": 3,\n        \"Mars\": 4,\n   \
    \     \"Jupiter\": 5,\n        \"Saturn\": 6,\n        \"Uranus\": 7,\n      \
    \  \"Neptune\": 8,\n    }\n    if val, ok := planetMap[planet1]; ok {\n      \
    \  pl1 = val\n    } else {\n        return []interface{}{}\n    }\n    if val,\
    \ ok := planetMap[planet2]; ok {\n        pl2 = val\n    } else {\n        return\
    \ []interface{}{}\n    }\n    if pl1 > pl2 {\n        distance = pl1 - pl2\n \
    \   } else {\n        distance = pl2 - pl1\n    }\n    var planetList []interface{}\n\
    \    if pl1 < pl2 {\n        for i := 0; i < distance - 1; i++ {\n           \
    \ planetList = append(planetList, planetMap[pl1+i+1])\n        }\n    } else {\n\
    \        for i := 0; i < distance - 1; i++ {\n            planetList = append(planetList,\
    \ planetMap[pl1-i-1])\n        }\n    }\n    return planetList\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2g1j_4dm_test.go:55:55: cannot use pl1 + i + 1 (value of type int) as
    type string in map index

    /tmp/tmp2g1j_4dm_test.go:59:55: cannot use pl1 - i - 1 (value of type int) as
    type string in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074316
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // \u8FD4\u56DE\u7A7A\
    \n    if !is_planet_name(planet1) || !is_planet_name(planet2) {\n        return\
    \ []interface{}{}\n    }\n    var planets []string = []string{\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    }\n    var has_planet1, has_planet2 bool = false, false\n    var p1_index, p2_index\
    \ int = 0, 0\n    for index, planet := range planets {\n        if planet == planet1\
    \ {\n            has_planet1 = true\n            p1_index = index\n        }\n\
    \        if planet == planet2 {\n            has_planet2 = true\n            p2_index\
    \ = index\n        }\n    }\n    if !has_planet1 || !has_planet2 {\n        return\
    \ []interface{}{}\n    }\n    fmt.Println(p1_index, p2_index)\n    // \u8FD4\u56DE\
    \u7684\u4E3A\u7A7A\n    if p1_index == p2_index {\n        return []interface{}{}\n\
    \    }\n    // \u4ECE\u5C0F\u5230\u5927\n    if p1_index < p2_index {\n      \
    \  return planets[p1_index+1:p2_index]\n    }\n    // \u4ECE\u5927\u5230\u5C0F\
    \n    return planets[p2_index+1:p1_index]\n}\n\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzhyqj_80_test.go:26:9: undefined: is_planet_name

    /tmp/tmpzhyqj_80_test.go:52:23: cannot use planets[p1_index + 1:p2_index] (value
    of type []string) as type []interface{} in return statement

    /tmp/tmpzhyqj_80_test.go:55:19: cannot use planets[p2_index + 1:p1_index] (value
    of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074316
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    index1 := -1\n    index2 := -1\n    result := make([]interface{},\
    \ 0)\n    for index, planet := range planets {\n        if planet == planet1 {\n\
    \            index1 = index\n        }\n        if planet == planet2 {\n     \
    \       index2 = index\n        }\n    }\n    if index1 < 0 || index2 < 0 {\n\
    \        return result\n    }\n    for i := index1; i <= index2; i++ {\n     \
    \   result = append(result, planets[i])\n    }\n    return result\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpg9yxlxe7_test.go:65: expected '[Saturn Uranus]', got '[Jupiter Saturn\
    \ Uranus Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpg9yxlxe7_test.go:65:\
    \ expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n   \
    \     tmpg9yxlxe7_test.go:65: expected '[Venus Earth Mars Jupiter Saturn]', got\
    \ '[Mercury Venus Earth Mars Jupiter Saturn Uranus]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpg9yxlxe7_test.go:65: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpg9yxlxe7_test.go:65:\
    \ expected '[]', got '[Earth]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074316
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // your code here\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz_ov3pdm_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074316
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\tplanets := make([]string,\
    \ 8)\n\tplanets[0] = \"Mercury\"\n\tplanets[1] = \"Venus\"\n\tplanets[2] = \"\
    Earth\"\n\tplanets[3] = \"Mars\"\n\tplanets[4] = \"Jupiter\"\n\tplanets[5] = \"\
    Saturn\"\n\tplanets[6] = \"Uranus\"\n\tplanets[7] = \"Neptune\"\n\n\tn1 := -1\n\
    \tn2 := -1\n\tfor n, name := range planets {\n\t\tif planet1 == name {\n\t\t\t\
    n1 = n\n\t\t} else if planet2 == name {\n\t\t\tn2 = n\n\t\t}\n\t}\n\n\tif n1 ==\
    \ -1 || n2 == -1 {\n\t\treturn []interface{}{}\n\t}\n\n\tif n1 > n2 {\n\t\tn1,\
    \ n2 = n2, n1\n\t}\n\n\tresult := make([]interface{}, n2 - n1 - 1)\n\tfor i :=\
    \ n1 + 1; i < n2; i++ {\n\t\tresult[i - n1 - 1] = planets[i]\n\t}\n\n\treturn\
    \ result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074316
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start int = -1\n    var end int = -1\n    for i, planet\
    \ := range planets {\n        if planet == planet1 {\n            start = i\n\
    \        }\n        if planet == planet2 {\n            end = i\n        }\n \
    \   }\n    if start == -1 || end == -1 {\n        return make([]interface{}, 0)\n\
    \    }\n    var result []interface{}\n    if start < end {\n        result = planets[start+1:end]\n\
    \    } else {\n        result = planets[end+1:start]\n    }\n    fmt.Println(result)\n\
    \    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4t8tqbnl_test.go:41:25: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in assignment

    /tmp/tmp4t8tqbnl_test.go:43:25: cannot use planets[end + 1:start] (value of type
    []string) as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074316
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    position1 := 0\n    position2 := 0\n    for index, planet\
    \ := range planets {\n        if planet == planet1 {\n            position1 =\
    \ index\n        }\n        if planet == planet2 {\n            position2 = index\n\
    \        }\n    }\n    var result []interface{}\n    if position1 < position2\
    \ {\n        result = planets[position1 + 1:position2]\n    } else {\n       \
    \ result = planets[position2 + 1:position1]\n    }\n    return result\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppg12t0gk_test.go:38:25: cannot use planets[position1 + 1:position2] (value
    of type []string) as type []interface{} in assignment

    /tmp/tmppg12t0gk_test.go:40:25: cannot use planets[position2 + 1:position1] (value
    of type []string) as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074316
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return []interface{}{\"\
    Mars\", \"Earth\", \"Venus\"}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpuori1dh9_test.go:47: expected '[Saturn Uranus]', got '[Mars Earth Venus]'\n\
    \    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpuori1dh9_test.go:47: expected\
    \ '[Venus]', got '[Mars Earth Venus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n\
    \        tmpuori1dh9_test.go:47: expected '[Venus Earth Mars Jupiter Saturn]',\
    \ got '[Mars Earth Venus]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n       \
    \ tmpuori1dh9_test.go:47: expected '[Earth Mars Jupiter Saturn Uranus]', got '[Mars\
    \ Earth Venus]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpuori1dh9_test.go:47:\
    \ expected '[]', got '[Mars Earth Venus]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n\
    \        tmpuori1dh9_test.go:47: expected '[]', got '[Mars Earth Venus]'\n   \
    \ --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpuori1dh9_test.go:47: expected\
    \ '[]', got '[Mars Earth Venus]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074316
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Get the position\
    \ of planet1 and planet2 on list\n    planets := []string{\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n   \
    \ planet1Pos := -1\n    planet2Pos := -1\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            planet1Pos = i\n        }\n     \
    \   if planet == planet2 {\n            planet2Pos = i\n        }\n    }\n   \
    \ if planet1Pos == -1 || planet2Pos == -1 {\n        return []interface{}{}\n\
    \    }\n    // Get the list of planets between\n    planetsBetween := planets[planet1Pos+1:planet2Pos]\n\
    \    var result []interface{}\n    for _, planet := range planetsBetween {\n \
    \       result = append(result, planet)\n    }\n    return result\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\npanic: runtime error: slice bounds out of range\
    \ [3:0] [recovered]\n\tpanic: runtime error: slice bounds out of range [3:0]\n\
    \ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513780, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513780,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.bf({0x51e62f, 0x5}, {0x51eae1, 0x7})\n\t\
    /tmp/tmp4dxdxmmw_test.go:41 +0x47c\ncommand-line-arguments_test.TestBf(0x0?)\n\
    \t/tmp/tmp4dxdxmmw_test.go:57 +0x97\ntesting.tRunner(0xc0001a01a0, 0x5290d0)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074316
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start, end int\n    for i, v := range planets {\n    \
    \    if v == planet1 {\n            start = i\n        }\n        if v == planet2\
    \ {\n            end = i\n        }\n    }\n    fmt.Println(start, end)\n    //\
    \ return planets[start+1:end]\n    if start < end {\n        return planets[start+1:end]\n\
    \    } else {\n        return planets[end+1:start]\n    }\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpti22k01t_test.go:38:23: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    /tmp/tmpti22k01t_test.go:40:23: cannot use planets[end + 1:start] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074316
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    idx1 := -1\n    idx2 := -1\n    for i, planet := range planets\
    \ {\n        if planet == planet1 {\n            idx1 = i\n        }\n       \
    \ if planet == planet2 {\n            idx2 = i\n        }\n    }\n    if idx1\
    \ == -1 || idx2 == -1 {\n        return nil\n    }\n    var ret []interface{}\n\
    \    if idx1 < idx2 {\n        ret = planets[idx1+1:idx2]\n    } else {\n    \
    \    ret = planets[idx2+1:idx1]\n    }\n    return ret\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbok8j98n_test.go:41:22: cannot use planets[idx1 + 1:idx2] (value of type
    []string) as type []interface{} in assignment

    /tmp/tmpbok8j98n_test.go:43:22: cannot use planets[idx2 + 1:idx1] (value of type
    []string) as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074317
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Index, planet2Index int\n\n    for i, p := range\
    \ planets {\n        if p == planet1 {\n            planet1Index = i\n       \
    \ }\n        if p == planet2 {\n            planet2Index = i\n        }\n    }\n\
    \n    if planet1Index == 0 || planet2Index == 0 {\n        return []interface{}{}\n\
    \    }\n\n    if planet1Index < planet2Index {\n        return planets[planet1Index\
    \ + 1:planet2Index]\n    } else {\n        return planets[planet2Index + 1:planet1Index]\n\
    \    }\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbaj48cks_test.go:42:23: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    /tmp/tmpbaj48cks_test.go:44:23: cannot use planets[planet2Index + 1:planet1Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074317
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // your code goes\
    \ here\n    return []interface{}{}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpnc81s4x0_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpnc81s4x0_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpnc81s4x0_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpnc81s4x0_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074317
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    a := make([]interface{},8)\n\
    \    a[0] = \"Mercury\"\n    a[1] = \"Venus\"\n    a[2] = \"Earth\"\n    a[3]\
    \ = \"Mars\"\n    a[4] = \"Jupiter\"\n    a[5] = \"Saturn\"\n    a[6] = \"Uranus\"\
    \n    a[7] = \"Neptune\"\n    var b []interface{}\n    var start int\n    var\
    \ end int\n    for i := 0; i < len(a); i++ {\n        if a[i] == planet1 {\n \
    \           start = i\n        }\n        if a[i] == planet2 {\n            end\
    \ = i\n        }\n    }\n    if start == end {\n        return b\n    }\n    if\
    \ start > end {\n        temp := start\n        start = end\n        end = temp\n\
    \    }\n    for i := start + 1; i < end; i++ {\n        b = append(b, a[i])\n\
    \    }\n    return b\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpq53f3muo_test.go:78: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074317
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Write your code\
    \ here\n    return []interface{}{}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpskfcbe5c_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpskfcbe5c_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpskfcbe5c_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpskfcbe5c_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    ret := []interface{}{}\n    index1 := -1\n    index2 := -1\n\
    \    for i, p := range planets {\n        if p == planet1 {\n            index1\
    \ = i\n        }\n        if p == planet2 {\n            index2 = i\n        }\n\
    \    }\n    if index1 != -1 && index2 != -1 {\n        if index1 > index2 {\n\
    \            for i := index2; i < index1; i++ {\n                ret = append(ret,\
    \ planets[i])\n            }\n        } else {\n            for i := index1; i\
    \ < index2; i++ {\n                ret = append(ret, planets[i])\n           \
    \ }\n        }\n    }\n    return ret\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpgfxs9pf__test.go:70: expected '[Saturn Uranus]', got '[Jupiter Saturn\
    \ Uranus]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpgfxs9pf__test.go:70:\
    \ expected '[Venus]', got '[Mercury Venus]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpgfxs9pf__test.go:70: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[Mercury Venus Earth Mars Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpgfxs9pf__test.go:70: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[Venus Earth Mars Jupiter Saturn Uranus]'\n    --- FAIL: TestBf/test_num__5\
    \ (0.00s)\n        tmpgfxs9pf__test.go:70: expected '[]', got '[Earth]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074317
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return nil\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpbw3czdoh_test.go:47: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpbw3czdoh_test.go:47:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"\
    Mercury\" {\n        if planet2 == \"Mercury\" {\n            return []interface{}{\"\
    Mercury\"}\n        } else if planet2 == \"Venus\" {\n            return []interface{}{\"\
    Mercury\", \"Venus\"}\n        } else if planet2 == \"Earth\" {\n            return\
    \ []interface{}{\"Mercury\", \"Venus\", \"Earth\"}\n        } else if planet2\
    \ == \"Mars\" {\n            return []interface{}{\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\"}\n        } else if planet2 == \"Jupiter\" {\n            return []interface{}{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"}\n        } else if planet2\
    \ == \"Saturn\" {\n            return []interface{}{\"Mercury\", \"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n        } else if planet2 == \"Uranus\"\
    \ {\n            return []interface{}{\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"}\n        } else if planet2 == \"Neptune\"\
    \ {\n            return []interface{}{\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n        } else {\n      \
    \      return []interface{}{}\n        }\n    } else if planet1 == \"Venus\" {\n\
    \        if planet2 == \"Venus\" {\n            return []interface{}{\"Venus\"\
    }\n        } else if planet2 == \"Earth\" {\n            return []interface{}{\"\
    Venus\", \"Earth\"}\n        } else if planet2 == \"Mars\" {\n            return\
    \ []interface{}{\"Venus\", \"Earth\", \"Mars\"}\n        } else if planet2 ==\
    \ \"Jupiter\" {\n            return []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\"}\n        } else if planet2 == \"Saturn\" {\n            return\
    \ []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n   \
    \     } else if planet2 == \"Uranus\" {\n            return []interface{}{\"Venus\"\
    , \"Earth\", \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz_16f5wd_test.go:57:52: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074316
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    l1 := c2i(planet1)\n\
    \    l2 := c2i(planet2)\n    if l1 < 0 || l2 < 0 {\n        return nil\n    }\n\
    \    max := l1\n    min := l2\n    if l1 < l2 {\n        max = l2\n        min\
    \ = l1\n    }\n    ret := make([]interface{}, 0)\n    for i := min + 1; i < max;\
    \ i++ {\n        ret = append(ret, i2c(i))\n    }\n    return ret\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpifdb010s_test.go:25:11: undefined: c2i

    /tmp/tmpifdb010s_test.go:26:11: undefined: c2i

    /tmp/tmpifdb010s_test.go:38:27: undefined: i2c

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074317
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    index1 := 0\n    index2 := 0\n    for i, planet := range planets\
    \ {\n        if planet == planet1 {\n            index1 = i\n        } else if\
    \ planet == planet2 {\n            index2 = i\n        }\n    }\n    if index1\
    \ == 0 || index2 == 0 {\n        return []interface{}{}\n    }\n    if index1\
    \ < index2 {\n        return planets[index1+1:index2]\n    } else {\n        return\
    \ planets[index2+1:index1]\n    }\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpimhegj4c_test.go:39:23: cannot use planets[index1 + 1:index2] (value of
    type []string) as type []interface{} in return statement

    /tmp/tmpimhegj4c_test.go:41:23: cannot use planets[index2 + 1:index1] (value of
    type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074317
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planets := []string{\"Mercury\", \"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    list := []interface{}{}\n\
    \    var pos1, pos2 int\n    for i, v := range planets {\n        if v == planet1\
    \ {\n            pos1 = i\n        }\n        if v == planet2 {\n            pos2\
    \ = i\n        }\n    }\n    if pos1 > pos2 {\n        for i := pos2; i <= pos1;\
    \ i++ {\n            list = append(list, planets[i])\n        }\n    } else {\n\
    \        for i := pos1; i <= pos2; i++ {\n            list = append(list, planets[i])\n\
    \        }\n    }\n    return list\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpb0mxtcow_test.go:68: expected '[Saturn Uranus]', got '[Jupiter Saturn\
    \ Uranus Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpb0mxtcow_test.go:68:\
    \ expected '[Venus]', got '[Mercury Venus Earth]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpb0mxtcow_test.go:68: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[Mercury Venus Earth Mars Jupiter Saturn Uranus]'\n    --- FAIL:\
    \ TestBf/test_num__3 (0.00s)\n        tmpb0mxtcow_test.go:68: expected '[Earth\
    \ Mars Jupiter Saturn Uranus]', got '[Venus Earth Mars Jupiter Saturn Uranus Neptune]'\n\
    \    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpb0mxtcow_test.go:68: expected\
    \ '[]', got '[Earth]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpb0mxtcow_test.go:68:\
    \ expected '[]', got '[Earth Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n\
    \        tmpb0mxtcow_test.go:68: expected '[]', got '[Mercury Venus Earth Mars\
    \ Jupiter]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074317
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string\
    \ {\n        \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"\
    Mars\",\n        \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n    \
    \    \"Neptune\",\n    }\n    var p1 int = -1\n    var p2 int = -1\n    for i,\
    \ p := range planets {\n        if planet1 == p {\n            p1 = i\n      \
    \  }\n        if planet2 == p {\n            p2 = i\n        }\n    }\n    if\
    \ p1 == -1 || p2 == -1 {\n        return make([]interface{}, 0)\n    }\n\n   \
    \ var l, r int\n    if p1 < p2 {\n        l = p1\n        r = p2\n    } else {\n\
    \        l = p2\n        r = p1\n    }\n    return planets[l+1:r]\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5sx_w46s_test.go:57:19: cannot use planets[l + 1:r] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074317
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // your code here\n\
    \    // returns either a list containing all planets or an empty list.\n    return\
    \ []interface{}{}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmp6q0r4csx_test.go:49: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmp6q0r4csx_test.go:49: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmp6q0r4csx_test.go:49:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmp6q0r4csx_test.go:49: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074317
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // put your code\
    \ here\n    return []interface{}{}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmptig39w16_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmptig39w16_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmptig39w16_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmptig39w16_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074318
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var result []interface{}\n\
    \    bf := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\", \"Neptune\"}\n    switch {\n    case planet1 == \"Mercury\"\
    \ && planet2 == \"Venus\":\n        result = append(result, \"Venus\")\n    case\
    \ planet1 == \"Mercury\" && planet2 == \"Earth\":\n        result = append(result,\
    \ \"Venus\", \"Earth\")\n    case planet1 == \"Mercury\" && planet2 == \"Mars\"\
    :\n        result = append(result, \"Venus\", \"Earth\", \"Mars\")\n    case planet1\
    \ == \"Mercury\" && planet2 == \"Jupiter\":\n        result = append(result, \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\")\n    case planet1 == \"Mercury\" &&\
    \ planet2 == \"Saturn\":\n        result = append(result, \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    case planet1 == \"Mercury\" && planet2\
    \ == \"Uranus\":\n        result = append(result, \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\")\n    case planet1 == \"Mercury\" && planet2\
    \ == \"Neptune\":\n        result = append(result, \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    case planet1 == \"Venus\"\
    \ && planet2 == \"Earth\":\n        result = append(result, \"Earth\")\n    case\
    \ planet1 == \"Venus\" && planet2 == \"Mars\":\n        result = append(result,\
    \ \"Earth\", \"Mars\")\n    case planet1 == \"Venus\" && planet2 == \"Jupiter\"\
    :\n        result = append(result, \"Earth\", \"Mars\", \"Jupiter\")\n    case\
    \ planet1 == \"Venus\" && planet2 == \"Saturn\":\n        result = append(result,\
    \ \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    case planet1 == \"Venus\"\
    \ && planet2 == \"Uranus\":\n        result = append(result, \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvk7095yv_test.go:51:61: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074317
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var l1, l2, sol []interface{}\n\
    \    sol = []interface{}{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"}\n    for _, v := range sol {\n        if\
    \ v == planet1 {\n            l1 = sol[sol.index(v):]\n        } else if v ==\
    \ planet2 {\n            l2 = sol[:sol.index(v)]\n        }\n    }\n    for _,\
    \ v := range l1 {\n        if l2.index(v) != -1 {\n            return l2[l2.index(v):]\n\
    \        }\n    }\n    return []interface{}{}\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp62mbqbrr_test.go:29:26: sol.index undefined (type []interface{} has no
    field or method index)

    /tmp/tmp62mbqbrr_test.go:31:27: sol.index undefined (type []interface{} has no
    field or method index)

    /tmp/tmp62mbqbrr_test.go:35:15: l2.index undefined (type []interface{} has no
    field or method index)

    /tmp/tmp62mbqbrr_test.go:36:26: l2.index undefined (type []interface{} has no
    field or method index)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074318
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // your code here\n\
    \    return []interface{}{}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmptdxa5e59_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmptdxa5e59_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmptdxa5e59_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmptdxa5e59_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // your code here\n\
    \    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpcp7hlud0_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpcp7hlud0_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpcp7hlud0_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpcp7hlud0_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code goes\
    \ here\n    planets := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    idx1 := 0\n    idx2 := 0\n\
    \    res := []interface{}{}\n    for i := 0; i < len(planets); i++ {\n       \
    \ if planets[i] == planet1 {\n            idx1 = i\n        }\n        if planets[i]\
    \ == planet2 {\n            idx2 = i\n        }\n    }\n    if idx1 == 0 || idx2\
    \ == 0 {\n        return res\n    }\n    for i := idx1 + 1; i < idx2; i++ {\n\
    \        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp17rjmrdp_test.go:66: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp17rjmrdp_test.go:66: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmp17rjmrdp_test.go:66:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074318
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    // var planetIdx1, planetIdx2 int\n    // for i, v := range\
    \ planets {\n    //     if v == planet1 {\n    //         planetIdx1 = i\n   \
    \ //     }\n    //     if v == planet2 {\n    //         planetIdx2 = i\n    //\
    \     }\n    // }\n    // if planetIdx1 < planetIdx2 {\n    //     return planets[planetIdx1+1:planetIdx2]\n\
    \    // } else {\n    //     return planets[planetIdx2+1:planetIdx1]\n    // }\n\
    \    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpnpx8c_pp_test.go:62: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpnpx8c_pp_test.go:62: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpnpx8c_pp_test.go:62:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpnpx8c_pp_test.go:62: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074318
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // WRITE YOUR CODE\
    \ HERE\n    var list []interface{}\n    if planet1 == \"Mercury\" && planet2 ==\
    \ \"Mercury\" {\n        list = append(list, \"Mercury\")\n    } else if planet1\
    \ == \"Mercury\" && planet2 == \"Venus\" {\n        list = append(list, \"Mercury\"\
    , \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n\
    \        list = append(list, \"Mercury\", \"Venus\", \"Earth\")\n    } else if\
    \ planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        list = append(list,\
    \ \"Mercury\", \"Venus\", \"Earth\", \"Mars\")\n    } else if planet1 == \"Mercury\"\
    \ && planet2 == \"Jupiter\" {\n        list = append(list, \"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2\
    \ == \"Saturn\" {\n        list = append(list, \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\")\n    } else if planet1 == \"Mercury\" &&\
    \ planet2 == \"Uranus\" {\n        list = append(list, \"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\")\n    } else if planet1\
    \ == \"Mercury\" && planet2 == \"Neptune\" {\n        list = append(list, \"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    )\n    } else if planet1 == \"Venus\" && planet2 == \"Venus\" {\n        list\
    \ = append(list, \"Venus\")\n    } else if planet1 == \"Venus\" && planet2 ==\
    \ \"Earth\" {\n        list = append(list, \"Venus\", \"Earth\")\n    } else if\
    \ planet1 == \"Venus\" && planet2 == \"Mars\" {\n        list = append(list, \"\
    Venus\", \"Earth\", \"Mars\")\n    } else if planet1 == \"Venus\" && planet2 ==\
    \ \"Jupiter\" {\n        list =\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfk_39gnh_test.go:51:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074317
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\t planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n     position1 := 0\n     position2 := 0\n     for i := 0; i <\
    \ len(planets); i++ {\n     \tif planets[i] == planet1 {\n     \t\tposition1 =\
    \ i\n     \t}\n     \tif planets[i] == planet2 {\n     \t\tposition2 = i\n   \
    \  \t}\n     }\n     if position1 > position2 {\n     \tposition1, position2 =\
    \ position2, position1\n     }\n     if position1 + 1 == position2 {\n     \t\
    return []interface{}{planets[position1 + 1]}\n     }\n     if position1 == position2\
    \ {\n     \treturn []interface{}{}\n     }\n     var result []interface{}\n  \
    \   for i := position1 + 1; i < position2; i++ {\n     \tresult = append(result,\
    \ planets[i])\n     }\n     return result\n}\n\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__5 (0.00s)\n  \
    \      tmpvod8gloq_test.go:71: expected '[]', got '[Mars]'\n    --- FAIL: TestBf/test_num__6\
    \ (0.00s)\n        tmpvod8gloq_test.go:71: expected '[]', got '[Venus Earth Mars]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074318
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    ret := []interface{}{}\n\
    \    planetList := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"}\n    flag := false\n    for _, v := range\
    \ planetList {\n        if v == planet1 {\n            flag = true\n        }\n\
    \        if flag {\n            ret = append(ret, v)\n        }\n        if v\
    \ == planet2 {\n            break\n        }\n    }\n    return ret\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmp8jiaspci_test.go:61: expected '[Saturn Uranus]', got '[Jupiter Saturn\
    \ Uranus Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmp8jiaspci_test.go:61:\
    \ expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n   \
    \     tmp8jiaspci_test.go:61: expected '[Venus Earth Mars Jupiter Saturn]', got\
    \ '[Mercury Venus Earth Mars Jupiter Saturn Uranus]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmp8jiaspci_test.go:61: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmp8jiaspci_test.go:61:\
    \ expected '[]', got '[Earth]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n   \
    \     tmp8jiaspci_test.go:61: expected '[]', got '[Jupiter Saturn Uranus Neptune]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074318
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    idx1 := 0\n    idx2 := 0\n    for i, v := range planets {\n\
    \        if v == planet1 {\n            idx1 = i\n        } else if v == planet2\
    \ {\n            idx2 = i\n        }\n    }\n    if idx1 < idx2 {\n        return\
    \ planets[idx1+1:idx2]\n    } else if idx1 > idx2 {\n        return planets[idx2+1:idx1]\n\
    \    } else {\n        return []interface{}{}\n    }\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq5u8jull_test.go:36:23: cannot use planets[idx1 + 1:idx2] (value of type
    []string) as type []interface{} in return statement

    /tmp/tmpq5u8jull_test.go:38:23: cannot use planets[idx2 + 1:idx1] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074318
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\n\
    \        \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\"\
    ,\n        \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"\
    Neptune\",\n    }\n    var pos1, pos2 int\n    for i, p := range planets {\n \
    \       if p == planet1 {\n            pos1 = i\n        }\n        if p == planet2\
    \ {\n            pos2 = i\n        }\n    }\n    if pos1 == pos2 {\n        return\
    \ []interface{}{}\n    }\n    if pos1 > pos2 {\n        pos1, pos2 = pos2, pos1\n\
    \    }\n    return planets[pos1+1:pos2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8qz8bs_w_test.go:50:19: cannot use planets[pos1 + 1:pos2] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074318
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // the order of the\
    \ planets does not matter\n    planets := []string{\"Mercury\", \"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    start\
    \ := 0\n    end := 0\n    for i, planet := range planets {\n        if planet\
    \ == planet1 {\n            start = i\n        }\n        if planet == planet2\
    \ {\n            end = i\n        }\n    }\n    // fmt.Println(start, end)\n \
    \   if start == 0 || end == 0 {\n        return []interface{}{}\n    }\n    if\
    \ start > end {\n        tmp := start\n        start = end\n        end = tmp\n\
    \    }\n    return planets[start:end+1]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjdhj3ig8_test.go:46:19: cannot use planets[start:end + 1] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074318
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\tplanets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n\ti1 := -1\n\ti2 := -1\n\tfor i, planet := range planets {\n\t\
    \tif planet == planet1 {\n\t\t\ti1 = i\n\t\t}\n\t\tif planet == planet2 {\n\t\t\
    \ti2 = i\n\t\t}\n\t}\n\tif i1 == -1 || i2 == -1 {\n\t\treturn []interface{}{}\n\
    \t}\n\n\t// swap planet order\n\tif i1 > i2 {\n\t\ti1, i2 = i2, i1\n\t}\n\n\t\
    return planets[i1+1:i2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo9pxn5mg_test.go:45:16: cannot use planets[i1 + 1:i2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074318
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n  var planets = [8]string{\n\
    \    \"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\",\n  }\n  var res []interface{}\n  var p1, p2 bool\n\n  for\
    \ i := 0; i < len(planets); i++ {\n    if planets[i] == planet1 {\n      p1 =\
    \ true\n    }\n    if planets[i] == planet2 {\n      p2 = true\n    }\n  }\n\n\
    \  if p1 == false || p2 == false {\n    return res\n  }\n\n  for i := 0; i < len(planets);\
    \ i++ {\n    if (planets[i] == planet1) || (planets[i] == planet2) {\n      if\
    \ i == 0 {\n        if planets[len(planets) - 1] == planet1 {\n          for j\
    \ := 0; j < len(planets); j++ {\n            res = append(res, planets[j])\n \
    \         }\n        } else {\n          for j := len(planets) - 1; j >= 0; j--\
    \ {\n            res = append(res, planets[j])\n          }\n        }\n     \
    \   break\n      } else {\n        if planets[i - 1] == planet1 {\n          for\
    \ j := i - 1; j <= i; j++ {\n            res = append(res, planets[j])\n     \
    \     }\n        } else {\n          for j := i; j >= i - 1; j-- {\n         \
    \   res = append(res, planets[j])\n          }\n        }\n        break\n   \
    \   }\n    }\n  }\n\n  return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmp9c5vjdsp_test.go:94: expected '[Saturn Uranus]', got '[Jupiter Mars]'\n\
    \    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmp9c5vjdsp_test.go:94: expected\
    \ '[Venus]', got '[Neptune Uranus Saturn Jupiter Mars Earth Venus Mercury]'\n\
    \    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmp9c5vjdsp_test.go:94: expected\
    \ '[Venus Earth Mars Jupiter Saturn]', got '[Neptune Uranus Saturn Jupiter Mars\
    \ Earth Venus Mercury]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmp9c5vjdsp_test.go:94:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Venus Mercury]'\n    ---\
    \ FAIL: TestBf/test_num__4 (0.00s)\n        tmp9c5vjdsp_test.go:94: expected '[]',\
    \ got '[Earth Venus]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmp9c5vjdsp_test.go:94:\
    \ expected '[]', got '[Earth Venus]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074319
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\tplanets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n\tvar index1, index2 int\n\tfor i, s := range planets {\n\t\t\
    if s == planet1 {\n\t\t\tindex1 = i\n\t\t}\n\t\tif s == planet2 {\n\t\t\tindex2\
    \ = i\n\t\t}\n\t}\n\tvar l []interface{}\n\tfor _, s := range planets[index1+1:index2]\
    \ {\n\t\tl = append(l, s)\n\t}\n\treturn l\n}\n\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\npanic: runtime error: slice bounds out of range\
    \ [3:0] [recovered]\n\tpanic: runtime error: slice bounds out of range [3:0]\n\
    \ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x515780, 0xc000162000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x515780,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.bf(...)\n\t/tmp/tmp5kk7bfuy_test.go:36\n\
    command-line-arguments_test.TestBf(0xc0001036c0?)\n\t/tmp/tmp5kk7bfuy_test.go:50\
    \ +0x2855\ntesting.tRunner(0xc0001036c0, 0x52b0d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074319
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return []interface{}{\"\
    Saturn\", \"Uranus\"}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpkvknatzv_test.go:47: expected '[Venus]', got '[Saturn Uranus]'\n   \
    \ --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpkvknatzv_test.go:47: expected\
    \ '[Venus Earth Mars Jupiter Saturn]', got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpkvknatzv_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n\
    \        tmpkvknatzv_test.go:47: expected '[]', got '[Saturn Uranus]'\n    ---\
    \ FAIL: TestBf/test_num__5 (0.00s)\n        tmpkvknatzv_test.go:47: expected '[]',\
    \ got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpkvknatzv_test.go:47:\
    \ expected '[]', got '[Saturn Uranus]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // your code here\n\
    \    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpcp7hlud0_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpcp7hlud0_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpcp7hlud0_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpcp7hlud0_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    if !sliceContains(planets, planet1) || !sliceContains(planets,\
    \ planet2) {\n        return []interface{}{}\n    }\n    planet1Index := 0\n \
    \   planet2Index := 0\n    planet1Found := false\n    planet2Found := false\n\
    \    for i, planet := range planets {\n        if planet == planet1 {\n      \
    \      planet1Index = i\n            planet1Found = true\n        }\n        if\
    \ planet == planet2 {\n            planet2Index = i\n            planet2Found\
    \ = true\n        }\n        if planet1Found && planet2Found {\n            break\n\
    \        }\n    }\n    if planet1Index > planet2Index {\n        planet1Index,\
    \ planet2Index = planet2Index, planet1Index\n    }\n    planestBetween := planets[planet1Index\
    \ + 1:planet2Index]\n    fmt.Println(planestBetween)\n    return []interface{}{}\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5eo7ikai_test.go:26:9: undefined: sliceContains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074319
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // write your code\
    \ here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpms1czs8j_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpms1czs8j_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpms1czs8j_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpms1czs8j_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074319
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    orbit_order := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1_index := -1\n    planet2_index := -1\n    for i, planet\
    \ := range orbit_order {\n        if planet == planet1 {\n            planet1_index\
    \ = i\n        }\n        if planet == planet2 {\n            planet2_index =\
    \ i\n        }\n    }\n    if planet1_index == -1 || planet2_index == -1 {\n \
    \       return []interface{}{}\n    }\n    start := planet1_index\n    end :=\
    \ planet2_index\n    if start > end {\n        start = planet2_index\n       \
    \ end = planet1_index\n    }\n    return orbit_order[start+1:end]\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcv8z9g6h_test.go:45:23: cannot use orbit_order[start + 1:end] (value of
    type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074319
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // 1. check if the\
    \ planets are in the map\n    if _, ok := planets[planet1]; !ok {\n        return\
    \ []interface{}{}\n    }\n    if _, ok := planets[planet2]; !ok {\n        return\
    \ []interface{}{}\n    }\n    // 2. arrange by proximity to the sun\n    planetsSorted\
    \ := sortMap(planets)\n    planet1Pos := -1\n    planet2Pos := -1\n    for i,\
    \ p := range planetsSorted {\n        if p == planet1 {\n            planet1Pos\
    \ = i\n        }\n        if p == planet2 {\n            planet2Pos = i\n    \
    \    }\n    }\n    if planet1Pos > planet2Pos {\n        planet1Pos, planet2Pos\
    \ = planet2Pos, planet1Pos\n    }\n    // 3. return all planets within the range\n\
    \    return planetsSorted[planet1Pos+1:planet2Pos]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr0p3zkp9_test.go:26:17: undefined: planets

    /tmp/tmpr0p3zkp9_test.go:29:17: undefined: planets

    /tmp/tmpr0p3zkp9_test.go:33:22: undefined: sortMap

    /tmp/tmpr0p3zkp9_test.go:33:30: undefined: planets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074319
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return []interface{}{\"\
    saturn\", \"uranus\"}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpn2pb5bbb_test.go:47: expected '[Saturn Uranus]', got '[saturn uranus]'\n\
    \    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpn2pb5bbb_test.go:47: expected\
    \ '[Venus]', got '[saturn uranus]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n\
    \        tmpn2pb5bbb_test.go:47: expected '[Venus Earth Mars Jupiter Saturn]',\
    \ got '[saturn uranus]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpn2pb5bbb_test.go:47:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[saturn uranus]'\n    ---\
    \ FAIL: TestBf/test_num__4 (0.00s)\n        tmpn2pb5bbb_test.go:47: expected '[]',\
    \ got '[saturn uranus]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpn2pb5bbb_test.go:47:\
    \ expected '[]', got '[saturn uranus]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n\
    \        tmpn2pb5bbb_test.go:47: expected '[]', got '[saturn uranus]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074320
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    m := map[string]int{\n\
    \        \"Mercury\": 0,\n        \"Venus\": 1,\n        \"Earth\": 2,\n     \
    \   \"Mars\": 3,\n        \"Jupiter\": 4,\n        \"Saturn\": 5,\n        \"\
    Uranus\": 6,\n        \"Neptune\": 7,\n    }\n    l := make([]interface{}, 0)\n\
    \    if _, ok := m[planet1]; !ok {\n        return l\n    }\n    if _, ok := m[planet2];\
    \ !ok {\n        return l\n    }\n    start := m[planet1]\n    end := m[planet2]\n\
    \    if start > end {\n        start, end = end, start\n    }\n    for i := start\
    \ + 1; i < end; i++ {\n        for k, v := range m {\n            if v == i {\n\
    \                l = append(l, k)\n            }\n        }\n    }\n    return\
    \ l\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074320
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // your solution\
    \ goes here\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzi2ngw0u_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074319
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"\
    Mercury\" {\n        if planet2 == \"Venus\" {\n            return []interface{}{\"\
    Venus\"}\n        } else if planet2 == \"Earth\" {\n            return []interface{}{\"\
    Venus\", \"Earth\"}\n        } else if planet2 == \"Mars\" {\n            return\
    \ []interface{}{\"Venus\", \"Earth\", \"Mars\"}\n        } else if planet2 ==\
    \ \"Jupiter\" {\n            return []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\"}\n        } else if planet2 == \"Saturn\" {\n            return\
    \ []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n   \
    \     } else if planet2 == \"Uranus\" {\n            return []interface{}{\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"}\n        } else if\
    \ planet2 == \"Neptune\" {\n            return []interface{}{\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n        }\n   \
    \ } else if planet1 == \"Venus\" {\n        if planet2 == \"Earth\" {\n      \
    \      return []interface{}{\"Earth\"}\n        } else if planet2 == \"Mars\"\
    \ {\n            return []interface{}{\"Earth\", \"Mars\"}\n        } else if\
    \ planet2 == \"Jupiter\" {\n            return []interface{}{\"Earth\", \"Mars\"\
    , \"Jupiter\"}\n        } else if planet2 == \"Saturn\" {\n            return\
    \ []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n        } else\
    \ if planet2 == \"Uranus\" {\n            return []interface{}{\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"}\n        } else if planet2 == \"Neptune\"\
    \ {\n            return []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"}\n        }\n    } else if planet1 == \"Earth\" {\n\
    \        if planet2 == \"Mars\" {\n            return []interface{}{\"Mars\"}\n\
    \        } else if planet2 == \"Jupiter\" {\n\nfunc TestBf(t *testing.T) {\n \
    \ candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmhsmptoh_test.go:60:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074318
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var i1, i2 int\n    for i, planet := range planets {\n   \
    \     if planet == planet1 {\n            i1 = i\n        }\n        if planet\
    \ == planet2 {\n            i2 = i\n        }\n    }\n    if i1 == 0 || i2 ==\
    \ 0 {\n        return nil\n    }\n    if i1 > i2 {\n        i1, i2 = i2, i1\n\
    \    }\n    return planets[i1+1:i2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptw_3q0gh_test.go:41:19: cannot use planets[i1 + 1:i2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074319
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    first := -1\n    second := -1\n    for i,p := range planets\
    \ {\n        if p == planet1 {\n            first = i\n        }\n        if p\
    \ == planet2 {\n            second = i\n        }\n    }\n    if first < 0 ||\
    \ second < 0 {\n        return nil\n    }\n    list := make([]interface{},0)\n\
    \    if first < second {\n        for i := first+1; i < second; i++ {\n      \
    \      list = append(list, planets[i])\n        }\n    } else {\n        for i\
    \ := first-1; i > second; i-- {\n            list = append(list, planets[i])\n\
    \        }\n    }\n    return list\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__3 (0.00s)\n  \
    \      tmpqnw93xbd_test.go:71: expected '[Earth Mars Jupiter Saturn Uranus]',\
    \ got '[Uranus Saturn Jupiter Mars Earth]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074320
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planetIndex =\
    \ make(map[string]int)\n    planetIndex[\"Mercury\"] = 0\n    planetIndex[\"Venus\"\
    ] = 1\n    planetIndex[\"Earth\"] = 2\n    planetIndex[\"Mars\"] = 3\n    planetIndex[\"\
    Jupiter\"] = 4\n    planetIndex[\"Saturn\"] = 5\n    planetIndex[\"Uranus\"] =\
    \ 6\n    planetIndex[\"Neptune\"] = 7\n\n    var planetList = []string{\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    }\n\n    var ret []interface{}\n\n    if val, ok := planetIndex[planet1]; ok {\n\
    \        if val2, ok2 := planetIndex[planet2]; ok2 {\n            if val2 > val\
    \ {\n                ret = planetList[val+1:val2]\n            } else {\n    \
    \            ret = planetList[val2+1:val]\n            }\n        }\n    }\n\n\
    \    return ret\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3oo1amwr_test.go:42:33: cannot use planetList[val + 1:val2] (value of
    type []string) as type []interface{} in assignment

    /tmp/tmp3oo1amwr_test.go:44:33: cannot use planetList[val2 + 1:val] (value of
    type []string) as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074320
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    // make a map with the names and indeces in it to make lookup\
    \ easier\n    m := make(map[string]int)\n    for i, planet := range planets {\n\
    \        m[planet] = i\n    }\n    index1, ok1 := m[planet1]\n    index2, ok2\
    \ := m[planet2]\n    // if one of the planets does not exist return nil\n    if\
    \ !ok1 || !ok2 {\n        return nil\n    }\n    // if both planets exist but\
    \ are the same just return one of them\n    if planet1 == planet2 {\n        return\
    \ []interface{}{planet1}\n    }\n    // if planet1 is not before planet2 swap\
    \ them\n    if index1 > index2 {\n        planet1, planet2 = planet2, planet1\n\
    \        index1, index2 = index2, index1\n    }\n    // now collect the planets\n\
    \    result := make([]interface{}, 0)\n    for i := index1 + 1; i < index2; i++\
    \ {\n        result = append(result, planets[i])\n    }\n    return result\n}\n\
    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__4 (0.00s)\n  \
    \      tmpmgg4vgnv_test.go:73: expected '[]', got '[Earth]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074320
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    all_planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    all_planets_map := make(map[string]int)\n    for i, planet\
    \ := range all_planets {\n        all_planets_map[planet] = i\n    }\n    planet1_idx,\
    \ planet1_exists := all_planets_map[planet1]\n    planet2_idx, planet2_exists\
    \ := all_planets_map[planet2]\n    if !planet1_exists || !planet2_exists {\n \
    \       return []interface{}{}\n    }\n    planets := []interface{}{}\n    if\
    \ planet1_idx < planet2_idx {\n        for i := planet1_idx+1; i < planet2_idx;\
    \ i++ {\n            planets = append(planets, all_planets[i])\n        }\n  \
    \  } else {\n        for i := planet2_idx+1; i < planet1_idx; i++ {\n        \
    \    planets = append(planets, all_planets[i])\n        }\n    }\n    return planets\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    p := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    from, from_index := contains(p, planet1)\n    to, to_index\
    \ := contains(p, planet2)\n    if from && to {\n        if from_index > to_index\
    \ {\n            return p[to_index:from_index]\n        } else {\n           \
    \ return p[from_index:to_index]\n        }\n    } else {\n        return []interface{}{}\n\
    \    }\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxh9uxejg_test.go:26:25: undefined: contains

    /tmp/tmpxh9uxejg_test.go:27:21: undefined: contains

    /tmp/tmpxh9uxejg_test.go:30:21: cannot use p[to_index:from_index] (value of type
    []string) as type []interface{} in return statement

    /tmp/tmpxh9uxejg_test.go:32:21: cannot use p[from_index:to_index] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074320
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    p := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    c1, c2 := false, false\n    r := []interface{}{}\n    for\
    \ i, v := range p {\n        if v == planet1 {\n            c1 = true\n      \
    \      if i <= len(p) - 2 {\n                for _, v2 := range p[i+1:] {\n  \
    \                  if v2 == planet2 {\n                        c2 = true\n   \
    \                     break\n                    }\n                    r = append(r,\
    \ v2)\n                }\n            }\n            break\n        }\n    }\n\
    \    if c1 && c2 {\n        return r\n    }\n    return nil\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpspt4ybcq_test.go:68: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpspt4ybcq_test.go:68: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // map planets to\
    \ their index in the array\n    planet_map := map[string]int {\n        \"Mercury\"\
    : 0,\n        \"Venus\": 1,\n        \"Earth\": 2,\n        \"Mars\": 3,\n   \
    \     \"Jupiter\": 4,\n        \"Saturn\": 5,\n        \"Uranus\": 6,\n      \
    \  \"Neptune\": 7,\n    }\n    if _, planet1_exists := planet_map[planet1]; !planet1_exists\
    \ {\n        return []interface{}{}\n    }\n    if _, planet2_exists := planet_map[planet2];\
    \ !planet2_exists {\n        return []interface{}{}\n    }\n    if planet_map[planet1]\
    \ < planet_map[planet2] {\n        return []interface{}{}\n    }\n    // order\
    \ planets from closest to furthest from the sun\n    planets := []string{\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    }\n    var result []interface{}\n    for _, planet := range planets {\n      \
    \  if planet_map[planet] > planet_map[planet1] && planet_map[planet] < planet_map[planet2]\
    \ {\n            result = append(result, planet)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmp9muhkmt6_test.go:75: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmp9muhkmt6_test.go:75: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmp9muhkmt6_test.go:75:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmp9muhkmt6_test.go:75: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\tarr := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n\tresult := []interface{}{}\n\tcheckPlanet1 := false\n\tcheckPlanet2\
    \ := false\n\tfor _, v := range arr {\n\t\tif v == planet1 {\n\t\t\tcheckPlanet1\
    \ = true\n\t\t}\n\t\tif v == planet2 {\n\t\t\tcheckPlanet2 = true\n\t\t}\n\t}\n\
    \tif checkPlanet1 && checkPlanet2 {\n\t\tfor i, v := range arr {\n\t\t\tif v ==\
    \ planet1 {\n\t\t\t\tfor j := i+1; j < len(arr); j++ {\n\t\t\t\t\tif arr[j] ==\
    \ planet2 {\n\t\t\t\t\t\treturn result\n\t\t\t\t\t}\n\t\t\t\t\tresult = append(result,\
    \ arr[j])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpelk0i7t4_test.go:71: expected '[Venus]', got '[Mars Jupiter Saturn Uranus\
    \ Neptune]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpelk0i7t4_test.go:71:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[]'\n    --- FAIL: TestBf/test_num__4\
    \ (0.00s)\n        tmpelk0i7t4_test.go:71: expected '[]', got '[Mars Jupiter Saturn\
    \ Uranus Neptune]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpelk0i7t4_test.go:71:\
    \ expected '[]', got '[Jupiter Saturn Uranus Neptune]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, v := range planets {\n\
    \        if v == planet1 {\n            p1 = i\n        }\n        if v == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    res := []interface{}{}\n    for i := p1 + 1; i < p2; i++ {\n     \
    \   res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1, p2 := -1, -1\n    for i, p := range planets {\n      \
    \  if p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n\
    \            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n       \
    \ return nil\n    }\n    if p1 < p2 {\n        return planets[p1+1:p2]\n    }\
    \ else {\n        return planets[p2+1:p1]\n    }\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqs80nup2_test.go:39:23: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    /tmp/tmpqs80nup2_test.go:41:23: cannot use planets[p2 + 1:p1] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = map[string]int{\n\
    \        \"Mercury\": 1,\n        \"Venus\": 2,\n        \"Earth\": 3,\n     \
    \   \"Mars\": 4,\n        \"Jupiter\": 5,\n        \"Saturn\": 6,\n        \"\
    Uranus\": 7,\n        \"Neptune\": 8,\n    }\n    var result []interface{}\n \
    \   var found1, found2 bool\n    var p1, p2 int\n    if planets[planet1] != 0\
    \ {\n        found1 = true\n        p1 = planets[planet1]\n    }\n    if planets[planet2]\
    \ != 0 {\n        found2 = true\n        p2 = planets[planet2]\n    }\n    if\
    \ found1 && found2 {\n        if p1 < p2 {\n            for key, val := range\
    \ planets {\n                if val > p1 && val < p2 {\n                    result\
    \ = append(result, key)\n                }\n            }\n        } else {\n\
    \            for key, val := range planets {\n                if val > p2 && val\
    \ < p1 {\n                    result = append(result, key)\n                }\n\
    \            }\n        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__3 (0.00s)\n  \
    \      tmpxllebvd8_test.go:83: expected '[Earth Mars Jupiter Saturn Uranus]',\
    \ got '[Jupiter Saturn Uranus Earth Mars]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    inner := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    outer := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    var res []interface{}\n\
    \n    if !isIn(planet1, inner) || !isIn(planet2, outer) {\n        return res\n\
    \    }\n\n    planet1 = \"Mercury\"\n    planet2 = \"Uranus\"\n\n    if planet1\
    \ == planet2 {\n        return res\n    }\n\n    if !isIn(planet1, inner) {\n\
    \        if isIn(planet1, outer) {\n            inner, outer = outer, inner\n\
    \        } else {\n            return res\n        }\n    }\n\n    if !isIn(planet2,\
    \ outer) {\n        if isIn(planet2, inner) {\n            inner, outer = outer,\
    \ inner\n        } else {\n            return res\n        }\n    }\n\n    idx1\
    \ := 0\n    idx2 := 0\n    for i, v := range inner {\n        if v == planet1\
    \ {\n            idx1 = i\n        }\n        if v == planet2 {\n            idx2\
    \ = i\n        }\n    }\n\n    idx3 := 0\n    idx4 := 0\n    for i, v := range\
    \ outer {\n        if v == planet1 {\n            idx3 = i\n        }\n      \
    \  if v == planet2 {\n            idx4 = i\n        }\n    }\n\n    if idx1 >\
    \ idx2 {\n        idx1, idx2 = idx2, idx1\n    }\n\n    if idx3 > idx4 {\n   \
    \     idx3, idx4 = idx4, idx3\n    }\n\n    if idx1 == idx3 && idx2 == idx4 {\n\
    \        for _, v := range inner[idx1:idx2+1] {\n            res = append(res,\
    \ v)\n        }\n    } else {\n        for _, v := range inner[idx1:idx2+1\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz1p8ka0q_test.go:91:44: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074320
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    var flag1, flag2 int\n    for\
    \ i, v := range planets {\n        if v == planet1 {\n            flag1 = i\n\
    \        }\n        if v == planet2 {\n            flag2 = i\n        }\n    }\n\
    \    if flag1 > flag2 {\n        flag1, flag2 = flag2, flag1\n    }\n    for i,\
    \ v := range planets {\n        if flag1 <= i && i <= flag2 {\n            result\
    \ = append(result, v)\n        }\n    }\n    return result\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmphd1jj7ae_test.go:66: expected '[Saturn Uranus]', got '[Jupiter Saturn\
    \ Uranus Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmphd1jj7ae_test.go:66:\
    \ expected '[Venus]', got '[Mercury Venus Earth]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmphd1jj7ae_test.go:66: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[Mercury Venus Earth Mars Jupiter Saturn Uranus]'\n    --- FAIL:\
    \ TestBf/test_num__3 (0.00s)\n        tmphd1jj7ae_test.go:66: expected '[Earth\
    \ Mars Jupiter Saturn Uranus]', got '[Venus Earth Mars Jupiter Saturn Uranus Neptune]'\n\
    \    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmphd1jj7ae_test.go:66: expected\
    \ '[]', got '[Earth]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmphd1jj7ae_test.go:66:\
    \ expected '[]', got '[Earth Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n\
    \        tmphd1jj7ae_test.go:66: expected '[]', got '[Mercury Venus Earth Mars\
    \ Jupiter]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074322
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Make sure that\
    \ planet1 is closer to the Sun than planet2\n    planets := []string{ \"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \n                         \"Saturn\"\
    , \"Uranus\", \"Neptune\" }\n    if planet1 == planet2 {\n        return []interface{}{}\n\
    \    }\n    idx1 := -1\n    idx2 := -1\n    for i, planet := range planets {\n\
    \        if planet == planet1 {\n            idx1 = i\n        }\n        if planet\
    \ == planet2 {\n            idx2 = i\n        }\n    }\n    if idx1 < 0 || idx2\
    \ < 0 {\n        return []interface{}{}\n    }\n    if idx1 > idx2 {\n       \
    \ planet1, planet2 = planet2, planet1\n        idx1, idx2 = idx2, idx1\n    }\n\
    \    ret := make([]interface{}, idx2 - idx1 - 1)\n    for i := 0; i < idx2 - idx1\
    \ - 1; i++ {\n        ret[i] = planets[idx1 + i + 1]\n    }\n    return ret\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074322
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code here\n\
    \    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmp55jh4crb_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmp55jh4crb_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmp55jh4crb_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmp55jh4crb_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074322
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    solar_system := make(map[string]int)\n\
    \    solar_system[\"Mercury\"] = 1\n    solar_system[\"Venus\"] = 2\n    solar_system[\"\
    Earth\"] = 3\n    solar_system[\"Mars\"] = 4\n    solar_system[\"Jupiter\"] =\
    \ 5\n    solar_system[\"Saturn\"] = 6\n    solar_system[\"Uranus\"] = 7\n    solar_system[\"\
    Neptune\"] = 8\n\n    planet1_idx, exists := solar_system[planet1]\n    if !exists\
    \ {\n        return []interface{}{}\n    }\n    planet2_idx, exists := solar_system[planet2]\n\
    \    if !exists {\n        return []interface{}{}\n    }\n\n    if planet1_idx\
    \ > planet2_idx {\n        // swap\n        planet1_idx, planet2_idx = planet2_idx,\
    \ planet1_idx\n    }\n\n    keys := make([]string, 0, len(solar_system))\n   \
    \ for k := range solar_system {\n        keys = append(keys, k)\n    }\n\n   \
    \ res := make([]interface{}, 0, planet2_idx - planet1_idx)\n    for i := planet1_idx\
    \ + 1; i < planet2_idx; i++ {\n        res = append(res, keys[i])\n    }\n   \
    \ return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmppf57m9je_test.go:80: expected '[Saturn Uranus]', got '[Mercury Venus]'\n\
    \    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmppf57m9je_test.go:80: expected\
    \ '[Venus]', got '[Mars]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmppf57m9je_test.go:80:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Mars Jupiter Saturn Uranus\
    \ Neptune]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074322
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Write your code\
    \ here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpnhv4kdax_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpnhv4kdax_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpnhv4kdax_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpnhv4kdax_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074128
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n  return nil\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpi6z1euw5_test.go:47: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpi6z1euw5_test.go:47: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpi6z1euw5_test.go:47:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpi6z1euw5_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074322
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := map[string]int{\n\
    \        \"Mercury\": 1,\n        \"Venus\": 2,\n        \"Earth\": 3,\n     \
    \   \"Mars\": 4,\n        \"Jupiter\": 5,\n        \"Saturn\": 6,\n        \"\
    Uranus\": 7,\n        \"Neptune\": 8,\n    }\n    var (\n        a []interface{}\n\
    \        p1, p2 int\n    )\n    if p1, ok := planets[planet1]; ok {\n        if\
    \ p2, ok := planets[planet2]; ok {\n            if p1 > p2 {\n               \
    \ p1, p2 = p2, p1\n            }\n            for k, v := range planets {\n  \
    \              if v > p1 && v < p2 {\n                    a = append(a, k)\n \
    \               }\n            }\n        }\n    }\n    return a\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpipqz72i5_test.go:37:9: p1 declared but not used

    /tmp/tmpipqz72i5_test.go:37:13: p2 declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074322
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planetMap := map[string]int{\n\
    \        \"Mercury\": 0,\n        \"Venus\": 1,\n        \"Earth\": 2,\n     \
    \   \"Mars\": 3,\n        \"Jupiter\": 4,\n        \"Saturn\": 5,\n        \"\
    Uranus\": 6,\n        \"Neptune\": 7,\n    }\n    var planetList []interface{}\n\
    \    var planetSlice []int\n    for _, v := range planetMap {\n        planetSlice\
    \ = append(planetSlice, v)\n    }\n    if planetMap[planet1] > planetMap[planet2]\
    \ {\n        for i := planetMap[planet1]; i >= planetMap[planet2]; i-- {\n   \
    \         planetList = append(planetList, planetSlice[i])\n        }\n    } else\
    \ {\n        for i := planetMap[planet1]; i <= planetMap[planet2]; i++ {\n   \
    \         planetList = append(planetList, planetSlice[i])\n        }\n    }\n\
    \    return planetList\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpban7ti7o_test.go:71: expected '[Saturn Uranus]', got '[%!s(int=5) %!s(int=6)\
    \ %!s(int=7) %!s(int=0)]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpban7ti7o_test.go:71:\
    \ expected '[Venus]', got '[%!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL:\
    \ TestBf/test_num__2 (0.00s)\n        tmpban7ti7o_test.go:71: expected '[Venus\
    \ Earth Mars Jupiter Saturn]', got '[%!s(int=7) %!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4) %!s(int=5)]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n\
    \        tmpban7ti7o_test.go:71: expected '[Earth Mars Jupiter Saturn Uranus]',\
    \ got '[%!s(int=0) %!s(int=7) %!s(int=6) %!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2)]'\n\
    \    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpban7ti7o_test.go:71: expected\
    \ '[]', got '[%!s(int=4)]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n       \
    \ tmpban7ti7o_test.go:71: expected '[]', got '[%!s(int=7) %!s(int=6)]'\n    ---\
    \ FAIL: TestBf/test_num__6 (0.00s)\n        tmpban7ti7o_test.go:71: expected '[]',\
    \ got '[%!s(int=5) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074322
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    pos1 := -1\n    pos2 := -1\n    for i, v := range planets\
    \ {\n        if v == planet1 {\n            pos1 = i\n        }\n        if v\
    \ == planet2 {\n            pos2 = i\n        }\n    }\n    if pos1 == -1 || pos2\
    \ == -1 {\n        return []interface{}{}\n    }\n    planets = planets[pos1:pos2+1]\n\
    \    if pos1 > pos2 {\n        planets = planets[pos2:pos1+1]\n    }\n    return\
    \ planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt56vu6q6_test.go:43:12: cannot use planets (variable of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074322
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var start, end, planets\
    \ []interface{}\n    switch planet1 {\n        case \"Mercury\":\n           \
    \ start = append(start, 0)\n        case \"Venus\":\n            start = append(start,\
    \ 1)\n        case \"Earth\":\n            start = append(start, 2)\n        case\
    \ \"Mars\":\n            start = append(start, 3)\n        case \"Jupiter\":\n\
    \            start = append(start, 4)\n        case \"Saturn\":\n            start\
    \ = append(start, 5)\n        case \"Uranus\":\n            start = append(start,\
    \ 6)\n        case \"Neptune\":\n            start = append(start, 7)\n      \
    \  default:\n            start = append(start, -1)\n    }\n    switch planet2\
    \ {\n        case \"Mercury\":\n            end = append(end, 0)\n        case\
    \ \"Venus\":\n            end = append(end, 1)\n        case \"Earth\":\n    \
    \        end = append(end, 2)\n        case \"Mars\":\n            end = append(end,\
    \ 3)\n        case \"Jupiter\":\n            end = append(end, 4)\n        case\
    \ \"Saturn\":\n            end = append(end, 5)\n        case \"Uranus\":\n  \
    \          end = append(end, 6)\n        case \"Neptune\":\n            end =\
    \ append(end, 7)\n        default:\n            end = append(end, -1)\n    }\n\
    \    if start[0] != -1 && end[0] != -1 {\n        if start[0] > end[0] {\n   \
    \         start[0], end[0] = end[0], start[0]\n        }\n        for i := start[0];\
    \ i <= end[0]; i++ {\n            planets = append(planets,\n                []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}[i])\n        }\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprve6xbkl_test.go:67:12: invalid operation: start[0] > end[0] (operator
    > not defined on interface)

    /tmp/tmprve6xbkl_test.go:70:28: invalid operation: i <= end[0] (operator <= not
    defined on interface)

    /tmp/tmprve6xbkl_test.go:70:41: invalid operation: i++ (non-numeric type interface{})

    /tmp/tmprve6xbkl_test.go:72:105: invalid argument: index i (variable of type interface{})
    must be integer

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074322
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planetOrder := []string{}\n    result := []interface{}{}\n\
    \    planet1Index := -1\n    planet2Index := -1\n    for i, planet := range planets\
    \ {\n        if planet == planet1 {\n            planet1Index = i\n        }\n\
    \        if planet == planet2 {\n            planet2Index = i\n        }\n   \
    \ }\n    if planet1Index < 0 || planet2Index < 0 {\n        return result\n  \
    \  }\n    if planet1Index <= planet2Index {\n        planetOrder = append(planetOrder,\
    \ planets[planet1Index:]...)\n        planetOrder = append(planetOrder, planets[:planet2Index]...)\n\
    \    } else {\n        planetOrder = append(planetOrder, planets[planet1Index:planet2Index]...)\n\
    \    }\n    for _, planet := range planetOrder {\n        if planet != planet1\
    \ && planet != planet2 {\n            result = append(result, planet)\n      \
    \  }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\npanic: runtime error: slice bounds out of range\
    \ [2:0] [recovered]\n\tpanic: runtime error: slice bounds out of range [2:0]\n\
    \ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513780, 0xc0001c8000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513780,\
    \ 0xc0001c8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.bf({0x51e62f, 0x5}, {0x51eae1, 0x7})\n\t\
    /tmp/tmpsz0swwxp_test.go:45 +0x727\ncommand-line-arguments_test.TestBf(0x0?)\n\
    \t/tmp/tmpsz0swwxp_test.go:63 +0x97\ntesting.tRunner(0xc000185040, 0x5290d0)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074323
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    if !isPlanet(planet1)\
    \ || !isPlanet(planet2) {\n        return nil\n    }\n    if planet1 == planet2\
    \ {\n        return []interface{}{planet1}\n    }\n    a, b := 0, 0\n    planets\
    \ := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"}\n    for i, v := range planets {\n        if v == planet1\
    \ {\n            a = i\n        }\n        if v == planet2 {\n            b =\
    \ i\n        }\n    }\n    var c []interface{}\n    for i := a; i < b; i++ {\n\
    \        c = append(c, planets[i])\n    }\n    return c\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmeiv2nbu_test.go:25:9: undefined: isPlanet

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074322
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n  planets := []string{\n\
    \    \"Mercury\",\n    \"Venus\",\n    \"Earth\",\n    \"Mars\",\n    \"Jupiter\"\
    ,\n    \"Saturn\",\n    \"Uranus\",\n    \"Neptune\",\n  }\n  result := []interface{}{}\n\
    \  var start, end int\n  for i, v := range planets {\n    if v == planet1 {\n\
    \      start = i\n    }\n    if v == planet2 {\n      end = i\n    }\n  }\n  if\
    \ start > end {\n    for i:=end; i<=start; i++ {\n      result = append(result,\
    \ planets[i])\n    }\n  } else {\n    for i:=start; i<=end; i++ {\n      result\
    \ = append(result, planets[i])\n    }\n  }\n  return result\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmp0ogu063z_test.go:76: expected '[Saturn Uranus]', got '[Jupiter Saturn\
    \ Uranus Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmp0ogu063z_test.go:76:\
    \ expected '[Venus]', got '[Mercury Venus Earth]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmp0ogu063z_test.go:76: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[Mercury Venus Earth Mars Jupiter Saturn Uranus]'\n    --- FAIL:\
    \ TestBf/test_num__3 (0.00s)\n        tmp0ogu063z_test.go:76: expected '[Earth\
    \ Mars Jupiter Saturn Uranus]', got '[Venus Earth Mars Jupiter Saturn Uranus Neptune]'\n\
    \    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmp0ogu063z_test.go:76: expected\
    \ '[]', got '[Earth]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmp0ogu063z_test.go:76:\
    \ expected '[]', got '[Earth Mars]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n\
    \        tmp0ogu063z_test.go:76: expected '[]', got '[Mercury Venus Earth Mars\
    \ Jupiter]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074323
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var orderedPlanets\
    \ = []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"}\n    var planetIndex1, planetIndex2 int\n    var foundPlanet1,\
    \ foundPlanet2 bool\n    for i, planet := range orderedPlanets {\n        if planet\
    \ == planet1 {\n            planetIndex1 = i\n            foundPlanet1 = true\n\
    \        }\n        if planet == planet2 {\n            planetIndex2 = i\n   \
    \         foundPlanet2 = true\n        }\n    }\n    if !foundPlanet1 || !foundPlanet2\
    \ {\n        return []interface{}{}\n    }\n    if planetIndex1 > planetIndex2\
    \ {\n        planetIndex1, planetIndex2 = planetIndex2, planetIndex1\n    }\n\
    \    return orderedPlanets[planetIndex1+1:planetIndex2]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp50divyhb_test.go:44:26: cannot use orderedPlanets[planetIndex1 + 1:planetIndex2]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074323
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    if !exists(planet1)\
    \ || !exists(planet2) {\n        return []interface{}{}\n    }\n    orbits :=\
    \ []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"}\n    pos_planet1 := 0\n    pos_planet2 := 0\n    for\
    \ i, v := range orbits {\n        if v == planet1 {\n            pos_planet1 =\
    \ i\n        }\n        if v == planet2 {\n            pos_planet2 = i\n     \
    \   }\n    }\n    if pos_planet1 == pos_planet2 {\n        return []interface{}{}\n\
    \    }\n    min, max := min(pos_planet1, pos_planet2), max(pos_planet1, pos_planet2)\n\
    \    var ret []interface{}\n    for i := min + 1; i < max; i++ {\n        ret\
    \ = append(ret, orbits[i])\n    }\n    return ret\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxpr29yqa_test.go:25:9: undefined: exists

    /tmp/tmpxpr29yqa_test.go:42:17: undefined: min

    /tmp/tmpxpr29yqa_test.go:42:48: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074323
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // # of planet\n\
    \    var num_of_planets = 8\n    // map of planets\n    var planets = []string{\n\
    \        \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\"\
    ,\n        \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"\
    Neptune\",\n    }\n    // map of indices of planet1 and planet2\n    var planet1_index,\
    \ planet2_index int\n\n    var planet_index int = 0\n    for _, planet := range\
    \ planets {\n        if planet == planet1 {\n            planet1_index = planet_index\n\
    \        }\n        if planet == planet2 {\n            planet2_index = planet_index\n\
    \        }\n        planet_index++\n    }\n\n    var planets_between []interface{}\n\
    \    for planet_index = planet1_index; planet_index <= planet2_index; planet_index++\
    \ {\n        planets_between = append(planets_between, planets[planet_index])\n\
    \    }\n\n    return planets_between\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2344elbl_test.go:26:9: num_of_planets declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074323
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet_list := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1_index := 0\n    p2_index := 0\n    for i, planet := range\
    \ planet_list {\n        if planet == planet1 {\n            p1_index = i\n  \
    \      }\n        if planet == planet2 {\n            p2_index = i\n        }\n\
    \    }\n    if p1_index == 0 || p2_index == 0 {\n        return []interface{}{}\n\
    \    }\n    if p1_index > p2_index {\n        p1_index, p2_index = p2_index, p1_index\n\
    \    }\n    return planet_list[p1_index+1:p2_index]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptrpm26ct_test.go:42:23: cannot use planet_list[p1_index + 1:p2_index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074323
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Write your code\
    \ here\n    m := map[string]int{\n        \"Mercury\": 1,\n        \"Venus\":\
    \ 2,\n        \"Earth\": 3,\n        \"Mars\": 4,\n        \"Jupiter\": 5,\n \
    \       \"Saturn\": 6,\n        \"Uranus\": 7,\n        \"Neptune\": 8,\n    }\n\
    \    p1, ok1 := m[planet1]\n    p2, ok2 := m[planet2]\n    if !ok1 || !ok2 {\n\
    \        return []interface{}{}\n    }\n    if p1 > p2 {\n        p1, p2 = p2,\
    \ p1\n    }\n    r := []interface{}{}\n    for i := p1+1; i < p2; i++ {\n    \
    \    for k, v := range m {\n            if v == i {\n                r = append(r,\
    \ k)\n            }\n        }\n    }\n    return r\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074324
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    int1 := findPlanetIndex(planets, planet1)\n    int2 := findPlanetIndex(planets,\
    \ planet2)\n    res := []interface{}{}\n    for i := int1; i <= int2; i++ {\n\
    \        res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpakn2gks4_test.go:26:13: undefined: findPlanetIndex

    /tmp/tmpakn2gks4_test.go:27:13: undefined: findPlanetIndex

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return nil\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpbw3czdoh_test.go:47: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpbw3czdoh_test.go:47:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1Index := -1\n    planet2Index := -1\n    for i, p :=\
    \ range planets {\n        if p == planet1 {\n            planet1Index = i\n \
    \       } else if p == planet2 {\n            planet2Index = i\n        }\n  \
    \  }\n    if planet1Index == -1 || planet2Index == -1 {\n        return []interface{}{}\n\
    \    }\n    if planet1Index > planet2Index {\n        tmp := planet1Index\n  \
    \      planet1Index = planet2Index\n        planet2Index = tmp\n    }\n    return\
    \ planets[planet1Index+1:planet2Index]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp44gwaoed_test.go:43:19: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := map[string]int{\n\
    \        \"Mercury\": 1, \"Venus\": 2, \"Earth\": 3,\n        \"Mars\": 4, \"\
    Jupiter\": 5, \"Saturn\": 6,\n        \"Uranus\": 7, \"Neptune\": 8,\n    }\n\
    \    var result []interface{}\n    if _, ok := planets[planet1]; !ok {\n     \
    \   return result\n    }\n    if _, ok := planets[planet2]; !ok {\n        return\
    \ result\n    }\n    planet1_orbit := planets[planet1]\n    planet2_orbit := planets[planet2]\n\
    \    for orbit, planet := range planets {\n        if planet1_orbit < planet2_orbit\
    \ {\n            if planet1_orbit < planet && planet < planet2_orbit {\n     \
    \           result = append(result, orbit)\n            }\n        } else {\n\
    \            if planet2_orbit < planet && planet < planet1_orbit {\n         \
    \       result = append(result, orbit)\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__2 (0.00s)\n  \
    \      tmpk6kaoduk_test.go:72: expected '[Venus Earth Mars Jupiter Saturn]', got\
    \ '[Saturn Venus Earth Mars Jupiter]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n\
    \        tmpk6kaoduk_test.go:72: expected '[Earth Mars Jupiter Saturn Uranus]',\
    \ got '[Jupiter Saturn Uranus Earth Mars]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    a := make([]interface{},\
    \ 0)\n    return a\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpb9w_m45f_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpb9w_m45f_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpb9w_m45f_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpb9w_m45f_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\n\
    \        \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\"\
    ,\n        \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"\
    Neptune\",\n    }\n    planetMap := make(map[string]int)\n    for i, planet :=\
    \ range planets {\n        planetMap[planet] = i\n    }\n    if _, ok := planetMap[planet1];\
    \ !ok {\n        return nil\n    }\n    if _, ok := planetMap[planet2]; !ok {\n\
    \        return nil\n    }\n    start, end := planetMap[planet1], planetMap[planet2]\n\
    \    if start == end {\n        return nil\n    }\n    if start > end {\n    \
    \    start, end = end, start\n    }\n    var res []interface{}\n    for i := start+1;\
    \ i < end; i++ {\n        res = append(res, planets[i])\n    }\n    return res\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    p := map[string]int\
    \ {\n        \"Mercury\": 1,\n        \"Venus\": 2,\n        \"Earth\": 3,\n \
    \       \"Mars\": 4,\n        \"Jupiter\": 5,\n        \"Saturn\": 6,\n      \
    \  \"Uranus\": 7,\n        \"Neptune\": 8,\n    }\n    x := p[planet1]\n    y\
    \ := p[planet2]\n    if x == 0 || y == 0 {\n        return []interface{}{}\n \
    \   }\n    if x > y {\n        return []interface{}{}\n    }\n    var result []interface{}\n\
    \    for i := x + 1; i < y; i++ {\n        for key, value := range p {\n     \
    \       if value == i {\n                result = append(result, key)\n      \
    \      }\n        }\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmps41kvu37_test.go:73: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmps41kvu37_test.go:73: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var bfPlanets []interface{}\n    for i := 0; i < len(planets);\
    \ i++ {\n        if planets[i] == planet1 {\n            if i < 4 {\n        \
    \        for j := 4; j < len(planets); j++ {\n                    bfPlanets =\
    \ append(bfPlanets, planets[j])\n                }\n            } else {\n   \
    \             for j := 0; j < i; j++ {\n                    bfPlanets = append(bfPlanets,\
    \ planets[j])\n                }\n            }\n        }\n    }\n    for i :=\
    \ 0; i < len(planets); i++ {\n        if planets[i] == planet2 {\n           \
    \ if i < 4 {\n                for j := 4; j < len(planets); j++ {\n          \
    \          bfPlanets = append(bfPlanets, planets[j])\n                }\n    \
    \        } else {\n                for j := 0; j < i; j++ {\n                \
    \    bfPlanets = append(bfPlanets, planets[j])\n                }\n          \
    \  }\n        }\n    }\n    return bfPlanets\n}\n\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpqe_rhmcw_test.go:75: expected '[Saturn Uranus]', got '[Mercury Venus\
    \ Earth Mars Mercury Venus Earth Mars Jupiter Saturn Uranus]'\n    --- FAIL: TestBf/test_num__1\
    \ (0.00s)\n        tmpqe_rhmcw_test.go:75: expected '[Venus]', got '[Jupiter Saturn\
    \ Uranus Neptune Jupiter Saturn Uranus Neptune]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpqe_rhmcw_test.go:75: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[Jupiter Saturn Uranus Neptune Mercury Venus Earth Mars Jupiter\
    \ Saturn]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpqe_rhmcw_test.go:75:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Mercury Venus Earth Mars\
    \ Jupiter Saturn Uranus Jupiter Saturn Uranus Neptune]'\n    --- FAIL: TestBf/test_num__4\
    \ (0.00s)\n        tmpqe_rhmcw_test.go:75: expected '[]', got '[Jupiter Saturn\
    \ Uranus Neptune Jupiter Saturn Uranus Neptune]'\n    --- FAIL: TestBf/test_num__5\
    \ (0.00s)\n        tmpqe_rhmcw_test.go:75: expected '[]', got '[Jupiter Saturn\
    \ Uranus Neptune Jupiter Saturn Uranus Neptune]'\n    --- FAIL: TestBf/test_num__6\
    \ (0.00s)\n        tmpqe_rhmcw_test.go:75: expected '[]', got '[Mercury Venus\
    \ Earth Mars]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return nil\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpbw3czdoh_test.go:47: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpbw3czdoh_test.go:47:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := map[string]int{\n\
    \        \"Mercury\": 1,\n        \"Venus\": 2,\n        \"Earth\": 3,\n     \
    \   \"Mars\": 4,\n        \"Jupiter\": 5,\n        \"Saturn\": 6,\n        \"\
    Uranus\": 7,\n        \"Neptune\": 8,\n    }\n    p1, ok1 := planets[planet1]\n\
    \    p2, ok2 := planets[planet2]\n    if !ok1 || !ok2 {\n        return []interface{}{}\n\
    \    }\n    res := []interface{}{}\n    for k, v := range planets {\n        if\
    \ (p1 <= v && v <= p2) || (p2 <= v && v <= p1) {\n            res = append(res,\
    \ k)\n        }\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpbe799cfl_test.go:68: expected '[Saturn Uranus]', got '[Jupiter Saturn\
    \ Uranus Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpbe799cfl_test.go:68:\
    \ expected '[Venus]', got '[Venus Earth Mercury]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpbe799cfl_test.go:68: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[Jupiter Saturn Uranus Mercury Venus Earth Mars]'\n    --- FAIL:\
    \ TestBf/test_num__3 (0.00s)\n        tmpbe799cfl_test.go:68: expected '[Earth\
    \ Mars Jupiter Saturn Uranus]', got '[Earth Mars Jupiter Saturn Uranus Neptune\
    \ Venus]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpbe799cfl_test.go:68:\
    \ expected '[]', got '[Earth]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n   \
    \     tmpbe799cfl_test.go:68: expected '[]', got '[Earth Mars]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return []interface{}{\"\
    Mars\", \"Jupiter\", \"Saturn\"}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmprwafa4id_test.go:47: expected '[Saturn Uranus]', got '[Mars Jupiter\
    \ Saturn]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmprwafa4id_test.go:47:\
    \ expected '[Venus]', got '[Mars Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmprwafa4id_test.go:47: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[Mars Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n\
    \        tmprwafa4id_test.go:47: expected '[Earth Mars Jupiter Saturn Uranus]',\
    \ got '[Mars Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n    \
    \    tmprwafa4id_test.go:47: expected '[]', got '[Mars Jupiter Saturn]'\n    ---\
    \ FAIL: TestBf/test_num__5 (0.00s)\n        tmprwafa4id_test.go:47: expected '[]',\
    \ got '[Mars Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n    \
    \    tmprwafa4id_test.go:47: expected '[]', got '[Mars Jupiter Saturn]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    a := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    res := []interface{}{}\n    flag1 := false\n    flag2 := false\n\
    \    for _, s := range a {\n        if s == planet1 {\n            flag1 = true\n\
    \        }\n        if s == planet2 {\n            flag2 = true\n        }\n \
    \       if flag1 && !flag2 {\n            res = append(res, s)\n        }\n  \
    \  }\n    if !flag1 || !flag2 {\n        return res\n    }\n    return res[:len(res)-1]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\npanic: runtime error: slice bounds out of range\
    \ [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of range [:-1]\n\
    \ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x515780, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x515780,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.bf(...)\n\t/tmp/tmpgagnk7s6_test.go:43\n\
    command-line-arguments_test.TestBf(0xc0001a0340?)\n\t/tmp/tmpgagnk7s6_test.go:54\
    \ +0x2866\ntesting.tRunner(0xc0001a0340, 0x52b0d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    PLANETS := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    pl := make([]interface{}, 0)\n    if (planet1 == planet2)\
    \ {\n        return pl\n    }\n    i1 := -1\n    i2 := -1\n    for i, p := range\
    \ PLANETS {\n        if p == planet1 {\n            i1 = i\n        }\n      \
    \  if p == planet2 {\n            i2 = i\n        }\n    }\n    for i, p := range\
    \ PLANETS {\n        if i1 < i2 {\n            if i1 < i && i < i2 {\n       \
    \         pl = append(pl, p)\n            }\n        } else {\n            if\
    \ i2 < i && i < i1 {\n                pl = append(pl, p)\n            }\n    \
    \    }\n    }\n    return pl\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpxwg8g8hy_test.go:73: expected '[]', got '[Mercury Venus Earth Mars]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    start, stop := -1, -1\n    for i, planet := range planets\
    \ {\n        if planet == planet1 {\n            start = i\n        }\n      \
    \  if planet == planet2 {\n            stop = i\n        }\n    }\n    if start\
    \ == -1 || stop == -1 {\n        return []interface{}{}\n    }\n    if start >\
    \ stop {\n        start, stop = stop, start\n    }\n    return planets[start +\
    \ 1:stop]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph62lc08n_test.go:41:19: cannot use planets[start + 1:stop] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074325
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, planet := range planets\
    \ {\n        if planet == planet1 {\n            p1 = i\n        }\n        if\
    \ planet == planet2 {\n            p2 = i\n        }\n    }\n    if p1 == -1 ||\
    \ p2 == -1 {\n        return []interface{}{}\n    }\n    if p1 > p2 {\n      \
    \  p1, p2 = p2, p1\n    }\n    ret := []interface{}{}\n    for i := p1+1; i <\
    \ p2; i++ {\n        ret = append(ret, planets[i])\n    }\n    return ret\n}\n\
    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\n\
    \        \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\"\
    ,\n        \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"\
    Neptune\",\n    }\n    p1 := -1\n    p2 := -1\n    for i, planet := range planets\
    \ {\n        if planet == planet1 {\n            p1 = i\n        }\n        if\
    \ planet == planet2 {\n            p2 = i\n        }\n    }\n    if p1 == -1 ||\
    \ p2 == -1 {\n        return []interface{}{}\n    }\n    if p1 > p2 {\n      \
    \  p1, p2 = p2, p1\n    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo5qt4bme_test.go:51:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074325
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    m := map[string]int{\n\
    \        \"Mercury\": 1,\n        \"Venus\": 2,\n        \"Earth\": 3,\n     \
    \   \"Mars\": 4,\n        \"Jupiter\": 5,\n        \"Saturn\": 6,\n        \"\
    Uranus\": 7,\n        \"Neptune\": 8,\n    }\n    v1, ok1 := m[planet1]\n    v2,\
    \ ok2 := m[planet2]\n    if !ok1 || !ok2 {\n        return []interface{}{}\n \
    \   }\n    if v1 == v2 {\n        return []interface{}{}\n    }\n    var tmp int\n\
    \    var sl []interface{}\n    if v1 > v2 {\n        tmp = v1\n        v1 = v2\n\
    \        v2 = tmp\n    }\n    for i := v1 + 1; i < v2; i++ {\n        for k, v\
    \ := range m {\n            if v == i {\n                sl = append(sl, k)\n\
    \            }\n        }\n    }\n    return sl\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var list []interface{}\n\
    \    // 8 planets in our solar system\n    planets := []string{\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    }\n    l := len(planets)\n    var m, n int\n    for i := 0; i < l; i++ {\n   \
    \     if planets[i] == planet1 {\n            m = i\n        }\n        if planets[i]\
    \ == planet2 {\n            n = i\n        }\n    }\n    if m == n {\n       \
    \ return list\n    } else if m > n {\n        m, n = n, m\n    }\n    for i :=\
    \ m + 1; i < n; i++ {\n        list = append(list, planets[i])\n    }\n    return\
    \ list\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpa7krai5r_test.go:68: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074326
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1Pos := -1\n    planet2Pos := -1\n    for i, planet\
    \ := range planets {\n        if planet == planet1 {\n            planet1Pos =\
    \ i\n        } else if planet == planet2 {\n            planet2Pos = i\n     \
    \   }\n    }\n    if planet1Pos == -1 || planet2Pos == -1 {\n        return []interface{}{}\n\
    \    }\n    var res []interface{}\n    if planet1Pos < planet2Pos {\n        res\
    \ = planets[planet1Pos+1:planet2Pos]\n    } else {\n        res = planets[planet2Pos+1:planet1Pos]\n\
    \    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv_rbh33a_test.go:40:22: cannot use planets[planet1Pos + 1:planet2Pos]
    (value of type []string) as type []interface{} in assignment

    /tmp/tmpv_rbh33a_test.go:42:22: cannot use planets[planet2Pos + 1:planet1Pos]
    (value of type []string) as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    inbetween := []interface{}{}\n\
    \    a, b := solarSystemPosition(planet1), solarSystemPosition(planet2)\n    if\
    \ a == -1 || b == -1 {\n        return inbetween\n    }\n\n    if a <= b {\n \
    \       return solarSystem[a+1:b]\n    } else {\n        return solarSystem[b+1:a]\n\
    \    }\n}\n\nvar solarSystem = []interface{}{\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkgf54qya_test.go:26:13: undefined: solarSystemPosition

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074326
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\tvar sortedPlanets =\
    \ []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"}\n\tvar result []interface{}\n\tvar foundFirstPlanet,\
    \ foundSecondPlanet bool\n\t\n\tfor _, planet := range sortedPlanets {\n\t\tif\
    \ planet == planet1 {\n\t\t\tfoundFirstPlanet = true\n\t\t} else if planet ==\
    \ planet2 {\n\t\t\tfoundSecondPlanet = true\n\t\t} else if foundFirstPlanet {\n\
    \t\t\tresult = append(result, planet)\n\t\t}\n\t\tif foundSecondPlanet {\n\t\t\
    \tbreak\n\t\t}\n\t}\n\treturn result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpozkh2qw3_test.go:63: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpozkh2qw3_test.go:63: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpozkh2qw3_test.go:63:\
    \ expected '[]', got '[Mars Jupiter Saturn Uranus Neptune]'\n    --- FAIL: TestBf/test_num__6\
    \ (0.00s)\n        tmpozkh2qw3_test.go:63: expected '[]', got '[Saturn Uranus\
    \ Neptune]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074326
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var orbits []interface{}\n    // first planet\n    first :=\
    \ -1\n    // second planet\n    second := -1\n    // first and second planet\n\
    \    fst := false\n    snd := false\n    // Find the corresponding planets\n \
    \   for i, planet := range planets {\n        if planet == planet1 {\n       \
    \     first = i\n            fst = true\n        }\n        if planet == planet2\
    \ {\n            second = i\n            snd = true\n        }\n    }\n    //\
    \ If the corresponding planet not found return a empty list\n    if !fst || !snd\
    \ {\n        return orbits\n    }\n    // Ascending order\n    if first < second\
    \ {\n        for i := first + 1; i < second; i++ {\n            orbits = append(orbits,\
    \ planets[i])\n        }\n    } else {\n        for i := second + 1; i < first;\
    \ i++ {\n            orbits = append(orbits, planets[i])\n        }\n    }\n \
    \   return orbits\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074326
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := [8]string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1Index := -1\n    planet2Index := -1\n    for index,\
    \ planet := range planets {\n        if planet == planet1 {\n            planet1Index\
    \ = index\n        }\n        if planet == planet2 {\n            planet2Index\
    \ = index\n        }\n    }\n    if planet1Index == -1 || planet2Index == -1 {\n\
    \        return []interface{}{}\n    }\n\n    if planet1Index < planet2Index {\n\
    \        return planets[planet1Index+1:planet2Index]\n    } else {\n        return\
    \ planets[planet2Index+1:planet1Index]\n    }\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoipwb4u3_test.go:41:23: cannot use planets[planet1Index + 1:planet2Index]
    (value of type []string) as type []interface{} in return statement

    /tmp/tmpoipwb4u3_test.go:43:23: cannot use planets[planet2Index + 1:planet1Index]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074326
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\tvar distanceToSun =\
    \ map[string]int{\n\t\t\"Mercury\": 0,\n\t\t\"Venus\": 1,\n\t\t\"Earth\": 2,\n\
    \t\t\"Mars\": 3,\n\t\t\"Jupiter\": 4,\n\t\t\"Saturn\": 5,\n\t\t\"Uranus\": 6,\n\
    \t\t\"Neptune\": 7,\n\t}\n\tvar planetsBetween = make([]interface{}, 0)\n\tvar\
    \ planets = []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"}\n\tvar p1, p2 int\n\tif (distanceToSun[planet1]\
    \ != 0) {\n\t\tp1 = distanceToSun[planet1]\n\t} else {\n\t\tfmt.Println(\"planet1\
    \ is not a planet\")\n\t\treturn planetsBetween\n\t}\n\tif (distanceToSun[planet2]\
    \ != 0) {\n\t\tp2 = distanceToSun[planet2]\n\t} else {\n\t\tfmt.Println(\"planet2\
    \ is not a planet\")\n\t\treturn planetsBetween\n\t}\n\tif (p1 <= p2) {\n\t\t\
    for i := p1 + 1; i < p2; i++ {\n\t\t\tplanetsBetween = append(planetsBetween,\
    \ planets[i])\n\t\t}\n\t} else {\n\t\tfor i := p2 + 1; i < p1; i++ {\n\t\t\tplanetsBetween\
    \ = append(planetsBetween, planets[i])\n\t\t}\n\t}\n\treturn planetsBetween\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "planet2 is not a planet\nplanet1 is not a planet\nplanet2 is not a planet\n\
    --- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmppe9ehnxs_test.go:81:\
    \ expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n   \
    \     tmppe9ehnxs_test.go:81: expected '[Venus Earth Mars Jupiter Saturn]', got\
    \ '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074326
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planetSlice := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet1Pos, planet2Pos int\n    var planets []interface{}\n\
    \    for _, planet := range planetSlice {\n        if planet == planet1 {\n  \
    \          planet1Pos = i\n        } else if planet == planet2 {\n           \
    \ planet2Pos = i\n        }\n    }\n    if planet1Pos == 0 || planet2Pos == 0\
    \ {\n        return planets\n    } else if planet1Pos == planet2Pos {\n      \
    \  planets = append(planets, planet1)\n    } else if planet1Pos < planet2Pos {\n\
    \        planets = planetSlice[planet1Pos+1:planet2Pos]\n    } else {\n      \
    \  planets = planetSlice[planet2Pos+1:planet1Pos]\n    }\n    return planets\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr9_pqjvz_test.go:30:26: undefined: i

    /tmp/tmpr9_pqjvz_test.go:32:26: undefined: i

    /tmp/tmpr9_pqjvz_test.go:40:30: cannot use planetSlice[planet1Pos + 1:planet2Pos]
    (value of type []string) as type []interface{} in assignment

    /tmp/tmpr9_pqjvz_test.go:42:30: cannot use planetSlice[planet2Pos + 1:planet1Pos]
    (value of type []string) as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074326
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var emptyList []interface{}\n\
    \    if planet1 == \"\" || planet2 == \"\" {\n        return emptyList\n    }\n\
    \    planet := map[string]int{\n        \"Mercury\": 1,\n        \"Venus\": 2,\n\
    \        \"Earth\": 3,\n        \"Mars\": 4,\n        \"Jupiter\": 5,\n      \
    \  \"Saturn\": 6,\n        \"Uranus\": 7,\n        \"Neptune\": 8,\n    }\n  \
    \  planet_order := []string{\n        \"Mercury\",\n        \"Venus\",\n     \
    \   \"Earth\",\n        \"Mars\",\n        \"Jupiter\",\n        \"Saturn\",\n\
    \        \"Uranus\",\n        \"Neptune\",\n    }\n    _, ok1 := planet[planet1]\n\
    \    _, ok2 := planet[planet2]\n    if !ok1 || !ok2 {\n        return emptyList\n\
    \    }\n    var num1, num2 int\n    num1 = planet[planet1]\n    num2 = planet[planet2]\n\
    \    if num1 > num2 {\n        num1, num2 = num2, num1\n    }\n    var ret_list\
    \ []interface{}\n    for i := num1+1; i < num2; i++ {\n        ret_list = append(ret_list,\
    \ planet_order[i-1])\n    }\n    return ret_list\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074327
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var res []interface{}\n\
    \    if planet1 != \"Mercury\" && planet1 != \"Venus\" && planet1 != \"Earth\"\
    \ && planet1 != \"Mars\" && planet1 != \"Jupiter\" && planet1 != \"Saturn\" &&\
    \ planet1 != \"Uranus\" && planet1 != \"Neptune\" {\n        return res\n    }\n\
    \    if planet2 != \"Mercury\" && planet2 != \"Venus\" && planet2 != \"Earth\"\
    \ && planet2 != \"Mars\" && planet2 != \"Jupiter\" && planet2 != \"Saturn\" &&\
    \ planet2 != \"Uranus\" && planet2 != \"Neptune\" {\n        return res\n    }\n\
    \    if planet1 == planet2 {\n        return res\n    }\n    var planets = [8]string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start int\n    var end int\n    for i := 0; i < len(planets);\
    \ i++ {\n        if planets[i] == planet1 {\n            start = i\n        }\n\
    \        if planets[i] == planet2 {\n            end = i\n        }\n    }\n \
    \   if start > end {\n        end = start + end\n        start = end - start\n\
    \        end = end - start\n    }\n    for i := start + 1; i < end; i++ {\n  \
    \      res = append(res, planets[i])\n    }\n    return res\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074327
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var index1, index2 int\n\n    for i, v := range planets {\n\
    \        if v == planet1 {\n            index1 = i\n        }\n\n        if v\
    \ == planet2 {\n            index2 = i\n        }\n    }\n\n    if index1 == 0\
    \ && index2 == 0 {\n        return nil\n    }\n\n    if index1 > index2 {\n  \
    \      index1, index2 = index2, index1\n    }\n\n    return planets[index1 + 1:index2]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppdfho06w_test.go:46:19: cannot use planets[index1 + 1:index2] (value of
    type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074327
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\n\
    \        \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\"\
    ,\n        \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"\
    Neptune\",\n    }\n    var indexes = map[string]int{\n        \"Mercury\": 0,\n\
    \        \"Venus\": 1,\n        \"Earth\": 2,\n        \"Mars\": 3,\n        \"\
    Jupiter\": 4,\n        \"Saturn\": 5,\n        \"Uranus\": 6,\n        \"Neptune\"\
    : 7,\n    }\n    var p1, p2 = indexes[planet1], indexes[planet2]\n    var res\
    \ []interface{}\n    for p1 < p2 {\n        res = append(res, planets[p1])\n \
    \       p1++\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmp4krjj1pd_test.go:73: expected '[Saturn Uranus]', got '[Jupiter Saturn\
    \ Uranus]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmp4krjj1pd_test.go:73:\
    \ expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n   \
    \     tmp4krjj1pd_test.go:73: expected '[Venus Earth Mars Jupiter Saturn]', got\
    \ '[Mercury Venus Earth Mars Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmp4krjj1pd_test.go:73: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074328
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"\
    Jupiter\" {\n        return []interface{}{\"Saturn\", \"Uranus\"}\n    } else\
    \ if planet1 == \"Earth\" {\n        return []interface{}{\"Venus\"}\n    } else\
    \ if planet1 == \"Mercury\" {\n        return []interface{}{\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"}\n    } else {\n        return []interface{}{}\n\
    \    }\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__3 (0.00s)\n  \
    \      tmpkusf_83j_test.go:55: expected '[Earth Mars Jupiter Saturn Uranus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpkusf_83j_test.go:55:\
    \ expected '[]', got '[Venus]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n   \
    \     tmpkusf_83j_test.go:55: expected '[]', got '[Saturn Uranus]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074328
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // max is the maximum\
    \ number of possible planets between planet1 and planet2\n    max := 8\n    //\
    \ We need to store the index of planet1 and planet2\n    index1 := 0\n    index2\
    \ := 0\n    // List of planets\n    planets := []string{\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n   \
    \ // List to return\n    in_between := make([]interface{}, max)\n    // Find the\
    \ index of planet1\n    for i, planet := range planets {\n        if planet ==\
    \ planet1 {\n            index1 = i\n        }\n    }\n    // Find the index of\
    \ planet2\n    for i, planet := range planets {\n        if planet == planet2\
    \ {\n            index2 = i\n        }\n    }\n    // We are only interested in\
    \ the planets between the two planets\n    if index1 > index2 {\n        index1,\
    \ index2 = index2, index1\n    }\n    // Sort the planets from closest to furthest\
    \ from the sun\n    for i := index1 + 1; i < index2; i++ {\n        in_between[i]\
    \ = planets[i]\n    }\n    return in_between\n}\n\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpmeg5x75z_test.go:76: expected '[Saturn Uranus]', got '[<nil> <nil> <nil>\
    \ <nil> <nil> Saturn Uranus <nil>]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n\
    \        tmpmeg5x75z_test.go:76: expected '[Venus]', got '[<nil> Venus <nil> <nil>\
    \ <nil> <nil> <nil> <nil>]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n      \
    \  tmpmeg5x75z_test.go:76: expected '[Venus Earth Mars Jupiter Saturn]', got '[<nil>\
    \ Venus Earth Mars Jupiter Saturn <nil> <nil>]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpmeg5x75z_test.go:76: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[<nil> <nil> Earth Mars Jupiter Saturn Uranus <nil>]'\n    ---\
    \ FAIL: TestBf/test_num__4 (0.00s)\n        tmpmeg5x75z_test.go:76: expected '[]',\
    \ got '[<nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil>]'\n    --- FAIL: TestBf/test_num__5\
    \ (0.00s)\n        tmpmeg5x75z_test.go:76: expected '[]', got '[<nil> <nil> <nil>\
    \ <nil> <nil> <nil> <nil> <nil>]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n\
    \        tmpmeg5x75z_test.go:76: expected '[]', got '[<nil> Venus Earth Mars <nil>\
    \ <nil> <nil> <nil>]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074328
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets map[string]int\
    \ = map[string]int {\n        \"Mercury\": 1,\n        \"Venus\": 2,\n       \
    \ \"Earth\": 3,\n        \"Mars\": 4,\n        \"Jupiter\": 5,\n        \"Saturn\"\
    : 6,\n        \"Uranus\": 7,\n        \"Neptune\": 8,\n    }\n    var ret []interface{}\n\
    \    planet1Index, ok1 := planets[planet1]\n    planet2Index, ok2 := planets[planet2]\n\
    \    if !ok1 || !ok2 {\n        return ret\n    }\n    if planet1Index < planet2Index\
    \ {\n        for i := planet1Index + 1; i < planet2Index; i++ {\n            for\
    \ planet, index := range planets {\n                if index == i {\n        \
    \            ret = append(ret, planet)\n                }\n            }\n   \
    \     }\n    } else {\n        for i := planet2Index + 1; i < planet1Index; i++\
    \ {\n            for planet, index := range planets {\n                if index\
    \ == i {\n                    ret = append(ret, planet)\n                }\n \
    \           }\n        }\n    }\n    return ret\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074328
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // your code here\n\
    \    return []interface{}{}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate :=\
    \ bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmptdxa5e59_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmptdxa5e59_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmptdxa5e59_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmptdxa5e59_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet := map[string]int\
    \ {\n        \"Mercury\": 1,\n        \"Venus\": 2,\n        \"Earth\": 3,\n \
    \       \"Mars\": 4,\n        \"Jupiter\": 5,\n        \"Saturn\": 6,\n      \
    \  \"Uranus\": 7,\n        \"Neptune\": 8,\n    }\n    orbit := []string {\n \
    \       \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\"\
    ,\n        \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"\
    Neptune\",\n    }\n    _, ok1 := planet[planet1]\n    _, ok2 := planet[planet2]\n\
    \    if ok1 == false || ok2 == false {\n        return nil\n    }\n    if planet[planet1]\
    \ > planet[planet2] {\n        planet1, planet2 = planet2, planet1\n    }\n  \
    \  res := []interface{}{}\n    for i := planet[planet1] + 1; i < planet[planet2];\
    \ i++ {\n        res = append(res, orbit[i])\n    }\n    return res\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpx5r7jmvq_test.go:79: expected '[Saturn Uranus]', got '[Uranus Neptune]'\n\
    \    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpx5r7jmvq_test.go:79: expected\
    \ '[Venus]', got '[Earth]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n       \
    \ tmpx5r7jmvq_test.go:79: expected '[Venus Earth Mars Jupiter Saturn]', got '[Earth\
    \ Mars Jupiter Saturn Uranus]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n   \
    \     tmpx5r7jmvq_test.go:79: expected '[Earth Mars Jupiter Saturn Uranus]', got\
    \ '[Mars Jupiter Saturn Uranus Neptune]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074328
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    start, end := 0, 0\n    for i, v := range planets {\n    \
    \    if v == planet1 {\n            start = i\n        }\n        if v == planet2\
    \ {\n            end = i\n        }\n    }\n    if start > end {\n        start,\
    \ end = end, start\n    }\n    fmt.Println(start, end)\n    // if start == end\
    \ {\n    //     fmt.Println(\"no between\")\n    //     return []interface{}{}\n\
    \    // }\n    // fmt.Println(planets[start:end])\n    // for _, v := range planets[start:end]\
    \ {\n    //     fmt.Println(v)\n    // }\n    return planets[start:end]\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8m3xexaq_test.go:47:19: cannot use planets[start:end] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074327
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, p := range planets {\n        if\
    \ p == planet1 {\n            p1 = i\n        }\n        if p == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 == 0 || p2 == 0 {\n        return\
    \ []interface{}{}\n    }\n    var res []interface{}\n    if p1 > p2 {\n      \
    \  for i := p2; i <= p1; i++ {\n            res = append(res, planets[i])\n  \
    \      }\n    } else {\n        for i := p1; i <= p2; i++ {\n            res =\
    \ append(res, planets[i])\n        }\n    }\n    return res\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpis_vonln_test.go:70: expected '[Saturn Uranus]', got '[Jupiter Saturn\
    \ Uranus Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpis_vonln_test.go:70:\
    \ expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n   \
    \     tmpis_vonln_test.go:70: expected '[Venus Earth Mars Jupiter Saturn]', got\
    \ '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpis_vonln_test.go:70:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Venus Earth Mars Jupiter\
    \ Saturn Uranus Neptune]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpis_vonln_test.go:70:\
    \ expected '[]', got '[Earth]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n   \
    \     tmpis_vonln_test.go:70: expected '[]', got '[Earth Mars]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074328
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\n\
    \        \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\"\
    ,\n        \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"\
    Neptune\",\n    }\n    m := make(map[string]int)\n    for i, p := range planets\
    \ {\n        m[p] = i\n    }\n    start, end := m[planet1], m[planet2]\n    if\
    \ start == 0 || end == 0 {\n        return []interface{}{}\n    }\n    if start\
    \ > end {\n        start, end = end, start\n    }\n    ret := make([]interface{},\
    \ 0)\n    for i := start + 1; i < end; i++ {\n        ret = append(ret, planets[i])\n\
    \    }\n    return ret\n}\n\n//#############################################################\n\
    //#                        MY SOLUTIONS                       #\n//#############################################################\n\
    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpcjj8xq3o_test.go:76: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpcjj8xq3o_test.go:76: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074328
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planetMap = map[string]int\
    \ {\n        \"Mercury\": 1,\n        \"Venus\": 2,\n        \"Earth\": 3,\n \
    \       \"Mars\": 4,\n        \"Jupiter\": 5,\n        \"Saturn\": 6,\n      \
    \  \"Uranus\": 7,\n        \"Neptune\": 8,\n    }\n    // check if they are in\
    \ the map\n    if _, ok := planetMap[planet1]; !ok {\n        return []interface{}{}\n\
    \    }\n    if _, ok := planetMap[planet2]; !ok {\n        return []interface{}{}\n\
    \    }\n    var res []interface{}\n    // now find all planets in between\n  \
    \  var start, end int\n    if planetMap[planet1] < planetMap[planet2] {\n    \
    \    start = planetMap[planet1]\n        end = planetMap[planet2]\n    } else\
    \ {\n        start = planetMap[planet2]\n        end = planetMap[planet1]\n  \
    \  }\n    for i := start + 1; i < end; i++ {\n        for planet, num := range\
    \ planetMap {\n            if num == i {\n                res = append(res, planet)\n\
    \            }\n        }\n    }\n    return res\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074328
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\tplanets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n\tvar leftIndex int\n\tvar rightIndex int\n\tvar output []interface{}\n\
    \tvar exist bool\n\tfor i, p := range planets {\n\t\tif p == planet1 {\n\t\t\t\
    leftIndex = i\n\t\t\texist = true\n\t\t}\n\t\tif p == planet2 {\n\t\t\trightIndex\
    \ = i\n\t\t\texist = true\n\t\t}\n\t}\n\tif !exist {\n\t\treturn output\n\t}\n\
    \tfor i := leftIndex; i <= rightIndex; i++ {\n\t\toutput = append(output, planets[i])\n\
    \t}\n\treturn output\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpriqmfgk9_test.go:68: expected '[Saturn Uranus]', got '[Jupiter Saturn\
    \ Uranus Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpriqmfgk9_test.go:68:\
    \ expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n   \
    \     tmpriqmfgk9_test.go:68: expected '[Venus Earth Mars Jupiter Saturn]', got\
    \ '[Mercury Venus Earth Mars Jupiter Saturn Uranus]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpriqmfgk9_test.go:68: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmpriqmfgk9_test.go:68:\
    \ expected '[]', got '[Earth]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074328
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var startIndex, endIndex int\n    var found1, found2 bool\n\
    \    for i, v := range planets {\n        if v == planet1 {\n            startIndex\
    \ = i\n            found1 = true\n        }\n        if v == planet2 {\n     \
    \       endIndex = i\n            found2 = true\n        }\n    }\n    if !found1\
    \ || !found2 {\n        return []interface{}{}\n    }\n    if startIndex < endIndex\
    \ {\n        return planets[startIndex + 1:endIndex]\n    } else {\n        return\
    \ planets[endIndex + 1:startIndex]\n    }\n}\n\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6z0ufi8q_test.go:42:23: cannot use planets[startIndex + 1:endIndex] (value
    of type []string) as type []interface{} in return statement

    /tmp/tmp6z0ufi8q_test.go:44:23: cannot use planets[endIndex + 1:startIndex] (value
    of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074328
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet_list := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planet_idx_list []int\n    var result []interface{}\n\
    \    for _, planet := range planet_list {\n        if planet == planet1 || planet\
    \ == planet2 {\n            planet_idx_list = append(planet_idx_list, idx_of(planet,\
    \ planet_list))\n        }\n    }\n    if len(planet_idx_list) == 2 {\n      \
    \  for i := planet_idx_list[0]; i < planet_idx_list[1]; i++ {\n            result\
    \ = append(result, planet_list[i])\n        }\n    }\n    return result\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0rxe8ls5_test.go:30:55: undefined: idx_of

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074328
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\tvar planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n\tvar result []interface{}\n\tvar start, stop int\n\tvar p1, p2\
    \ int\n\tvar found1, found2 bool\n\tfor i, p := range planets {\n\t\tif p == planet1\
    \ {\n\t\t\tp1 = i\n\t\t\tfound1 = true\n\t\t}\n\t\tif p == planet2 {\n\t\t\tp2\
    \ = i\n\t\t\tfound2 = true\n\t\t}\n\t}\n\tif found1 && found2 {\n\t\tif p1 > p2\
    \ {\n\t\t\tstart = p2 + 1\n\t\t\tstop = p1\n\t\t} else {\n\t\t\tstart = p1 + 1\n\
    \t\t\tstop = p2\n\t\t}\n\t\tfor i := start; i < stop; i++ {\n\t\t\tresult = append(result,\
    \ planets[i])\n\t\t}\n\t}\n\treturn result\n}\n\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074328
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    i1, i2 := -1, -1\n    for i, planet := range planets {\n \
    \       if planet == planet1 {\n            i1 = i\n        } else if planet ==\
    \ planet2 {\n            i2 = i\n        }\n    }\n    if i1 == -1 || i2 == -1\
    \ {\n        return []interface{}{}\n    }\n    if i1 < i2 {\n        return planets[i1+1:i2]\n\
    \    } else {\n        return planets[i2+1:i1]\n    }\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvngk9vh6_test.go:38:23: cannot use planets[i1 + 1:i2] (value of type []string)
    as type []interface{} in return statement

    /tmp/tmpvngk9vh6_test.go:40:23: cannot use planets[i2 + 1:i1] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074328
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = [...]string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    startIndex := -1\n    endIndex\
    \ := -1\n    for index, planet := range planets {\n        if planet == planet1\
    \ {\n            startIndex = index\n        }\n        if planet == planet2 {\n\
    \            endIndex = index\n        }\n    }\n    if startIndex > endIndex\
    \ {\n        startIndex, endIndex = endIndex, startIndex\n    }\n    for index\
    \ := startIndex + 1; index < endIndex; index++ {\n        result = append(result,\
    \ planets[index])\n    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpgrcib6iu_test.go:65: expected '[]', got '[Mercury Venus Earth Mars]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074328
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\tvar planets = map[string]int{\n\
    \t\t\"Mercury\": 1,\n\t\t\"Venus\": 2,\n\t\t\"Earth\": 3,\n\t\t\"Mars\": 4,\n\t\
    \t\"Jupiter\": 5,\n\t\t\"Saturn\": 6,\n\t\t\"Uranus\": 7,\n\t\t\"Neptune\": 8,\n\
    \t}\n\tvar result []interface{}\n\tvar start, end int\n\tfor k, v := range planets\
    \ {\n\t\tif k == planet1 {\n\t\t\tstart = v\n\t\t}\n\t\tif k == planet2 {\n\t\t\
    \tend = v\n\t\t}\n\t}\n\tif start > end {\n\t\tstart, end = end, start\n\t}\n\t\
    for k, v := range planets {\n\t\tif v > start && v < end {\n\t\t\tresult = append(result,\
    \ k)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__2 (0.00s)\n  \
    \      tmp1imr0iis_test.go:75: expected '[Venus Earth Mars Jupiter Saturn]', got\
    \ '[Earth Mars Jupiter Saturn Venus]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n\
    \        tmp1imr0iis_test.go:75: expected '[]', got '[Mercury Venus Earth Mars]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpjd37inte_test.go:47: expected '[Saturn Uranus]', got '[Venus Earth Mars\
    \ Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpjd37inte_test.go:47:\
    \ expected '[Venus]', got '[Venus Earth Mars Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpjd37inte_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[Venus Earth Mars Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__4\
    \ (0.00s)\n        tmpjd37inte_test.go:47: expected '[]', got '[Venus Earth Mars\
    \ Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpjd37inte_test.go:47:\
    \ expected '[]', got '[Venus Earth Mars Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__6\
    \ (0.00s)\n        tmpjd37inte_test.go:47: expected '[]', got '[Venus Earth Mars\
    \ Jupiter Saturn]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    solar_system := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var planets []interface{}\n    var start, end int\n\n    //\
    \ Get starting and ending index\n    for i, planet := range solar_system {\n \
    \       if planet == planet1 {\n            start = i\n        } else if planet\
    \ == planet2 {\n            end = i\n        }\n    }\n\n    // Order the index\n\
    \    if start > end {\n        start, end = end, start\n    }\n\n    // Check\
    \ if indexes are out of range\n    if start == 0 || end == 0 {\n        return\
    \ planets\n    }\n\n    // Generate result\n    for i := start; i <= end; i++\
    \ {\n        planets = append(planets, solar_system[i])\n    }\n\n    return planets\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpx5v8ts15_test.go:75: expected '[Saturn Uranus]', got '[Jupiter Saturn\
    \ Uranus Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpx5v8ts15_test.go:75:\
    \ expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n   \
    \     tmpx5v8ts15_test.go:75: expected '[Venus Earth Mars Jupiter Saturn]', got\
    \ '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpx5v8ts15_test.go:75:\
    \ expected '[Earth Mars Jupiter Saturn Uranus]', got '[Venus Earth Mars Jupiter\
    \ Saturn Uranus Neptune]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpx5v8ts15_test.go:75:\
    \ expected '[]', got '[Earth Mars]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074329
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    m := map[string]int{\n\
    \        \"Mercury\": 1,\n        \"Venus\": 2,\n        \"Earth\": 3,\n     \
    \   \"Mars\": 4,\n        \"Jupiter\": 5,\n        \"Saturn\": 6,\n        \"\
    Uranus\": 7,\n        \"Neptune\": 8,\n    }\n    if _, ok := m[planet1]; !ok\
    \ {\n        return nil\n    }\n    if _, ok := m[planet2]; !ok {\n        return\
    \ nil\n    }\n    var pl []interface{}\n    if m[planet1] > m[planet2] {\n   \
    \     tmp := planet1\n        planet1 = planet2\n        planet2 = tmp\n    }\n\
    \    for i := m[planet1] + 1; i < m[planet2]; i++ {\n        for k, v := range\
    \ m {\n            if v == i {\n                pl = append(pl, k)\n         \
    \   }\n        }\n    }\n    return pl\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074329
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planetsMap := make(map[string]int)\n    for i, p := range\
    \ planets {\n        planetsMap[p] = i\n    }\n    left := planetsMap[planet1]\n\
    \    right := planetsMap[planet2]\n    var s int\n    var e int\n    if left >\
    \ right {\n        s = right\n        e = left\n    } else {\n        s = left\n\
    \        e = right\n    }\n    ret := make([]interface{}, 0)\n    for i := s +\
    \ 1; i < e; i++ {\n        ret = append(ret, planets[i])\n    }\n    return ret\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmp0zme33xf_test.go:67: expected '[]', got '[Venus Earth Mars]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return nil\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpbw3czdoh_test.go:47: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpbw3czdoh_test.go:47:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1_index := -1\n    planet2_index := -1\n    for i, planet\
    \ := range planets {\n        if planet == planet1 {\n            planet1_index\
    \ = i\n        }\n        if planet == planet2 {\n            planet2_index =\
    \ i\n        }\n    }\n    if planet1_index == -1 || planet2_index == -1 {\n \
    \       return []interface{}{}\n    }\n    planets_between := []interface{}{}\n\
    \    for i := planet1_index + 1; i < planet2_index; i++ {\n        planets_between\
    \ = append(planets_between, planets[i])\n    }\n    return planets_between\n}\n\
    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmp_u5u0qiz_test.go:65: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmp_u5u0qiz_test.go:65: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074330
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planits := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var pos1, pos2 int\n    for i, v := range planits {\n    \
    \    if v == planet1 {\n            pos1 = i\n        }\n        if v == planet2\
    \ {\n            pos2 = i\n        }\n    }\n    fmt.Println(pos1, pos2)\n   \
    \ var ret []interface{}\n    if pos1 > pos2 {\n        for i := pos2 + 1; i <\
    \ pos1; i++ {\n            ret = append(ret, planits[i])\n        }\n    } else\
    \ {\n        for i := pos1 + 1; i < pos2; i++ {\n            ret = append(ret,\
    \ planits[i])\n        }\n    }\n    return ret\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "4 7\n2 0\n0 6\n7 1\n2 2\n3 2\n4 0\n--- FAIL: TestBf (0.00s)\n    --- FAIL:\
    \ TestBf/test_num__6 (0.00s)\n        tmpq4a3jxmy_test.go:68: expected '[]', got\
    \ '[Venus Earth Mars]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074330
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // your code here\n\
    \    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n    } else if planet1\
    \ == \"Earth\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"\
    }\n    } else if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        return\
    \ []interface{}{\"Saturn\", \"Uranus\"}\n    } else {\n        return []interface{}{}\n\
    \    }\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__3 (0.00s)\n  \
    \      tmpb7frwizu_test.go:56: expected '[Earth Mars Jupiter Saturn Uranus]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074330
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your solution\
    \ to this problem goes here\n    return []interface{}{}\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpjq7b4kgo_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpjq7b4kgo_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpjq7b4kgo_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpjq7b4kgo_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074330
- exit_code: 0
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    orbits := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    pos1 := -1\n    pos2 := -1\n    for i,v := range orbits {\n\
    \        if v == planet1 {\n            pos1 = i\n        }\n        if v == planet2\
    \ {\n            pos2 = i\n        }\n    }\n    if pos1 == -1 || pos2 == -1 {\n\
    \        return []interface{}{}\n    }\n    if pos1 > pos2 {\n        pos1, pos2\
    \ = pos2, pos1\n    }\n    planets := []interface{}{}\n    for i:=pos1+1; i<pos2;\
    \ i++ {\n        planets = append(planets, orbits[i])\n    }\n    return planets\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074330
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    start, end := -1, -1\n    for i, v := range planets {\n  \
    \      if v == planet1 {\n            start = i\n        } else if v == planet2\
    \ {\n            end = i\n        }\n    }\n    if start == -1 || end == -1 {\n\
    \        return []interface{}{}\n    }\n    if start > end {\n        tmp := start\n\
    \        start = end\n        end = tmp\n    }\n    return planets[start+1:end]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcum9zu76_test.go:42:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074330
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\tplanets := map[string]int{\n\
    \t\t\"Mercury\": 1,\n\t\t\"Venus\": 2,\n\t\t\"Earth\": 3,\n\t\t\"Mars\": 4,\n\t\
    \t\"Jupiter\": 5,\n\t\t\"Saturn\": 6,\n\t\t\"Uranus\": 7,\n\t\t\"Neptune\": 8,\n\
    \t}\n\tvar ret []interface{}\n\tfor k, v := range planets {\n\t\tif v >= planets[planet1]\
    \ && v <= planets[planet2] {\n\t\t\tret = append(ret, k)\n\t\t}\n\t}\n\treturn\
    \ ret\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmp30ct5qhy_test.go:63: expected '[Saturn Uranus]', got '[Uranus Neptune\
    \ Jupiter Saturn]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmp30ct5qhy_test.go:63:\
    \ expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n   \
    \     tmp30ct5qhy_test.go:63: expected '[Venus Earth Mars Jupiter Saturn]', got\
    \ '[Earth Mars Jupiter Saturn Uranus Mercury Venus]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmp30ct5qhy_test.go:63: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n        tmp30ct5qhy_test.go:63:\
    \ expected '[]', got '[Earth]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074331
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"\
    Mercury\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"}\n    } else if planet1\
    \ == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Jupiter\"\
    \ && planet2 == \"Neptune\" {\n        return []interface{}{\"Saturn\", \"Uranus\"\
    }\n    } else if planet1 == \"Earth\" && planet2 == \"Mercury\" {\n        return\
    \ []interface{}{\"Venus\"}\n    } else {\n        return []interface{}{}\n   \
    \ }\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__3 (0.00s)\n  \
    \      tmpe8z2cex6_test.go:57: expected '[Earth Mars Jupiter Saturn Uranus]',\
    \ got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074331
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1 := -1\n    p2 := -1\n    for i, p := range planets {\n\
    \        if p == planet1 {\n            p1 = i\n        }\n        if p == planet2\
    \ {\n            p2 = i\n        }\n    }\n    if p1 == -1 || p2 == -1 {\n   \
    \     return nil\n    }\n\n    if p1 < p2 {\n        return planets[p1+1:p2]\n\
    \    } else {\n        return planets[p2+1:p1]\n    }\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpss78zu_8_test.go:41:23: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    /tmp/tmpss78zu_8_test.go:43:23: cannot use planets[p2 + 1:p1] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074330
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    idx1 := -1\n    idx2 := -1\n    for i, v := range planets\
    \ {\n        if planet1 == v {\n            idx1 = i\n        }\n        if planet2\
    \ == v {\n            idx2 = i\n        }\n    }\n    if idx1 > idx2 {\n     \
    \   idx1, idx2 = idx2, idx1\n    }\n    idx1++\n    idx2--\n    if idx1 > idx2\
    \ {\n        return []interface{}{}\n    }\n    res := []interface{}{}\n    for\
    \ i := idx1; i <= idx2; i++ {\n        res = append(res, planets[i])\n    }\n\
    \    return res\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpdcjutz73_test.go:70: expected '[]', got '[Mercury Venus Earth Mars]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074331
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return nil\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpbw3czdoh_test.go:47: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpbw3czdoh_test.go:47:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return nil\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpbw3czdoh_test.go:47: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpbw3czdoh_test.go:47:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    bfmap := map[string]int\
    \ {\n        \"Mercury\": 1,\n        \"Venus\": 2,\n        \"Earth\": 3,\n \
    \       \"Mars\": 4,\n        \"Jupiter\": 5,\n        \"Saturn\": 6,\n      \
    \  \"Uranus\": 7,\n        \"Neptune\": 8,\n    }\n    var ret []interface{}\n\
    \    if _,ok := bfmap[planet1]; !ok {\n        return ret\n    }\n    if _,ok\
    \ := bfmap[planet2]; !ok {\n        return ret\n    }\n    if bfmap[planet1] >\
    \ bfmap[planet2] {\n        planet1, planet2 = planet2, planet1\n    }\n    for\
    \ k,v := range bfmap {\n        if v > bfmap[planet1] && v < bfmap[planet2] {\n\
    \            ret = append(ret, k)\n        }\n    }\n    return ret\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__3 (0.00s)\n  \
    \      tmph18tgdl9_test.go:72: expected '[Earth Mars Jupiter Saturn Uranus]',\
    \ got '[Saturn Uranus Earth Mars Jupiter]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074331
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var p1, p2 int\n    for i, v := range planets {\n        if\
    \ v == planet1 {\n            p1 = i\n        }\n        if v == planet2 {\n \
    \           p2 = i\n        }\n    }\n    if p1 > p2 {\n        p1, p2 = p2, p1\n\
    \    }\n    return planets[p1+1:p2]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl8t8jwj1_test.go:38:19: cannot use planets[p1 + 1:p2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074330
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    start := 0\n    end := 0\n    for i, planet := range planets\
    \ {\n        if planet == planet1 {\n            start = i\n        }\n      \
    \  if planet == planet2 {\n            end = i\n        }\n    }\n    if start\
    \ == 0 || end == 0 {\n        return []interface{}{}\n    }\n    if start > end\
    \ {\n        start, end = end, start\n    }\n    return planets[start+1:end]\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpekwddpoc_test.go:42:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074330
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets []string\
    \ = []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"}\n    var planet1Pos, planet2Pos int\n    var planetsInRange\
    \ []interface{}\n    for i, planet := range planets {\n        if planet == planet1\
    \ {\n            planet1Pos = i\n        }\n        if planet == planet2 {\n \
    \           planet2Pos = i\n        }\n    }\n    if planet1Pos < planet2Pos {\n\
    \        planetsInRange = append(planetsInRange, planets[planet1Pos + 1:planet2Pos]...)\n\
    \    } else {\n        planetsInRange = append(planetsInRange, planets[planet2Pos\
    \ + 1:planet1Pos]...)\n    }\n    return planetsInRange\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpojsie8k7_test.go:37:56: cannot use planets[planet1Pos + 1:planet2Pos]
    (value of type []string) as type []interface{} in argument to append

    /tmp/tmpojsie8k7_test.go:39:56: cannot use planets[planet2Pos + 1:planet1Pos]
    (value of type []string) as type []interface{} in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074330
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\tvar p1, p2 int\n\t\
    p1 = 0\n\tp2 = 0\n\tplanet1 = \"Mercury\"\n\tplanet2 = \"Neptune\"\n\tplanets\
    \ := []string{\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"}\n\tfor _, p := range planets {\n\t\tif p == planet1\
    \ {\n\t\t\tp1 = 1\n\t\t} else if p == planet2 {\n\t\t\tp2 = 1\n\t\t}\n\t}\n\t\
    var result []interface{}\n\tif p1 == 1 && p2 == 1 {\n\t\tfor _, p := range planets\
    \ {\n\t\t\tif p == planet1 {\n\t\t\t\tp1 = 1\n\t\t\t} else if p == planet2 {\n\
    \t\t\t\tp2 = 1\n\t\t\t}\n\t\t}\n\t} else {\n\t\tresult = []interface{}{}\n\t}\n\
    \tif p1 == 1 && p2 == 1 {\n\t\tif planet1 == \"Mercury\" {\n\t\t\tresult = []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    }\n\t\t} else if planet1 == \"Venus\" {\n\t\t\tresult = []interface{}{\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\t\t} else if planet1\
    \ == \"Earth\" {\n\t\t\tresult = []interface{}{\"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"}\n\t\t} else if planet1 == \"Mars\" {\n\t\t\tresult\
    \ = []interface{}{\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\t\t} else\
    \ if planet1 == \"Jupiter\" {\n\t\t\tresult = []interface{}{\"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n\t\t} else if planet1 == \"Saturn\" {\n\t\t\tresult = []interface{}{\"\
    Uranus\", \"Neptune\"}\n\t\t} else if planet1 == \"Uranus\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo1fkz106_test.go:63:24: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074330
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var start int = -1\n    var end int = -1\n    var flag bool\
    \ = false\n    var result []interface{}\n    for i := 0; i < len(planets); i++\
    \ {\n        if planets[i] == planet1 {\n            start = i\n            flag\
    \ = true\n        }\n        if planets[i] == planet2 {\n            end = i\n\
    \            flag = true\n        }\n        if start != -1 && end != -1 {\n \
    \           break\n        }\n    }\n    if !flag {\n        fmt.Println(\"\u8BF7\
    \u8F93\u5165\u6B63\u786E\u7684\u884C\u661F\u540D\u79F0\")\n        return result\n\
    \    }\n    if start > end {\n        start, end = end, start\n    }\n    for\
    \ i := start + 1; i < end; i++ {\n        result = append(result, planets[i])\n\
    \    }\n    return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__6 (0.00s)\n  \
    \      tmpu_f24xzt_test.go:75: expected '[]', got '[Mercury Venus Earth Mars]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074331
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var index1, index2 = -1, -1\n    for i, v := range planets\
    \ {\n        if v == planet1 {\n            index1 = i\n        }\n        if\
    \ v == planet2 {\n            index2 = i\n        }\n    }\n    if index1 == -1\
    \ || index2 == -1 {\n        return []interface{}{}\n    }\n    if index1 > index2\
    \ {\n        index1, index2 = index2, index1\n    }\n    planets = planets[index1+1:index2]\n\
    \    var list = make([]interface{}, len(planets))\n    for i, v := range planets\
    \ {\n        list[i] = v\n    }\n    return list\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\npanic: runtime error: slice bounds out of range\
    \ [3:2] [recovered]\n\tpanic: runtime error: slice bounds out of range [3:2]\n\
    \ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513780, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513780,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.bf({0x51e62f, 0x5}, {0x51e62f, 0x5})\n\t\
    /tmp/tmpobwdcn_z_test.go:41 +0x3fd\ncommand-line-arguments_test.TestBf(0x0?)\n\
    \t/tmp/tmpobwdcn_z_test.go:60 +0x145\ntesting.tRunner(0xc0001964e0, 0x5290d0)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074331
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var result []interface{}\n\
    \    var lower string\n    var upper string\n    planets := []string{\"Mercury\"\
    , \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    }\n    for i := 0; i < len(planets); i++ {\n        if planets[i] == planet1 {\n\
    \            lower = planet1\n        }\n        if planets[i] == planet2 {\n\
    \            upper = planet2\n        }\n    }\n    if lower == \"\" || upper\
    \ == \"\" {\n        return result\n    }\n    if lower == upper {\n        return\
    \ result\n    }\n    if lower == \"Mercury\" && upper == \"Venus\" {\n       \
    \ return []interface{}{\"Venus\"}\n    }\n    if lower == \"Mercury\" && upper\
    \ == \"Earth\" {\n        return []interface{}{\"Venus\", \"Earth\"}\n    }\n\
    \    if lower == \"Mercury\" && upper == \"Mars\" {\n        return []interface{}{\"\
    Venus\", \"Earth\", \"Mars\"}\n    }\n    if lower == \"Mercury\" && upper ==\
    \ \"Jupiter\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\",\
    \ \"Jupiter\"}\n    }\n    if lower == \"Mercury\" && upper == \"Saturn\" {\n\
    \        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\"}\n    }\n    if lower == \"Mercury\" && upper == \"Uranus\" {\n     \
    \   return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"}\n    }\n    if lower == \"Mercury\" && upper == \"Neptune\" {\n\
    \        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\"}\n    }\n    if lower == \"Venus\" && upper\
    \ == \"Earth\" {\n        return []interface{}{\"Earth\"}\n    }\n    if lower\
    \ == \"Venus\" && upper == \"Mars\" {\n        return []interface{}{\"Earth\"\
    , \"Mars\"}\n    }\n    if lower == \"Venus\" &&\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprbrektc8_test.go:71:6: expected ''('', found TestBf

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074330
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return []interface{}{\"\
    Saturn\", \"Uranus\"}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpkvknatzv_test.go:47: expected '[Venus]', got '[Saturn Uranus]'\n   \
    \ --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpkvknatzv_test.go:47: expected\
    \ '[Venus Earth Mars Jupiter Saturn]', got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpkvknatzv_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n\
    \        tmpkvknatzv_test.go:47: expected '[]', got '[Saturn Uranus]'\n    ---\
    \ FAIL: TestBf/test_num__5 (0.00s)\n        tmpkvknatzv_test.go:47: expected '[]',\
    \ got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpkvknatzv_test.go:47:\
    \ expected '[]', got '[Saturn Uranus]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    index1 := -1\n    index2 := -1\n    for i, planet := range\
    \ planets {\n        if planet == planet1 {\n            index1 = i\n        }\n\
    \        if planet == planet2 {\n            index2 = i\n        }\n    }\n  \
    \  if index1 == -1 || index2 == -1 {\n        return []interface{}{}\n    }\n\
    \    res := []interface{}{}\n    if index1 < index2 {\n        for _, planet :=\
    \ range planets[index1+1:index2] {\n            res = append(res, planet)\n  \
    \      }\n    } else {\n        for _, planet := range planets[index2+1:index1]\
    \ {\n            res = append(res, planet)\n        }\n    }\n    return res\n\
    }\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\"\
    , \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\npanic: runtime error: slice bounds out of range\
    \ [3:2] [recovered]\n\tpanic: runtime error: slice bounds out of range [3:2]\n\
    \ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513780, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513780,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.bf({0x51e62f, 0x5}, {0x51e62f, 0x5})\n\t\
    /tmp/tmpmck297va_test.go:45 +0x4ed\ncommand-line-arguments_test.TestBf(0x0?)\n\
    \t/tmp/tmpmck297va_test.go:63 +0x145\ntesting.tRunner(0xc0001924e0, 0x5290d0)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074331
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\tplanetNames := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n\tp1 := findPlanet(planet1, planetNames)\n\tp2 := findPlanet(planet2,\
    \ planetNames)\n\treturn findPlanets(p1, p2, planetNames)\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvv8k6m6p_test.go:26:8: undefined: findPlanet

    /tmp/tmpvv8k6m6p_test.go:27:8: undefined: findPlanet

    /tmp/tmpvv8k6m6p_test.go:28:9: undefined: findPlanets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074331
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    i1,i2 := 0,0\n    for index, planet := range planets {\n \
    \       if planet == planet1 {\n            i1 = index\n        }\n        if\
    \ planet == planet2 {\n            i2 = index\n        }\n    }\n    fmt.Println(i1,i2)\n\
    \    if i1 > i2 {\n        i1,i2 = i2,i1\n    }\n    if i1 != 0 || i2 != 0 {\n\
    \        return planets[i1+1:i2]\n    }\n    return []interface{}{}\n}\n\nfunc\
    \ TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3jj4whb9_test.go:40:23: cannot use planets[i1 + 1:i2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074331
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    switch(planet1) {\n\
    \        case \"Mercury\":\n            switch(planet2) {\n                case\
    \ \"Venus\":\n                    return []interface{}{\"Venus\"}\n          \
    \      case \"Earth\":\n                    return []interface{}{\"Venus\", \"\
    Earth\"}\n                case \"Mars\":\n                    return []interface{}{\"\
    Venus\", \"Earth\", \"Mars\"}\n                case \"Jupiter\":\n           \
    \         return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"}\n\
    \                case \"Saturn\":\n                    return []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n                case \"\
    Uranus\":\n                    return []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"}\n                case \"Neptune\":\n  \
    \                  return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"}\n            }\n        case \"Venus\"\
    :\n            switch(planet2) {\n                case \"Earth\":\n          \
    \          return []interface{}{\"Earth\"}\n                case \"Mars\":\n \
    \                   return []interface{}{\"Earth\", \"Mars\"}\n              \
    \  case \"Jupiter\":\n                    return []interface{}{\"Earth\", \"Mars\"\
    , \"Jupiter\"}\n                case \"Saturn\":\n                    return []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n                case \"Uranus\":\n\
    \                    return []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\"}\n                case \"Neptune\":\n                   \
    \ return []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n            }\n        case \"Earth\":\n            switch(planet2)\
    \ {\n                case \"Mars\":\n                    return []interface{}{\"\
    Mars\"}\n                case \"Jupiter\":\n                    return []interface{}{\"\
    Mars\", \"Jupiter\"}\n                case \"Saturn\":\n                    return\
    \ []interface{}{\"Mars\", \"Jupiter\", \"Saturn\"}\n                case \"Uranus\"\
    :\n                    return []interface{}{\"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpaua1w5j0_test.go:67:71: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074331
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\tif len(planet1) ==\
    \ 0 || len(planet2) == 0{\n\t\treturn nil\n\t}\n\tvar planets []string = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n\tvar position1, position2 int\n\tfor i, _ := range planets {\n\
    \t\tif planets[i] == planet1 {\n\t\t\tposition1 = i\n\t\t}else if planets[i] ==\
    \ planet2 {\n\t\t\tposition2 = i\n\t\t}\n\t}\n\tfmt.Println(position1, position2)\n\
    \tif position1 == position2 {\n\t\treturn nil\n\t}\n\tvar start, end int\n\tif\
    \ position1 < position2 {\n\t\tstart = position1\n\t\tend = position2\n\t}else\
    \ {\n\t\tstart = position2\n\t\tend = position1\n\t}\n\tvar ret []interface{}\n\
    \tfor i := start+1; i < end; i++ {\n\t\tret = append(ret, planets[i])\n\t}\n\t\
    return ret\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "4 7\n2 0\n0 6\n7 1\n2 0\n3 2\n4 0\n--- FAIL: TestBf (0.00s)\n    --- FAIL:\
    \ TestBf/test_num__4 (0.00s)\n        tmpw7g3airw_test.go:75: expected '[]', got\
    \ '[Venus]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpw7g3airw_test.go:75:\
    \ expected '[]', got '[Venus Earth Mars]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074332
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    switch planet1 {\n\
    \    case \"Mercury\":\n        return []interface{}{\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    case \"Venus\"\
    :\n        return []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\",\
    \ \"Uranus\", \"Neptune\"}\n    case \"Earth\":\n        return []interface{}{\"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    case \"Mars\":\n\
    \        return []interface{}{\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    }\n    case \"Jupiter\":\n        return []interface{}{\"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    case \"Saturn\":\n        return []interface{}{\"Uranus\"\
    , \"Neptune\"}\n    case \"Uranus\":\n        return []interface{}{\"Neptune\"\
    }\n    case \"Neptune\":\n        return []interface{}{}\n    default:\n     \
    \   return []interface{}{}\n    }\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpvfzpsnls_test.go:66: expected '[Saturn Uranus]', got '[Saturn Uranus\
    \ Neptune]'\n    --- FAIL: TestBf/test_num__1 (0.00s)\n        tmpvfzpsnls_test.go:66:\
    \ expected '[Venus]', got '[Mars Jupiter Saturn Uranus Neptune]'\n    --- FAIL:\
    \ TestBf/test_num__2 (0.00s)\n        tmpvfzpsnls_test.go:66: expected '[Venus\
    \ Earth Mars Jupiter Saturn]', got '[Venus Earth Mars Jupiter Saturn Uranus Neptune]'\n\
    \    --- FAIL: TestBf/test_num__3 (0.00s)\n        tmpvfzpsnls_test.go:66: expected\
    \ '[Earth Mars Jupiter Saturn Uranus]', got '[]'\n    --- FAIL: TestBf/test_num__4\
    \ (0.00s)\n        tmpvfzpsnls_test.go:66: expected '[]', got '[Mars Jupiter Saturn\
    \ Uranus Neptune]'\n    --- FAIL: TestBf/test_num__5 (0.00s)\n        tmpvfzpsnls_test.go:66:\
    \ expected '[]', got '[Jupiter Saturn Uranus Neptune]'\n    --- FAIL: TestBf/test_num__6\
    \ (0.00s)\n        tmpvfzpsnls_test.go:66: expected '[]', got '[Saturn Uranus\
    \ Neptune]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074332
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return nil\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmpbw3czdoh_test.go:47: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpbw3czdoh_test.go:47:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpbw3czdoh_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074130
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1_index := -1\n    planet2_index := -1\n    for i, p\
    \ := range planets {\n        if p == planet1 {\n            planet1_index = i\n\
    \        }\n        if p == planet2 {\n            planet2_index = i\n       \
    \ }\n    }\n    if planet1_index < 0 || planet2_index < 0 {\n        return []interface{}{}\n\
    \    }\n    var index_from int\n    var index_to int\n    if planet1_index > planet2_index\
    \ {\n        index_from = planet2_index\n        index_to = planet1_index\n  \
    \  } else {\n        index_from = planet1_index\n        index_to = planet2_index\n\
    \    }\n    //fmt.Println(planets[index_from : index_to+1])\n    return planets[index_from\
    \ : index_to+1]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp70sbqab8_test.go:49:19: cannot use planets[index_from:index_to + 1] (value
    of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074332
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var result []interface{}\n    p1 := 0\n    p2 := 0\n    for\
    \ i, p := range planets {\n        if p == planet1 {\n            p1 = i\n   \
    \     }\n        if p == planet2 {\n            p2 = i\n        }\n    }\n   \
    \ fmt.Println(p1, p2)\n    if p1 == 0 || p2 == 0 {\n        return result\n  \
    \  }\n    if p1 > p2 {\n        for i:=p2; i<=p1; i++ {\n            result =\
    \ append(result, planets[i])\n        }\n    } else {\n        for i:=p1; i<=p2;\
    \ i++ {\n            result = append(result, planets[i])\n        }\n    }\n \
    \   return result\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "4 7\n2 0\n0 6\n7 1\n2 2\n3 2\n4 0\n--- FAIL: TestBf (0.00s)\n    --- FAIL:\
    \ TestBf/test_num__0 (0.00s)\n        tmpgiwmg0dz_test.go:72: expected '[Saturn\
    \ Uranus]', got '[Jupiter Saturn Uranus Neptune]'\n    --- FAIL: TestBf/test_num__1\
    \ (0.00s)\n        tmpgiwmg0dz_test.go:72: expected '[Venus]', got '[]'\n    ---\
    \ FAIL: TestBf/test_num__2 (0.00s)\n        tmpgiwmg0dz_test.go:72: expected '[Venus\
    \ Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3 (0.00s)\n\
    \        tmpgiwmg0dz_test.go:72: expected '[Earth Mars Jupiter Saturn Uranus]',\
    \ got '[Venus Earth Mars Jupiter Saturn Uranus Neptune]'\n    --- FAIL: TestBf/test_num__4\
    \ (0.00s)\n        tmpgiwmg0dz_test.go:72: expected '[]', got '[Earth]'\n    ---\
    \ FAIL: TestBf/test_num__5 (0.00s)\n        tmpgiwmg0dz_test.go:72: expected '[]',\
    \ got '[Earth Mars]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074332
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\n\
    \        \"Mercury\",\n        \"Venus\",\n        \"Earth\",\n        \"Mars\"\
    ,\n        \"Jupiter\",\n        \"Saturn\",\n        \"Uranus\",\n        \"\
    Neptune\",\n    }\n    planet1_idx := -1\n    planet2_idx := -1\n    for i, name\
    \ := range planets {\n        if name == planet1 {\n            planet1_idx =\
    \ i\n        }\n        if name == planet2 {\n            planet2_idx = i\n  \
    \      }\n    }\n    fmt.Println(planet1_idx, planet2_idx)\n    if planet1_idx\
    \ == -1 || planet2_idx == -1 {\n        return []interface{}{}\n    }\n    if\
    \ planet1_idx > planet2_idx {\n        planet1_idx, planet2_idx = planet2_idx,\
    \ planet1_idx\n    }\n    fmt.Println(planet1_idx, planet2_idx)\n    return planets[planet1_idx\
    \ + 1:planet2_idx]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplbf6c4yc_test.go:53:19: cannot use planets[planet1_idx + 1:planet2_idx]
    (value of type []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074332
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    return []interface{}{\"\
    Saturn\", \"Uranus\"}\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpkvknatzv_test.go:47: expected '[Venus]', got '[Saturn Uranus]'\n   \
    \ --- FAIL: TestBf/test_num__2 (0.00s)\n        tmpkvknatzv_test.go:47: expected\
    \ '[Venus Earth Mars Jupiter Saturn]', got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmpkvknatzv_test.go:47: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__4 (0.00s)\n\
    \        tmpkvknatzv_test.go:47: expected '[]', got '[Saturn Uranus]'\n    ---\
    \ FAIL: TestBf/test_num__5 (0.00s)\n        tmpkvknatzv_test.go:47: expected '[]',\
    \ got '[Saturn Uranus]'\n    --- FAIL: TestBf/test_num__6 (0.00s)\n        tmpkvknatzv_test.go:47:\
    \ expected '[]', got '[Saturn Uranus]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074131
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\t// code here\n\treturn\
    \ nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__0 (0.00s)\n  \
    \      tmph925e21i_test.go:48: expected '[Saturn Uranus]', got '[]'\n    --- FAIL:\
    \ TestBf/test_num__1 (0.00s)\n        tmph925e21i_test.go:48: expected '[Venus]',\
    \ got '[]'\n    --- FAIL: TestBf/test_num__2 (0.00s)\n        tmph925e21i_test.go:48:\
    \ expected '[Venus Earth Mars Jupiter Saturn]', got '[]'\n    --- FAIL: TestBf/test_num__3\
    \ (0.00s)\n        tmph925e21i_test.go:48: expected '[Earth Mars Jupiter Saturn\
    \ Uranus]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074332
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    var planets = []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    var found_planet1, found_planet2 bool\n    var i1, i2 int\n\
    \    for i, p := range planets {\n        if p == planet1 {\n            found_planet1\
    \ = true\n            i1 = i\n        } else if p == planet2 {\n            found_planet2\
    \ = true\n            i2 = i\n        }\n    }\n    if !found_planet1 || !found_planet2\
    \ {\n        return []interface{}{}\n    }\n    if i1 > i2 {\n        i1, i2 =\
    \ i2, i1\n    }\n    return planets[i1+1:i2]\n}\n\nfunc TestBf(t *testing.T) {\n\
    \  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppr6uz0m2_test.go:43:19: cannot use planets[i1 + 1:i2] (value of type []string)
    as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074332
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    // Your code goes\
    \ here\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"\
    Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected:\
    \ []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"\
    ), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    } },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"\
    Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi6pjrv_u_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074332
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planetOneIndex := -1\n    planetTwoIndex := -1\n    for i,\
    \ planet := range planets {\n        if planet == planet1 {\n            planetOneIndex\
    \ = i\n        }\n        if planet == planet2 {\n            planetTwoIndex =\
    \ i\n        }\n    }\n    if planetOneIndex == -1 || planetTwoIndex == -1 {\n\
    \        return make([]interface{}, 0)\n    }\n    if planetOneIndex > planetTwoIndex\
    \ {\n        tmp := planetOneIndex\n        planetOneIndex = planetTwoIndex\n\
    \        planetTwoIndex = tmp\n    }\n    results := make([]interface{}, planetTwoIndex\
    \ - planetOneIndex - 1)\n    index := 0\n    for i := planetOneIndex + 1; i <\
    \ planetTwoIndex; i++ {\n        results[index] = planets[i]\n        index++\n\
    \    }\n    return results\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected:\
    \ []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\"\
    , \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\npanic: runtime error: makeslice: len out of range\
    \ [recovered]\n\tpanic: runtime error: makeslice: len out of range\n\ngoroutine\
    \ 18 [running]:\ntesting.tRunner.func1.2({0x503a00, 0x54a230})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503a00, 0x54a230})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.bf({0x51e62f, 0x5}, {0x51e62f, 0x5})\n\t\
    /tmp/tmp453200lm_test.go:44 +0x2f3\ncommand-line-arguments_test.TestBf(0x0?)\n\
    \t/tmp/tmp453200lm_test.go:64 +0x145\ntesting.tRunner(0xc00019b380, 0x5290d0)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074332
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\tplanets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n\tvar res []interface{}\n\tvar p1, p2 int\n\tfor i, v := range\
    \ planets {\n\t\tif v == planet1 {\n\t\t\tp1 = i\n\t\t}\n\t\tif v == planet2 {\n\
    \t\t\tp2 = i\n\t\t}\n\t}\n\tif p1 > p2 {\n\t\tp1, p2 = p2, p1\n\t}\n\tfor _,v\
    \ := range planets[p1+1:p2] {\n\t\tres = append(res, v)\n\t}\n\treturn res\n}\n\
    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\npanic: runtime error: slice bounds out of range\
    \ [3:2] [recovered]\n\tpanic: runtime error: slice bounds out of range [3:2]\n\
    \ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x515780, 0xc000164000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x515780,\
    \ 0xc000164000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.bf(...)\n\t/tmp/tmp9cjibkss_test.go:39\n\
    command-line-arguments_test.TestBf(0xc0001031e0?)\n\t/tmp/tmp9cjibkss_test.go:56\
    \ +0x2830\ntesting.tRunner(0xc0001031e0, 0x52b0d0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074332
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planet1_idx := findPlanet(planet1)\n\
    \    planet2_idx := findPlanet(planet2)\n    if planet1_idx == -1 || planet2_idx\
    \ == -1 {\n        return []interface{}{}\n    }\n    i, j := min(planet1_idx,\
    \ planet2_idx), max(planet1_idx, planet2_idx)\n    return planets[i:j]\n}\n\n\
    func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"\
    Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbx60fl1h_test.go:25:20: undefined: findPlanet

    /tmp/tmpbx60fl1h_test.go:26:20: undefined: findPlanet

    /tmp/tmpbx60fl1h_test.go:30:13: undefined: min

    /tmp/tmpbx60fl1h_test.go:30:44: undefined: max

    /tmp/tmpbx60fl1h_test.go:31:12: undefined: planets

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074332
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    start, end := -1, -1\n    for i, v := range planets {\n  \
    \      if v == planet1 {\n            start = i\n        }\n        if v == planet2\
    \ {\n            end = i\n        }\n    }\n    if start == -1 || end == -1 {\n\
    \        return []interface{}{}\n    }\n    if start > end {\n        start, end\
    \ = end, start\n    }\n    return planets[start+1:end]\n}\n\nfunc TestBf(t *testing.T)\
    \ {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\"\
    , \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual:\
    \ candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n \
    \    { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjvy3thyu_test.go:41:19: cannot use planets[start + 1:end] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074332
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    p1i := -1\n    p2i := -1\n    for i,v := range planets {\n\
    \        if v == planet1 {\n            p1i = i\n        }\n        if v == planet2\
    \ {\n            p2i = i\n        }\n    }\n    if p1i < 0 || p2i < 0 {\n    \
    \    return nil\n    }\n    if p1i > p2i {\n        p1i, p2i = p2i, p1i\n    }\n\
    \    return planets[p1i+1:p2i]\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpydck_rbe_test.go:42:19: cannot use planets[p1i + 1:p2i] (value of type
    []string) as type []interface{} in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074332
- exit_code: 1
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n\tplanets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n\tvar result []interface{}\n\tvar i1, i2 int\n\n\tfor i, v :=\
    \ range planets {\n\t\tif v == planet1 {\n\t\t\ti1 = i\n\t\t}\n\t\tif v == planet2\
    \ {\n\t\t\ti2 = i\n\t\t}\n\t}\n\n\tif i1 == 0 || i2 == 0 {\n\t\treturn result\n\
    \t}\n\n\tif i1 < i2 {\n\t\tfor i := i1 + 1; i < i2; i++ {\n\t\t\tresult = append(result,\
    \ planets[i])\n\t\t}\n\t} else {\n\t\tfor i := i2 + 1; i < i1; i++ {\n\t\t\tresult\
    \ = append(result, planets[i])\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc TestBf(t\
    \ *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n\
    \     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"\
    Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"\
    Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"),\
    \ expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"\
    ), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBf (0.00s)\n    --- FAIL: TestBf/test_num__1 (0.00s)\n  \
    \      tmpqwwbxo3r_test.go:74: expected '[Venus]', got '[]'\n    --- FAIL: TestBf/test_num__2\
    \ (0.00s)\n        tmpqwwbxo3r_test.go:74: expected '[Venus Earth Mars Jupiter\
    \ Saturn]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074332
- exit_code: 2
  program: "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There\
    \ are eight planets in our solar system: the closerst to the Sun \n// is Mercury,\
    \ the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n\
    // Write a function that takes two planet names as strings planet1 and planet2.\
    \ \n// The function should return a list containing all planets whose orbits are\
    \ \n// located between the orbit of planet1 and the orbit of planet2, sorted by\
    \ \n// the proximity to the sun. \n// The function should return an empty list\
    \ if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>>\
    \ bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>>\
    \ bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\"\
    )\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n\
    func bf(planet1 string, planet2 string) []interface{} {\n    planets := []string{\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\n    planet1_index := -1\n    planet2_index := -1\n    for i, planet\
    \ := range planets {\n        if planet == planet1 {\n            planet1_index\
    \ = i\n        }\n        if planet == planet2 {\n            planet2_index =\
    \ i\n        }\n    }\n    if planet1_index == -1 || planet2_index == -1 {\n \
    \       return []interface{}{}\n    }\n    var planet_range []interface{}\n  \
    \  if planet1_index < planet2_index {\n        planet_range = planets[planet1_index+1:planet2_index]\n\
    \    } else {\n        planet_range = planets[planet2_index+1:planet1_index]\n\
    \    }\n    return planet_range\n}\n\nfunc TestBf(t *testing.T) {\n  candidate\
    \ := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"),\
    \ expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"\
    Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"\
    Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"\
    ), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    } },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{}\
    \ },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyklvsbu3_test.go:41:31: cannot use planets[planet1_index + 1:planet2_index]
    (value of type []string) as type []interface{} in assignment

    /tmp/tmpyklvsbu3_test.go:43:31: cannot use planets[planet2_index + 1:planet1_index]
    (value of type []string) as type []interface{} in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074332
