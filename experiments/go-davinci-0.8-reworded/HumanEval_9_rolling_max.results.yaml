language: go_test.go
name: HumanEval_9_rolling_max
results:
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max := make([]int, len(numbers))\n    for i, _ := range\
    \ numbers {\n        if i == 0 {\n            rolling_max[i] = numbers[i]\n  \
    \      } else {\n            if numbers[i] > rolling_max[i-1] {\n            \
    \    rolling_max[i] = numbers[i]\n            } else {\n                rolling_max[i]\
    \ = rolling_max[i-1]\n            }\n        }\n    }\n    return rolling_max\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // TODO: implement me\n    return []int{1, 2, 3, 3, 3, 4, 4}\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__0\
    \ (0.00s)\n        tmp853jvw2w_test.go:33: expected '[]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmp853jvw2w_test.go:33: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=4)\
    \ %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n        tmp853jvw2w_test.go:33:\
    \ expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=4)]'\n    --- FAIL: TestRolling_Max/test_num__3\
    \ (0.00s)\n        tmp853jvw2w_test.go:33: expected '[%!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=100) %!s(int=100)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=3)\
    \ %!s(int=3) %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max int\n    res := make([]int, len(numbers))\n    for i, e\
    \ := range numbers {\n        if i == 0 {\n            max = e\n        } else\
    \ {\n            if e > max {\n                max = e\n            }\n      \
    \  }\n        res[i] = max\n    }\n    return res\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    for i, number := range\
    \ numbers {\n        if i == 0 {\n            result[i] = number\n        } else\
    \ {\n            if number > result[i-1] {\n                result[i] = number\n\
    \            } else {\n                result[i] = result[i-1]\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073931
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var (\n        maxs = make([]int, len(numbers))\n        max =\
    \ numbers[0]\n    )\n    for i, n := range numbers {\n        if n > max {\n \
    \           max = n\n        }\n        maxs[i] = max\n    }\n    return maxs\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmph9b8n8l8_test.go:15\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmph9b8n8l8_test.go:33\
    \ +0x2f\ntesting.tRunner(0xc000192680, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073931
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max_list := make([]int, len(numbers))\n    var max = numbers[0]\n\
    \    for idx, num := range numbers {\n        if num > max {\n            max\
    \ = num\n        }\n        rolling_max_list[idx] = max\n    }\n    return rolling_max_list\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpv9qw497f_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpv9qw497f_test.go:31\
    \ +0x2f\ntesting.tRunner(0xc0001036c0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073931
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    result := make([]int, len(numbers))\n  \
    \  result[0] = max\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i]\
    \ > max {\n            max = numbers[i]\n        }\n        result[i] = max\n\
    \    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmprw0wt7vo_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmprw0wt7vo_test.go:32\
    \ +0x18\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073802
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    if len(numbers) == 0 {\n        return result\n\
    \    }\n    var lastMax int = numbers[0]\n    result = append(result, lastMax)\n\
    \    for _, n := range numbers[1:] {\n        if n > lastMax {\n            lastMax\
    \ = n\n        }\n        result = append(result, lastMax)\n    }\n    return\
    \ result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    m := []int{}\n    for i, number := range numbers {\n        if\
    \ i == 0 {\n            m = append(m, number)\n        } else {\n            if\
    \ number > m[i-1] {\n                m = append(m, number)\n            } else\
    \ {\n                m = append(m, m[i-1])\n            }\n        }\n    }\n\
    \    return m\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max int\n    var result []int\n    for _, number := range numbers\
    \ {\n        if number > max {\n            max = number\n        }\n        result\
    \ = append(result, max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073802
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n\n    if len(numbers) > 0 {\n        result =\
    \ append(result, numbers[0])\n    }\n\n    for i, number := range numbers {\n\
    \        if i > 0 {\n            previous := result[i - 1]\n            if number\
    \ > previous {\n                result = append(result, number)\n            }\
    \ else {\n                result = append(result, previous)\n            }\n \
    \       }\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    max := numbers[0]\n  \
    \  result[0] = max\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i]\
    \ > max {\n            max = numbers[i]\n        }\n        result[i] = max\n\
    \    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000158000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000158000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpom_gcshv_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpom_gcshv_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001036c0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660073802
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var n = len(numbers)\n    if n == 0 {\n        return numbers\n\
    \    }\n    var result = make([]int, n)\n    result[0] = numbers[0]\n    for i\
    \ := 1; i < n; i++ {\n        if numbers[i] > result[i-1] {\n            result[i]\
    \ = numbers[i]\n        } else {\n            result[i] = result[i-1]\n      \
    \  }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n\
    \    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[i-1]\
    \ {\n            result[i] = numbers[i]\n        } else {\n            result[i]\
    \ = result[i-1]\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp5mpp14sq_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp5mpp14sq_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073802
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    rolling_max_numbers\
    \ := make([]int, len(numbers))\n    rolling_max_numbers[0] = numbers[0]\n    max\
    \ := numbers[0]\n    for i, n := range numbers[1:] {\n        if n > max {\n \
    \           max = n\n        }\n        rolling_max_numbers[i+1] = max\n    }\n\
    \    return rolling_max_numbers\n}\n\nfunc TestRolling_Max(t *testing.T) {\n \
    \ candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    maxValue := numbers[0]\n\
    \    result[0] = maxValue\n    for i := 1; i < len(numbers); i++ {\n        result[i]\
    \ = result[i-1]\n        if maxValue < numbers[i] {\n            maxValue = numbers[i]\n\
    \            result[i] = maxValue\n        }\n    }\n    return result\n}\n\n\
    func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpnqcd45kq_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpnqcd45kq_test.go:33\
    \ +0x2f\ntesting.tRunner(0xc000103520, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max := make([]int, len(numbers))\n    for i, x := range\
    \ numbers {\n        rolling_max[i] = x\n        for j := 0; j < i; j++ {\n  \
    \          if rolling_max[j] > rolling_max[i] {\n                rolling_max[i]\
    \ = rolling_max[j]\n            }\n        }\n    }\n    return rolling_max\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var rolling_max []int\n    max := 0\n    for _, n := range numbers\
    \ {\n        if n > max {\n            max = n\n        }\n        rolling_max\
    \ = append(rolling_max, max)\n    }\n    return rolling_max\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n\
    \    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[i-1]\
    \ {\n            result[i] = numbers[i]\n        } else {\n            result[i]\
    \ = result[i-1]\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp5mpp14sq_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp5mpp14sq_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073802
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    max\
    \ := numbers[0]\n    result := []int{max}\n\n    for _, number := range numbers[1:]\
    \ {\n        if number > max {\n            max = number\n        }\n        result\
    \ = append(result, max)\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := make([]int, len(numbers))\n    for i, v := range numbers\
    \ {\n        if i == 0 {\n            max[i] = v\n        } else {\n         \
    \   if max[i-1] > v {\n                max[i] = max[i-1]\n            } else {\n\
    \                max[i] = v\n            }\n        }\n    }\n    return max\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073931
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    maxSoFar := numbers[0]\n    rollingMax := make([]int, len(numbers))\n\
    \    rollingMax[0] = maxSoFar\n    for index, value := range numbers[1:] {\n \
    \       if value > maxSoFar {\n            maxSoFar = value\n        }\n     \
    \   rollingMax[index + 1] = maxSoFar\n    }\n    return rollingMax\n}\n\nfunc\
    \ TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmphbtya5le_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmphbtya5le_test.go:32\
    \ +0x18\ntesting.tRunner(0xc0001924e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073931
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n\n    for _, num := range numbers {\n       \
    \ result = append(result, max(num, result))\n    }\n\n    return result\n}\n\n\
    func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpov_m3e6a_test.go:16:33: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073930
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    r := make([]int, len(numbers))\n    // copy first element\n   \
    \ r[0] = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i]\
    \ > r[i-1] {\n            r[i] = numbers[i]\n        } else {\n            r[i]\
    \ = r[i-1]\n        }\n    }\n    return r\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpy_2ijj22_test.go:15\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpy_2ijj22_test.go:33\
    \ +0x2f\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073931
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    window := []int{}\n    rolling_max := []int{}\n    for _, num :=\
    \ range numbers {\n        for i := len(window) - 1; i >= 0; i-- {\n         \
    \   if window[i] >= num {\n                window = window[:i]\n            }\n\
    \        }\n        window = append(window, num)\n        rolling_max = append(rolling_max,\
    \ window[0])\n    }\n    return rolling_max\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpxvbv25cc_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__2 (0.00s)\n        tmpxvbv25cc_test.go:43: expected\
    \ '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3)\
    \ %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n\
    \        tmpxvbv25cc_test.go:43: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)\
    \ %!s(int=100)]', got '[%!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=2)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    max := 0\n    for _, v := range numbers {\n\
    \        if v > max {\n            max = v\n        }\n        result = append(result,\
    \ max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    length := len(numbers)\n    result := make([]int, length)\n   \
    \ max := numbers[0]\n    result[0] = max\n    for i := 1; i < length; i++ {\n\
    \        if numbers[i] > max {\n            max = numbers[i]\n        }\n    \
    \    result[i] = max\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpmg6gbrnn_test.go:15\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpmg6gbrnn_test.go:33\
    \ +0x2f\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n\n    if len(numbers) == 0 {\n        return\
    \ result\n    }\n\n    result = append(result, numbers[0])\n\n    for i := 1;\
    \ i < len(numbers); i++ {\n        if numbers[i] > result[i - 1] {\n         \
    \   result = append(result, numbers[i])\n        } else {\n            result\
    \ = append(result, result[i - 1])\n        }\n    }\n\n    return result\n}\n\n\
    func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var maximum int\n    result := make([]int, len(numbers))\n    for\
    \ i, number := range numbers {\n        if number > maximum {\n            maximum\
    \ = number\n        }\n        result[i] = maximum\n    }\n    return result\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073932
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    output := []int{max}\n    for _, n := range\
    \ numbers[1:] {\n        if n > max {\n            max = n\n        }\n      \
    \  output = append(output, max)\n    }\n    return output\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmph3gq0f4f_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmph3gq0f4f_test.go:31\
    \ +0x18\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var (\n        output []int\n        maxSoFar int\n    )\n\n  \
    \  if len(numbers) == 0 {\n        return output\n    }\n\n    maxSoFar = numbers[0]\n\
    \    output = append(output, maxSoFar)\n\n    for _, n := range numbers[1:] {\n\
    \        if n > maxSoFar {\n            maxSoFar = n\n        }\n        output\
    \ = append(output, maxSoFar)\n    }\n\n    return output\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073933
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := make([]int, len(numbers))\n    max[0] = numbers[0]\n   \
    \ for index, number := range numbers {\n        if number > max[index] {\n   \
    \         max[index] = number\n        } else {\n            max[index] = max[index\
    \ - 1]\n        }\n    }\n    return max\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp6rfmogxw_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp6rfmogxw_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    roll_max\
    \ := []int{numbers[0]}\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i]\
    \ > roll_max[i-1] {\n            roll_max = append(roll_max, numbers[i])\n   \
    \     } else {\n            roll_max = append(roll_max, roll_max[i-1])\n     \
    \   }\n    }\n    return roll_max\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    length := len(numbers)\n    max_numbers := make([]int, length)\n\
    \    if length == 0 {\n        return max_numbers\n    }\n    max_numbers[0] =\
    \ numbers[0]\n    for i := 1; i < length; i++ {\n        if numbers[i] > max_numbers[i-1]\
    \ {\n            max_numbers[i] = numbers[i]\n        } else {\n            max_numbers[i]\
    \ = max_numbers[i-1]\n        }\n    }\n    return max_numbers\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    res := make([]int, len(numbers))\n    var max int\n    for i, num\
    \ := range numbers {\n        if i == 0 {\n            max = num\n        } else\
    \ {\n            if num > max {\n                max = num\n            }\n  \
    \      }\n        res[i] = max\n    }\n    return res\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073933
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    maxes := make([]int, len(numbers))\n    var max, pos int\n    max\
    \ = numbers[0]\n    for pos, value := range numbers {\n        if value > max\
    \ {\n            max = value\n        }\n        maxes[pos] = max\n    }\n   \
    \ return maxes\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp73he4v6y_test.go:14:14: pos declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073933
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    maximums := make([]int, len(numbers))\n    maximums[0] = numbers[0]\n\
    \    for idx, number := range numbers[1:] {\n        if number > maximums[idx]\
    \ {\n            maximums[idx + 1] = number\n        } else {\n            maximums[idx\
    \ + 1] = maximums[idx]\n        }\n    }\n    return maximums\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp3gras171_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp3gras171_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073933
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var output []int\n    max := numbers[0]\n    for _, n := range\
    \ numbers {\n        if n > max {\n            max = n\n        }\n        output\
    \ = append(output, max)\n    }\n    return output\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpslr9tf3o_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpslr9tf3o_test.go:31\
    \ +0x18\ntesting.tRunner(0xc000192680, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    var max int\n\n    if len(numbers) == 0 {\n\
    \        return result\n    }\n\n    max = numbers[0]\n    result = append(result,\
    \ max)\n\n    for _, number := range numbers[1:] {\n        if number > max {\n\
    \            max = number\n        }\n        result = append(result, max)\n \
    \   }\n\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073933
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var r []int\n    if len(numbers) == 0 {\n        return r\n   \
    \ }\n    r = append(r, numbers[0])\n    for i := 1; i < len(numbers); i++ {\n\
    \        r = append(r, max(r[i-1], numbers[i]))\n    }\n    return r\n}\n\nfunc\
    \ TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpefw2rxbx_test.go:19:23: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    max\
    \ := numbers[0]\n    result := []int{max}\n\n    for _, num := range numbers[1:]\
    \ {\n        if num > max {\n            max = num\n        }\n        result\
    \ = append(result, max)\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073933
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max := make([]int, len(numbers))\n    current_max := 0\n\
    \    for i, n := range numbers {\n        current_max = int(math.Max(float64(current_max),\
    \ float64(n)))\n        rolling_max[i] = current_max\n    }\n    return rolling_max\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppf3xiubw_test.go:16:27: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073933
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    results := make([]int, len(numbers))\n    max := numbers[0]\n \
    \   for i, e := range numbers {\n        if e > max {\n            max = e\n \
    \       }\n        results[i] = max\n    }\n    return results\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpskujcwvu_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpskujcwvu_test.go:31\
    \ +0x2f\ntesting.tRunner(0xc000103520, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    maximum := 0\n    for\
    \ idx, val := range numbers {\n        if val > maximum {\n            maximum\
    \ = val\n        }\n        result[idx] = maximum\n    }\n    return result\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073933
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max_numbers := make([]int, len(numbers))\n    max_number := numbers[0]\n\
    \    for i, number := range numbers {\n        if number > max_number {\n    \
    \        max_number = number\n        }\n        max_numbers[i] = max_number\n\
    \    }\n    return max_numbers\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpl9of2pdz_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpl9of2pdz_test.go:31\
    \ +0x2f\ntesting.tRunner(0xc000199040, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if numbers == nil || len(numbers) == 0 {\n        return numbers\n\
    \    }\n\n    res := make([]int, len(numbers))\n    res[0] = numbers[0]\n    for\
    \ i := 1; i < len(numbers); i++ {\n        if numbers[i] > res[i-1] {\n      \
    \      res[i] = numbers[i]\n        } else {\n            res[i] = res[i-1]\n\
    \        }\n    }\n\n    return res\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := -1\n    result := make([]int, len(numbers))\n    for i,\
    \ n := range numbers {\n        if n > max {\n            max = n\n        }\n\
    \        result[i] = max\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073933
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // Pad the array with a zero, it's a trick to avoid many edge cases.\n\
    \    numbers = append([]int{0}, numbers...)\n    // Array that will hold the result.\n\
    \    rolling_max := make([]int, len(numbers))\n    // Iterate over the entire\
    \ array, starting from the second element\n    // (which is actually the first\
    \ element of the original sequence).\n    for i := 1; i < len(numbers); i++ {\n\
    \        // Set the current value to the max between the current value and the\n\
    \        // value of the previous element.\n        rolling_max[i] = max(numbers[i],\
    \ rolling_max[i-1])\n    }\n    // Return only the original array (skipping the\
    \ initial 0).\n    return rolling_max[1:]\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9b9e2u97_test.go:22:26: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    output := make([]int, len(numbers))\n    var max int\n    for i,\
    \ v := range numbers {\n        if i == 0 {\n            max = v\n        } else\
    \ {\n            if v > max {\n                max = v\n            }\n      \
    \  }\n        output[i] = max\n    }\n    return output\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    rollingMax\
    \ := make([]int, len(numbers))\n    rollingMax[0] = numbers[0]\n    for i, n :=\
    \ range numbers[1:] {\n        if n > rollingMax[i] {\n            rollingMax[i+1]\
    \ = n\n        } else {\n            rollingMax[i+1] = rollingMax[i]\n       \
    \ }\n    }\n    return rollingMax\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073933
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max_element := numbers[0]\n    rolling_max := make([]int, len(numbers))\n\
    \    for index, number := range numbers {\n        if number > max_element {\n\
    \            max_element = number\n        }\n        rolling_max[index] = max_element\n\
    \    }\n    return rolling_max\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpm20r0fw7_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpm20r0fw7_test.go:31\
    \ +0x18\ntesting.tRunner(0xc000199040, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073933
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    rolling_max_list := []int{max}\n    for\
    \ _, n := range numbers[1:] {\n        if n > max {\n            max = n\n   \
    \     }\n        rolling_max_list = append(rolling_max_list, max)\n    }\n   \
    \ return rolling_max_list\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpgotecxkj_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpgotecxkj_test.go:31\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073934
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max_so_far := numbers[0]\n    result := make([]int, len(numbers))\n\
    \    result[0] = max_so_far\n    for index, number := range numbers[1:] {\n  \
    \      if number > max_so_far {\n            max_so_far = number\n        }\n\
    \        result[index + 1] = max_so_far\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp0r5jlkem_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp0r5jlkem_test.go:32\
    \ +0x18\ntesting.tRunner(0xc0001924e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073935
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n\
    \    for index, num := range numbers[1:] {\n        if num > result[index] {\n\
    \            result[index + 1] = num\n        } else {\n            result[index\
    \ + 1] = result[index]\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpnbmypuow_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpnbmypuow_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073935
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    max := numbers[0]\n  \
    \  result[0] = max\n    for i, num := range numbers[1:] {\n        if num > max\
    \ {\n            max = num\n        }\n        result[i+1] = max\n    }\n    return\
    \ result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpklym_gug_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpklym_gug_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc000192680, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073935
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    for _, number := range numbers {\n      \
    \  if len(result) == 0 {\n            result = append(result, number)\n      \
    \  } else {\n            if number > result[len(result) - 1] {\n             \
    \   result = append(result, number)\n            } else {\n                result\
    \ = append(result, result[len(result) - 1])\n            }\n        }\n    }\n\
    \    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate :=\
    \ rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4}\
    \ },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4}\
    \ },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3,\
    \ 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073935
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    max\
    \ := numbers[0]\n    result := []int{max}\n    for _, n := range numbers[1:] {\n\
    \        if n > max {\n            max = n\n        }\n        result = append(result,\
    \ max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073935
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    out := make([]int, len(numbers))\n    if len(numbers) > 0 {\n \
    \       out[0] = numbers[0]\n    }\n    for i, _ := range numbers {\n        if\
    \ numbers[i] > out[i] {\n            out[i] = numbers[i]\n        }\n    }\n \
    \   return out\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__2\
    \ (0.00s)\n        tmpsrejvwui_test.go:41: expected '[%!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmpsrejvwui_test.go:41: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=2) %!s(int=3) %!s(int=100) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073935
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n\
    \    for i, n := range numbers[1:] {\n        if n > result[i] {\n           \
    \ result[i+1] = n\n        } else {\n            result[i+1] = result[i]\n   \
    \     }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpnzfccfsx_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpnzfccfsx_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073935
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := make([]int, len(numbers))\n    max[0] = numbers[0]\n   \
    \ for i := 1; i < len(numbers); i++ {\n        if numbers[i] > max[i-1] {\n  \
    \          max[i] = numbers[i]\n        } else {\n            max[i] = max[i-1]\n\
    \        }\n    }\n    return max\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmppkqjvb2r_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmppkqjvb2r_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073802
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    max := numbers[0]\n  \
    \  result[0] = max\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i]\
    \ > max {\n            max = numbers[i]\n        }\n        result[i] = max\n\
    \    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000158000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000158000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpom_gcshv_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpom_gcshv_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001036c0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660073802
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // NOTE: Problem asks not to alter the passed in slice, so we make\
    \ a copy\n    // of the passed in slice to work with.\n    // NOTE: Not using\
    \ this because Go seems to be doing an implicit copy\n    // of the slice.\n \
    \   //var numbers_copy []int = make([]int, len(numbers))\n    //copy(numbers_copy,\
    \ numbers)\n\n    var result []int = make([]int, len(numbers))\n    var max_number\
    \ int = numbers[0]\n    for i, number := range numbers {\n        if number >\
    \ max_number {\n            max_number = number\n        }\n        result[i]\
    \ = max_number\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpvf1dmuca_test.go:21\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpvf1dmuca_test.go:38\
    \ +0x2f\ntesting.tRunner(0xc000103380, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) < 1 {\n        return []int{}\n    }\n    result\
    \ := make([]int, len(numbers))\n    result[0] = numbers[0]\n    for i := 1; i\
    \ < len(numbers); i++ {\n        if numbers[i] > result[i-1] {\n            result[i]\
    \ = numbers[i]\n        } else {\n            result[i] = result[i-1]\n      \
    \  }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    ans := make([]int, len(numbers))\n    if len(numbers) < 1 {\n \
    \       return ans\n    }\n    ans[0] = numbers[0]\n    for i := 1; i < len(numbers);\
    \ i++ {\n        n := numbers[i]\n        m := ans[i-1]\n        if n > m {\n\
    \            ans[i] = n\n        } else {\n            ans[i] = m\n        }\n\
    \    }\n    return ans\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073936
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max := make([]int, len(numbers))\n    rolling_max[0] =\
    \ numbers[0]\n    for index, number := range numbers {\n        if index == 0\
    \ {\n            continue\n        }\n        rolling_max[index] = rolling_max[index\
    \ - 1]\n        if number > rolling_max[index] {\n            rolling_max[index]\
    \ = number\n        }\n    }\n    return rolling_max\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpghy2si4g_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpghy2si4g_test.go:34\
    \ +0x2f\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var maximum = 0\n    var max_seq = make([]int, len(numbers))\n\
    \    for index, num := range numbers {\n        if num > maximum {\n         \
    \   maximum = num\n        }\n        max_seq[index] = maximum\n    }\n    return\
    \ max_seq\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073936
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    rollMax\
    \ := make([]int, len(numbers))\n    rollMax[0] = numbers[0]\n\n    for i := 1;\
    \ i < len(numbers); i++ {\n        rollMax[i] = max(rollMax[i-1], numbers[i])\n\
    \    }\n\n    return rollMax\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp793pt4f_test.go:21:22: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073935
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max_numbers []int\n\n    for i, n := range numbers {\n    \
    \    m := n\n        for j := 0; j < i; j++ {\n            if numbers[j] > m {\n\
    \                m = numbers[j]\n            }\n        }\n        max_numbers\
    \ = append(max_numbers, m)\n    }\n\n    return max_numbers\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073936
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    max := numbers[0]\n    for _, number := range\
    \ numbers {\n        if number > max {\n            max = number\n        }\n\
    \        result = append(result, max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmprunp6u3v_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmprunp6u3v_test.go:31\
    \ +0x18\ntesting.tRunner(0xc0001924e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073804
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // TODO: Implement\n    return []int{}\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpir3miwbc_test.go:33: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n\
    \        tmpir3miwbc_test.go:33: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpir3miwbc_test.go:33:\
    \ expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got\
    \ '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073936
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n\
    \    for i := 1; i < len(numbers); i++ {\n        curr := numbers[i]\n       \
    \ if result[i-1] > curr {\n            result[i] = result[i-1]\n        } else\
    \ {\n            result[i] = curr\n        }\n    }\n    return result\n}\n\n\
    func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpmw1wior2_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpmw1wior2_test.go:33\
    \ +0x2f\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    result\
    \ := make([]int, len(numbers))\n    result[0] = numbers[0]\n    for i := 1; i\
    \ < len(numbers); i++ {\n        if numbers[i] > result[i-1] {\n            result[i]\
    \ = numbers[i]\n        } else {\n            result[i] = result[i-1]\n      \
    \  }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073802
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := 0\n    result := make([]int, len(numbers))\n    for i, element\
    \ := range numbers {\n        if element > max {\n            max = element\n\
    \        }\n        result[i] = max\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n\n    max := 0\n    for _, n := range numbers\
    \ {\n        if n > max {\n            max = n\n        }\n        result = append(result,\
    \ max)\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := 0\n    result := make([]int, len(numbers))\n    for i, v\
    \ := range numbers {\n        if v > max {\n            max = v\n        }\n \
    \       result[i] = max\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073864
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n\
    \    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[i-1]\
    \ {\n            result[i] = numbers[i]\n        } else {\n            result[i]\
    \ = result[i-1]\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp5mpp14sq_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp5mpp14sq_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073802
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    result\
    \ := make([]int, len(numbers))\n    result[0] = numbers[0]\n    for i := 1; i\
    \ < len(numbers); i++ {\n        currentMax := result[i-1]\n        if numbers[i]\
    \ > currentMax {\n            currentMax = numbers[i]\n        }\n        result[i]\
    \ = currentMax\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073936
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n\
    \    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[i-1]\
    \ {\n            result[i] = numbers[i]\n        } else {\n            result[i]\
    \ = result[i-1]\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp5mpp14sq_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp5mpp14sq_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073802
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    maximums := make([]int, len(numbers))\n    maximums[0] = numbers[0]\n\
    \    for i, v := range numbers[1:] {\n        if i+1 >= len(maximums) {\n    \
    \        break\n        }\n        // fmt.Printf(\"Rolling max: prev: %d, current:\
    \ %d, i: %d\\n\", maximums[i], v, i)\n        if v > maximums[i] {\n         \
    \   maximums[i+1] = v\n        } else {\n            maximums[i+1] = maximums[i]\n\
    \        }\n    }\n    return maximums\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpq7wslq40_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpq7wslq40_test.go:36\
    \ +0x2f\ntesting.tRunner(0xc000198ea0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073936
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    output := make([]int, len(numbers))\n    // the maximum currently\
    \ found is the first element in the list\n    current_max := numbers[0]\n    for\
    \ i, v := range numbers {\n        if v > current_max {\n            current_max\
    \ = v\n        }\n        output[i] = current_max\n    }\n    return output\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp4nv725it_test.go:15\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp4nv725it_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001036c0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073936
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    max := numbers[0]\n  \
    \  result[0] = max\n    for i := 1; i < len(numbers); i++ {\n        num := numbers[i]\n\
    \        if num > max {\n            max = num\n        }\n        result[i] =\
    \ max\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n \
    \ candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpoj5292ql_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpoj5292ql_test.go:33\
    \ +0x2f\ntesting.tRunner(0xc0001036c0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073936
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    max_el := numbers[0]\n\
    \    result[0] = max_el\n    for i := 1; i < len(numbers); i++ {\n        result[i]\
    \ = max_el\n        if numbers[i] > max_el {\n            max_el = numbers[i]\n\
    \        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpig8fcw1k_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpig8fcw1k_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var rolling_numbers []int\n    maximum := 0\n    for _, number\
    \ := range numbers {\n        if number > maximum {\n            maximum = number\n\
    \        }\n        rolling_numbers = append(rolling_numbers, maximum)\n    }\n\
    \    return rolling_numbers\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073937
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max_elements := make([]int, len(numbers))\n    max_elements[0]\
    \ = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        max_elements[i]\
    \ = max(max_elements[i-1], numbers[i])\n    }\n    return max_elements\n}\n\n\
    func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpncejq11v_test.go:16:27: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073937
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var res []int\n    for i := 0; i < len(numbers); i++ {\n      \
    \  max := numbers[i]\n        for j := i; j < len(numbers); j++ {\n          \
    \  if numbers[j] > max {\n                max = numbers[j]\n            }\n  \
    \      }\n        res = append(res, max)\n    }\n    return res\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpfm66jshl_test.go:42: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__2 (0.00s)\n        tmpfm66jshl_test.go:42: expected\
    \ '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3)\
    \ %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n\
    \        tmpfm66jshl_test.go:42: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)\
    \ %!s(int=100)]', got '[%!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=3)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073937
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := make([]int, len(numbers))\n    for i, num := range numbers\
    \ {\n        if i == 0 {\n            max[i] = num\n        } else {\n       \
    \     if num > max[i-1] {\n                max[i] = num\n            } else {\n\
    \                max[i] = max[i-1]\n            }\n        }\n    }\n    return\
    \ max\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073937
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    rolling_maximum\
    \ := make([]int, len(numbers))\n    rolling_maximum[0] = numbers[0]\n    for i\
    \ := 1; i < len(numbers); i++ {\n        if numbers[i] > rolling_maximum[i-1]\
    \ {\n            rolling_maximum[i] = numbers[i]\n        } else {\n         \
    \   rolling_maximum[i] = rolling_maximum[i-1]\n        }\n    }\n    return rolling_maximum\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073937
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    result\
    \ := make([]int, len(numbers))\n    result[0] = numbers[0]\n    for i, n := range\
    \ numbers[1:] {\n        if result[i] > n {\n            result[i+1] = result[i]\n\
    \        } else {\n            result[i+1] = n\n        }\n    }\n    return result\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073938
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    // The\
    \ last integer in the list is always the maximum in the range\n    output := []int{numbers[len(numbers)\
    \ - 1]}\n    for i := len(numbers) - 2; i >= 0; i-- {\n        value := numbers[i]\n\
    \        if value > output[len(output) - 1] {\n            output = append(output,\
    \ value)\n        } else {\n            output = append(output, output[len(output)\
    \ - 1])\n        }\n    }\n    // The list we generate is in reverse order, need\
    \ to reverse it back\n    for i, j := 0, len(output) - 1; i < j; i, j = i + 1,\
    \ j - 1 {\n        output[i], output[j] = output[j], output[i]\n    }\n    return\
    \ output\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmp8rea6w5x_test.go:49: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__2 (0.00s)\n        tmp8rea6w5x_test.go:49: expected\
    \ '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3)\
    \ %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n\
    \        tmp8rea6w5x_test.go:49: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)\
    \ %!s(int=100)]', got '[%!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=3)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073938
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    result\
    \ := make([]int, len(numbers))\n    // first element of sequence is always the\
    \ same\n    result[0] = numbers[0]\n    for i := 1; i < len(numbers); i++ {\n\
    \        if numbers[i] > result[i-1] {\n            result[i] = numbers[i]\n \
    \       } else {\n            result[i] = result[i-1]\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073938
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max []int\n    for i, num := range numbers {\n        if i\
    \ == 0 {\n            max = append(max, num)\n        } else {\n            var\
    \ new_max int\n            if num > max[i-1] {\n                new_max = num\n\
    \            } else {\n                new_max = max[i-1]\n            }\n   \
    \         max = append(max, new_max)\n        }\n    }\n    return max\n}\n\n\
    func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073938
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := make([]int, len(numbers))\n    runningMax := numbers[0]\n\
    \    for i, x := range numbers {\n        if x > runningMax {\n            runningMax\
    \ = x\n        }\n        max[i] = runningMax\n    }\n    return max\n}\n\nfunc\
    \ TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp0rn0gxtx_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp0rn0gxtx_test.go:31\
    \ +0x2f\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073938
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling := make([]int, len(numbers))\n    currMax := 0\n    for\
    \ i, n := range numbers {\n        if n > currMax {\n            currMax = n\n\
    \        }\n        rolling[i] = currMax\n    }\n    return rolling\n}\n\nfunc\
    \ TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073938
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    result\
    \ := make([]int, len(numbers))\n    result[0] = numbers[0]\n    for i := 1; i\
    \ < len(numbers); i++ {\n        if numbers[i] > result[i-1] {\n            result[i]\
    \ = numbers[i]\n        } else {\n            result[i] = result[i-1]\n      \
    \  }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073802
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // TODO: implement\n    var max int\n    if len(numbers) > 0 {\n\
    \        max = numbers[0]\n    }\n    output := make([]int, len(numbers))\n  \
    \  for i, n := range numbers {\n        output[i] = max\n        if n > max {\n\
    \            max = n\n        }\n    }\n    return output\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmppj_0gohm_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__3 (0.00s)\n        tmppj_0gohm_test.go:44: expected\
    \ '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got '[%!s(int=3)\
    \ %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073938
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    r := make([]int, len(numbers))\n    max := numbers[0]\n    for\
    \ i, n := range numbers {\n        if n > max {\n            max = n\n       \
    \ }\n        r[i] = max\n    }\n    return r\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmplifzya6__test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmplifzya6__test.go:31\
    \ +0x2f\ntesting.tRunner(0xc0001924e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073938
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    res := make([]int, len(numbers))\n    res[0] = numbers[0]\n   \
    \ for i := 1; i < len(numbers); i++ {\n        if numbers[i] > res[i-1] {\n  \
    \          res[i] = numbers[i]\n        } else {\n            res[i] = res[i-1]\n\
    \        }\n    }\n    return res\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp83fx6xx3_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp83fx6xx3_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073938
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    current_max := numbers[0]\n    result = append(result,\
    \ current_max)\n    for _, num := range numbers[1:] {\n        if num > current_max\
    \ {\n            current_max = num\n        }\n        result = append(result,\
    \ current_max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp6yh9qfbr_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp6yh9qfbr_test.go:32\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073938
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n\
    \    max := numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if max\
    \ < numbers[i] {\n            max = numbers[i]\n        }\n        result[i] =\
    \ max\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n \
    \ candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmprdd7pmcl_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmprdd7pmcl_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001036c0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073938
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    n := len(numbers)\n    max_numbers := make([]int, n)\n    var max\
    \ int\n    for i, v := range numbers {\n        if i == 0 {\n            max =\
    \ v\n        } else {\n            if v > max {\n                max = v\n   \
    \         }\n        }\n        max_numbers[i] = max\n    }\n    return max_numbers\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073938
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n\
    \    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[i-1]\
    \ {\n            result[i] = numbers[i]\n        } else {\n            result[i]\
    \ = result[i-1]\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp5mpp14sq_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp5mpp14sq_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073802
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    if len(numbers) == 0 {\n        return result\n\
    \    }\n    result = append(result, numbers[0])\n    for i := 1; i < len(numbers);\
    \ i++ {\n        current := numbers[i]\n        max := result[i-1]\n        if\
    \ current > max {\n            max = current\n        }\n        result = append(result,\
    \ max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073938
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := 0\n    var result []int\n    for _, n := range numbers {\n\
    \        if n > max {\n            max = n\n        }\n        result = append(result,\
    \ max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073938
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max int\n    var result []int\n    for i, number := range numbers\
    \ {\n        if i == 0 {\n            max = number\n        } else {\n       \
    \     if number > max {\n                max = number\n            }\n       \
    \ }\n        result = append(result, max)\n    }\n    return result\n}\n\nfunc\
    \ TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073938
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var rolling_max_list []int\n    rolling_max := -1\n\n    for _,\
    \ number := range numbers {\n        if number > rolling_max {\n            rolling_max\
    \ = number\n        }\n        rolling_max_list = append(rolling_max_list, rolling_max)\n\
    \    }\n\n    return rolling_max_list\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073938
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max int\n    results := make([]int, len(numbers))\n    for\
    \ i, v := range numbers {\n        if v > max {\n            max = v\n       \
    \ }\n        results[i] = max\n    }\n    return results\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073938
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    if len(numbers) == 0 {\n\
    \        return result\n    }\n    result[0] = numbers[0]\n    max := numbers[0]\n\
    \    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > max {\n    \
    \        max = numbers[i]\n        }\n        result[i] = max\n    }\n    return\
    \ result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073938
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    max := numbers[0]\n  \
    \  result[0] = max\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i]\
    \ > max {\n            max = numbers[i]\n        }\n        result[i] = max\n\
    \    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000158000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000158000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpom_gcshv_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpom_gcshv_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001036c0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660073802
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var maximum = 0\n    var result = make([]int, len(numbers))\n \
    \   for i, num := range numbers {\n        if num > maximum {\n            maximum\
    \ = num\n        }\n        result[i] = maximum\n    }\n    return result\n}\n\
    \nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073939
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    r_max := make([]int, len(numbers))\n    r_max[0] = numbers[0]\n\
    \    for idx, num := range numbers[1:] {\n        max := r_max[idx]\n        if\
    \ num > max {\n            max = num\n        }\n        r_max[idx+1] = max\n\
    \    }\n    return r_max\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpb_al5g8t_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpb_al5g8t_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001924e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073939
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    rolling_max\
    \ := make([]int, len(numbers))\n    rolling_max[0] = numbers[0]\n    for i :=\
    \ 1; i < len(numbers); i++ {\n        if numbers[i] > rolling_max[i-1] {\n   \
    \         rolling_max[i] = numbers[i]\n        } else {\n            rolling_max[i]\
    \ = rolling_max[i-1]\n        }\n    }\n    return rolling_max\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073804
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    r :=\
    \ make([]int, len(numbers))\n    m := numbers[0]\n    for i, n := range numbers\
    \ {\n        if n > m {\n            m = n\n        }\n        r[i] = m\n    }\n\
    \    return r\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073939
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    var\
    \ result = make([]int, len(numbers))\n    result[0] = numbers[0]\n    for i :=\
    \ 1; i < len(numbers); i++ {\n        if numbers[i] > result[i-1] {\n        \
    \    result[i] = numbers[i]\n        } else {\n            result[i] = result[i-1]\n\
    \        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073939
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := 0\n    result := make([]int, len(numbers))\n    for index,\
    \ value := range numbers {\n        if index == 0 {\n            max = value\n\
    \        } else {\n            if value > max {\n                max = value\n\
    \            }\n        }\n        result[index] = max\n    }\n    return result\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073940
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max := make([]int, len(numbers))\n    var max = numbers[0]\n\
    \    for i, x := range numbers {\n        if x > max {\n            max = x\n\
    \        }\n        rolling_max[i] = max\n    }\n    return rolling_max\n}\n\n\
    func TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpmchci2ku_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpmchci2ku_test.go:31\
    \ +0x2f\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073940
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    n_size := len(numbers)\n    if n_size == 0 {\n        return []int{}\n\
    \    }\n\n    if n_size == 1 {\n        return numbers\n    }\n\n    result :=\
    \ make([]int, n_size)\n    last_max := numbers[0]\n    for idx, item := range\
    \ numbers {\n        if item > last_max {\n            last_max = item\n     \
    \   }\n        result[idx] = last_max\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073940
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var current_max int\n    var result []int\n    current_max = numbers[0]\n\
    \    result = make([]int, len(numbers))\n    result[0] = current_max\n    for\
    \ i := 1; i < len(numbers); i++ {\n        if current_max < numbers[i] {\n   \
    \         current_max = numbers[i]\n        }\n        result[i] = current_max\n\
    \    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpqu9brxcl_test.go:15\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpqu9brxcl_test.go:34\
    \ +0x18\ntesting.tRunner(0xc000103380, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073940
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    result\
    \ := make([]int, len(numbers))\n    result[0] = numbers[0]\n    current_max :=\
    \ numbers[0]\n    for idx, v := range numbers[1:] {\n        if v > current_max\
    \ {\n            current_max = v\n        }\n        result[idx + 1] = current_max\n\
    \    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073940
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max := make([]int, len(numbers))\n    if len(numbers) ==\
    \ 0 {\n        return rolling_max\n    }\n    rolling_max[0] = numbers[0]\n  \
    \  for index, number := range numbers[1:] {\n        if number > rolling_max[index]\
    \ {\n            rolling_max[index + 1] = number\n        } else {\n         \
    \   rolling_max[index + 1] = rolling_max[index]\n        }\n    }\n    return\
    \ rolling_max\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073940
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    result\
    \ := make([]int, len(numbers))\n    result[0] = numbers[0]\n    for i := 1; i\
    \ < len(numbers); i++ {\n        result[i] = result[i-1]\n        if numbers[i]\
    \ > result[i] {\n            result[i] = numbers[i]\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073940
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := 0\n    result := make([]int, len(numbers))\n    for i, num\
    \ := range numbers {\n        if num > max {\n            max = num\n        }\n\
    \        result[i] = max\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073940
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    for i, v := range numbers\
    \ {\n        if i == 0 {\n            result[i] = v\n        } else {\n      \
    \      if v > result[i-1] {\n                result[i] = v\n            } else\
    \ {\n                result[i] = result[i-1]\n            }\n        }\n    }\n\
    \    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate :=\
    \ rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4}\
    \ },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4}\
    \ },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3,\
    \ 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073940
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max := make([]int, len(numbers))\n    var current_max int\n\
    \    for i, val := range numbers {\n        if i == 0 {\n            current_max\
    \ = val\n        } else {\n            if val > current_max {\n              \
    \  current_max = val\n            }\n        }\n        rolling_max[i] = current_max\n\
    \    }\n    return rolling_max\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073940
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    result\
    \ := make([]int, len(numbers))\n    copy(result, numbers)\n    max_number := numbers[0]\n\
    \    for i := 0; i < len(numbers); i++ {\n        number := numbers[i]\n     \
    \   if number > max_number {\n            max_number = number\n        }\n   \
    \     result[i] = max_number\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073940
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    output := make([]int, len(numbers))\n    max := 0\n    for i, current\
    \ := range numbers {\n        if current > max {\n            max = current\n\
    \        }\n        output[i] = max\n    }\n    return output\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073940
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    m := numbers[0]\n    for\
    \ i, n := range numbers {\n        if n > m {\n            m = n\n        }\n\
    \        result[i] = m\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpkruw3rqo_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpkruw3rqo_test.go:31\
    \ +0x2f\ntesting.tRunner(0xc00019b040, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073940
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    length := len(numbers)\n    if length == 0 {\n        return numbers\n\
    \    }\n    max_so_far := numbers[0]\n    for i := 1; i < length; i++ {\n    \
    \    if numbers[i] > max_so_far {\n            max_so_far = numbers[i]\n     \
    \   }\n        numbers[i] = max_so_far\n    }\n    return numbers\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073940
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    result\
    \ := make([]int, len(numbers))\n    result[0] = numbers[0]\n    for i := 1; i\
    \ < len(numbers); i++ {\n        if numbers[i] > result[i-1] {\n            result[i]\
    \ = numbers[i]\n        } else {\n            result[i] = result[i-1]\n      \
    \  }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073802
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n\n    maxSoFar := 0\n    for _, v := range numbers\
    \ {\n        if v > maxSoFar {\n            maxSoFar = v\n        }\n        result\
    \ = append(result, maxSoFar)\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073940
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    output := []int{max}\n    for _, v := range\
    \ numbers[1:] {\n        if v > max {\n            max = v\n        }\n      \
    \  output = append(output, max)\n    }\n    return output\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpnyg9bstl_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpnyg9bstl_test.go:31\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073940
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // If a list has no elements, we return an empty list\n    if len(numbers)\
    \ == 0 {\n        return numbers\n    }\n\n    // If a list has one element, it\
    \ is the maximum\n    if len(numbers) == 1 {\n        return []int{numbers[0]}\n\
    \    }\n\n    // We create a list with a capacity of the length of given list,\
    \ this\n    // way we are avoiding capacity changes that would cause reallocation.\n\
    \    result := make([]int, 0, len(numbers))\n\n    // We start with the first\
    \ element being the maximum\n    maximum := numbers[0]\n    result = append(result,\
    \ maximum)\n\n    // For each element in the list, compare it to the current maximum.\n\
    \    // If greater, then it is the new maximum.\n    for _, i := range numbers[1:]\
    \ {\n        if i > maximum {\n            maximum = i\n        }\n        result\
    \ = append(result, maximum)\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073940
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    for i, n := range numbers\
    \ {\n        if i == 0 {\n            result[i] = n\n        } else {\n      \
    \      if n > result[i-1] {\n                result[i] = n\n            } else\
    \ {\n                result[i] = result[i-1]\n            }\n        }\n    }\n\
    \    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate :=\
    \ rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4}\
    \ },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4}\
    \ },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3,\
    \ 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073802
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n\n    rolling_maximums\
    \ := make([]int, len(numbers))\n    rolling_maximums[0] = numbers[0]\n\n    for\
    \ i := 1; i < len(numbers); i++ {\n        if numbers[i] > rolling_maximums[i-1]\
    \ {\n            rolling_maximums[i] = numbers[i]\n        } else {\n        \
    \    rolling_maximums[i] = rolling_maximums[i-1]\n        }\n    }\n\n    return\
    \ rolling_maximums\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate :=\
    \ rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4}\
    \ },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4}\
    \ },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3,\
    \ 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073940
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // r: rolling maximum found until given moment in the sequence\n\
    \    var r []int\n    var max int\n\n    for i, n := range numbers {\n       \
    \ if i == 0 {\n            max = n\n        } else {\n            if n > max {\n\
    \                max = n\n            }\n        }\n        r = append(r, max)\n\
    \    }\n\n    return r\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073940
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var output []int\n    var max int\n    for _, n := range numbers\
    \ {\n        if n > max {\n            max = n\n        }\n        output = append(output,\
    \ max)\n    }\n    return output\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073941
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    window := numbers[:1]\n    result := window\n    for _, v := range\
    \ numbers[1:] {\n        window = append(window, v)\n        if window[len(window)-1]\
    \ >= window[len(window)-2] {\n            result = append(result, window[len(window)-1])\n\
    \        } else {\n            result = append(result, window[len(window)-2])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: slice bounds out\
    \ of range [:1] with capacity 0 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:1] with capacity 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpwos7xpiw_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpwos7xpiw_test.go:33\
    \ +0x1a\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073941
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    maximums := make([]int, len(numbers))\n    maximums[0] = numbers[0]\n\
    \    for i, _ := range numbers {\n        if i == 0 {\n            continue\n\
    \        }\n        if numbers[i] > maximums[i-1] {\n            maximums[i] =\
    \ numbers[i]\n        } else {\n            maximums[i] = maximums[i-1]\n    \
    \    }\n    }\n    return maximums\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpufn93tse_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpufn93tse_test.go:35\
    \ +0x2f\ntesting.tRunner(0xc000199040, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073941
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    result\
    \ := make([]int, len(numbers))\n    for i, n := range numbers {\n        if i\
    \ == 0 {\n            result[i] = n\n        } else {\n            if n > result[i-1]\
    \ {\n                result[i] = n\n            } else {\n                result[i]\
    \ = result[i-1]\n            }\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073941
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    max := numbers[0]\n    for _, n := range\
    \ numbers {\n        if n > max {\n            max = n\n        }\n        result\
    \ = append(result, max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpksd6n917_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpksd6n917_test.go:31\
    \ +0x18\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073942
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // TODO: Implement\n    return []int{}\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmpir3miwbc_test.go:33: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n\
    \        tmpir3miwbc_test.go:33: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmpir3miwbc_test.go:33:\
    \ expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got\
    \ '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    result\
    \ := make([]int, len(numbers))\n    result[0] = numbers[0]\n    for i := 1; i\
    \ < len(numbers); i++ {\n        if numbers[i] > result[i-1] {\n            result[i]\
    \ = numbers[i]\n        } else {\n            result[i] = result[i-1]\n      \
    \  }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073802
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    length := len(numbers)\n    max := make([]int, length)\n    for\
    \ i := 0; i < length; i++ {\n        max[i] = numbers[i]\n        for j := 0;\
    \ j < i; j++ {\n            if numbers[j] > max[i] {\n                max[i] =\
    \ numbers[j]\n            }\n        }\n    }\n    return max\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073942
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    current_max := numbers[0]\n    rolling_max := make([]int, len(numbers))\n\
    \    rolling_max[0] = current_max\n    for i := 1; i < len(numbers); i++ {\n \
    \       current_max = max(current_max, numbers[i])\n        rolling_max[i] = current_max\n\
    \    }\n    return rolling_max\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo64obq8l_test.go:17:23: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073941
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    var max int\n\n    for\
    \ i, current := range numbers {\n        if i == 0 {\n            max = current\n\
    \        } else {\n            if current > max {\n                max = current\n\
    \            }\n        }\n        result[i] = max\n    }\n\n    return result\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073942
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // solution 1:\n    //\n    // we want to find rolling maximum\
    \ for numbers\n    // [1, 2, 3, 2, 3, 4, 2]\n    //\n    // we can use the following\
    \ algorithm:\n    // starting from the left\n    //  1  2  3  2  3  4  2\n   \
    \ //  1  2  3  3  3  4  4\n    //\n    // 1.) take the first element as the max\n\
    \    // 2.) then take the second element, and compare it to the first, if\n  \
    \  //     it is bigger, it is the new max\n    // 3.) repeat until the end\n \
    \   //\n    // let's use two pointers, one the current position and the other\
    \ a pointer\n    // to the current max\n    //\n    // we can use two indices,\
    \ current_position and curren_max_position\n    //\n    // starting from 0 for\
    \ the position, and 0 for the max_position\n\n    // initialize the max slice\
    \ with the first element\n    if len(numbers) == 0 {\n        return numbers\n\
    \    }\n\n    max := make([]int, len(numbers))\n    max[0] = numbers[0]\n\n  \
    \  // initialize the max positions\n    current_position := 1\n    current_max_position\
    \ := 0\n\n    for current_position < len(numbers) {\n        if numbers[current_position]\
    \ > numbers[current_max_position] {\n            max[current_position] = numbers[current_position]\n\
    \            current_max_position = current_position\n        } else {\n     \
    \       max[current_position] = numbers[current_max_position]\n        }\n   \
    \     current_position++\n    }\n\n    return max\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073942
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    var current_max int\n\n    for _, number\
    \ := range numbers {\n        if len(result) == 0 {\n            current_max =\
    \ number\n        } else {\n            if number > current_max {\n          \
    \      current_max = number\n            }\n        }\n        result = append(result,\
    \ current_max)\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073942
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    currentMax := 0\n    for _, v := range numbers\
    \ {\n        if v > currentMax {\n            currentMax = v\n        }\n    \
    \    result = append(result, currentMax)\n    }\n    return result\n}\n\nfunc\
    \ TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073942
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    results := make([]int, len(numbers))\n    var max int\n\n    for\
    \ idx, n := range numbers {\n        if idx == 0 {\n            max = n\n    \
    \    }\n\n        if n > max {\n            max = n\n        }\n\n        results[idx]\
    \ = max\n    }\n\n    return results\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073942
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max := make([]int, len(numbers))\n    rolling_max[0] =\
    \ numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] >\
    \ rolling_max[i-1] {\n            rolling_max[i] = numbers[i]\n        } else\
    \ {\n            rolling_max[i] = rolling_max[i-1]\n        }\n    }\n    return\
    \ rolling_max\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpg5f9vi4s_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpg5f9vi4s_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001924e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073804
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n\
    \    for i, number := range numbers[1:] {\n        if number > result[i] {\n \
    \           result[i+1] = number\n        } else {\n            result[i+1] =\
    \ result[i]\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp0nwb9pls_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp0nwb9pls_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001924e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073942
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    current_max := numbers[0]\n\
    \    result[0] = current_max\n    for i := 1; i < len(numbers); i++ {\n      \
    \  if numbers[i] > current_max {\n            current_max = numbers[i]\n     \
    \   }\n        result[i] = current_max\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmppplctrvd_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmppplctrvd_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073804
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    max\
    \ := numbers[0]\n    result := []int{max}\n    for _, n := range numbers[1:] {\n\
    \        if n > max {\n            max = n\n        }\n        result = append(result,\
    \ max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073804
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    max := numbers[0]\n  \
    \  result[0] = max\n    for i := 1; i < len(numbers); i++ {\n        current :=\
    \ numbers[i]\n        if current > max {\n            max = current\n        }\n\
    \        result[i] = max\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpn1yfsyd8_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpn1yfsyd8_test.go:33\
    \ +0x2f\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073942
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var output []int\n    var max = 0\n    for _, number := range numbers\
    \ {\n        if number > max {\n            max = number\n        }\n        output\
    \ = append(output, max)\n    }\n    return output\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073942
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    output := []int{}\n    for _, n := range\
    \ numbers {\n        if n > max {\n            max = n\n        }\n        output\
    \ = append(output, max)\n    }\n    return output\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp1ye5trpt_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp1ye5trpt_test.go:31\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073942
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var res []int\n    var max int\n    for i, v := range numbers {\n\
    \        if i == 0 {\n            max = v\n        } else {\n            if v\
    \ > max {\n                max = v\n            }\n        }\n        res = append(res,\
    \ max)\n    }\n    return res\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073942
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max_numbers := make([]int, len(numbers))\n    max_numbers[0] =\
    \ numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] >\
    \ max_numbers[i-1] {\n            max_numbers[i] = numbers[i]\n        } else\
    \ {\n            max_numbers[i] = max_numbers[i-1]\n        }\n    }\n    return\
    \ max_numbers\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 4 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpxxkjdhhg_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpxxkjdhhg_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc00019e000, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660073864
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    max := 0\n    for i, x\
    \ := range numbers {\n        if x > max {\n            max = x\n        }\n \
    \       result[i] = max\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073942
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    rolling_max\
    \ := make([]int, len(numbers))\n    rolling_max[0] = numbers[0]\n    for i :=\
    \ 1; i < len(numbers); i++ {\n        if numbers[i] > rolling_max[i-1] {\n   \
    \         rolling_max[i] = numbers[i]\n        } else {\n            rolling_max[i]\
    \ = rolling_max[i-1]\n        }\n    }\n    return rolling_max\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073942
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max, i int\n    var result []int\n    for _, e := range numbers\
    \ {\n        if e > max {\n            max = e\n        }\n        result = append(result,\
    \ max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnghn9rsd_test.go:13:14: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073942
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    var max int\n    for i,\
    \ n := range numbers {\n        if n > max {\n            max = n\n        }\n\
    \        result[i] = max\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073942
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    maximums := make([]int, len(numbers))\n    for i, number := range\
    \ numbers {\n        var prevMax int\n        if i > 0 {\n            prevMax\
    \ = maximums[i-1]\n        }\n        maximums[i] = max(number, prevMax)\n   \
    \ }\n    return maximums\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu27eh8s3_test.go:19:23: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073942
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    maxs := make([]int, len(numbers))\n    max := numbers[0]\n    for\
    \ i, n := range numbers {\n        if n > max {\n            max = n\n       \
    \ }\n        maxs[i] = max\n    }\n    return maxs\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc0001ce000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp79zgtenv_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp79zgtenv_test.go:31\
    \ +0x2f\ntesting.tRunner(0xc00019aea0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073942
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var rolling_maxes []int\n    var max_so_far int\n    for _, n :=\
    \ range numbers {\n        if n > max_so_far {\n            max_so_far = n\n \
    \       }\n        rolling_maxes = append(rolling_maxes, max_so_far)\n    }\n\
    \    return rolling_maxes\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073943
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    // TODO\n    return []int{}\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmp0khox59p_test.go:33: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[]'\n    --- FAIL: TestRolling_Max/test_num__2 (0.00s)\n\
    \        tmp0khox59p_test.go:33: expected '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n        tmp0khox59p_test.go:33:\
    \ expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100) %!s(int=100)]', got\
    \ '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073943
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    max\
    \ := numbers[0]\n    result := []int{max}\n    for _, number := range numbers[1:]\
    \ {\n        if number > max {\n            max = number\n        }\n        result\
    \ = append(result, max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073804
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    for index, num := range numbers {\n        if index == 0 {\n  \
    \          continue\n        }\n\n        if numbers[index-1] < num {\n      \
    \      numbers[index] = num\n        } else {\n            numbers[index] = numbers[index-1]\n\
    \        }\n    }\n\n    return numbers\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073943
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n\
    \    for i, v := range numbers[1:] {\n        result[i+1] = max(result[i], v)\n\
    \    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdrv4mj6k_test.go:16:23: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073943
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    max := numbers[0]\n  \
    \  result[0] = max\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i]\
    \ > max {\n            max = numbers[i]\n        }\n        result[i] = max\n\
    \    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000158000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000158000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpom_gcshv_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpom_gcshv_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001036c0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660073802
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    if len(numbers) == 0 {\n\
    \        return result\n    }\n    result[0] = numbers[0]\n    var last_value\
    \ int = numbers[0]\n    for index, value := range numbers[1:] {\n        if value\
    \ > last_value {\n            result[index+1] = value\n            last_value\
    \ = value\n        } else {\n            result[index+1] = last_value\n      \
    \  }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073943
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    max := 0\n    for i, number\
    \ := range numbers {\n        if number > max {\n            max = number\n  \
    \      }\n        result[i] = max\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073864
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    max := 0\n    for _, n := range numbers {\n\
    \        if n > max {\n            max = n\n        }\n        result = append(result,\
    \ max)\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073864
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var solution []int\n    if len(numbers) == 0 {\n        return\
    \ solution\n    }\n    solution = append(solution, numbers[0])\n    for _, number\
    \ := range numbers[1:] {\n        previous := solution[len(solution) - 1]\n  \
    \      if number > previous {\n            solution = append(solution, number)\n\
    \        } else {\n            solution = append(solution, previous)\n       \
    \ }\n    }\n    return solution\n}\n\nfunc TestRolling_Max(t *testing.T) {\n \
    \ candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073944
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    result\
    \ := make([]int, len(numbers))\n    result[0] = numbers[0]\n    for i := 1; i\
    \ < len(numbers); i++ {\n        if numbers[i] > result[i-1] {\n            result[i]\
    \ = numbers[i]\n        } else {\n            result[i] = result[i-1]\n      \
    \  }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073802
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var max_till_now int\n    var max_at_index []int\n\n    for _,\
    \ val := range numbers {\n        if val > max_till_now {\n            max_till_now\
    \ = val\n        }\n        max_at_index = append(max_at_index, max_till_now)\n\
    \    }\n\n    return max_at_index\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073944
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    out\
    \ := make([]int, len(numbers))\n    out[0] = numbers[0]\n    for i := 1; i < len(numbers);\
    \ i++ {\n        if numbers[i] > out[i-1] {\n            out[i] = numbers[i]\n\
    \        } else {\n            out[i] = out[i-1]\n        }\n    }\n    return\
    \ out\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073944
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    current_max := numbers[0]\n\
    \    result[0] = current_max\n    for i := 1; i < len(numbers); i++ {\n      \
    \  if current_max < numbers[i] {\n            current_max = numbers[i]\n     \
    \   }\n        result[i] = current_max\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpn8das3t1_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpn8das3t1_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001924e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073944
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var rolling = make([]int, len(numbers))\n    var max_elem = 0\n\
    \    for i, n := range numbers {\n        if n > max_elem {\n            max_elem\
    \ = n\n        }\n        rolling[i] = max_elem\n    }\n    return rolling\n}\n\
    \nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073944
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return []int{}\n    }\n    output\
    \ := make([]int, len(numbers))\n    output[0] = numbers[0]\n    for i, n := range\
    \ numbers[1:] {\n        if n > output[i] {\n            output[i+1] = n\n   \
    \     } else {\n            output[i+1] = output[i]\n        }\n    }\n    return\
    \ output\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073944
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max := make([]int, len(numbers))\n    rolling_max[0] =\
    \ numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] >\
    \ rolling_max[i-1] {\n            rolling_max[i] = numbers[i]\n        } else\
    \ {\n            rolling_max[i] = rolling_max[i-1]\n        }\n    }\n    return\
    \ rolling_max\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpg5f9vi4s_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpg5f9vi4s_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001924e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073804
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := 0\n    max_list := make([]int, len(numbers))\n    for i,\
    \ n := range numbers {\n        if n > max {\n            max = n\n        }\n\
    \        max_list[i] = max\n    }\n    return max_list\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073944
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    res := make([]int, len(numbers))\n    m := 0\n    for i, v := range\
    \ numbers {\n        if v > m {\n            m = v\n        }\n        res[i]\
    \ = m\n    }\n    return res\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073944
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    for i, v := range numbers {\n        if i\
    \ == 0 {\n            result = append(result, v)\n        } else {\n         \
    \   if v > result[i-1] {\n                result = append(result, v)\n       \
    \     } else {\n                result = append(result, result[i-1])\n       \
    \     }\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073944
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max := numbers[0]\n    res := []int{}\n    for _, n := range numbers\
    \ {\n        if n > max {\n            max = n\n        }\n        res = append(res,\
    \ max)\n    }\n    return res\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpvz8_5w_n_test.go:13\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpvz8_5w_n_test.go:31\
    \ +0x18\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073944
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    res := make([]int, len(numbers))\n    res[0] = numbers[0]\n   \
    \ for i := 1; i < len(numbers); i++ {\n        if numbers[i] > res[i-1] {\n  \
    \          res[i] = numbers[i]\n        } else {\n            res[i] = res[i-1]\n\
    \        }\n    }\n    return res\n}\n\nfunc TestRolling_Max(t *testing.T) {\n\
    \  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp83fx6xx3_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp83fx6xx3_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073938
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var rollingMax []int\n    var j int\n\n    for i := 0; i < len(numbers);\
    \ i++ {\n        rollingMax = append(rollingMax, numbers[i])\n        for j =\
    \ i - 1; j >= 0; j-- {\n            if numbers[j] > rollingMax[i] {\n        \
    \        rollingMax[i] = numbers[j]\n            }\n        }\n    }\n\n    return\
    \ rollingMax\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073944
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    res := make([]int, len(numbers))\n    for i, num := range numbers\
    \ {\n        if i == 0 {\n            res[i] = num\n        } else {\n       \
    \     if num > res[i-1] {\n                res[i] = num\n            } else {\n\
    \                res[i] = res[i-1]\n            }\n        }\n    }\n    return\
    \ res\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073944
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n    var max int\n\n    for i, n := range numbers\
    \ {\n        if i == 0 {\n            max = n\n        } else {\n            if\
    \ n > max {\n                max = n\n            }\n        }\n        result\
    \ = append(result, max)\n    }\n\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073944
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n\
    \    for i := 1; i < len(numbers); i++ {\n        result[i] = max(result[i-1],\
    \ numbers[i])\n    }\n    return result\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3vlsrrtk_test.go:16:21: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073944
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    res := make([]int, len(numbers))\n    if len(numbers) == 0 {\n\
    \        return res\n    }\n    res[0] = numbers[0]\n    for i := 1; i < len(numbers);\
    \ i++ {\n        res[i] = max(res[i-1], numbers[i])\n    }\n    return res\n}\n\
    \nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc4d8wqhz_test.go:19:18: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073944
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    max\
    \ := numbers[0]\n    for _, n := range numbers {\n        if n > max {\n     \
    \       max = n\n        }\n    }\n    return append([]int{max}, rolling_max(numbers[1:])...)\n\
    }\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmps32640xp_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__2 (0.00s)\n        tmps32640xp_test.go:41: expected\
    \ '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3)\
    \ %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n\
    \        tmps32640xp_test.go:41: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)\
    \ %!s(int=100)]', got '[%!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=3)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073944
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max_at := make([]int, len(numbers))\n    current_max := 0\n   \
    \ for i, current := range numbers {\n        if current > current_max {\n    \
    \        current_max = current\n        }\n        max_at[i] = current_max\n \
    \   }\n    return max_at\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate\
    \ := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected:\
    \ []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4,\
    \ 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3,\
    \ 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073944
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    maxSoFar := numbers[0]\n\
    \    result[0] = maxSoFar\n    for i := 1; i < len(numbers); i++ {\n        if\
    \ numbers[i] > maxSoFar {\n            maxSoFar = numbers[i]\n        }\n    \
    \    result[i] = maxSoFar\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmph2pxg4hh_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmph2pxg4hh_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001201a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073944
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    result[0] = numbers[0]\n\
    \    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > result[i-1]\
    \ {\n            result[i] = numbers[i]\n        } else {\n            result[i]\
    \ = result[i-1]\n        }\n    }\n    return result\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmp5mpp14sq_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmp5mpp14sq_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073802
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    var result []int\n\n    for i, _ := range numbers {\n        max\
    \ := numbers[i]\n        for j := i + 1; j < len(numbers); j++ {\n           \
    \ if numbers[j] > max {\n                max = numbers[j]\n            }\n   \
    \     }\n        result = append(result, max)\n    }\n\n    return result\n}\n\
    \nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     {\
    \ actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     {\
    \ actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     {\
    \ actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\n    --- FAIL: TestRolling_Max/test_num__1\
    \ (0.00s)\n        tmparkrztna_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\n    --- FAIL:\
    \ TestRolling_Max/test_num__2 (0.00s)\n        tmparkrztna_test.go:44: expected\
    \ '[%!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]', got '[%!s(int=4) %!s(int=3)\
    \ %!s(int=2) %!s(int=1)]'\n    --- FAIL: TestRolling_Max/test_num__3 (0.00s)\n\
    \        tmparkrztna_test.go:44: expected '[%!s(int=3) %!s(int=3) %!s(int=3) %!s(int=100)\
    \ %!s(int=100)]', got '[%!s(int=100) %!s(int=100) %!s(int=100) %!s(int=100) %!s(int=3)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073944
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    result := make([]int, len(numbers))\n    maximum := 0\n    for\
    \ index, number := range numbers {\n        if number > maximum {\n          \
    \  maximum = number\n        }\n        result[index] = maximum\n    }\n    return\
    \ result\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073944
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    maximums := make([]int, len(numbers))\n    maximums[0] = numbers[0]\n\
    \    for i := 1; i < len(numbers); i++ {\n        if numbers[i] > maximums[i-1]\
    \ {\n            maximums[i] = numbers[i]\n        } else {\n            maximums[i]\
    \ = maximums[i-1]\n        }\n    }\n    return maximums\n}\n\nfunc TestRolling_Max(t\
    \ *testing.T) {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4,\
    \ 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3,\
    \ 2, 3, 100, 3}), expected: []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpp268_mb4_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpp268_mb4_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc000198ea0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n"
  timestamp: 1660073944
- exit_code: 2
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    max_numbers := make([]int, len(numbers))\n    m := numbers[0]\n\
    \    for i, n := range numbers {\n        m = max(m, n)\n        max_numbers[i]\
    \ = m\n    }\n    return max_numbers\n}\n\nfunc TestRolling_Max(t *testing.T)\
    \ {\n  candidate := rolling_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{1, 2, 3, 4}), expected:\
    \ []int{1, 2, 3, 4} },\n     { actual: candidate([]int{4, 3, 2, 1}), expected:\
    \ []int{4, 4, 4, 4} },\n     { actual: candidate([]int{3, 2, 3, 100, 3}), expected:\
    \ []int{3, 3, 3, 100, 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw_xlcwzc_test.go:16:13: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073944
- exit_code: 1
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    rolling_max := make([]int, len(numbers))\n    rolling_max[0] =\
    \ numbers[0]\n    for i := 1; i < len(numbers); i++ {\n        if numbers[i] >\
    \ rolling_max[i-1] {\n            rolling_max[i] = numbers[i]\n        } else\
    \ {\n            rolling_max[i] = rolling_max[i-1]\n        }\n    }\n    return\
    \ rolling_max\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestRolling_Max (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.rolling_max(...)\n\t/tmp/tmpg5f9vi4s_test.go:14\n\
    command-line-arguments_test.TestRolling_Max(0x0?)\n\t/tmp/tmpg5f9vi4s_test.go:32\
    \ +0x2f\ntesting.tRunner(0xc0001924e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073804
- exit_code: 0
  program: "package rolling_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// From a given list of integers, generate a list of rolling maximum element\
    \ found until given moment\n// in the sequence.\n// >>> rolling_max([]int{1, 2,\
    \ 3, 2, 3, 4, 2})\n// []int{1, 2, 3, 3, 3, 4, 4}\nfunc rolling_max(numbers []int)\
    \ []int {\n    if len(numbers) == 0 {\n        return numbers\n    }\n    res\
    \ := make([]int, len(numbers))\n    res[0] = numbers[0]\n    for i := 1; i < len(numbers);\
    \ i++ {\n        if numbers[i] > res[i-1] {\n            res[i] = numbers[i]\n\
    \        } else {\n            res[i] = res[i-1]\n        }\n    }\n    return\
    \ res\n}\n\nfunc TestRolling_Max(t *testing.T) {\n  candidate := rolling_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{}), expected: []int{} },\n\
    \     { actual: candidate([]int{1, 2, 3, 4}), expected: []int{1, 2, 3, 4} },\n\
    \     { actual: candidate([]int{4, 3, 2, 1}), expected: []int{4, 4, 4, 4} },\n\
    \     { actual: candidate([]int{3, 2, 3, 100, 3}), expected: []int{3, 3, 3, 100,\
    \ 100} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073944
