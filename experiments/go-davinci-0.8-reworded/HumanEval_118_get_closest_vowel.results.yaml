language: go_test.go
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consontants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\",\n                               \"n\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    var cons_vow_index\
    \ map[int]bool = make(map[int]bool)\n    for i, l := range word {\n        for\
    \ _, v := range vowels {\n            if string(l) == v {\n                cons_vow_index[i]\
    \ = true\n            }\n        }\n    }\n    for i, l := range word {\n    \
    \    if !cons_vow_index[i] {\n            continue\n        }\n        for _,\
    \ c := range consontants {\n            if string(l) == c {\n                if\
    \ (i + 1) < len(word) && cons_vow_index[i + 1] {\n                    return string(word[i])\n\
    \                }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp2c909g7o_test.go:74: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp2c909g7o_test.go:74: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmp2c909g7o_test.go:74: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmp2c909g7o_test.go:74: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp2c909g7o_test.go:74:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp2c909g7o_test.go:74: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var (\n        res string\n        vowel_map = map[rune]bool{\n\
    \            'a': true,\n            'e': true,\n            'i': true,\n    \
    \        'o': true,\n            'u': true,\n            'A': true,\n        \
    \    'E': true,\n            'I': true,\n            'O': true,\n            'U':\
    \ true,\n        }\n    )\n    if len(word) < 3 {\n        return res\n    }\n\
    \    for _, v := range word {\n        if !vowel_map[v] {\n            continue\n\
    \        }\n        if !vowel_map[rune(word[len(word)-1])] {\n            res\
    \ = string(v)\n            break\n        }\n    }\n    return res\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpr3vjnoi2_test.go:78: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmpr3vjnoi2_test.go:78: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmpr3vjnoi2_test.go:78: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpr3vjnoi2_test.go:78: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpr3vjnoi2_test.go:78:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpr3vjnoi2_test.go:78: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    vowels\
    \ := \"AEIOUaeiou\"\n    i := len(word) - 1\n    prev_consonant := false\n   \
    \ for ; i >= 0; i-- {\n        if vowels[strings.Index(vowels, string(word[i]))]\
    \ != 0 {\n            if prev_consonant {\n                return string(word[i])\n\
    \            }\n        } else {\n            prev_consonant = true\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyyn2cagj_test.go:30:19: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[byte]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true}\n    result := \"\"\n    start := len(word) - 1\n    end\
    \ := len(word) - 1\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[word[i]]\
    \ {\n            start = i\n            break\n        }\n    }\n    for i :=\
    \ start - 1; i >= 0; i-- {\n        if !vowels[word[i]] {\n            end = i\n\
    \            break\n        }\n    }\n    if start > end {\n        result = string(word[start])\n\
    \    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n \
    \ candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpw2eo2vyb_test.go:70: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpw2eo2vyb_test.go:70: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpw2eo2vyb_test.go:70: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpw2eo2vyb_test.go:70: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpw2eo2vyb_test.go:70:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpw2eo2vyb_test.go:70: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if strInArr(word[i:i+1],\
    \ vowels) {\n            return word[i:i+1]\n        }\n    }\n    return \"\"\
    \n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpseb7ntll_test.go:25:12: undefined: strInArr

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[string]\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9iqwm_k0_test.go:23:29: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074570
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]int {\n        'a': 1,\n        'e':\
    \ 1,\n        'i': 1,\n        'o': 1,\n        'u': 1,\n        'A': 1,\n   \
    \     'E': 1,\n        'I': 1,\n        'O': 1,\n        'U': 1,\n    }\n    result\
    \ := \"\"\n    count := len(word)\n    for i := len(word) - 1; i >= 0; i-- {\n\
    \        if _, ok := vowels[rune(word[i])]; ok {\n            if count - i < count\
    \ {\n                result = string(word[i])\n                count = i\n   \
    \         }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpx2mhrrx__test.go:73: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmpx2mhrrx__test.go:73: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmpx2mhrrx__test.go:73: expected '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpx2mhrrx__test.go:73: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpx2mhrrx__test.go:73: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpx2mhrrx__test.go:73: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmpx2mhrrx__test.go:73: expected '', got 'i'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        for j := len(vowels) - 1; j >= 0; j-- {\n           \
    \ if word[i] == vowels[j] {\n                return string(word[i])\n        \
    \    }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpzhnpkf6y_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpzhnpkf6y_test.go:59: expected\
    \ '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpzhnpkf6y_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpzhnpkf6y_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpzhnpkf6y_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpzhnpkf6y_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpzhnpkf6y_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpzhnpkf6y_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpzhnpkf6y_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if findSlice(vowels, string(word[i]))\
    \ != -1 {\n            return string(word[i])\n        }\n    }\n    return \"\
    \"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw3to9hmb_test.go:25:12: undefined: findSlice

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074571
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"AEIOUaeiou\"\n    distance := len(word)\n\
    \    var closestVowel string\n    for i, c := range word {\n        if strings.Contains(vowels,\
    \ string(c)) {\n            currentDistance := len(word) - i\n            if currentDistance\
    \ < distance {\n                distance = currentDistance\n                closestVowel\
    \ = string(c)\n            }\n        }\n    }\n    return closestVowel\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp7u3j4bk_test.go:27:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) <= 1 {\n        return \"\"\n    }\n    var\
    \ vowels = map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true,\
    \ \"u\": true}\n    var last string\n    var first string\n    var last_vowel\
    \ string\n    for i := len(word) - 1; i >= 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ ok {\n            last_vowel = string(word[i])\n            continue\n     \
    \   }\n        if last_vowel != \"\" {\n            last = string(word[i])\n \
    \           break\n        }\n    }\n    for i := 0; i < len(word); i++ {\n  \
    \      if _, ok := vowels[string(word[i])]; ok {\n            continue\n     \
    \   }\n        if last_vowel != \"\" {\n            first = string(word[i])\n\
    \            break\n        }\n    }\n    if last_vowel == \"\" || last == \"\"\
    \ || first == \"\" {\n        return \"\"\n    }\n    return last_vowel\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpxp34yfti_test.go:80: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpxp34yfti_test.go:80: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpxp34yfti_test.go:80: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpxp34yfti_test.go:80: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpxp34yfti_test.go:80:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpxp34yfti_test.go:80: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n\tif len(word) < 3 {\n\t\treturn \"\"\n\t}\n\t// reverse word\n\
    \tvar reversedWord string\n\tfor i := len(word) - 1; i >= 0; i-- {\n\t\treversedWord\
    \ += string(word[i])\n\t}\n\t// find the first consonant\n\tvar firstConsonant\
    \ string\n\tfor i := 0; i < len(reversedWord); i++ {\n\t\tswitch reversedWord[i]\
    \ {\n\t\tcase 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U':\n\t\t\tfirstConsonant\
    \ = \"\"\n\t\tdefault:\n\t\t\tfirstConsonant = string(reversedWord[i])\n\t\t\t\
    i++\n\t\t\tbreak\n\t\t}\n\t}\n\t// find the closest vowel\n\tvar closestVowel\
    \ string\n\tfor i := 0; i < len(reversedWord); i++ {\n\t\tswitch reversedWord[i]\
    \ {\n\t\tcase 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U':\n\t\t\tclosestVowel\
    \ = string(reversedWord[i])\n\t\t\tbreak\n\t\t}\n\t}\n\treturn closestVowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9n74ngwp_test.go:32:6: firstConsonant declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074571
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n\tvowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\t\
    for i := len(word) - 1; i >= 0; i-- {\n\t\tif j := find_vowel(word[i], vowels);\
    \ j >= 0 {\n\t\t\tif i+1 < len(word) && find_vowel(word[i+1], vowels) == -1 {\n\
    \t\t\t\treturn vowels[j]\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8klsd0n__test.go:25:11: undefined: find_vowel

    /tmp/tmp8klsd0n__test.go:26:26: undefined: find_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074571
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    res := \"\"\n    distance\
    \ := -1\n    is_previous_consonant := false\n    is_next_consonant := false\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_next_consonant {\n \
    \           break\n        }\n        is_previous_consonant = false\n        is_next_consonant\
    \ = false\n        if contains(vowels, string(word[i])) {\n            continue\n\
    \        }\n        for j := i + 1; j < len(word); j++ {\n            if contains(vowels,\
    \ string(word[j])) {\n                is_previous_consonant = true\n         \
    \       if is_next_consonant {\n                    distance = j - i\n       \
    \             res = string(word[j])\n                    break\n             \
    \   }\n            } else {\n                is_next_consonant = true\n      \
    \          if is_previous_consonant {\n                    if distance == -1 ||\
    \ j - i < distance {\n                        distance = j - i\n             \
    \           res = string(word[j-1])\n                    }\n                 \
    \   break\n                }\n            }\n        }\n    }\n    return res\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuyabrlhq_test.go:34:12: undefined: contains

    /tmp/tmpuyabrlhq_test.go:38:16: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074571
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    var re string\n    for idx :=\
    \ len(word) - 1; idx >= 0; idx-- {\n        if len(re) == 0 {\n            idx2\
    \ := vowels.IndexRune(rune(word[idx]))\n            if idx2 >= 0 {\n         \
    \       re = string(word[idx])\n            }\n        } else {\n            idx2\
    \ := vowels.IndexRune(rune(word[idx]))\n            if idx2 < 0 {\n          \
    \      return re\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2f5ewh9r_test.go:27:28: vowels.IndexRune undefined (type string has no
    field or method IndexRune)

    /tmp/tmp2f5ewh9r_test.go:32:28: vowels.IndexRune undefined (type string has no
    field or method IndexRune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpfmtrvl3e_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpfmtrvl3e_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpfmtrvl3e_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpfmtrvl3e_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpfmtrvl3e_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpfmtrvl3e_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var ans = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        for\
    \ _, vowel := range vowels {\n            if word[i] == vowel[0] {\n         \
    \       ans = string(word[i])\n                return ans\n            }\n   \
    \     }\n    }\n    return ans\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmponrx0fm1_test.go:61: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmponrx0fm1_test.go:61: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmponrx0fm1_test.go:61: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmponrx0fm1_test.go:61: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmponrx0fm1_test.go:61: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmponrx0fm1_test.go:61: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmponrx0fm1_test.go:61: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmponrx0fm1_test.go:61:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmponrx0fm1_test.go:61: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    l := len(word)\n    if l == 0 {\n        return \"\"\n\
    \    }\n    vowels := map[byte]bool{\n        'a': true,\n        'e': true,\n\
    \        'i': true,\n        'o': true,\n        'u': true,\n        'A': true,\n\
    \        'E': true,\n        'I': true,\n        'O': true,\n        'U': true,\n\
    \    }\n    res := \"\"\n    for i := l - 1; i >= 0; i-- {\n        if !vowels[word[i]]\
    \ {\n            continue\n        }\n        if i + 1 < l && !vowels[word[i +\
    \ 1]] {\n            res = string(word[i])\n            break\n        }\n   \
    \ }\n    return res\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpfv0w6yq9_test.go:77: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpfv0w6yq9_test.go:77: expected\
    \ '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpfv0w6yq9_test.go:77: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpfv0w6yq9_test.go:77: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpfv0w6yq9_test.go:77: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n    \
    \    tmpfv0w6yq9_test.go:77: expected '', got 'A'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    r := []rune(word)\n    if len(r) < 2 {\n        return\
    \ \"\"\n    }\n    i := len(r) - 1\n    for i > 0 {\n        if !is_vowel(r[i])\
    \ {\n            j := i - 1\n            for j > 0 {\n                if !is_vowel(r[j])\
    \ {\n                    return \"\"\n                }\n                if is_vowel(r[j])\
    \ {\n                    return string(r[j])\n                }\n            \
    \    j--\n            }\n        }\n        i--\n    }\n    return \"\"\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyh7iqjfh_test.go:29:13: undefined: is_vowel

    /tmp/tmpyh7iqjfh_test.go:32:21: undefined: is_vowel

    /tmp/tmpyh7iqjfh_test.go:35:20: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var idx int\n    var closest_vowel string\n    var result\
    \ string\n    var start_idx int\n    vowels := \"aeiou\"\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if string(word[i]) == \" \" {\n            start_idx\
    \ = i - 1\n            break\n        }\n    }\n    for i := start_idx; i >= 0;\
    \ i-- {\n        if vowels[0:1] == string(word[i]) || vowels[1:2] == string(word[i])\
    \ ||\n            vowels[2:3] == string(word[i]) || vowels[3:4] == string(word[i])\
    \ ||\n            vowels[4:5] == string(word[i]) {\n            idx = i\n    \
    \        closest_vowel = string(word[i])\n            break\n        }\n    }\n\
    \    if idx == 0 {\n        result = \"\"\n    } else {\n        result = closest_vowel\n\
    \    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n \
    \ candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpy_n1s_na_test.go:76: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpy_n1s_na_test.go:76: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpy_n1s_na_test.go:76: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpy_n1s_na_test.go:76: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpy_n1s_na_test.go:76:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpy_n1s_na_test.go:76: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var length = len(word)\n    for i := length - 1; i > 1; i-- {\n       \
    \ for _, v := range vowels {\n            if word[i] == v[0] {\n             \
    \   return string(word[i])\n            }\n        }\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__1\
    \ (0.00s)\n        tmpkpizzlhu_test.go:60: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpkpizzlhu_test.go:60: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpkpizzlhu_test.go:60: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpkpizzlhu_test.go:60: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpkpizzlhu_test.go:60: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n    \
    \    tmpkpizzlhu_test.go:60: expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmpkpizzlhu_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpkpizzlhu_test.go:60:\
    \ expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074571
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    index := len(word) - 1\n    nextVowel := \"\"\n    for index >= 0 {\n   \
    \     if contains(vowels, string(word[index])) {\n            nextVowel = string(word[index])\n\
    \            index--\n            break\n        }\n        index--\n    }\n \
    \   if nextVowel == \"\" {\n        return \"\"\n    }\n    found := false\n \
    \   for index >= 0 {\n        if contains(vowels, string(word[index])) {\n   \
    \         return nextVowel\n        }\n        if !found {\n            if index\
    \ == 0 {\n                return nextVowel\n            }\n            found =\
    \ true\n        }\n        index--\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcbml52xu_test.go:27:12: undefined: contains

    /tmp/tmpcbml52xu_test.go:39:12: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074571
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var (\n        vowels = []string{\"a\", \"e\", \"i\",\
    \ \"o\", \"u\"}\n        index int\n    )\n    if len(word) <= 1 {\n        return\
    \ \"\"\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if !in(vowels,\
    \ string(word[i])) {\n            if i + 1 < len(word) && in(vowels, string(word[i\
    \ + 1])) {\n                index = i + 1\n                break\n           \
    \ }\n        }\n    }\n    if index > 0 {\n        return string(word[index])\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu2ts9lrb_test.go:31:13: undefined: in

    /tmp/tmpu2ts9lrb_test.go:32:37: undefined: in

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074571
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]int{\n        'a': 1,\n        'e':\
    \ 1,\n        'i': 1,\n        'o': 1,\n        'u': 1,\n        'A': 1,\n   \
    \     'E': 1,\n        'I': 1,\n        'O': 1,\n        'U': 1,\n    }\n    word_len\
    \ := len(word)\n    if word_len < 3 {\n        return \"\"\n    }\n    for i :=\
    \ word_len - 2; i >= 0; i-- {\n        if _, ok := vowels[rune(word[i])]; ok {\n\
    \            if _, ok := vowels[rune(word[i + 1])]; !ok {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp2hps0ycb_test.go:74: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp2hps0ycb_test.go:74: expected\
    \ '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp2hps0ycb_test.go:74: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp2hps0ycb_test.go:74: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp2hps0ycb_test.go:74:\
    \ expected '', got 'A'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074572
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowel string\n    var re = []string{\"a\", \"e\",\
    \ \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        // find a consonant from the right\n        if !contains(re,\
    \ string(word[i])) {\n            for j := i - 1; j >= 0; j-- {\n            \
    \    // find a vowel from the left of the consonant\n                if contains(re,\
    \ string(word[j])) {\n                    return string(word[j])\n           \
    \     }\n            }\n        }\n    }\n    return vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6geilt2e_test.go:27:13: undefined: contains

    /tmp/tmp6geilt2e_test.go:30:20: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074573
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var ret string\n    found_consonant := false\n    for _, r\
    \ := range word {\n        if vowels[string(r)] {\n            if found_consonant\
    \ {\n                ret = string(r)\n                break\n            }\n \
    \       } else {\n            found_consonant = true\n        }\n    }\n    return\
    \ ret\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp7z20nco7_test.go:70: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmp7z20nco7_test.go:70: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmp7z20nco7_test.go:70: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp7z20nco7_test.go:70: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp7z20nco7_test.go:70:\
    \ expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074573
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    wordLen := len(word)\n    closest := \"\"\n    j := 0\n\
    \    for i := wordLen - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \ closest = string(word[i])\n            j = i\n            break\n        }\n\
    \    }\n    for j > 0 {\n        for i := j - 1; i >= 0; i-- {\n            if\
    \ word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i]\
    \ != 'u' {\n                j = i\n                break\n            }\n    \
    \    }\n        if j == 0 {\n            break\n        }\n        for i := j\
    \ - 1; i >= 0; i-- {\n            if word[i] == 'a' || word[i] == 'e' || word[i]\
    \ == 'i' || word[i] == 'o' || word[i] == 'u' {\n                if len(closest)\
    \ == 0 || (j - i) < len(closest) {\n                    closest = string(word[i])\n\
    \                }\n                j = i\n                break\n           \
    \ }\n        }\n    }\n    return closest\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp8luou9nz_test.go:81: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp8luou9nz_test.go:81: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp8luou9nz_test.go:81: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp8luou9nz_test.go:81: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp8luou9nz_test.go:81: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp8luou9nz_test.go:81: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp8luou9nz_test.go:81: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp8luou9nz_test.go:81:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp8luou9nz_test.go:81: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074573
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowel_index = make([]int, 0)\n    for i, letter :=\
    \ range word {\n        switch letter {\n        case 'a', 'e', 'i', 'o', 'u':\n\
    \            vowel_index = append(vowel_index, i)\n        }\n    }\n    if len(vowel_index)\
    \ == 0 {\n        return \"\"\n    }\n\n    var first_vowel_index = vowel_index[0]\n\
    \    var last_vowel_index = vowel_index[len(vowel_index) - 1]\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        switch word[i] {\n        case 'a', 'e', 'i', 'o',\
    \ 'u':\n            continue\n        }\n        // current letter is consonant\n\
    \        if i < last_vowel_index {\n            return string(word[last_vowel_index])\n\
    \        }\n        return string(word[first_vowel_index])\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpuvnougz5_test.go:75: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmpuvnougz5_test.go:75: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmpuvnougz5_test.go:75: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpuvnougz5_test.go:75: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpuvnougz5_test.go:75: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpuvnougz5_test.go:75: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpuvnougz5_test.go:75: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpuvnougz5_test.go:75:\
    \ expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmpuvnougz5_test.go:75: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12\
    \ (0.00s)\n        tmpuvnougz5_test.go:75: expected 'o', got 'e'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074573
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    prev_is_vowel := false\n    curr_is_vowel := false\n    s := \"\"\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        r := string(word[i])\n        curr_is_vowel\
    \ = false\n        for _, v := range vowels {\n            if r == v {\n     \
    \           curr_is_vowel = true\n                break\n            }\n     \
    \   }\n        if !prev_is_vowel && curr_is_vowel {\n            s = r\n     \
    \       break\n        }\n        prev_is_vowel = curr_is_vowel\n    }\n    return\
    \ s\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp12d59vds_test.go:70: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp12d59vds_test.go:70: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp12d59vds_test.go:70: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp12d59vds_test.go:70: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp12d59vds_test.go:70: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp12d59vds_test.go:70: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp12d59vds_test.go:70: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp12d59vds_test.go:70:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp12d59vds_test.go:70: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074574
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]bool{\n        'a': true,\n       \
    \ 'e': true,\n        'i': true,\n        'o': true,\n        'u': true,\n   \
    \     'A': true,\n        'E': true,\n        'I': true,\n        'O': true,\n\
    \        'U': true,\n    }\n    prev_vowel := \"\"\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        ch := rune(word[i])\n        if _, ok := vowels[ch];\
    \ ok {\n            prev_vowel = string(ch)\n        } else if prev_vowel != \"\
    \" {\n            return prev_vowel\n        }\n    }\n    return \"\"\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpmgtoa_tk_test.go:72: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpmgtoa_tk_test.go:72: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpmgtoa_tk_test.go:72: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpmgtoa_tk_test.go:72: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpmgtoa_tk_test.go:72:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpmgtoa_tk_test.go:72: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074573
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    var vowel_list []string\n   \
    \ var offset int\n    var closest_vowel string\n    closest_offset := len(word)\n\
    \n    for i := 0; i < len(word); i++ {\n        if vowels_index := strings.IndexAny(vowels,\
    \ word[i:i+1]); vowels_index != -1 {\n            vowel_list = append(vowel_list,\
    \ word[i:i+1])\n        }\n    }\n\n    if len(vowel_list) == 0 {\n        return\
    \ \"\"\n    }\n\n    for _, v := range vowel_list {\n        if offset = strings.LastIndex(word,\
    \ v); offset != -1 {\n            if closest_offset > offset {\n             \
    \   closest_offset = offset\n                closest_vowel = v\n            }\n\
    \        }\n    }\n\n    return closest_vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr3ugv9e3_test.go:30:28: undefined: strings

    /tmp/tmpr3ugv9e3_test.go:40:21: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074573
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if is_consonant(word[i]) {\n\
    \            for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    return string(word[j])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp04vohk17_test.go:23:5: vowels declared but not used

    /tmp/tmp04vohk17_test.go:25:12: undefined: is_consonant

    /tmp/tmp04vohk17_test.go:27:20: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    i := len(word) - 1\n    before := \"\
    \"\n    after := \"\"\n    for ; i >= 0; i-- {\n        if vowels[string(word[i])]\
    \ {\n            after = string(word[i])\n            break\n        }\n    }\n\
    \    for ; i >= 0; i-- {\n        if !vowels[string(word[i])] {\n            before\
    \ = string(word[i])\n            break\n        }\n    }\n    if before == \"\"\
    \ || after == \"\" {\n        return \"\"\n    }\n    return after\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmptji24w4x_test.go:70: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmptji24w4x_test.go:70: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmptji24w4x_test.go:70: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmptji24w4x_test.go:70: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmptji24w4x_test.go:70:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmptji24w4x_test.go:70: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074573
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n\t// Write your code here!\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmppon8pjjf_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmppon8pjjf_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmppon8pjjf_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmppon8pjjf_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmppon8pjjf_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmppon8pjjf_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074573
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    reverseWord\
    \ := []rune(word)\n    result := \"\"\n    for i := len(reverseWord) - 1; i >\
    \ 0; i-- {\n        if isVowel(reverseWord[i]) {\n            if !isVowel(reverseWord[i\
    \ - 1]) {\n                result = string(reverseWord[i])\n                break\n\
    \            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeq89k10f_test.go:29:12: undefined: isVowel

    /tmp/tmpeq89k10f_test.go:30:17: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074573
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    vowels\
    \ := map[string]string{\"a\": \"\", \"e\": \"\", \"i\": \"\", \"o\": \"\", \"\
    u\": \"\"}\n    for i := len(word) - 1; i > 0; i-- {\n        if _, exists :=\
    \ vowels[string(word[i])]; exists {\n            if _, exists := vowels[string(word[i-1])];\
    \ !exists {\n                return string(word[i])\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpz8g7m04t_test.go:62: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpz8g7m04t_test.go:62: expected\
    \ '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n    \
    \    tmpz8g7m04t_test.go:62: expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmpz8g7m04t_test.go:62: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpz8g7m04t_test.go:62:\
    \ expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074573
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    wordLen := len(word)\n    for\
    \ i := wordLen - 1; i > 0; i-- {\n        for j := len(vowels) - 1; j >= 0; j--\
    \ {\n            if word[i] == vowels[j] {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpbks_dre1_test.go:60: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpbks_dre1_test.go:60: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpbks_dre1_test.go:60: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpbks_dre1_test.go:60: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpbks_dre1_test.go:60:\
    \ expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmpbks_dre1_test.go:60: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12\
    \ (0.00s)\n        tmpbks_dre1_test.go:60: expected 'o', got 'e'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074574
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n\tvowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\t\
    isConsonant := func(c string) bool {\n\t\tfor _, v := range vowels {\n\t\t\tif\
    \ c == v {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\ti :=\
    \ len(word) - 1\n\tfor ; i >= 0; i-- {\n\t\tif isConsonant(word[i:i+1]) {\n\t\t\
    \tfor j := i - 1; j >= 0; j-- {\n\t\t\t\tif !isConsonant(word[j:j+1]) {\n\t\t\t\
    \t\treturn word[j:j+1]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpym8344ls_test.go:70: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpym8344ls_test.go:70: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpym8344ls_test.go:70: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpym8344ls_test.go:70: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpym8344ls_test.go:70: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074574
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    l := len(word)\n    if l < 2 {\n        return \"\"\n\
    \    }\n    vowels := \"AEIOUaeiou\"\n    for i := l - 1; i > 0; i-- {\n     \
    \   if strings.Contains(vowels, string(word[i])) {\n            return string(word[i])\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx77v4ubf_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074573
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    word_len := len(word)\n    if word_len == 0 {\n      \
    \  return \"\"\n    }\n    if word_len == 1 {\n        if IsVowel(string(word[0]))\
    \ {\n            return string(word[0])\n        } else {\n            return\
    \ \"\"\n        }\n    }\n    for i := word_len - 1; i > 0; i-- {\n        if\
    \ IsVowel(string(word[i])) {\n            if IsVowel(string(word[i-1])) {\n  \
    \              continue\n            } else {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp492waeqj_test.go:28:12: undefined: IsVowel

    /tmp/tmp492waeqj_test.go:35:12: undefined: IsVowel

    /tmp/tmp492waeqj_test.go:36:16: undefined: IsVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074573
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    dist := len(word)\n    r := len(word) - 1\n    d := 0\n\
    \    w := \"\"\n    for i := r; i >= 0; i-- {\n        if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \ d = r - i\n            if d < dist {\n                dist = d\n           \
    \     w = string(word[i])\n            }\n        }\n    }\n    return w\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpkltijrht_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpkltijrht_test.go:64: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpkltijrht_test.go:64: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpkltijrht_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpkltijrht_test.go:64: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpkltijrht_test.go:64: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpkltijrht_test.go:64: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpkltijrht_test.go:64:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpkltijrht_test.go:64: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074574
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    last_vowel := \"\"\n    var index_last_vowel int = -1\n    var index_last_consonant\
    \ int = -1\n    for i, c := range word {\n        str := string(c)\n        if\
    \ stringInSlice(str, vowels) {\n            last_vowel = str\n            index_last_vowel\
    \ = i\n        } else {\n            if index_last_vowel > index_last_consonant\
    \ {\n                return last_vowel\n            }\n            index_last_consonant\
    \ = i\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppv7ejj8m_test.go:29:12: undefined: stringInSlice

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074573
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    vowels\
    \ := \"AEIOU\"\n    pos := len(word) - 2\n    for ; pos >= 0; pos-- {\n      \
    \  if vowels[vowels_index(word[pos])] == word[pos] {\n            // Is vowel\n\
    \            if vowels[vowels_index(word[pos+1])] != word[pos+1] {\n         \
    \       // Is consonant\n                return string(word[pos])\n          \
    \  }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp4ym1_3m_test.go:29:19: undefined: vowels_index

    /tmp/tmpp4ym1_3m_test.go:31:23: undefined: vowels_index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074574
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code goes here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp_bc_eadn_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp_bc_eadn_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmp_bc_eadn_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmp_bc_eadn_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp_bc_eadn_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp_bc_eadn_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074574
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    last_pos := -1\n    for i := len(word) - 1; i >= 0; i-- {\n        for _,\
    \ v := range vowels {\n            if v == string(word[i]) {\n               \
    \ last_pos = i\n                break\n            }\n        }\n        if last_pos\
    \ != -1 {\n            break\n        }\n    }\n    return string(word[last_pos])\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp9gz9tnkz_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp9gz9tnkz_test.go:64: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp9gz9tnkz_test.go:64: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp9gz9tnkz_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp9gz9tnkz_test.go:64: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp9gz9tnkz_test.go:64: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp9gz9tnkz_test.go:64: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp9gz9tnkz_test.go:64:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp9gz9tnkz_test.go:64: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074574
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    for\
    \ i := len(word) - 2; i > 0; i-- {\n        if is_consonant(word[i]) && is_consonant(word[i-1])\
    \ {\n            return string(word[i+1])\n        }\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjog5x0eo_test.go:27:12: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074574
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) <= 2 {\n        return \"\"\n    }\n    var\
    \ vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var is_vowel = func(c\
    \ string) bool {\n        for _, v := range vowels {\n            if c == v {\n\
    \                return true\n            }\n        }\n        return false\n\
    \    }\n    var is_consonant = func(c string) bool {\n        return !is_vowel(c)\n\
    \    }\n    var index int\n    for i := len(word) - 1; i >= 0; i-- {\n       \
    \ if is_consonant(string(word[i])) {\n            index = i\n            break\n\
    \        }\n    }\n    if index <= 0 {\n        return \"\"\n    }\n    for i\
    \ := index - 1; i >= 0; i-- {\n        if is_vowel(string(word[i])) {\n      \
    \      return string(word[i])\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpkodf8vyf_test.go:81: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpkodf8vyf_test.go:81: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpkodf8vyf_test.go:81: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpkodf8vyf_test.go:81: expected '', got 'i'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074574
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    for i:=len(word)-1; i>0; i-- {\n        if isVowel(word[i])\
    \ && !isVowel(word[i-1]) {\n            return string(word[i])\n        }\n  \
    \  }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw2_cqfkr_test.go:24:12: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074574
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // TODO your code here\n    return \"\";\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp97t4oxd9_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp97t4oxd9_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmp97t4oxd9_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmp97t4oxd9_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp97t4oxd9_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp97t4oxd9_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.010s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // see the comment in the reverse version\n    // I don't\
    \ really like this version. The reverse version is much clearer\n    consonants\
    \ := map[rune]bool{\n        'B': true, 'C': true, 'D': true, 'F': true, 'G':\
    \ true, 'H': true,\n        'J': true, 'K': true, 'L': true, 'M': true, 'N': true,\
    \ 'P': true,\n        'Q': true, 'R': true, 'S': true, 'T': true, 'V': true, 'W':\
    \ true,\n        'X': true, 'Y': true, 'Z': true,\n    }\n    vowels := map[rune]bool{\n\
    \        'A': true, 'E': true, 'I': true, 'O': true, 'U': true,\n    }\n    var\
    \ prev_consonant, cur_consonant, cur_vowel rune\n    for i, char := range word\
    \ {\n        if consonants[char] {\n            if vowels[cur_vowel] {\n     \
    \           return string(cur_vowel)\n            }\n            prev_consonant\
    \ = cur_consonant\n            cur_consonant = char\n        } else if vowels[char]\
    \ {\n            if i == 0 || consonants[prev_consonant] {\n                return\
    \ string(char)\n            }\n            cur_vowel = char\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpccq4dl_k_test.go:77: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpccq4dl_k_test.go:77: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpccq4dl_k_test.go:77: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpccq4dl_k_test.go:77: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpccq4dl_k_test.go:77:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmpccq4dl_k_test.go:77: expected '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12\
    \ (0.00s)\n        tmpccq4dl_k_test.go:77: expected 'o', got 'A'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 0
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true, 'A': true, 'E': true, 'I': true, 'O': true, 'U': true}\n\
    \    consonants := map[rune]bool{'q': true, 'w': true, 'r': true, 't': true, 'p':\
    \ true, 's': true, 'd': true, 'f': true, 'g': true, 'h': true, 'j': true, 'k':\
    \ true, 'l': true, 'z': true, 'x': true, 'c': true, 'v': true, 'b': true, 'n':\
    \ true, 'm': true, 'Q': true, 'W': true, 'R': true, 'T': true, 'P': true, 'S':\
    \ true, 'D': true, 'F': true, 'G': true, 'H': true, 'J': true, 'K': true, 'L':\
    \ true, 'Z': true, 'X': true, 'C': true, 'V': true, 'B': true, 'N': true, 'M':\
    \ true}\n    word_runes := []rune(word)\n    for i, ch := range word_runes {\n\
    \        if vowels[ch] {\n            if (i > 0 && consonants[word_runes[i-1]])\
    \ && (i < len(word_runes)-1 && consonants[word_runes[i+1]]) {\n              \
    \  return string(ch)\n            }\n        }\n    }\n    return \"\"\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n\tif len(word) <= 1 {\n\t\treturn \"\"\n\t}\n\tfor i := len(word)\
    \ - 1; i > 0; i-- {\n\t\tif word[i] == 'a' || word[i] == 'e' || word[i] == 'i'\
    \ || word[i] == 'o' || word[i] == 'u' {\n\t\t\tif word[i-1] != 'a' && word[i-1]\
    \ != 'e' && word[i-1] != 'i' && word[i-1] != 'o' && word[i-1] != 'u' {\n\t\t\t\
    \treturn string(word[i])\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp4r92mt5j_test.go:61: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp4r92mt5j_test.go:61: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp4r92mt5j_test.go:61: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp4r92mt5j_test.go:61: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp4r92mt5j_test.go:61:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp4r92mt5j_test.go:61: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    cons := \"bcdfghjklmnpqrstvwxyz\"\
    \n    for i := len(word) - 2; i >= 0; i-- {\n        if strings.Contains(cons,\
    \ string(word[i])) {\n            for j := i + 1; j < len(word); j++ {\n     \
    \           if strings.Contains(vowels, string(word[j])) {\n                 \
    \   return string(word[j])\n                }\n            }\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoyhzn58o_test.go:26:12: undefined: strings

    /tmp/tmpoyhzn58o_test.go:28:20: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmphg8cafef_test.go:51: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmphg8cafef_test.go:51: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmphg8cafef_test.go:51: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmphg8cafef_test.go:51: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmphg8cafef_test.go:51:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmphg8cafef_test.go:51: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    v := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n   \
    \ lastC := -1\n    lastV := -1\n    best := 1000\n    for i, c := range word {\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n     \
    \       if lastC != -1 {\n                if i - lastC < best {\n            \
    \        best = i - lastC\n                    lastV = i\n                }\n\
    \            }\n        } else {\n            lastC = i\n        }\n    }\n  \
    \  if lastV != -1 {\n        return v[(word[lastV] - 'a') % len(v)]\n    }\n \
    \   return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_cisjk9e_test.go:40:18: invalid operation: (word[lastV] - ''a'') % len(v)
    (mismatched types byte and int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    distance := -1\n    result := \"\"\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        char := string(word[i])\n        if char == \"a\"\
    \ || char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n    \
    \        // get distance from the end\n            current_distance := len(word)\
    \ - i\n            if distance == -1 || current_distance < distance {\n      \
    \          distance = current_distance\n                result = char\n      \
    \      }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpub605861_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpub605861_test.go:64: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpub605861_test.go:64: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpub605861_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpub605861_test.go:64: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpub605861_test.go:64: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpub605861_test.go:64: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpub605861_test.go:64:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpub605861_test.go:64: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var prev, next rune\n    for i := len(word) - 1; i >= 0; i-- {\n      \
    \  if i != len(word) - 1 {\n            next = rune(word[i + 1])\n        } else\
    \ {\n            next = 0\n        }\n        prev = rune(word[i])\n        for\
    \ _, v := range vowels {\n            if rune(v[0]) == prev {\n              \
    \  if next != 0 {\n                    if rune(v[0]) != next {\n             \
    \           return v\n                    }\n                } else {\n      \
    \              return v\n                }\n            }\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpfa5w8f93_test.go:72: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpfa5w8f93_test.go:72: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpfa5w8f93_test.go:72: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpfa5w8f93_test.go:72: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpfa5w8f93_test.go:72: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpfa5w8f93_test.go:72: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpfa5w8f93_test.go:72: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpfa5w8f93_test.go:72:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpfa5w8f93_test.go:72: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                return v\n            }\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpod18x8w5_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpod18x8w5_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpod18x8w5_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpod18x8w5_test.go:59:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpod18x8w5_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // TODO\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp305ojq2s_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp305ojq2s_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmp305ojq2s_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmp305ojq2s_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp305ojq2s_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp305ojq2s_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmphg8cafef_test.go:51: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmphg8cafef_test.go:51: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmphg8cafef_test.go:51: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmphg8cafef_test.go:51: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmphg8cafef_test.go:51:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmphg8cafef_test.go:51: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune(\"aeiou\")\n    prev := ' '\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        char := rune(word[i])\n        if\
    \ isVowel(char, vowels) {\n            if isConsonant(prev, vowels) {\n      \
    \          return string(char)\n            }\n        } else {\n            prev\
    \ = char\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7dcwcz8g_test.go:27:12: undefined: isVowel

    /tmp/tmp7dcwcz8g_test.go:28:16: undefined: isConsonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    is_vowel := func(c byte) bool {\n        return c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n               c == 'A'\
    \ || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n    }\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if !is_vowel(word[i]) {\n            if i == len(word)\
    \ - 1 {\n                return \"\"\n            }\n            if is_vowel(word[i+1])\
    \ {\n                return string(word[i+1])\n            }\n        }\n    }\n\
    \    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpt7bgjpme_test.go:65: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpt7bgjpme_test.go:65: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpt7bgjpme_test.go:65: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmpt7bgjpme_test.go:65: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpt7bgjpme_test.go:65: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpt7bgjpme_test.go:65: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpt7bgjpme_test.go:65: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpt7bgjpme_test.go:65:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpt7bgjpme_test.go:65: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n    for i := len(word) - 1; i > 0;\
    \ i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1]) {\n            return\
    \ string(word[i-1])\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjg3xfo6m_test.go:25:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmphg8cafef_test.go:51: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmphg8cafef_test.go:51: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmphg8cafef_test.go:51: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmphg8cafef_test.go:51: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmphg8cafef_test.go:51:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmphg8cafef_test.go:51: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]int{\"a\":1, \"e\":1, \"i\":1, \"\
    o\":1, \"u\":1, \"A\":1, \"E\":1, \"I\":1, \"O\":1, \"U\":1}\n    if len(word)\
    \ < 3 {\n        return \"\"\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n\
    \        if _, ok := vowels[string(word[i])]; ok {\n            if _, ok := vowels[string(word[i-1])];\
    \ !ok {\n                if _, ok := vowels[string(word[i-2])]; !ok {\n      \
    \              return string(word[i])\n                }\n            }\n    \
    \    }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\npanic: runtime error: index out\
    \ of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\
    \ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513640, 0xc000156000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513640,\
    \ 0xc000156000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_closest_vowel({0x51e879, 0x6})\n\t/tmp/tmpze3a_ajr_test.go:30\
    \ +0x309\ncommand-line-arguments_test.TestGet_Closest_Vowel(0x0?)\n\t/tmp/tmpze3a_ajr_test.go:46\
    \ +0x4d\ntesting.tRunner(0xc000119040, 0x528fa0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]int{\"a\":1, \"e\":1, \"i\":1, \"\
    o\":1, \"u\":1, \"A\":1, \"E\":1, \"I\":1, \"O\":1, \"U\":1}\n    previous_vowel\
    \ := \"\"\n    previous_consonant := \"\"\n    previous_found := false\n    i\
    \ := len(word) - 1\n    for ; i > 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ ok {\n            if previous_found {\n                break\n            }\n\
    \            previous_vowel = string(word[i])\n        } else {\n            if\
    \ previous_vowel != \"\" {\n                previous_found = true\n          \
    \  }\n            previous_consonant = string(word[i])\n        }\n    }\n   \
    \ if previous_vowel != \"\" && previous_consonant != \"\" {\n        return previous_vowel\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp8cvz23pb_test.go:72: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp8cvz23pb_test.go:72: expected\
    \ '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp8cvz23pb_test.go:72: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp8cvz23pb_test.go:72: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp8cvz23pb_test.go:72:\
    \ expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmp8cvz23pb_test.go:72: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12\
    \ (0.00s)\n        tmp8cvz23pb_test.go:72: expected 'o', got 'e'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if word == \"\" {\n        return \"\"\n    }\n    vowel\
    \ := \"aeiou\"\n    last_char := word[len(word)-1:]\n    second_last_char := word[len(word)-2:len(word)-1]\n\
    \    var vowel_index int\n    for index, v := range vowel {\n        if string(v)\
    \ == last_char {\n            vowel_index = index\n            break\n       \
    \ }\n    }\n    if vowel_index != 0 {\n        for i := vowel_index; i >= 0; i--\
    \ {\n            if string(vowel[i]) == second_last_char {\n                return\
    \ \"\"\n            }\n        }\n        return last_char\n    }\n    for i :=\
    \ vowel_index; i < len(vowel); i++ {\n        if string(vowel[i]) == second_last_char\
    \ {\n            return \"\"\n        }\n    }\n    return last_char\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpvnjsmsky_test.go:77: expected 'u', got 't'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpvnjsmsky_test.go:77: expected\
    \ 'u', got 'l'\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n    \
    \    tmpvnjsmsky_test.go:77: expected '', got 'y'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3\
    \ (0.00s)\n        tmpvnjsmsky_test.go:77: expected '', got 'y'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpvnjsmsky_test.go:77: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpvnjsmsky_test.go:77: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpvnjsmsky_test.go:77: expected 'o', got 't'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpvnjsmsky_test.go:77: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpvnjsmsky_test.go:77: expected '', got 'k'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpvnjsmsky_test.go:77: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpvnjsmsky_test.go:77:\
    \ expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i])\
    \ && is_vowel(word[i-1]) {\n            return string(word[i-1])\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_osxxlcr_test.go:24:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"AEIOUaeiou\"\n    result := \"\"\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        for j := 0; j < len(vowels); j++\
    \ {\n            if i >= 1 && word[i] == vowels[j] && word[i-1] != vowels[j] {\n\
    \                result = string(word[i])\n                break\n           \
    \ }\n        }\n        if result != \"\" {\n            break\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp_n90g4ls_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp_n90g4ls_test.go:64: expected\
    \ '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp_n90g4ls_test.go:64: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8\
    \ (0.00s)\n        tmp_n90g4ls_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmp_n90g4ls_test.go:64: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n    \
    \    tmp_n90g4ls_test.go:64: expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmp_n90g4ls_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmp_n90g4ls_test.go:64:\
    \ expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 2 {\n        return \"\"\n    }\n    vowels\
    \ := map[rune]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true,\n  \
    \                          'A': true, 'E': true, 'I': true, 'O': true, 'U': true}\n\
    \    consonants := map[rune]bool{'b': true, 'c': true, 'd': true, 'f': true, 'g':\
    \ true, 'h': true,\n                                'j': true, 'k': true, 'l':\
    \ true, 'm': true, 'n': true, 'p': true,\n                                'q':\
    \ true, 'r': true, 's': true, 't': true, 'v': true, 'w': true,\n             \
    \                   'x': true, 'y': true, 'z': true,\n                       \
    \         'B': true, 'C': true, 'D': true, 'F': true, 'G': true, 'H': true,\n\
    \                                'J': true, 'K': true, 'L': true, 'M': true, 'N':\
    \ true, 'P': true,\n                                'Q': true, 'R': true, 'S':\
    \ true, 'T': true, 'V': true, 'W': true,\n                                'X':\
    \ true, 'Y': true, 'Z': true}\n    for i := len(word) - 1; i > 0; i-- {\n    \
    \    if _, ok := consonants[rune(word[i])]; ok {\n            if _, ok := consonants[rune(word[i-1])];\
    \ ok {\n                if _, ok := vowels[rune(word[i-2])]; ok {\n          \
    \          return string(word[i-2])\n                }\n            }\n      \
    \  }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpe0ld3hsj_test.go:73: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpe0ld3hsj_test.go:73: expected\
    \ '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpe0ld3hsj_test.go:73: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpe0ld3hsj_test.go:73: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpe0ld3hsj_test.go:73:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpe0ld3hsj_test.go:73: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // TODO: implement\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpwxh_ynr1_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpwxh_ynr1_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpwxh_ynr1_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpwxh_ynr1_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpwxh_ynr1_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpwxh_ynr1_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    const vowels = \"aeiouAEIOU\"\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if strings.Contains(vowels, string(word[i])) {\n\
    \            for j := i; j >= 0; j-- {\n                if strings.Contains(vowels,\
    \ string(word[j])) {\n                    return \"\"\n                }\n   \
    \             if j == 0 {\n                    return string(word[i])\n      \
    \          }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpunxl9sdb_test.go:25:12: undefined: strings

    /tmp/tmpunxl9sdb_test.go:27:20: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]int {\n        \"a\": 1,\n      \
    \  \"e\": 1,\n        \"i\": 1,\n        \"o\": 1,\n        \"u\": 1,\n      \
    \  \"A\": 1,\n        \"E\": 1,\n        \"I\": 1,\n        \"O\": 1,\n      \
    \  \"U\": 1,\n    }\n    closest := \"\"\n    for i := len(word) - 1; i >= 0;\
    \ i-- {\n        if _, ok := vowels[string(word[i])]; ok {\n            closest\
    \ = string(word[i])\n            continue\n        }\n        if closest != \"\
    \" {\n            break\n        }\n    }\n    return closest\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpff7wcadf_test.go:73: expected '', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpff7wcadf_test.go:73: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpff7wcadf_test.go:73: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpff7wcadf_test.go:73: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpff7wcadf_test.go:73: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpff7wcadf_test.go:73: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpff7wcadf_test.go:73: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpff7wcadf_test.go:73:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpff7wcadf_test.go:73: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074577
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // TODO: rewrite this function\n    return \"\"\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpuwt8tcfw_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpuwt8tcfw_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpuwt8tcfw_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpuwt8tcfw_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpuwt8tcfw_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpuwt8tcfw_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowel_map := map[string]int{\"a\": 1, \"e\": 1, \"i\"\
    : 1, \"o\": 1, \"u\": 1, \"A\": 1, \"E\": 1, \"I\": 1, \"O\": 1, \"U\": 1}\n \
    \   chars := []rune(word)\n    target_vowel := \"\"\n    vowels := \"\"\n    for\
    \ i:=len(chars)-1; i>=0; i-- {\n        if v, ok := vowel_map[string(chars[i])];\
    \ ok {\n            vowels = string(chars[i]) + vowels\n        } else {\n   \
    \         if len(vowels) > 0 {\n                target_vowel = vowels[0:1]\n \
    \               break\n            }\n        }\n    }\n    return target_vowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk_afh87o_test.go:28:12: v declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmphg8cafef_test.go:51: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmphg8cafef_test.go:51: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmphg8cafef_test.go:51: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmphg8cafef_test.go:51: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmphg8cafef_test.go:51:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmphg8cafef_test.go:51: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var map_vowel = map[string]int{\"a\": 0, \"e\": 0, \"\
    i\": 0, \"o\": 0, \"u\": 0}\n    for i := len(word) - 1; i >= 0; i-- {\n     \
    \   if _, ok := map_vowel[string(word[i])]; ok {\n            return string(word[i])\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpf0zls252_test.go:57: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpf0zls252_test.go:57: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpf0zls252_test.go:57: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpf0zls252_test.go:57: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpf0zls252_test.go:57: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpf0zls252_test.go:57: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpf0zls252_test.go:57: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpf0zls252_test.go:57:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpf0zls252_test.go:57: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074578
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    last_index := len(word) - 1\n    for index, char := range\
    \ word {\n        if index == 0 {\n            continue\n        }\n        if\
    \ char == 'A' || char == 'E' || char == 'I' || char == 'O' || char == 'U' {\n\
    \            if word[index-1] == ' ' || word[index-1] == 'A' || word[index-1]\
    \ == 'E' || word[index-1] == 'I' || word[index-1] == 'O' || word[index-1] == 'U'\
    \ {\n                continue\n            }\n            if index != last_index\
    \ {\n                if word[index+1] == ' ' || word[index+1] == 'A' || word[index+1]\
    \ == 'E' || word[index+1] == 'I' || word[index+1] == 'O' || word[index+1] == 'U'\
    \ {\n                    continue\n                }\n            }\n        \
    \    return string(char)\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmplipzi_ls_test.go:68: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmplipzi_ls_test.go:68: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmplipzi_ls_test.go:68: expected '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmplipzi_ls_test.go:68: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmplipzi_ls_test.go:68: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n    \
    \    tmplipzi_ls_test.go:68: expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12\
    \ (0.00s)\n        tmplipzi_ls_test.go:68: expected 'o', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074578
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[byte]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true}\n    new_word := []byte(word)\n    l := len(new_word)\n\
    \    index := l - 1\n    for {\n        if index < 0 {\n            break\n  \
    \      }\n        if !vowels[new_word[index]] {\n            break\n        }\n\
    \        index--\n    }\n    index--\n    for {\n        if index < 0 {\n    \
    \        break\n        }\n        if vowels[new_word[index]] {\n            return\
    \ string(new_word[index])\n        }\n        index--\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpqk16bkw0_test.go:74: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpqk16bkw0_test.go:74: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpqk16bkw0_test.go:74: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpqk16bkw0_test.go:74: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpqk16bkw0_test.go:74: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074578
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpvi3gi411_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpvi3gi411_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpvi3gi411_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvi3gi411_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n        \
    \    if i + 1 < len(word) && !is_vowel(word[i + 1]) {\n                return\
    \ string(word[i])\n            }\n        } else {\n            if i + 1 < len(word)\
    \ && is_vowel(word[i + 1]) {\n                return string(word[i + 1])\n   \
    \         }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmi02u3w2_test.go:27:12: undefined: is_vowel

    /tmp/tmpmi02u3w2_test.go:28:38: undefined: is_vowel

    /tmp/tmpmi02u3w2_test.go:32:37: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074578
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    word = word[::-1] // reverse word\n\n    first := -1\n\
    \    found := -1\n    for index, value := range word {\n        if value == 'a'\
    \ || value == 'e' || value == 'i' || value == 'o' || value == 'u' {\n        \
    \    found = index\n            if first != -1 {\n                break\n    \
    \        }\n        } else {\n            if first == -1 {\n                first\
    \ = index\n            }\n        }\n    }\n\n    if first == -1 || found == -1\
    \ {\n        return \"\"\n    } else {\n        return string(word[found])\n \
    \   }\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcqjueki__test.go:23:17: 2nd index required in 3-index slice

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074577
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = \"aeiouAEIOU\"\n    var rv string = \"\"\n\
    \    var vowel_idx int = -1\n    var vowel_pos int = len(word)\n    for i, l :=\
    \ range word {\n        if vowels[0:5].IndexRune(l) >= 0 {\n            if vowel_idx\
    \ == -1 {\n                vowel_idx = vowels[0:5].IndexRune(l)\n            \
    \    vowel_pos = i\n            } else {\n                if i - vowel_pos > vowel_pos\
    \ {\n                    break\n                }\n                if vowels[0:5].IndexRune(l)\
    \ > vowel_idx {\n                    vowel_idx = vowels[0:5].IndexRune(l)\n  \
    \                  vowel_pos = i\n                }\n            }\n        }\n\
    \    }\n    if vowel_idx == -1 {\n        return rv\n    }\n    return vowels[vowel_idx:vowel_idx+1]\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgu0_5z58_test.go:28:24: vowels[0:5].IndexRune undefined (type string has
    no field or method IndexRune)

    /tmp/tmpgu0_5z58_test.go:30:41: vowels[0:5].IndexRune undefined (type string has
    no field or method IndexRune)

    /tmp/tmpgu0_5z58_test.go:36:32: vowels[0:5].IndexRune undefined (type string has
    no field or method IndexRune)

    /tmp/tmpgu0_5z58_test.go:37:45: vowels[0:5].IndexRune undefined (type string has
    no field or method IndexRune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074578
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true, 'A': true, 'E': true, 'I': true, 'O': true, 'U': true}\n\
    \    rs := []rune(word)\n    for i := len(rs) - 1; i >= 0; i-- {\n        if vowels[rs[i]]\
    \ {\n            if i > 0 && vowels[rs[i - 1]] {\n                continue\n \
    \           }\n            if i < len(rs) - 1 && vowels[rs[i + 1]] {\n       \
    \         continue\n            }\n            return string(rs[i])\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp1l8mg4il_test.go:64: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmp1l8mg4il_test.go:64: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmp1l8mg4il_test.go:64: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp1l8mg4il_test.go:64: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp1l8mg4il_test.go:64:\
    \ expected '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp1l8mg4il_test.go:64: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074578
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var result string\n    previous_was_vowel := false\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        if _, is_vowel := vowels[string(word[i])];\
    \ is_vowel {\n            if !previous_was_vowel {\n                result = string(word[i])\n\
    \                break\n            }\n            previous_was_vowel = true\n\
    \        } else {\n            previous_was_vowel = false\n        }\n    }\n\
    \    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmplvhjz4pv_test.go:71: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmplvhjz4pv_test.go:71: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmplvhjz4pv_test.go:71: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmplvhjz4pv_test.go:71: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmplvhjz4pv_test.go:71: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmplvhjz4pv_test.go:71: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmplvhjz4pv_test.go:71: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmplvhjz4pv_test.go:71:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmplvhjz4pv_test.go:71: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074578
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    consonants := \"bcdfghjklmnpqrstvwxyz\"\n    vowels :=\
    \ \"aeiou\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if strings.Contains(consonants,\
    \ word[i:i+1]) {\n            for j := i - 1; j >= 0; j-- {\n                if\
    \ strings.Contains(vowels, word[j:j+1]) {\n                    return word[j:j+1]\n\
    \                }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphbg25ddb_test.go:26:12: undefined: strings

    /tmp/tmphbg25ddb_test.go:28:20: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074578
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true,\n        'A': true, 'E': true, 'I': true, 'O': true, 'U':\
    \ true}\n    var preConsonant, foundVowel rune\n    for i := len(word) - 1; i\
    \ >= 0; i-- {\n        if vowels[rune(word[i])] {\n            foundVowel = rune(word[i])\n\
    \            if preConsonant != 0 {\n                return string(foundVowel)\n\
    \            }\n        } else {\n            preConsonant = rune(word[i])\n \
    \       }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmplac2sgp3_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmplac2sgp3_test.go:64: expected\
    \ '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmplac2sgp3_test.go:64: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmplac2sgp3_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmplac2sgp3_test.go:64: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n    \
    \    tmplac2sgp3_test.go:64: expected '', got 'A'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074579
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    chars := []rune(word)\n    numChars := len(chars)\n  \
    \  for i := numChars - 1; i > 0; i-- {\n        if isVowel(chars[i]) && !isVowel(chars[i-1])\
    \ {\n            return string(chars[i])\n        }\n    }\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgx8nzqmn_test.go:26:12: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074578
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    fmt.Println(\"Input: \", word)\n    if len(word) < 3 {\n\
    \        return \"\"\n    }\n    vowels := []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\"}\n    for i := 0; i < len(word) - 1; i++ {\n        if is_consonant(word[i])\
    \ && is_consonant(word[i + 1]) {\n            // word has 2 consonants, check\
    \ if there is vowel\n            // in between.\n            for j := i + 1; j\
    \ < len(word); j++ {\n                for _,v := range vowels {\n            \
    \        if string(word[j]) == v {\n                        return string(word[j])\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfd_lfum2_test.go:29:12: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074578
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var closest_vowel string = \"\"\n    var consonant_count\
    \ int = 0\n    var closest_pos int = -1\n    for _, c := range word {\n      \
    \  if !is_vowel(c) {\n            consonant_count++\n        } else {\n      \
    \      if consonant_count >= 2 {\n                closest_vowel = string(c)\n\
    \                break\n            } else {\n                closest_pos = -1\n\
    \            }\n        }\n        closest_pos++\n    }\n    return closest_vowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphimzd118_test.go:27:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074578
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string {\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels\
    \ {\n            if string(word[i]) == v {\n                if i == len(word)\
    \ - 1 {\n                    break\n                }\n                for j :=\
    \ i - 1; j >= 0; j-- {\n                    for _, v := range vowels {\n     \
    \                   if string(word[j]) == v {\n                            break\n\
    \                        }\n                        if j == 0 {\n            \
    \                return string(word[i])\n                        }\n         \
    \           }\n                }\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp3zhmusam_test.go:71: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmp3zhmusam_test.go:71: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n    \
    \    tmp3zhmusam_test.go:71: expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmp3zhmusam_test.go:71: expected '', got 'i'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074579
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels string = \"AEIOUaeiou\"\n    var i int\n  \
    \  var vowel_index int = -1\n    var consonant_index int = -1\n    var result\
    \ string = \"\"\n    for i = len(word) - 1; i >= 0; i-- {\n        if -1 == consonant_index\
    \ && -1 == vowel_index {\n            if strings.Contains(vowels, string(word[i]))\
    \ {\n                vowel_index = i\n            } else {\n                consonant_index\
    \ = i\n            }\n        } else if -1 == consonant_index {\n            if\
    \ strings.Contains(vowels, string(word[i])) {\n                vowel_index = i\n\
    \            } else {\n                consonant_index = i\n                result\
    \ = string(word[vowel_index])\n                break\n            }\n        }\
    \ else if -1 == vowel_index {\n            if strings.Contains(vowels, string(word[i]))\
    \ {\n                vowel_index = i\n                result = string(word[vowel_index])\n\
    \                break\n            } else {\n                consonant_index\
    \ = i\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpixdlav1x_test.go:30:16: undefined: strings

    /tmp/tmpixdlav1x_test.go:36:16: undefined: strings

    /tmp/tmpixdlav1x_test.go:44:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074578
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"AEIOUaeiou\"\n    cons := \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n    var found string\n    var pos int\n\n    for i := len(word) - 1; i >= 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            continue\n\
    \        }\n        if strings.Contains(cons, string(word[i])) {\n           \
    \ found = string(word[i])\n            pos = i\n            break\n        }\n\
    \    }\n\n    if found == \"\" {\n        return \"\"\n    }\n\n    for i := pos\
    \ + 1; i < len(word); i++ {\n        if strings.Contains(vowels, string(word[i]))\
    \ {\n            return string(word[i])\n        }\n    }\n\n    return \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp92jpvqd2_test.go:29:12: undefined: strings

    /tmp/tmp92jpvqd2_test.go:32:12: undefined: strings

    /tmp/tmp92jpvqd2_test.go:44:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074579
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i])\
    \ && is_vowel(word[i-1]) {\n            return string(word[i-1])\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_osxxlcr_test.go:24:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    ret := \"\"\n    first_consonant := true\n    for i :=\
    \ len(word) - 1; i >= 0; i-- {\n        ch := string(word[i])\n        if ch ==\
    \ \"a\" || ch == \"e\" || ch == \"i\" || ch == \"o\" || ch == \"u\" {\n      \
    \      if !first_consonant {\n                ret = ch\n                break\n\
    \            }\n        } else {\n            first_consonant = false\n      \
    \  }\n    }\n    return ret\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpn_dexxxi_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpn_dexxxi_test.go:64: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpn_dexxxi_test.go:64: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpn_dexxxi_test.go:64: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpn_dexxxi_test.go:64: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074579
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    i := len(word) - 1\n    var prev, prevPrev rune\n    for\
    \ ; i >= 0; i-- {\n        if i == len(word) - 1 {\n            prev = rune(word[i])\n\
    \        } else if i == len(word) - 2 {\n            prevPrev = rune(word[i])\n\
    \        } else {\n            prevPrev = prev\n            prev = rune(word[i])\n\
    \        }\n        if prevPrev == 'a' || prevPrev == 'e' || prevPrev == 'i' ||\
    \ prevPrev == 'o' || prevPrev == 'u' ||\n           prevPrev == 'A' || prevPrev\
    \ == 'E' || prevPrev == 'I' || prevPrev == 'O' || prevPrev == 'U' {\n        \
    \    return \"\"\n        }\n        if prev == 'a' || prev == 'e' || prev ==\
    \ 'i' || prev == 'o' || prev == 'u' ||\n           prev == 'A' || prev == 'E'\
    \ || prev == 'I' || prev == 'O' || prev == 'U' {\n            if i == 0 {\n  \
    \              return \"\"\n            }\n            current := rune(word[i\
    \ - 1])\n            if current == 'a' || current == 'e' || current == 'i' ||\
    \ current == 'o' || current == 'u' ||\n               current == 'A' || current\
    \ == 'E' || current == 'I' || current == 'O' || current == 'U' {\n           \
    \     return \"\"\n            }\n            return string(prev)\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp6jemn3ek_test.go:79: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__5 (0.00s)\n        tmp6jemn3ek_test.go:79: expected\
    \ 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmp6jemn3ek_test.go:79: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp6jemn3ek_test.go:79: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmp6jemn3ek_test.go:79:\
    \ expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074579
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    consonants := []rune{'B', 'C', 'D', 'F', 'G', 'H', 'J',\
    \ 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z'}\n    vowels\
    \ := []rune{'A', 'E', 'I', 'O', 'U'}\n    all_letters := append(consonants, vowels...)\n\
    \    l := len(word)\n    for i := range word {\n        for _, c := range consonants\
    \ {\n            if word[i] == c {\n                for j := i + 1; j < l; j++\
    \ {\n                    for _, v := range vowels {\n                        if\
    \ word[j] == v {\n                            return string(word[j])\n       \
    \                 }\n                    }\n                    for _, v := range\
    \ consonants {\n                        if word[j] == v {\n                  \
    \          break\n                        }\n                    }\n         \
    \       }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpybetfhd8_test.go:25:5: all_letters declared but not used

    /tmp/tmpybetfhd8_test.go:29:27: invalid operation: word[i] == c (mismatched types
    byte and rune)

    /tmp/tmpybetfhd8_test.go:32:39: invalid operation: word[j] == v (mismatched types
    byte and rune)

    /tmp/tmpybetfhd8_test.go:37:39: invalid operation: word[j] == v (mismatched types
    byte and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074579
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]int{\"a\": 1, \"e\": 1, \"i\": 1,\
    \ \"o\": 1, \"u\": 1,\n        \"A\": 1, \"E\": 1, \"I\": 1, \"O\": 1, \"U\":\
    \ 1}\n    var lastVowelPos int\n    var lastConsonantPos int\n    for i, v :=\
    \ range word {\n        if _, ok := vowels[string(v)]; ok {\n            lastVowelPos\
    \ = i\n        } else {\n            lastConsonantPos = i\n        }\n       \
    \ if lastVowelPos > lastConsonantPos {\n            return string(word[lastVowelPos])\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpk8l47zfi_test.go:65: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmpk8l47zfi_test.go:65: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmpk8l47zfi_test.go:65: expected '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpk8l47zfi_test.go:65: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpk8l47zfi_test.go:65: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpk8l47zfi_test.go:65: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmpk8l47zfi_test.go:65: expected '', got 'i'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074579
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var closest string\n    closest = \"\"\n    var closestPos int\n    closestPos\
    \ = -1\n    for i := len(word) - 1; i >= 0; i-- {\n        for j := 0; j < len(vowels);\
    \ j++ {\n            if word[i] == vowels[j][0] {\n                if closestPos\
    \ == -1 {\n                    closestPos = i\n                    closest = vowels[j]\n\
    \                } else if i > closestPos {\n                    closestPos =\
    \ i\n                    closest = vowels[j]\n                }\n            }\n\
    \        }\n    }\n    return closest\n}\n\ntype TestData \nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzzeuqo68_test.go:44:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074578
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Your code here\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpysdha206_test.go:24:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074579
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // check the word len\n    // if the len is less than\
    \ 3, return \"\"\n    if len(word) < 3 {\n        return \"\"\n    }\n    // slice\
    \ the string from the end to first vowel\n    // which is the closest vowel from\
    \ the end of the string\n    // loop it\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        // check if it is a vowel\n        if is_vowel(word[i]) {\n     \
    \       // if it is a vowel, return it\n            return string(word[i])\n \
    \       }\n    }\n    // otherwise return \"\"\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppghoe9eu_test.go:33:12: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074579
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    vowelDict\
    \ := map[rune]int{'a':0, 'e':0, 'i':0, 'o':0, 'u':0, 'A':0, 'E':0, 'I':0, 'O':0,\
    \ 'U':0}\n    vowelRune := []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O',\
    \ 'U'}\n    lastConsonant, lastVowel := -1, -1\n    for i := len(word) - 1; i\
    \ >= 0; i-- {\n        if _, ok := vowelDict[rune(word[i])]; ok {\n          \
    \  lastVowel = i\n        } else {\n            if lastVowel != -1 {\n       \
    \         lastConsonant = i\n                break\n            }\n        }\n\
    \    }\n    if lastConsonant == -1 || lastVowel == -1 {\n        return \"\"\n\
    \    }\n    curVowel := rune(word[lastVowel])\n    for _, v := range vowelRune\
    \ {\n        if v == curVowel {\n            return string(v)\n        }\n   \
    \ }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpmeks18fx_test.go:76: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpmeks18fx_test.go:76: expected\
    \ '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n    \
    \    tmpmeks18fx_test.go:76: expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmpmeks18fx_test.go:76: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpmeks18fx_test.go:76:\
    \ expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074580
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"AEIOUaeiou\"\n    var positions []int\n  \
    \  for _, i := range vowels {\n        for j, v := range word {\n            if\
    \ v == i {\n                positions = append(positions, j)\n            }\n\
    \        }\n    }\n    if len(positions) == 0 {\n        return \"\"\n    }\n\
    \    last := len(word) - 1\n    if last - positions[len(positions) - 1] == 1 {\n\
    \        return string(word[positions[len(positions) - 1]])\n    }\n    if positions[0]\
    \ == 0 {\n        return string(word[positions[0]])\n    }\n    return string(word[positions[0]])\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp1ocu6uhc_test.go:70: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmp1ocu6uhc_test.go:70: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmp1ocu6uhc_test.go:70: expected '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp1ocu6uhc_test.go:70: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmp1ocu6uhc_test.go:70: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmp1ocu6uhc_test.go:70: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp1ocu6uhc_test.go:70: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp1ocu6uhc_test.go:70:\
    \ expected 'i', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmp1ocu6uhc_test.go:70: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12\
    \ (0.00s)\n        tmp1ocu6uhc_test.go:70: expected 'o', got 'A'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074581
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = map[rune]bool{'a': true, 'e': true, 'i':\
    \ true, 'o': true, 'u': true,\n        'A': true, 'E': true, 'I': true, 'O': true,\
    \ 'U': true}\n    last_is_vowel := false\n    closest_vowel := \"\"\n    for i:=len(word)-1;\
    \ i>=0; i-- {\n        current_rune := rune(word[i])\n        if vowels[current_rune]\
    \ {\n            if last_is_vowel {\n                continue\n            } else\
    \ {\n                closest_vowel = string(current_rune)\n                last_is_vowel\
    \ = true\n            }\n        } else {\n            if last_is_vowel {\n  \
    \              break\n            }\n        }\n    }\n    return closest_vowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp6vyhiem3_test.go:70: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp6vyhiem3_test.go:70: expected\
    \ '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp6vyhiem3_test.go:70: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp6vyhiem3_test.go:70: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp6vyhiem3_test.go:70: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp6vyhiem3_test.go:70: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp6vyhiem3_test.go:70: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp6vyhiem3_test.go:70:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp6vyhiem3_test.go:70: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660074581
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmphg8cafef_test.go:51: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmphg8cafef_test.go:51: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmphg8cafef_test.go:51: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmphg8cafef_test.go:51: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmphg8cafef_test.go:51:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmphg8cafef_test.go:51: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowelIndex := 0\n    var result string\n    fmt.Println(word)\n\
    \    for index, letter := range word {\n        if letter == 'a' || letter ==\
    \ 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n            vowelIndex\
    \ = index\n            if index == 0 {\n                continue\n           \
    \ } else if index == len(word) - 1 {\n                if word[index - 1] == 'a'\
    \ || word[index - 1] == 'e' || word[index - 1] == 'i' || word[index - 1] == 'o'\
    \ || word[index - 1] == 'u' {\n                    continue\n                }\
    \ else {\n                    result = string(letter)\n                    break\n\
    \                }\n            } else {\n                if word[index - 1] ==\
    \ 'a' || word[index - 1] == 'e' || word[index - 1] == 'i' || word[index - 1] ==\
    \ 'o' || word[index - 1] == 'u' {\n                    continue\n            \
    \    } else {\n                    result = string(letter)\n                 \
    \   break\n                }\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp07sregp5_test.go:23:5: vowelIndex declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074580
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n\t// find the first vowel from the end of the string\n\tindex\
    \ := len(word) - 1\n\tvowels := map[string]bool{\n\t\t\"a\": true,\n\t\t\"e\"\
    : true,\n\t\t\"i\": true,\n\t\t\"o\": true,\n\t\t\"u\": true,\n\t}\n\tfor ; index\
    \ >= 0; index -- {\n\t\tif _, is_vowel := vowels[string(word[index])]; is_vowel\
    \ {\n\t\t\tbreak\n\t\t}\n\t}\n\t// if index <= 0, we don't find any vowel\n\t\
    if index <= 0 {\n\t\treturn \"\"\n\t}\n\t// search back and find a consonant\n\
    \tfor i := index - 1; i >= 0; i -- {\n\t\tif _, is_vowel := vowels[string(word[i])];\
    \ !is_vowel {\n\t\t\treturn string(word[index])\n\t\t}\n\t}\n\treturn \"\"\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmps5n64bo0_test.go:75: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmps5n64bo0_test.go:75: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmps5n64bo0_test.go:75: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmps5n64bo0_test.go:75: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmps5n64bo0_test.go:75:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmps5n64bo0_test.go:75: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074581
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowel rune\n    var consonant rune\n    for idx, l\
    \ := range word {\n        if l == 'a' || l == 'e' || l == 'i' || l == 'o' ||\
    \ l == 'u' {\n            vowel = l\n        } else {\n            consonant =\
    \ l\n        }\n        if idx == len(word) - 1 {\n            return \"\"\n \
    \       }\n        if vowel != 0 && consonant != 0 {\n            if idx == 0\
    \ {\n                if word[idx + 1] == 'a' || word[idx + 1] == 'e' || word[idx\
    \ + 1] == 'i' || word[idx + 1] == 'o' || word[idx + 1] == 'u' {\n            \
    \        return \"\"\n                }\n            } else {\n              \
    \  return string(vowel)\n            }\n        }\n    }\n    return \"\"\n}\n\
    \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp05zjt2qf_test.go:72: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmp05zjt2qf_test.go:72: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmp05zjt2qf_test.go:72: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp05zjt2qf_test.go:72: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmp05zjt2qf_test.go:72: expected\
    \ '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n    \
    \    tmp05zjt2qf_test.go:72: expected 'i', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmp05zjt2qf_test.go:72: expected '', got 'i'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074581
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var (\n        vowels = []string{\"a\", \"e\", \"i\",\
    \ \"o\", \"u\"}\n        distances = make([]int, len(vowels))\n        min_distance\
    \ int\n        closest_vowel string\n    )\n    for i, v := range vowels {\n \
    \       distances[i] = get_distance(word, v)\n    }\n    min_distance = min(distances)\n\
    \    if min_distance == -1 {\n        return \"\"\n    }\n    for i, d := range\
    \ distances {\n        if d == min_distance {\n            closest_vowel = vowels[i]\n\
    \            break\n        }\n    }\n    return closest_vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaq0ahjk8_test.go:30:24: undefined: get_distance

    /tmp/tmpaq0ahjk8_test.go:32:20: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074580
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n\tvar i, j int\n\n\t// try to find the first vowel from the\
    \ end\n\tfor i = len(word) - 1; i >= 0; i-- {\n\t\tif is_vowel(word[i]) {\n\t\t\
    \t// try to find the first consonant before the vowel\n\t\t\tfor j = i-1; j >=\
    \ 0; j-- {\n\t\t\t\tif !is_vowel(word[j]) {\n\t\t\t\t\t// it's OK, return the\
    \ vowel\n\t\t\t\t\treturn string(word[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\t// no consonant\
    \ found before, try to find consonant after this vowel\n\t\t\tfor j = i+1; j <\
    \ len(word); j++ {\n\t\t\t\tif !is_vowel(word[j]) {\n\t\t\t\t\t// it's OK, return\
    \ the vowel\n\t\t\t\t\treturn string(word[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\t// no\
    \ consonant found after, try to find another vowel\n\t\t}\n\t}\n\treturn \"\"\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8pg2gnra_test.go:27:6: undefined: is_vowel

    /tmp/tmp8pg2gnra_test.go:30:9: undefined: is_vowel

    /tmp/tmp8pg2gnra_test.go:37:9: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074580
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowelSet := []rune{'a', 'e', 'i', 'o', 'u'}\n    consonantSet\
    \ := []rune{'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r',\
    \ 's', 't', 'v', 'w', 'x', 'y', 'z'}\n    var res rune\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            res = rune(word[i])\n\
    \            if i < len(word) - 1 && word[i+1] == 'b' || word[i+1] == 'c' || word[i+1]\
    \ == 'd' || word[i+1] == 'f' || word[i+1] == 'g' || word[i+1] == 'h' || word[i+1]\
    \ == 'j' || word[i+1] == 'k' || word[i+1] == 'l' || word[i+1] == 'm' || word[i+1]\
    \ == 'n' || word[i+1] == 'p' || word[i+1] == 'q' || word[i+1] == 'r' || word[i+1]\
    \ == 's' || word[i+1] == 't' || word[i+1] == 'v' || word[i+1] == 'w' || word[i+1]\
    \ == 'x' || word[i+1] == 'y' || word[i+1] == 'z' {\n                if i > 0 &&\
    \ word[i-1] == 'b' || word[i-1] == 'c' || word[i-1] == 'd' || word[i-1] == 'f'\
    \ || word[i-1] == 'g' || word[i-1] == 'h' || word[i-1] == 'j' || word[i-\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3ilnlkb9_test.go:31:6: expected ''('', found TestGet_Closest_Vowel

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074580
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        cur := string(word[i])\n        if vowels[cur] {\n            return\
    \ cur\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpabz84qfe_test.go:58: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpabz84qfe_test.go:58: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpabz84qfe_test.go:58: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpabz84qfe_test.go:58: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpabz84qfe_test.go:58: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpabz84qfe_test.go:58: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpabz84qfe_test.go:58: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpabz84qfe_test.go:58:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpabz84qfe_test.go:58: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074581
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var closest_vowel string = \"\"\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if len(closest_vowel) > 0 {\n            if len(word)\
    \ - 1 == i {\n                return closest_vowel\n            }\n          \
    \  if word[i+1] == 'a' ||\n                word[i+1] == 'e' ||\n             \
    \   word[i+1] == 'i' ||\n                word[i+1] == 'o' ||\n               \
    \ word[i+1] == 'u' {\n                return closest_vowel\n            }\n  \
    \      }\n\n        if word[i] == 'a' ||\n            word[i] == 'e' ||\n    \
    \        word[i] == 'i' ||\n            word[i] == 'o' ||\n            word[i]\
    \ == 'u' {\n            closest_vowel = string(word[i])\n        }\n    }\n  \
    \  return closest_vowel\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpgawvsv7m_test.go:74: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpgawvsv7m_test.go:74: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpgawvsv7m_test.go:74: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpgawvsv7m_test.go:74: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpgawvsv7m_test.go:74: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpgawvsv7m_test.go:74: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpgawvsv7m_test.go:74: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpgawvsv7m_test.go:74:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpgawvsv7m_test.go:74: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074581
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n\t// TODO: implement here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpush3skfw_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpush3skfw_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpush3skfw_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpush3skfw_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpush3skfw_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpush3skfw_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074581
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var is_consonant = func(ch byte) bool {\n        return\
    \ ch != 'a' && ch != 'e' && ch != 'i' && ch != 'o' && ch != 'u'\n    }\n    var\
    \ first_vowel int = -1\n    for i := len(word) - 1; i >= 0; i-- {\n        ch\
    \ := word[i]\n        if is_consonant(ch) {\n            if first_vowel != -1\
    \ {\n                return string(word[first_vowel])\n            }\n       \
    \ } else {\n            if first_vowel == -1 {\n                first_vowel =\
    \ i\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpyh9taa82_test.go:67: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpyh9taa82_test.go:67: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpyh9taa82_test.go:67: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpyh9taa82_test.go:67: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpyh9taa82_test.go:67:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpyh9taa82_test.go:67: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074581
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 2 {\n        return \"\"\n    }\n    var\
    \ is_vowel = func(c rune) bool {\n        return c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u' ||\n               c == 'A' || c == 'E' || c ==\
    \ 'I' || c == 'O' || c == 'U'\n    }\n    i := len(word) - 1\n    var prev rune\n\
    \    for i >= 0 {\n        c := rune(word[i])\n        if is_vowel(c) {\n    \
    \        if is_vowel(prev) {\n                i--\n                continue\n\
    \            }\n            return string(c)\n        }\n        prev = c\n  \
    \      i--\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp6wemmtrg_test.go:72: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp6wemmtrg_test.go:72: expected\
    \ '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp6wemmtrg_test.go:72: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp6wemmtrg_test.go:72: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp6wemmtrg_test.go:72: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp6wemmtrg_test.go:72: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp6wemmtrg_test.go:72: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp6wemmtrg_test.go:72:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp6wemmtrg_test.go:72: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074581
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if word == \"\" {\n        return \"\"\n    }\n    vowels\
    \ := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    last_consonant := \"\"\n\
    \    closest_vowel := \"\"\n    for _, v := range word {\n        if string(v)\
    \ == \"a\" || string(v) == \"e\" || string(v) == \"i\" || string(v) == \"o\" ||\
    \ string(v) == \"u\" {\n            // fmt.Println(\"vowel:\", string(v))\n  \
    \          if last_consonant != \"\" {\n                return string(v)\n   \
    \         }\n        } else {\n            // fmt.Println(\"consonant:\", string(v))\n\
    \            last_consonant = string(v)\n        }\n    }\n    return closest_vowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjv4afs_7_test.go:26:5: vowels declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074581
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    for i:=len(word)-1; i>=0; i--\
    \ {\n        for j:=0; j<len(vowels); j++ {\n            if word[i] == byte(vowels[j])\
    \ {\n                if i+1 == len(word) {\n                    return \"\"\n\
    \                }\n                return string(word[i])\n            }\n  \
    \      }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpt5h4m4f2_test.go:62: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpt5h4m4f2_test.go:62: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmpt5h4m4f2_test.go:62: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpt5h4m4f2_test.go:62: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpt5h4m4f2_test.go:62:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpt5h4m4f2_test.go:62: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074581
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmphg8cafef_test.go:51: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmphg8cafef_test.go:51: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmphg8cafef_test.go:51: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmphg8cafef_test.go:51: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmphg8cafef_test.go:51:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmphg8cafef_test.go:51: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmphg8cafef_test.go:51: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmphg8cafef_test.go:51: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmphg8cafef_test.go:51: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmphg8cafef_test.go:51: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmphg8cafef_test.go:51:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmphg8cafef_test.go:51: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    consonants := []string{\"b\", \"c\", \"d\", \"f\", \"\
    g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"\
    t\", \"v\", \"w\", \"x\", \"z\"}\n    vowels := []string{\"a\", \"e\", \"i\",\
    \ \"o\", \"u\"}\n    closest_vowel := \"\"\n    last_consonant := \"\"\n    is_last_consonant\
    \ := false\n    is_first_vowel := false\n    is_first_consonant := false\n   \
    \ for i := len(word) - 1; i >= 0; i-- {\n        if is_first_vowel == false {\n\
    \            for _, vowel := range vowels {\n                if string(word[i])\
    \ == vowel {\n                    is_first_vowel = true\n                    break\n\
    \                }\n            }\n        }\n        if is_first_consonant ==\
    \ false {\n            for _, consonant := range consonants {\n              \
    \  if string(word[i]) == consonant {\n                    is_first_consonant =\
    \ true\n                    break\n                }\n            }\n        }\n\
    \        if is_first_vowel == true && is_first_consonant == true {\n         \
    \   if is_last_consonant == false {\n                for _, consonant := range\
    \ consonants {\n                    if string(word[i]) == consonant {\n      \
    \                  is_last_consonant = true\n                        last_consonant\
    \ = string(word[i])\n                        break\n                    }\n  \
    \              }\n            } else {\n                for _, vowel := range\
    \ vowels {\n                    if string(word[i]) == vowel {\n              \
    \          closest_vowel = string(word[i])\n                        break\n  \
    \                  }\n                }\n                break\n            }\n\
    \        }\n    }\n    return closest_vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpath23n4k_test.go:26:5: last_consonant declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074581
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    consonants := []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"\
    x\", \"y\", \"z\"}\n    for i:= len(word)-1; i>=0; i-- {\n        for _, v :=\
    \ range vowels {\n            if word[i] == byte(v[0]) {\n                if i+1\
    \ < len(word) {\n                    for _, c := range consonants {\n        \
    \                if word[i+1] == byte(c[0]) {\n                            return\
    \ string(word[i])\n                        }\n                    }\n        \
    \        }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp_t42b3er_test.go:66: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmp_t42b3er_test.go:66: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmp_t42b3er_test.go:66: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp_t42b3er_test.go:66: expected '', got 'i'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074581
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels string = \"AEIOUaeiou\"\n    var (\n      \
    \  flag, found int = 0, 0\n        closest_vowel string = \"\"\n    )\n    //\
    \ find the first vowel, ignore the rest.\n    for i := len(word) - 1; i >= 0;\
    \ i-- {\n        for _, ch := range vowels {\n            if string(ch) == string(word[i])\
    \ {\n                if flag == 0 {\n                    closest_vowel = string(word[i])\n\
    \                    flag = 1\n                }\n                found = 1\n\
    \                break\n            }\n        }\n        if found == 1 {\n  \
    \          break\n        }\n    }\n    return closest_vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpl7suqtd0_test.go:72: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpl7suqtd0_test.go:72: expected\
    \ '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpl7suqtd0_test.go:72: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpl7suqtd0_test.go:72: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpl7suqtd0_test.go:72: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpl7suqtd0_test.go:72: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpl7suqtd0_test.go:72: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpl7suqtd0_test.go:72:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpl7suqtd0_test.go:72: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074581
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    for i := len(word) - 1; i > 0; i-- {\n        c := word[i]\n\
    \        switch c {\n        case 'a', 'e', 'i', 'o', 'u':\n            if word[i-1]\
    \ == 'a' || word[i-1] == 'e' || word[i-1] == 'i' || word[i-1] == 'o' || word[i-1]\
    \ == 'u' {\n                continue\n            }\n            return string(c)\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmph140yqbx_test.go:61: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmph140yqbx_test.go:61: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmph140yqbx_test.go:61: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmph140yqbx_test.go:61: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmph140yqbx_test.go:61:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmph140yqbx_test.go:61: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074581
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    closestVowel := \"\"\n    for\
    \ i, r := range word {\n        if i == 0 {\n            continue\n        }\n\
    \        if closestVowel != \"\" {\n            return closestVowel\n        }\n\
    \        if vowels[r] == -1 {\n            continue\n        }\n        // Found\
    \ a vowel\n        if i < len(word) - 1 {\n            nextR := word[i+1]\n  \
    \          if vowels[nextR] == -1 {\n                closestVowel = string(r)\n\
    \            }\n        }\n    }\n    return closestVowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppeo78v0b_test.go:32:25: -1 (untyped int constant) overflows byte

    /tmp/tmppeo78v0b_test.go:38:33: -1 (untyped int constant) overflows byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074581
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, vowel := range vowels\
    \ {\n            if i > 0 && word[i] == vowel[0] && word[i-1] != vowel[0] {\n\
    \                return vowel\n            }\n        }\n    }\n    return \"\"\
    \n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpbw2ap9uu_test.go:59: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpbw2ap9uu_test.go:59: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpbw2ap9uu_test.go:59: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpbw2ap9uu_test.go:59: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpbw2ap9uu_test.go:59:\
    \ expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmpbw2ap9uu_test.go:59: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12\
    \ (0.00s)\n        tmpbw2ap9uu_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074582
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                if i > 0 && i < len(word) -\
    \ 1 {\n                    if !contains(vowels, string(word[i-1])) && !contains(vowels,\
    \ string(word[i+1])) {\n                        return string(word[i])\n     \
    \               }\n                }\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg6rl80en_test.go:28:25: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074581
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // TODO: implement\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpwxh_ynr1_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpwxh_ynr1_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpwxh_ynr1_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpwxh_ynr1_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpwxh_ynr1_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpwxh_ynr1_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    const vowels = \"aeiou\"\n    var last_consonant rune\n\
    \    is_first_letter := true\n    for i := len(word) - 1; i >= 0; i-- {\n    \
    \    if i == 0 {\n            return \"\"\n        }\n        current_letter :=\
    \ rune(word[i])\n        if current_letter == ' ' {\n            continue\n  \
    \      }\n        if is_first_letter {\n            if contains_vowel(current_letter,\
    \ vowels) {\n                return \"\"\n            }\n            is_first_letter\
    \ = false\n            last_consonant = current_letter\n            continue\n\
    \        }\n        if contains_vowel(current_letter, vowels) {\n            if\
    \ contains_vowel(last_consonant, vowels) {\n                return \"\"\n    \
    \        }\n            return string(current_letter)\n        }\n        last_consonant\
    \ = current_letter\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpojtyh2ie_test.go:35:16: undefined: contains_vowel

    /tmp/tmpojtyh2ie_test.go:42:12: undefined: contains_vowel

    /tmp/tmpojtyh2ie_test.go:43:16: undefined: contains_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074582
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if\
    \ hasConsonant(word[i-1:i]) && hasConsonant(word[i+1:i+2]) {\n            for\
    \ _, v := range vowels {\n                if word[i:i+1] == v {\n            \
    \        result = v\n                    break\n                }\n          \
    \  }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt5_xmu27_test.go:26:12: undefined: hasConsonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074582
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"}\n    var consonantPos = make([]int, 0)\n    var vowelPos\
    \ = make([]int, 0)\n    for i, v := range word {\n        if isVowel(string(v),\
    \ vowels) {\n            vowelPos = append(vowelPos, i)\n        }\n        if\
    \ isConsonant(string(v), consonants) {\n            consonantPos = append(consonantPos,\
    \ i)\n        }\n    }\n    if len(consonantPos) < 2 {\n        return \"\"\n\
    \    }\n    for i, v := range consonantPos {\n        if i != 0 && i != len(consonantPos)\
    \ - 1 {\n            if vowelPos[0] > v && vowelPos[len(vowelPos) - 1] < consonantPos[i\
    \ + 1] {\n                return word[vowelPos[0]:vowelPos[len(vowelPos) - 1]\
    \ + 1]\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptfekb6cc_test.go:28:12: undefined: isVowel

    /tmp/tmptfekb6cc_test.go:31:12: undefined: isConsonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074582
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    const vowels = \"aeiou\"\n    var has_vowel, has_consonant\
    \ bool\n    for i := len(word) - 1; i >= 0; i-- {\n        c := word[i]\n    \
    \    if strings.ContainsRune(vowels, c) {\n            has_vowel = true\n    \
    \    } else {\n            has_consonant = true\n        }\n        if has_vowel\
    \ && has_consonant {\n            return string(c)\n        }\n    }\n    return\
    \ \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkd7agpn6_test.go:27:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074583
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var i, len int\n    var c1, c2, c_temp string\n    var\
    \ vowel_set = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n \
    \       \"i\": true,\n        \"o\": true,\n        \"u\": true,\n        \"A\"\
    : true,\n        \"E\": true,\n        \"I\": true,\n        \"O\": true,\n  \
    \      \"U\": true,\n    }\n    len = len(word)\n    for i = len - 1; i > 0; i--\
    \ {\n        c_temp = string(word[i])\n        if vowel_set[c_temp] {\n      \
    \      c2 = c_temp\n            break\n        }\n    }\n    for i = i - 1; i\
    \ >= 0; i-- {\n        c_temp = string(word[i])\n        if vowel_set[c_temp]\
    \ {\n            c1 = c_temp\n            break\n        }\n    }\n    if vowel_set[c1]\
    \ {\n        return c1\n    } else if vowel_set[c2] {\n        return c2\n   \
    \ } else {\n        return \"\"\n    }\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8o4wek08_test.go:37:11: invalid operation: cannot call non-function len
    (variable of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074583
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    }\n    var closest = \"\"\n    var distance = 0\n    for i := len(word) - 1; i\
    \ >= 0; i-- {\n        for _, v := range vowels {\n            if v == string(word[i])\
    \ {\n                if distance == 0 {\n                    closest = string(word[i])\n\
    \                    distance = 1\n                } else if closest != \"\" &&\
    \ distance < len(word) - i {\n                    closest = string(word[i])\n\
    \                    distance = len(word) - i\n                }\n           \
    \ }\n        }\n    }\n    return closest\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp5elpy3_s_test.go:67: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmp5elpy3_s_test.go:67: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmp5elpy3_s_test.go:67: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp5elpy3_s_test.go:67: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmp5elpy3_s_test.go:67: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmp5elpy3_s_test.go:67: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp5elpy3_s_test.go:67: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp5elpy3_s_test.go:67:\
    \ expected 'i', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmp5elpy3_s_test.go:67: expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074583
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var cons = \"bcdfghjklmnpqrstvwxyz\"\n    var vowels =\
    \ \"aeiou\"\n    var word_in_cons = true\n    var min_distance = len(word)\n \
    \   var min_vowel = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        var\
    \ current_letter = string(word[i])\n        var in_cons = false\n        for j\
    \ := 0; j < len(cons); j++ {\n            if cons[j] == current_letter[0] {\n\
    \                in_cons = true\n                break\n            }\n      \
    \  }\n        if in_cons && !word_in_cons {\n            for j := 0; j < len(vowels);\
    \ j++ {\n                if vowels[j] == current_letter[0] {\n               \
    \     if min_distance > i {\n                        min_distance = i\n      \
    \                  min_vowel = current_letter\n                    }\n       \
    \             break\n                }\n            }\n        }\n        word_in_cons\
    \ = in_cons\n    }\n    return min_vowel\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpg1ol09uj_test.go:78: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpg1ol09uj_test.go:78: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpg1ol09uj_test.go:78: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpg1ol09uj_test.go:78: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpg1ol09uj_test.go:78:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpg1ol09uj_test.go:78: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074583
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    var prev_char string\n    var closest_vowel string\n    var\
    \ found_consonant bool\n    for i := len(word) - 1; i >= 0; i-- {\n        current_char\
    \ := string(word[i])\n        if i == len(word) - 1 {\n            if !vowels[current_char]\
    \ {\n                found_consonant = true\n            }\n        } else {\n\
    \            if found_consonant {\n                if vowels[current_char] {\n\
    \                    closest_vowel = current_char\n                    break\n\
    \                }\n            } else {\n                if !vowels[current_char]\
    \ {\n                    found_consonant = true\n                }\n         \
    \   }\n        }\n        prev_char = current_char\n    }\n    return closest_vowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0u4fefhf_test.go:30:9: prev_char declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074583
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    for i := len(word) - 1; i > 0; i-- {\n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            if word[i-1] != 'a' && word[i-1] != 'e' && word[i-1] != 'i' &&\
    \ word[i-1] != 'o' && word[i-1] != 'u' {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp90ouif0s_test.go:58: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp90ouif0s_test.go:58: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp90ouif0s_test.go:58: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp90ouif0s_test.go:58: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp90ouif0s_test.go:58:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp90ouif0s_test.go:58: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074583
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true, 'A': true, 'E': true, 'I': true, 'O': true, 'U': true}\n\
    \    var offset int\n    for i := len(word) - 1; i >= 0; i-- {\n        if !vowels[rune(word[i])]\
    \ {\n            offset = i + 1\n            break\n        }\n    }\n    if offset\
    \ == 0 {\n        return \"\"\n    }\n    var result rune\n    var min int\n \
    \   for i := offset; i < len(word); i++ {\n        if vowels[rune(word[i])] {\n\
    \            temp := i - offset\n            if min == 0 || temp < min {\n   \
    \             min = temp\n                result = rune(word[i])\n           \
    \ }\n        }\n    }\n    return string(result)\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpiniqx42h_test.go:73: expected 'u', got '\0'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpiniqx42h_test.go:73: expected\
    \ 'u', got '\0'\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n   \
    \     tmpiniqx42h_test.go:73: expected '', got '\0'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3\
    \ (0.00s)\n        tmpiniqx42h_test.go:73: expected '', got '\0'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpiniqx42h_test.go:73: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpiniqx42h_test.go:73: expected 'a', got '\0'\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpiniqx42h_test.go:73: expected 'o', got '\0'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpiniqx42h_test.go:73: expected\
    \ '', got '\0'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n    \
    \    tmpiniqx42h_test.go:73: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmpiniqx42h_test.go:73: expected '', got '\0'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpiniqx42h_test.go:73:\
    \ expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmpiniqx42h_test.go:73: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12\
    \ (0.00s)\n        tmpiniqx42h_test.go:73: expected 'o', got 'e'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074583
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"\
    i\": true, \"o\": true, \"u\": true}\n    words := []rune(word)\n    last_vowel\
    \ := \"\"\n    for i := len(words) - 1; i >= 0; i-- {\n        char := string(words[i])\n\
    \        if vowels[char] {\n            if last_vowel == \"\" {\n            \
    \    last_vowel = char\n            }\n            continue\n        }\n     \
    \   return last_vowel\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpqkctk8z9_test.go:64: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpqkctk8z9_test.go:64: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpqkctk8z9_test.go:64: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmpqkctk8z9_test.go:64: expected 'a', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpqkctk8z9_test.go:64: expected\
    \ 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n     \
    \   tmpqkctk8z9_test.go:64: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpqkctk8z9_test.go:64: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpqkctk8z9_test.go:64:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpqkctk8z9_test.go:64: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074583
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpvi3gi411_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpvi3gi411_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpvi3gi411_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvi3gi411_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    word = word[:len(word)-1]\n \
    \   for i := len(word)-1; i >= 0; i-- {\n        if strings.ContainsRune(vowels,\
    \ rune(word[i])) {\n            return string(word[i])\n        }\n    }\n   \
    \ return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate :=\
    \ get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_zo2w1iu_test.go:26:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074583
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"AEIOU\"\n    word = word[::-1]\n    var found_vowel\
    \ string\n    for i, c := range word {\n        if vowels[0] == c || vowels[1]\
    \ == c || vowels[2] == c || vowels[3] == c || vowels[4] == c {\n            if\
    \ i == 0 {\n                break\n            }\n            if vowels[0] !=\
    \ word[i-1] && vowels[1] != word[i-1] && vowels[2] != word[i-1] && vowels[3] !=\
    \ word[i-1] && vowels[4] != word[i-1] {\n                found_vowel = string(c)\n\
    \                break\n            }\n        }\n    }\n    return found_vowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpesm2uvn7_test.go:24:17: 2nd index required in 3-index slice

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074582
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Write your code here!\n    vowels := []string {\"a\"\
    , \"e\", \"i\", \"o\", \"u\"}\n    vowel_dict := make(map[string]bool)\n    for\
    \ _, vowel := range vowels {\n        vowel_dict[vowel] = true\n    }\n    for\
    \ i:= len(word)-1; i>=0; i-- {\n        if vowel_dict[string(word[i])] && i >\
    \ 0 && !vowel_dict[string(word[i-1])] {\n            return string(word[i])\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp7ekcrm9g_test.go:62: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp7ekcrm9g_test.go:62: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp7ekcrm9g_test.go:62: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp7ekcrm9g_test.go:62: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp7ekcrm9g_test.go:62:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp7ekcrm9g_test.go:62: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074584
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Starting the counter at -1 because the first letter\
    \ is not considered\n    counter := -1\n    for i := 0; i < len(word); i++ {\n\
    \        character := string(word[i])\n        if character == \"a\" || character\
    \ == \"e\" || character == \"i\" || character == \"o\" || character == \"u\" {\n\
    \            counter = 0\n        } else {\n            if counter >= 0 {\n  \
    \              counter++\n            }\n        }\n    }\n    return string(word[len(word)\
    \ - counter - 1])\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpi5zurram_test.go:63: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpi5zurram_test.go:63: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpi5zurram_test.go:63: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpi5zurram_test.go:63: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpi5zurram_test.go:63: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpi5zurram_test.go:63: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpi5zurram_test.go:63: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpi5zurram_test.go:63:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpi5zurram_test.go:63: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074584
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n\tvowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\t\
    vowel_map := make(map[string]int)\n\tfor _, v := range vowels {\n\t\tvowel_map[v]\
    \ = 1\n\t}\n\t\n\tvar found_vowel string\n\tfor i := len(word) - 1; i >= 0; i--\
    \ {\n\t\tc := string(word[i])\n\t\tif _, ok := vowel_map[c]; ok {\n\t\t\tfound_vowel\
    \ = c\n\t\t\tbreak\n\t\t}\n\t}\n\t\n\tif found_vowel == \"\" {\n\t\treturn \"\"\
    \n\t}\n\t\n\tfor i := len(word) - 1; i >= 0; i-- {\n\t\tc := string(word[i])\n\
    \t\tif _, ok := vowel_map[c]; !ok {\n\t\t\tif found_vowel == c {\n\t\t\t\tfound_vowel\
    \ = \"\"\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn found_vowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp9yvheukf_test.go:81: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp9yvheukf_test.go:81: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp9yvheukf_test.go:81: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp9yvheukf_test.go:81: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp9yvheukf_test.go:81: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp9yvheukf_test.go:81: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp9yvheukf_test.go:81: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp9yvheukf_test.go:81:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp9yvheukf_test.go:81: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074584
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var chars = []rune(word)\n    var vowels = map[rune]bool{'a':\
    \ true, 'e': true, 'i': true, 'o': true, 'u': true}\n    var current = 0\n   \
    \ var closest = 0\n    var distance = len(chars)\n    var i = len(chars) - 1\n\
    \    for i >= 0 {\n        if vowels[chars[i]] {\n            current = i\n  \
    \          if current - closest <= distance {\n                distance = current\
    \ - closest\n                break\n            }\n        } else {\n        \
    \    closest = i\n        }\n        i--\n    }\n    if distance == len(chars)\
    \ {\n        return \"\"\n    }\n    return string(chars[current])\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpw_1rbt7x_test.go:72: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpw_1rbt7x_test.go:72: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpw_1rbt7x_test.go:72: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpw_1rbt7x_test.go:72: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpw_1rbt7x_test.go:72: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpw_1rbt7x_test.go:72: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpw_1rbt7x_test.go:72: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpw_1rbt7x_test.go:72:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpw_1rbt7x_test.go:72: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074584
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n\tvar vowels = \"aeiouAEIOU\"\n\tvar consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n\tresult := \"\"\n\twordBytes := []byte(word)\n\twordLen := len(wordBytes)\n\
    \tif wordLen == 1 {\n\t\treturn result\n\t}\n\tfor i := wordLen - 1; i > 0; i--\
    \ {\n\t\tif idx := strings.IndexByte(vowels, wordBytes[i]); idx > -1 {\n\t\t\t\
    if idx := strings.IndexByte(consonants, wordBytes[i-1]); idx > -1 {\n\t\t\t\t\
    result = string(wordBytes[i])\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0tv1j465_test.go:32:13: undefined: strings

    /tmp/tmp0tv1j465_test.go:33:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074583
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    word_len := len(word)\n    for i := word_len - 1; i >\
    \ 0; i-- {\n        if is_vowel(word[i]) {\n            var left int\n       \
    \     for left = i-1; left >= 0; left-- {\n                if is_vowel(word[left])\
    \ {\n                    break\n                }\n            }\n           \
    \ if left < 0 {\n                return string(word[i])\n            }\n     \
    \   }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf7_f6zfs_test.go:25:12: undefined: is_vowel

    /tmp/tmpf7_f6zfs_test.go:28:20: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074583
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]int{\n        \"a\": 0,\n       \
    \ \"e\": 0,\n        \"i\": 0,\n        \"o\": 0,\n        \"u\": 0,\n    }\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if _, exists := vowels[string(word[i])];\
    \ exists {\n            return string(word[i])\n        }\n    }\n    return \"\
    \"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmplqjd282c_test.go:63: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmplqjd282c_test.go:63: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmplqjd282c_test.go:63: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmplqjd282c_test.go:63: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmplqjd282c_test.go:63: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmplqjd282c_test.go:63: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmplqjd282c_test.go:63: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmplqjd282c_test.go:63:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmplqjd282c_test.go:63: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074584
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    index := -1\n    min_distance\
    \ := len(word)\n    for i, c := range word {\n        if strings.IndexByte(vowels,\
    \ byte(c)) != -1 {\n            if i == 0 || i == len(word) - 1 {\n          \
    \      continue\n            }\n            left := strings.IndexByte(vowels,\
    \ word[i-1])\n            right := strings.IndexByte(vowels, word[i+1])\n    \
    \        if left == -1 && right == -1 {\n                if min_distance > i {\n\
    \                    min_distance = i\n                    index = i\n       \
    \         }\n            }\n        }\n    }\n    if index != -1 {\n        return\
    \ string(word[index])\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpass0sr93_test.go:27:12: undefined: strings

    /tmp/tmpass0sr93_test.go:31:21: undefined: strings

    /tmp/tmpass0sr93_test.go:32:22: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074584
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    l := len(word)\n    for i := l - 1; i > 0; i-- {\n   \
    \     if isVowel(word[i]) && !isVowel(word[i-1]) {\n            return string(word[i])\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5k_ume9p_test.go:25:12: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074584
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    var closest_vowel string\n\
    \    var closest_vowel_pos int\n    for i := len(word) - 1; i >= 0; i-- {\n  \
    \      if vowels[i] != 0 {\n            closest_vowel_pos = i\n            closest_vowel\
    \ = string(word[i])\n            break\n        }\n    }\n    for i := closest_vowel_pos\
    \ - 1; i >= 0; i-- {\n        if vowels[i] == 0 {\n            return closest_vowel\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpmwilw3vh_test.go:66: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpmwilw3vh_test.go:66: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpmwilw3vh_test.go:66: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpmwilw3vh_test.go:66: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpmwilw3vh_test.go:66:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpmwilw3vh_test.go:66: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074584
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 3 {\n        return \"\"\n    }\n    vowels\
    \ := map[rune]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'A':\
    \ true, 'E': true, 'I': true, 'O': true, 'U': true}\n    var c1, c2 rune\n   \
    \ var found bool\n    for i := len(word) - 1; i >= 0; i-- {\n        c1, c2 =\
    \ rune(word[i]), c1\n        if vowels[c1] && vowels[c2] {\n            found\
    \ = true\n            break\n        }\n    }\n    if found {\n        return\
    \ string(c1)\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp9kpzgqnf_test.go:67: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp9kpzgqnf_test.go:67: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n     \
    \   tmp9kpzgqnf_test.go:67: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3\
    \ (0.00s)\n        tmp9kpzgqnf_test.go:67: expected '', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__5 (0.00s)\n        tmp9kpzgqnf_test.go:67: expected\
    \ 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n     \
    \   tmp9kpzgqnf_test.go:67: expected 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp9kpzgqnf_test.go:67: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp9kpzgqnf_test.go:67:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmp9kpzgqnf_test.go:67: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12\
    \ (0.00s)\n        tmp9kpzgqnf_test.go:67: expected 'o', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074585
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"AEIOUaeiou\"\n    prevIsVowel := false\n \
    \   var i int\n    for i = len(word) - 1; i >= 0; i-- {\n        if strings.Contains(vowels,\
    \ string(word[i])) {\n            if prevIsVowel {\n                break\n  \
    \          }\n            prevIsVowel = true\n        } else {\n            prevIsVowel\
    \ = false\n        }\n    }\n    if i >= 0 {\n        return string(word[i])\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1mccjt4i_test.go:27:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074585
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    chars := []rune(word)\n    vowels := []rune(\"aeiouAEIOU\"\
    )\n    var vowel rune\n    var distance int\n    for i := len(chars) - 1; i >=\
    \ 0; i-- {\n        if chars[i] == 'a' || chars[i] == 'e' || chars[i] == 'i' ||\
    \ chars[i] == 'o' || chars[i] == 'u' ||\n           chars[i] == 'A' || chars[i]\
    \ == 'E' || chars[i] == 'I' || chars[i] == 'O' || chars[i] == 'U' {\n        \
    \    if vowel == 0 {\n                vowel = chars[i]\n                distance\
    \ = len(chars) - i\n            } else {\n                for j := 0; j < len(vowels);\
    \ j++ {\n                    if vowel == vowels[j] {\n                       \
    \ return string(vowel)\n                    }\n                }\n           \
    \ }\n        } else {\n            if vowel != 0 {\n                if len(chars)\
    \ - i < distance {\n                    vowel = chars[i]\n                   \
    \ distance = len(chars) - i\n                }\n            }\n        }\n   \
    \ }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__1\
    \ (0.00s)\n        tmp4ejjajod_test.go:77: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmp4ejjajod_test.go:77: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n     \
    \   tmp4ejjajod_test.go:77: expected '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp4ejjajod_test.go:77: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__5 (0.00s)\n        tmp4ejjajod_test.go:77: expected\
    \ 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n     \
    \   tmp4ejjajod_test.go:77: expected 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp4ejjajod_test.go:77: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp4ejjajod_test.go:77:\
    \ expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n\
    \        tmp4ejjajod_test.go:77: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12\
    \ (0.00s)\n        tmp4ejjajod_test.go:77: expected 'o', got 'e'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074585
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n\t// TODO: Write your code here\n\treturn \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp9u8l6i8k_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp9u8l6i8k_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmp9u8l6i8k_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmp9u8l6i8k_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp9u8l6i8k_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp9u8l6i8k_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074585
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    return \"\";\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp7425ukmo_test.go:51: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp7425ukmo_test.go:51: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmp7425ukmo_test.go:51: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmp7425ukmo_test.go:51: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp7425ukmo_test.go:51:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp7425ukmo_test.go:51: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074585
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpvi3gi411_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpvi3gi411_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpvi3gi411_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvi3gi411_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowel, pos string\n    l := len(word)\n    for i :=\
    \ l - 1; i >= 0; i-- {\n        if i == 0 {\n            return \"\"\n       \
    \ }\n        v := string(word[i])\n        if v == \"a\" || v == \"e\" || v ==\
    \ \"i\" || v == \"o\" || v == \"u\" {\n            if i - 1 >= 0 {\n         \
    \       p := string(word[i - 1])\n                if p != \"a\" && p != \"e\"\
    \ && p != \"i\" && p != \"o\" && p != \"u\" {\n                    return v\n\
    \                }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpehz1zsqs_test.go:23:9: vowel declared but not used

    /tmp/tmpehz1zsqs_test.go:23:16: pos declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074585
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]bool{\n        \"a\": true,\n   \
    \     \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"u\"\
    : true,\n    }\n    result := \"\"\n    var first_vowel string = \"\"\n    var\
    \ second_vowel string = \"\"\n    //find the first vowel\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        cur_char := string(word[i])\n        if vowels[cur_char]\
    \ {\n            first_vowel = cur_char\n            break\n        }\n    }\n\
    \    //find the second vowel\n    for i := len(word) - 1; i >= 0; i-- {\n    \
    \    cur_char := string(word[i])\n        if vowels[cur_char] {\n            if\
    \ cur_char != first_vowel {\n                second_vowel = cur_char\n       \
    \         break\n            }\n        }\n    }\n    //find the closest vowel\n\
    \    if first_vowel != \"\" && second_vowel != \"\" {\n        first_vowel_idx\
    \ := len(word) - 1 - strings.LastIndex(word, first_vowel)\n        second_vowel_idx\
    \ := len(word) - 1 - strings.LastIndex(word, second_vowel)\n        if first_vowel_idx\
    \ > second_vowel_idx {\n            result = second_vowel\n        } else {\n\
    \            result = first_vowel\n        }\n    }\n    return result\n}\n\n\
    func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1knn1qgd_test.go:53:44: undefined: strings

    /tmp/tmp1knn1qgd_test.go:54:45: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074585
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    cons := map[byte]bool{\n        'b': true, 'c': true,\
    \ 'd': true, 'f': true, 'g': true,\n        'h': true, 'j': true, 'k': true, 'l':\
    \ true, 'm': true,\n        'n': true, 'p': true, 'q': true, 'r': true, 's': true,\n\
    \        't': true, 'v': true, 'w': true, 'x': true, 'y': true, 'z': true,\n \
    \   }\n    vowels := map[byte]bool{\n        'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true,\n    }\n    p := len(word) - 1\n    for ; p >= 0; p--\
    \ {\n        if cons[word[p]] {\n            break\n        }\n    }\n    for\
    \ ; p >= 0; p-- {\n        if vowels[word[p]] {\n            return string(word[p])\n\
    \        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmpz2hmqdpm_test.go:71: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpz2hmqdpm_test.go:71: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmpz2hmqdpm_test.go:71: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmpz2hmqdpm_test.go:71: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpz2hmqdpm_test.go:71: expected\
    \ '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074586
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpvi3gi411_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpvi3gi411_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpvi3gi411_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvi3gi411_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    l := len(word)\n    if l == 0 {\n        return \"\"\n\
    \    }\n    if l == 1 {\n        if word[0] == 'a' || word[0] == 'e' || word[0]\
    \ == 'i' || word[0] == 'o' || word[0] == 'u' {\n            return word\n    \
    \    }\n        return \"\"\n    }\n    for i := l - 1; i > 0; i-- {\n       \
    \ if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i]\
    \ == 'u' {\n            if word[i-1] != 'a' && word[i-1] != 'e' && word[i-1] !=\
    \ 'i' && word[i-1] != 'o' && word[i-1] != 'u' {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpx9aicl2__test.go:68: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpx9aicl2__test.go:68: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpx9aicl2__test.go:68: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpx9aicl2__test.go:68: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpx9aicl2__test.go:68:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpx9aicl2__test.go:68: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074586
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    word_len := len(word)\n    if word_len < 3 {\n       \
    \ return \"\"\n    }\n    for i := word_len - 1; i > 0; i-- {\n        left :=\
    \ word[i-1]\n        if left == 'a' || left == 'e' || left == 'i' || left == 'o'\
    \ || left == 'u' {\n            continue\n        }\n        right := word[i]\n\
    \        if right == 'a' || right == 'e' || right == 'i' || right == 'o' || right\
    \ == 'u' {\n            return string(right)\n        }\n    }\n    return \"\"\
    \n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp21nt_p5g_test.go:65: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmp21nt_p5g_test.go:65: expected\
    \ '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n    \
    \    tmp21nt_p5g_test.go:65: expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmp21nt_p5g_test.go:65: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmp21nt_p5g_test.go:65:\
    \ expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074586
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels string = \"aeiou\"\n    var consonants string\
    \ = \"bcdfghjklmnpqrstvwxyz\"\n    var wordLen int = len(word)\n    var i int\n\
    \    var j int\n\n    for i = wordLen - 1; i >= 0; i-- {\n        for j = 0; j\
    \ < 5; j++ {\n            if word[i] == vowels[j] {\n                return string(word[i])\n\
    \            }\n        }\n    }\n\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5v2tv_g8_test.go:24:9: consonants declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074585
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var prev, curr rune\n    var vowel string\n    var vowelInd\
    \ int\n    for i,r := range word {\n        curr = prev\n        prev = r\n  \
    \      if i == len(word) - 1 {\n            break\n        }\n        if is_vowel(curr)\
    \ && !is_vowel(prev) {\n            vowel = string(curr)\n            vowelInd\
    \ = i\n        }\n    }\n    if is_vowel(curr) && !is_vowel(prev) {\n        vowel\
    \ = string(curr)\n        vowelInd = len(word) - 1\n    }\n    if vowelInd ==\
    \ 0 {\n        return \"\"\n    }\n    for i, r := range word[vowelInd + 1:] {\n\
    \        if is_vowel(r) {\n            return \"\"\n        }\n        if !is_vowel(r)\
    \ && i == len(word[vowelInd + 1:]) - 1 {\n            return vowel\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplbh_28wb_test.go:32:12: undefined: is_vowel

    /tmp/tmplbh_28wb_test.go:37:8: undefined: is_vowel

    /tmp/tmplbh_28wb_test.go:45:12: undefined: is_vowel

    /tmp/tmplbh_28wb_test.go:48:13: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074586
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    current := len(word) - 1\n    for {\n        if word[current] == 'a' || word[current]\
    \ == 'e' || word[current] == 'i' || word[current] == 'o' || word[current] == 'u'\
    \ {\n            return string(word[current])\n        }\n        current--\n\
    \        if current == 0 {\n            return \"\"\n        }\n    }\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6mkvyvf1_test.go:23:5: vowels declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074586
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var consonants = make(map[string]bool)\n    consonants[\"\
    b\"] = true\n    consonants[\"c\"] = true\n    consonants[\"d\"] = true\n    consonants[\"\
    f\"] = true\n    consonants[\"g\"] = true\n    consonants[\"h\"] = true\n    consonants[\"\
    j\"] = true\n    consonants[\"k\"] = true\n    consonants[\"l\"] = true\n    consonants[\"\
    m\"] = true\n    consonants[\"n\"] = true\n    consonants[\"p\"] = true\n    consonants[\"\
    q\"] = true\n    consonants[\"r\"] = true\n    consonants[\"s\"] = true\n    consonants[\"\
    t\"] = true\n    consonants[\"v\"] = true\n    consonants[\"w\"] = true\n    consonants[\"\
    x\"] = true\n    consonants[\"y\"] = true\n    consonants[\"z\"] = true\n\n  \
    \  var vowels = make(map[string]bool)\n    vowels[\"a\"] = true\n    vowels[\"\
    e\"] = true\n    vowels[\"i\"] = true\n    vowels[\"o\"] = true\n    vowels[\"\
    u\"] = true\n\n    var consonant_index int = -1\n    var vowel_index int = -1\n\
    \    var min_index int = -1\n    var min_distance int = len(word)\n\n    for i,\
    \ c := range word {\n        s := string(c)\n        if consonants[s] == true\
    \ {\n            consonant_index = i\n            for j := i + 1; j < len(word);\
    \ j++ {\n                s = string(word[j])\n                if vowels[s] ==\
    \ true {\n                    vowel_index = j\n                    if vowel_index\
    \ - consonant_index < min_distance {\n                        min_distance = vowel_index\
    \ - consonant_index\n                        min_index = vowel_index\n       \
    \             }\n                }\n            }\n        }\n    }\n\n    if\
    \ min_index >= 0 {\n        return string(word[min_index])\n    } else {\n   \
    \     return \"\"\n    }\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmp8b3uqycc_test.go:107: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmp8b3uqycc_test.go:107:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n\
    \        tmp8b3uqycc_test.go:107: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp8b3uqycc_test.go:107: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp8b3uqycc_test.go:107:\
    \ expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074586
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // step 1. scan right to left\n    length := len(word)\n\
    \    if length < 3 {\n        return \"\"\n    }\n    char := word[length-1]\n\
    \    if char != 'a' && char != 'e' && char != 'i' && char != 'o' && char != 'u'\
    \ {\n        return get_closest_vowel(word[:length-1])\n    } else {\n       \
    \ return char\n    }\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvwwzy6_b_test.go:32:16: cannot use char (variable of type byte) as type
    string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074586
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    return \"u\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmplr5m6mx2_test.go:51: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmplr5m6mx2_test.go:51: expected\
    \ '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmplr5m6mx2_test.go:51: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5\
    \ (0.00s)\n        tmplr5m6mx2_test.go:51: expected 'a', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmplr5m6mx2_test.go:51: expected\
    \ 'o', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n    \
    \    tmplr5m6mx2_test.go:51: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8\
    \ (0.00s)\n        tmplr5m6mx2_test.go:51: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmplr5m6mx2_test.go:51: expected\
    \ '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n    \
    \    tmplr5m6mx2_test.go:51: expected 'i', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmplr5m6mx2_test.go:51: expected '', got 'u'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmplr5m6mx2_test.go:51:\
    \ expected 'o', got 'u'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074586
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if word == \"\" {\n        return \"\"\n    }\n    current_vowel_pos\
    \ := -1\n    best_vowel_pos := -1\n    cons_count := 0\n    for pos, char := range\
    \ word {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o'\
    \ || char == 'u' {\n            current_vowel_pos = pos\n            cons_count\
    \ = 0\n        } else {\n            cons_count++\n            if cons_count ==\
    \ 2 {\n                if best_vowel_pos == -1 || (current_vowel_pos > best_vowel_pos\
    \ && current_vowel_pos < pos) {\n                    best_vowel_pos = current_vowel_pos\n\
    \                }\n            }\n        }\n    }\n    if best_vowel_pos ==\
    \ -1 {\n        return \"\"\n    }\n    return string(word[best_vowel_pos])\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmplbj2vdxi_test.go:73: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmplbj2vdxi_test.go:73: expected\
    \ '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmplbj2vdxi_test.go:73: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmplbj2vdxi_test.go:73: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmplbj2vdxi_test.go:73:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmplbj2vdxi_test.go:73: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074586
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) < 2 {\n        return \"\"\n    }\n    vowels\
    \ := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    vowels_uppercase := []string{\"\
    A\", \"E\", \"I\", \"O\", \"U\"}\n    first_consonant := true\n    for i:= len(word)-1;\
    \ i>=0; i-- {\n        if first_consonant {\n            if not_in_slice(word[i:i+1],\
    \ vowels) && not_in_slice(word[i:i+1], vowels_uppercase) {\n                first_consonant\
    \ = false\n            }\n        } else {\n            if not_in_slice(word[i:i+1],\
    \ vowels) && not_in_slice(word[i:i+1], vowels_uppercase) {\n                return\
    \ \"\"\n            } else {\n                return word[i:i+1]\n           \
    \ }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbo186ncb_test.go:31:16: undefined: not_in_slice

    /tmp/tmpbo186ncb_test.go:35:16: undefined: not_in_slice

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074586
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]int{\n        \"a\": 1,\n       \
    \ \"e\": 1,\n        \"i\": 1,\n        \"o\": 1,\n        \"u\": 1,\n       \
    \ \"A\": 1,\n        \"E\": 1,\n        \"I\": 1,\n        \"O\": 1,\n       \
    \ \"U\": 1,\n    }\n    has_vowel := false\n    for _, letter := range word {\n\
    \        if _, ok := vowels[string(letter)]; ok {\n            has_vowel = true\n\
    \            break\n        }\n    }\n    if !has_vowel {\n        return \"\"\
    \n    }\n    for i := len(word) - 1; i >= 0; i-- {\n        _, ok := vowels[string(word[i])]\n\
    \        if ok {\n            if i == len(word) - 1 {\n                return\
    \ \"\"\n            }\n            _, ok = vowels[string(word[i+1])]\n       \
    \     if !ok {\n                return string(word[i])\n            }\n      \
    \  }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmph9dwp1pc_test.go:85: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmph9dwp1pc_test.go:85: expected\
    \ '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmph9dwp1pc_test.go:85: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmph9dwp1pc_test.go:85: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmph9dwp1pc_test.go:85:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmph9dwp1pc_test.go:85: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074586
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // Fill this in.\n    vowels := \"aeiou\"\n    lastConsonant\
    \ := len(word) - 1\n    while lastConsonant >= 0 && !isConsonant(word[lastConsonant])\
    \ {\n        lastConsonant--\n    }\n    if lastConsonant < 0 {\n        return\
    \ \"\"\n    }\n    firstVowel := len(word) - 1\n    while firstVowel >= 0 && !isVowel(word[firstVowel])\
    \ {\n        firstVowel--\n    }\n    if firstVowel <= lastConsonant {\n     \
    \   return \"\"\n    }\n    closestVowel := firstVowel\n    for i := lastConsonant\
    \ + 1; i < firstVowel; i++ {\n        if isVowel(word[i]) && firstVowel - i <\
    \ firstVowel - closestVowel {\n            closestVowel = i\n        }\n    }\n\
    \    return string(word[closestVowel])\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx_jhl93b_test.go:26:11: expected '';'', found lastConsonant

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074585
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := map[string]int{\"a\": 1, \"e\": 1, \"i\": 1,\
    \ \"o\": 1, \"u\": 1, \"A\": 1, \"E\": 1, \"I\": 1, \"O\": 1, \"U\": 1}\n    found_vowel\
    \ := \"\"\n    for pos := len(word) - 1; pos >= 0; pos-- {\n        if _, ok :=\
    \ vowels[string(word[pos])]; ok {\n            found_vowel = string(word[pos])\n\
    \            break\n        }\n    }\n    for pos := len(word) - 1; pos >= 0;\
    \ pos-- {\n        if _, ok := vowels[string(word[pos])]; !ok {\n            if\
    \ found_vowel != \"\" {\n                return found_vowel\n            }\n \
    \       } else {\n            found_vowel = \"\"\n        }\n    }\n    return\
    \ found_vowel\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate :=\
    \ get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp0cnpuokf_test.go:68: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp0cnpuokf_test.go:68: expected\
    \ '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n     \
    \   tmp0cnpuokf_test.go:68: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9\
    \ (0.00s)\n        tmp0cnpuokf_test.go:68: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp0cnpuokf_test.go:68:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp0cnpuokf_test.go:68: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074586
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var closestVowel string\n    vowels := \"AEIOUaeiou\"\n\
    \    const None rune = 0\n\n    var prev rune = None\n    var prevPrev rune =\
    \ None\n    for _, current := range word {\n        if current == prev && current\
    \ == prevPrev {\n            continue\n        }\n\n        if vowels[current]\
    \ {\n            if prev == None || prev == prevPrev {\n                prevPrev\
    \ = prev\n                prev = current\n                continue\n         \
    \   }\n            if closestVowel == \"\" || rune(closestVowel[0]) < current\
    \ {\n                closestVowel = string(current)\n            }\n        }\n\
    \n        prevPrev = prev\n        prev = current\n    }\n\n    return closestVowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy6ck_e4k_test.go:34:12: non-boolean condition in if statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074586
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    var last_vowel string\n    var\
    \ last_consonant bool\n    for _, char := range word {\n        if last_consonant\
    \ && vowels[char] != -1 {\n            return string(char)\n        } else if\
    \ vowels[char] != -1 {\n            last_vowel = string(char)\n            last_consonant\
    \ = false\n        } else {\n            last_consonant = true\n        }\n  \
    \  }\n    return last_vowel\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n\
    \  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0b_ib660_test.go:27:46: -1 (untyped int constant) overflows byte

    /tmp/tmp0b_ib660_test.go:29:35: -1 (untyped int constant) overflows byte

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074586
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // ---\n    if len(word) <= 2 {\n        return \"\"\n\
    \    }\n    for i := len(word) - 2; i >= 0; i-- {\n        if isVowel(word[i])\
    \ {\n            if isConsonant(word[i + 1]) {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp16juphb0_test.go:28:12: undefined: isVowel

    /tmp/tmp16juphb0_test.go:29:16: undefined: isConsonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074587
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if word[i] == v[0] {\n                if i > 0 && i < len(word) -\
    \ 1 {\n                    if word[i-1] != v[0] && word[i+1] != v[0] {\n     \
    \                   return v\n                    }\n                }\n     \
    \       }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp_ii9c26l_test.go:63: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmp_ii9c26l_test.go:63: expected\
    \ '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n    \
    \    tmp_ii9c26l_test.go:63: expected '', got 'i'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074587
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmphg8cafef_test.go:51: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmphg8cafef_test.go:51: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmphg8cafef_test.go:51: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmphg8cafef_test.go:51: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmphg8cafef_test.go:51:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmphg8cafef_test.go:51: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n\t// your code here\n\tfor i := len(word) - 1; i > 0; i--\
    \ {\n\t\tif word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o'\
    \ || word[i] == 'u' {\n\t\t\tif word[i-1] != 'a' && word[i-1] != 'e' && word[i-1]\
    \ != 'i' && word[i-1] != 'o' && word[i-1] != 'u' {\n\t\t\t\treturn string(word[i])\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp7dszk4js_test.go:59: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp7dszk4js_test.go:59: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp7dszk4js_test.go:59: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp7dszk4js_test.go:59: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp7dszk4js_test.go:59:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp7dszk4js_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074587
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    consonants := \"bcdfghjklmnpqrstvwxyz\"\n    vowels :=\
    \ \"aeiou\"\n    closest_vowel := \"\"\n    var i, j int\n    for i, j = len(word)\
    \ - 1, len(word) - 1; i >= 0; i-- {\n        for j >= 0 {\n            if strings.Contains(consonants,\
    \ string(word[j])) {\n                break\n            }\n            j--\n\
    \        }\n        if j < 0 {\n            return \"\"\n        }\n        if\
    \ strings.Contains(vowels, string(word[i])) {\n            if len(word) - 1 -\
    \ i > i - j {\n                closest_vowel = string(word[i])\n             \
    \   break\n            }\n        }\n    }\n    return closest_vowel\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwdij9jtc_test.go:29:16: undefined: strings

    /tmp/tmpwdij9jtc_test.go:37:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074587
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var res string\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if isVowel(word[i]) {\n            res = string(word[i])\n      \
    \      break\n        }\n    }\n    return res\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9d9jxzg0_test.go:25:12: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074587
- exit_code: 0
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // prepend a consonant\n    word = \"a\" + word\n    if\
    \ len(word) < 3 {\n        return \"\"\n    }\n    var closest_vowel string\n\
    \    for i := 1; i < len(word) - 1; i++ {\n        // get the letter\n       \
    \ letter := string(word[i])\n        // check if letter is vowel\n        is_vowel\
    \ := letter == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\"\
    \ || letter == \"u\"\n        if is_vowel {\n            // get left and right\
    \ letters\n            left_letter := string(word[i - 1])\n            right_letter\
    \ := string(word[i + 1])\n            // check if left and right letters are consonants\n\
    \            is_left_consonant := left_letter != \"a\" && left_letter != \"e\"\
    \ && left_letter != \"i\" && left_letter != \"o\" && left_letter != \"u\"\n  \
    \          is_right_consonant := right_letter != \"a\" && right_letter != \"e\"\
    \ && right_letter != \"i\" && right_letter != \"o\" && right_letter != \"u\"\n\
    \            if is_left_consonant && is_right_consonant {\n                //\
    \ save letter if left and right letters are consonants\n                closest_vowel\
    \ = letter\n            }\n        }\n    }\n    return closest_vowel\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074587
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if word == \"\" {\n        return \"\"\n    }\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        if i == 0 && isVowel(word[i]) {\n\
    \            return string(word[i])\n        }\n        if i == len(word) - 1\
    \ && isVowel(word[i]) {\n            return string(word[i])\n        }\n     \
    \   if isVowel(word[i]) && !isVowel(word[i+1]) && !isVowel(word[i-1]) {\n    \
    \        return string(word[i])\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpymx8hzsc_test.go:27:22: undefined: isVowel

    /tmp/tmpymx8hzsc_test.go:30:34: undefined: isVowel

    /tmp/tmpymx8hzsc_test.go:33:12: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074587
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    for i := len(word) - 1; i > 0; i-- {\n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            if word[i-1] != 'a' && word[i-1] != 'e' && word[i-1] != 'i' &&\
    \ word[i-1] != 'o' && word[i-1] != 'u' {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmp90ouif0s_test.go:58: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp90ouif0s_test.go:58: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp90ouif0s_test.go:58: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp90ouif0s_test.go:58: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp90ouif0s_test.go:58:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp90ouif0s_test.go:58: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074583
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    for i := len(word) - 1; i > 0; i-- {\n        ch := word[i]\n\
    \        switch ch {\n        case 'a', 'e', 'i', 'o', 'u':\n            if word[i\
    \ - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' &&\n               word[i\
    \ - 1] != 'o' && word[i - 1] != 'u' {\n                return string(ch)\n   \
    \         }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__4\
    \ (0.00s)\n        tmpjshn1nnd_test.go:61: expected '', got 'i'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpjshn1nnd_test.go:61: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpjshn1nnd_test.go:61: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmpjshn1nnd_test.go:61: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpjshn1nnd_test.go:61:\
    \ expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpjshn1nnd_test.go:61: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074587
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    var result string\n    min_index\
    \ := len(word)\n    for i := len(word) - 1; i >= 0; i-- {\n        c := word[i]\n\
    \        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n    \
    \       c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n         \
    \   last_consonant := false\n            if i == len(word) - 1 {\n           \
    \     last_consonant = true\n            } else {\n                prev_c := word[i\
    \ + 1]\n                if prev_c != 'a' && prev_c != 'e' && prev_c != 'i' &&\
    \ prev_c != 'o' && prev_c != 'u' &&\n                   prev_c != 'A' && prev_c\
    \ != 'E' && prev_c != 'I' && prev_c != 'O' && prev_c != 'U' {\n              \
    \      last_consonant = true\n                }\n            }\n            if\
    \ last_consonant {\n                if i < min_index {\n                    min_index\
    \ = i\n                    result = string(c)\n                }\n           \
    \ }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxvmlxgty_test.go:23:5: vowels declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074587
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var vowels, consonants = []string{\"a\", \"e\", \"i\"\
    , \"o\", \"u\"}, []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"\
    x\", \"y\", \"z\"}\n    var lst_consonant, lst_vowel = word[len(word)-1], \"\"\
    \n    for i := len(word)-2; i >= 0; i-- {\n        if is_letter_in_array(string(word[i]),\
    \ consonants) {\n            lst_consonant = string(word[i])\n            if is_letter_in_array(string(word[i+1]),\
    \ vowels) {\n                lst_vowel = string(word[i+1])\n                break\n\
    \            }\n        }\n    }\n    return lst_vowel\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfeeuhyrf_test.go:26:12: undefined: is_letter_in_array

    /tmp/tmpfeeuhyrf_test.go:27:29: cannot use string(word[i]) (value of type string)
    as type byte in assignment

    /tmp/tmpfeeuhyrf_test.go:28:16: undefined: is_letter_in_array

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074587
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    if len(word) <= 2 {\n        return \"\"\n    }\n    vowels\
    \ := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word) - 2;\
    \ i >= 0; i-- {\n        if is_consonant(word[i]) && is_consonant(word[i+1]) {\n\
    \            for _, vowel := range vowels {\n                if string(word[i+1])\
    \ == vowel {\n                    return vowel\n                }\n          \
    \  }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph7o6g2a6_test.go:28:12: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074587
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if stringInSlice(word[i:i+1],\
    \ vowels) {\n            return word[i:i+1]\n        }\n    }\n    return \"\"\
    \n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1pe_97ut_test.go:25:12: undefined: stringInSlice

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074333
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    offset\
    \ := 0\n    for i := len(word) - 1; i >= 0; i-- {\n        switch word[i] {\n\
    \        case 'a', 'e', 'i', 'o', 'u':\n            offset = i\n        case 'b',\
    \ 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v',\
    \ 'w', 'x', 'y', 'z':\n            fmt.Println(word[offset:i])\n            return\
    \ word[offset:i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnhggkljb_test.go:23:5: vowels declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074587
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiou\"\n    var count int\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if vowels[count] == word[i] {\n            return\
    \ string(word[i])\n        }\n        count++\n    }\n    return \"\"\n}\n\nfunc\
    \ TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\npanic: runtime error: index out\
    \ of range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of\
    \ range [5] with length 5\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513640,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513640, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.get_closest_vowel(...)\n\t/tmp/tmpw0mzs78l_test.go:26\n\
    command-line-arguments_test.TestGet_Closest_Vowel(0x0?)\n\t/tmp/tmpw0mzs78l_test.go:41\
    \ +0x10ac\ntesting.tRunner(0xc000103380, 0x528fa0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074588
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\
    \    len_word := len(word)\n    for i := len_word - 1; i >= 0; i-- {\n       \
    \ if string_in_slice(word[i:i+1], vowels) {\n            for j := i - 1; j >=\
    \ 0; j-- {\n                if string_in_slice(word[j:j+1], vowels) {\n      \
    \              return word[i:i+1]\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp13hu3r6f_test.go:26:12: undefined: string_in_slice

    /tmp/tmp13hu3r6f_test.go:28:20: undefined: string_in_slice

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074587
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    var foundVowel bool\n    var vowels []string\n    var\
    \ result string\n    var index int\n\n    vowels = []string{\"a\", \"e\", \"i\"\
    , \"o\", \"u\"}\n\n    for i := len(word) - 1; i >= 0; i-- {\n        if foundVowel\
    \ {\n            for _, v := range vowels {\n                if word[i] == v[0]\
    \ {\n                    result = string(word[i])\n                    break\n\
    \                }\n            }\n            if result != \"\" {\n         \
    \       break\n            }\n        } else {\n            for _, v := range\
    \ vowels {\n                if word[i] == v[0] {\n                    foundVowel\
    \ = true\n                    index = i\n                    break\n         \
    \       }\n            }\n        }\n    }\n\n    if result == \"\" {\n      \
    \  if index != len(word) - 1 {\n            result = string(word[index + 1])\n\
    \        }\n    }\n\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpnuz6pv8l_test.go:86: expected 'u', got 'o'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpnuz6pv8l_test.go:86: expected\
    \ 'u', got 'l'\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n    \
    \    tmpnuz6pv8l_test.go:86: expected '', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3\
    \ (0.00s)\n        tmpnuz6pv8l_test.go:86: expected '', got 'A'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpnuz6pv8l_test.go:86: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpnuz6pv8l_test.go:86: expected 'a', got 'd'\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpnuz6pv8l_test.go:86: expected 'o', got 's'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpnuz6pv8l_test.go:86: expected\
    \ '', got 'b'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmpnuz6pv8l_test.go:86: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11\
    \ (0.00s)\n        tmpnuz6pv8l_test.go:86: expected '', got 'i'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074588
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    letters := []string{\"A\", \"E\", \"I\", \"O\", \"U\"\
    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if stringInSlice(word[i:i+1],\
    \ letters) {\n            return word[i:i+1]\n        }\n    }\n    return \"\"\
    \n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl4m4pp49_test.go:25:12: undefined: stringInSlice

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074587
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := \"aeiouAEIOU\"\n    nearestVowel := \"\"\n \
    \   nearestVowelIdx := -1\n    //fmt.Println(word)\n    wordLen := len(word)\n\
    \    //fmt.Println(wordLen)\n    for i := wordLen - 1; i >= 0; i-- {\n       \
    \ //fmt.Println(i)\n        if nearestVowelIdx >= 0 {\n            //fmt.Println(\"\
    nearestVowelIdx >= 0\")\n            return string(nearestVowel)\n        }\n\
    \        currentLetter := string(word[i])\n        //fmt.Println(currentLetter)\n\
    \        for j := 0; j < len(vowels); j++ {\n            //fmt.Println(vowels[j])\n\
    \            if string(vowels[j]) == currentLetter {\n                //fmt.Println(\"\
    Current letter matches vowel: \" + currentLetter)\n                // If it is\
    \ a vowel, check if it is the first vowel met, or if it is\n                //\
    \ closer to the end of the word than the previous vowel met\n                if\
    \ nearestVowelIdx == -1 || i < nearestVowelIdx {\n                    //fmt.Println(\"\
    Setting vowel \" + currentLetter + \" at idx \" + string(i))\n               \
    \     nearestVowel = currentLetter\n                    nearestVowelIdx = i\n\
    \                }\n            }\n        }\n    }\n    return nearestVowel\n\
    }\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
    \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
    easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
    bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
    ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\"\
    \ },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual:\
    \ candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"),\
    \ expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2\
    \ (0.00s)\n        tmp50r66alq_test.go:79: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp50r66alq_test.go:79: expected\
    \ '', got 'A'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n     \
    \   tmp50r66alq_test.go:79: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7\
    \ (0.00s)\n        tmp50r66alq_test.go:79: expected '', got 'a'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp50r66alq_test.go:79: expected\
    \ '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n     \
    \   tmp50r66alq_test.go:79: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10\
    \ (0.00s)\n        tmp50r66alq_test.go:79: expected 'i', got 'e'\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp50r66alq_test.go:79:\
    \ expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmp50r66alq_test.go:79: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074588
- exit_code: 2
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    var prev\
    \ rune\n    for i := len(word) - 1; i >= 0; i-- {\n        r := []rune(word)[i]\n\
    \        if is_vowel(r, vowels) {\n            if !is_vowel(prev, vowels) {\n\
    \                return string(r)\n            }\n        }\n        prev = r\n\
    \    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate\
    \ := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"),\
    \ expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n\
    \     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"\
    eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\"\
    \ },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"\
    most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\"\
    \ },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"\
    quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"\
    i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual:\
    \ candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2a6lz1ll_test.go:27:12: undefined: is_vowel

    /tmp/tmp2a6lz1ll_test.go:28:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074588
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T)\
    \ {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"\
    u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual:\
    \ candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected:\
    \ \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual:\
    \ candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected:\
    \ \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual:\
    \ candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"\
    ), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n\
    \     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmphg8cafef_test.go:51: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmphg8cafef_test.go:51: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmphg8cafef_test.go:51: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmphg8cafef_test.go:51: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmphg8cafef_test.go:51:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmphg8cafef_test.go:51: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074576
- exit_code: 1
  program: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You are given a word. Your task is to find the closest vowel that stands\
    \ between \n// two consonants from the right side of the word (case sensitive).\n\
    // Vowels in the beginning and ending doesn't count. Return empty string if you\
    \ didn't\n// find any vowel met the above condition. \n// You may assume that\
    \ the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
    yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
    quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
    \ string) string {\n    // your code here\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t\
    \ *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"\
    full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\"\
    \ },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"\
    ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\"\
    \ },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"\
    ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n\
    \     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"\
    anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\
    \" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'u', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpvi3gi411_test.go:52: expected\
    \ 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n     \
    \   tmpvi3gi411_test.go:52: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6\
    \ (0.00s)\n        tmpvi3gi411_test.go:52: expected 'o', got ''\n    --- FAIL:\
    \ TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpvi3gi411_test.go:52:\
    \ expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n\
    \        tmpvi3gi411_test.go:52: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074329
