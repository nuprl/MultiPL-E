name: HumanEval_25_factorize
language: go_test.go
prompt: "package factorize_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ Return list of prime factors of given integer in the order from smallest to largest.\n\
  // Each of the factors should be listed number of times corresponding to how many\
  \ times it appeares in factorization.\n// Input number should be equal to the product\
  \ of all factors\n// >>> factorize(8)\n// []int{2, 2, 2}\n// >>> factorize(25)\n\
  // []int{5, 5}\n// >>> factorize(70)\n// []int{2, 5, 7}\nfunc factorize(n int) []int\
  \ {\n"
tests: "func TestFactorize(t *testing.T) {\n  candidate := factorize\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate(2), expected: []int{2} },\n     { actual: candidate(4),\
  \ expected: []int{2, 2} },\n     { actual: candidate(8), expected: []int{2, 2, 2}\
  \ },\n     { actual: candidate(57), expected: []int{3, 19} },\n     { actual: candidate(3249),\
  \ expected: []int{3, 3, 19, 19} },\n     { actual: candidate(185193), expected:\
  \ []int{3, 3, 3, 19, 19, 19} },\n     { actual: candidate(20577), expected: []int{3,\
  \ 19, 19, 19} },\n     { actual: candidate(18), expected: []int{2, 3, 3} },\n  \
  \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
  \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    factors := []int{}\n    k := 2\n\n    for n > 1 {\n        if n\
    \ % k == 0 {\n            factors = append(factors, k)\n            n = n / k\n\
    \        } else {\n            k++\n        }\n    }\n\n    return factors\n}\n",
  "    var r []int\n    return r\n}\n", "\tfactors := []int{}\n\t// loop starts from\
    \ 2 because it's the smallest prime number\n\tfor i := 2; i <= n; i++ {\n\t\t\
    if n % i == 0 {\n\t\t\tfactors = append(factors, i)\n\t\t\tn = n / i\n\t\t\ti\
    \ = i - 1\n\t\t}\n\t}\n\treturn factors\n}\n", "    factors := []int{}\n    divisor\
    \ := 2\n    for ; n > 1; {\n        for n % divisor == 0 {\n            factors\
    \ = append(factors, divisor)\n            n /= divisor\n        }\n        divisor++\n\
    \    }\n    return factors\n}\n", "    var result []int\n    for n % 2 == 0 {\n\
    \        result = append(result, 2)\n        n /= 2\n    }\n    for i := 3; i\
    \ * i <= n; i += 2 {\n        for n % i == 0 {\n            result = append(result,\
    \ i)\n            n /= i\n        }\n    }\n    if n > 2 {\n        result = append(result,\
    \ n)\n    }\n    return result\n}\n", "    factors := []int{}\n    number := n\n\
    \    divisor := 2\n    for number > 1 {\n        if number % divisor == 0 {\n\
    \            factors = append(factors, divisor)\n            number = number /\
    \ divisor\n        } else {\n            divisor++\n        }\n    }\n    return\
    \ factors\n}\n", "    factors := []int{}\n    x := 2\n    for x * x <= n {\n \
    \       for n % x == 0 {\n            factors = append(factors, x)\n         \
    \   n /= x\n        }\n        x += 1\n    }\n    if n > 1 {\n        factors\
    \ = append(factors, n)\n    }\n    return factors\n}\n", "    var res []int\n\
    \    for n % 2 == 0 {\n        res = append(res, 2)\n        n /= 2\n    }\n \
    \   for i := 3; i <= n; i += 2 {\n        for n % i == 0 {\n            res =\
    \ append(res, i)\n            n /= i\n        }\n    }\n    return res\n}\n",
  "    factors := []int{}\n    // starts from 2, as 1 is no prime number\n    factor\
    \ := 2\n    for n > 1 {\n        for n % factor == 0 {\n            factors =\
    \ append(factors, factor)\n            n /= factor\n        }\n        factor++\n\
    \    }\n    return factors\n}\n", "    var result []int\n\n    if n == 0 {\n \
    \       return result\n    }\n\n    for n % 2 == 0 {\n        result = append(result,\
    \ 2)\n        n /= 2\n    }\n\n    factor := 3\n    maxFactor := n\n\n    for\
    \ factor < maxFactor {\n        if n % factor == 0 {\n            result = append(result,\
    \ factor)\n            n /= factor\n            maxFactor = n\n        } else\
    \ {\n            factor += 2\n        }\n    }\n\n    result = append(result,\
    \ n)\n\n    return result\n}\n", "\tr := []int{}\n\tf := 2\n\tfor f <= n {\n\t\
    \tif n % f == 0 {\n\t\t\tr = append(r, f)\n\t\t\tn /= f\n\t\t} else {\n\t\t\t\
    f += 1\n\t\t}\n\t}\n\treturn r\n}\n", "    return []int{}\n}\n", "    factors\
    \ := []int{}\n    d := 2\n    for n > 1 {\n        for n % d == 0 {\n        \
    \    factors = append(factors, d)\n            n /= d\n        }\n        d +=\
    \ 1\n    }\n    return factors\n}\n", "    factors := []int{}\n    prime := 2\n\
    \    for n > 1 {\n        for n % prime == 0 {\n            factors = append(factors,\
    \ prime)\n            n /= prime\n        }\n        prime++\n    }\n    return\
    \ factors\n}\n", "\tvar n_factors []int\n\tvar m int\n\tm = n\n\tfor i := 2; i\
    \ <= m; i++ {\n\t\tfor m % i == 0 {\n\t\t\tm = m / i\n\t\t\tn_factors = append(n_factors,\
    \ i)\n\t\t}\n\t}\n\treturn n_factors\n}\n", "    return []int{}\n}\n", "    factors\
    \ := []int{}\n    number := n\n    for number != 1 {\n        for i := 2; i <=\
    \ number; i++ {\n            if number % i == 0 {\n                factors = append(factors,\
    \ i)\n                number = number / i\n                break\n           \
    \ }\n        }\n    }\n    return factors\n}\n", "    factor := 2\n    factors\
    \ := []int{}\n    for n > 1 {\n        for n % factor == 0 {\n            factors\
    \ = append(factors, factor)\n            n /= factor\n        }\n        factor\
    \ += 1\n    }\n    return factors\n}\n", "    factors := []int{}\n    i := 2\n\
    \    for n > 1 {\n        for n % i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n        }\n        i++\n    }\n    return factors\n\
    }\n", "    var factors []int\n    for d := 2; d <= n; d++ {\n        for n % d\
    \ == 0 {\n            factors = append(factors, d)\n            n /= d\n     \
    \   }\n    }\n    return factors\n}\n", "    res := []int{}\n    for n%2 == 0\
    \ {\n        res = append(res, 2)\n        n /= 2\n    }\n    for i := 3; i <=\
    \ n; i+=2 {\n        for n%i == 0 {\n            res = append(res, i)\n      \
    \      n /= i\n        }\n    }\n    return res\n}\n", "    ret := []int{}\n \
    \   // prime := 2\n    for divisor := 2; n > 1; divisor++ {\n        power :=\
    \ 0\n        for n % divisor == 0 {\n            power++\n            n /= divisor\n\
    \        }\n        if power > 0 {\n            for i := 0; i < power; i++ {\n\
    \                ret = append(ret, divisor)\n            }\n        }\n    }\n\
    \    return ret\n}\n", "    res := []int{}\n    for i := 2; i <= n; i++ {\n  \
    \      for n % i == 0 {\n            res = append(res, i)\n            n /= i\n\
    \        }\n    }\n    return res\n}\n", "    var factors []int\n    for n % 2\
    \ == 0 {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for\
    \ i := 3; i * i <= n; i += 2 {\n        for n % i == 0 {\n            factors\
    \ = append(factors, i)\n            n /= i\n        }\n    }\n    if n > 2 {\n\
    \        factors = append(factors, n)\n    }\n    return factors\n}\n", "    var\
    \ factors []int\n    currentNum := n\n    for i := 2; i <= currentNum; i++ {\n\
    \        if currentNum % i == 0 {\n            factors = append(factors, i)\n\
    \            currentNum = currentNum / i\n            i = 1\n        }\n    }\n\
    \    return factors\n}\n", "    if n < 2 {\n        return []int{}\n    }\n  \
    \  factors := []int{}\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n\
    \            return append(factors, i, factorize(n / i)...)\n        }\n    }\n\
    \    return append(factors, n)\n}\n", "    factors := []int{}\n    for f := 2;\
    \ f <= n; f++ {\n        for n % f == 0 {\n            factors = append(factors,\
    \ f)\n            n /= f\n        }\n    }\n    return factors\n}\n", "    if\
    \ n < 2 {\n        return []int{}\n    }\n    res := []int{}\n    for n % 2 ==\
    \ 0 {\n        res = append(res, 2)\n        n /= 2\n    }\n    for i := 3; i\
    \ <= n; i += 2 {\n        for n % i == 0 {\n            res = append(res, i)\n\
    \            n /= i\n        }\n    }\n    return res\n}\n", "    factors := []int{}\n\
    \    for i := 2; i <= n; i++ {\n        for n % i == 0 {\n            factors\
    \ = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n\
    }\n", "    factors := []int{}\n    for i := 2; i <= n; i++ {\n        if n % i\
    \ == 0 {\n            factors = append(factors, i)\n            n = n / i\n  \
    \          i = 1\n        }\n    }\n    return factors\n}\n", "    if n <= 1 {\n\
    \        return []int{}\n    }\n    isPrime := true\n    for i := 2; i < n; i++\
    \ {\n        if n % i == 0 {\n            isPrime = false\n            factors\
    \ := factorize(i)\n            factors = append(factors, factorize(n / i)...)\n\
    \            return factors\n        }\n    }\n    if isPrime {\n        return\
    \ []int{n}\n    }\n    return []int{}\n}\n", "    // TODO: implement the function\n\
    \    return []int{}\n}\n", "    factors := []int{}\n    i := 2\n    for n > 1\
    \ {\n        if n % i == 0 {\n            factors = append(factors, i)\n     \
    \       n /= i\n        } else {\n            i++\n        }\n    }\n    return\
    \ factors\n}\n", "    factors := []int{}\n    // Print the number of 2s that divide\
    \ n\n    for n%2 == 0 {\n        factors = append(factors, 2)\n        n = n /\
    \ 2\n    }\n    // n must be odd at this point.  So we can skip one element (Note\
    \ i = i +2)\n    for i := 3; i <= n; i = i + 2 {\n        // While i divides n,\
    \ append i and divide n\n        for n%i == 0 {\n            factors = append(factors,\
    \ i)\n            n = n / i\n        }\n    }\n    return factors\n}\n", "   \
    \ factors := []int{}\n    for i := 2; i <= n; i++ {\n        for n % i == 0 {\n\
    \            factors = append(factors, i)\n            n /= i\n        }\n   \
    \ }\n    return factors\n}\n", "    r := []int{}\n    for i := 2; i <= n; i++\
    \ {\n        for n % i == 0 {\n            r = append(r, i)\n            n /=\
    \ i\n        }\n    }\n    return r\n}\n", "    factors := []int{}\n    for i\
    \ := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors,\
    \ i)\n            n = n / i\n            i = 1\n        }\n    }\n    return factors\n\
    }\n", "    factors := []int{}\n    factor := 2\n    for n > 1 {\n        for n\
    \ % factor == 0 {\n            factors = append(factors, factor)\n           \
    \ n /= factor\n        }\n        factor += 1\n    }\n    return factors\n}\n",
  "    factors := []int{}\n    for n > 1 {\n        for divisor := 2; divisor <= n;\
    \ divisor++ {\n            if n % divisor == 0 {\n                factors = append(factors,\
    \ divisor)\n                n /= divisor\n                break\n            }\n\
    \        }\n    }\n    return factors\n}\n", "    factors := []int{}\n    f :=\
    \ 2\n    for n > 1 {\n        for ; n % f == 0; n /= f {\n            factors\
    \ = append(factors, f)\n        }\n        f++\n    }\n    return factors\n}\n",
  "    factors := []int{}\n    factor := 2\n    for n > 1 {\n        for n % factor\
    \ == 0 {\n            factors = append(factors, factor)\n            n /= factor\n\
    \        }\n        factor += 1\n    }\n    return factors\n}\n", "    var res\
    \ []int\n    var factors []int\n    if n < 0 {\n        factors = append(factors,\
    \ -1)\n        n = -n\n    }\n    for n % 2 == 0 {\n        factors = append(factors,\
    \ 2)\n        n /= 2\n    }\n    if n > 1 {\n        // left divisors are only\
    \ odd now\n        for x := 3; n > 1; x+=2 {\n            for n % x == 0 {\n \
    \               factors = append(factors, x)\n                n /= x\n       \
    \     }\n        }\n    }\n    for _,x := range factors {\n        res = append(res,\
    \ x)\n    }\n    return res\n}\n", "    factors := []int{}\n    // TODO: implement\
    \ me\n    return factors\n}\n", "    if n < 2 {\n        return []int{}\n    }\n\
    \    factors := []int{}\n    var d int\n    for n > 1 {\n        d = 2\n     \
    \   for n % d != 0 {\n            d += 1\n        }\n        factors = append(factors,\
    \ d)\n        n /= d\n    }\n    return factors\n}\n", "    return []int{}\n}\n",
  "    var nn int = n\n    var divisor int = 2\n    var factors []int\n\n    for nn\
    \ > 1 {\n        if nn % divisor == 0 {\n            factors = append(factors,\
    \ divisor)\n            nn = nn / divisor\n        } else {\n            divisor\
    \ += 1\n        }\n    }\n\n    return factors\n}\n", "    var result []int\n\
    \    var i = 2\n    for n > 1 {\n        for n % i == 0 {\n            result\
    \ = append(result, i)\n            n /= i\n        }\n        i++\n    }\n   \
    \ return result\n}\n", "    if n <= 1 {\n        return []int{}\n    }\n    i\
    \ := 2\n    for ; n%i != 0; i++ {\n    }\n    return append([]int{i}, factorize(n/i)...)\n\
    }\n", "    factors := []int{}\n    for i := 2; i <= n; i++ {\n        for n %\
    \ i == 0 {\n            factors = append(factors, i)\n            n /= i\n   \
    \     }\n    }\n    return factors\n}\n", "    if n <= 0 {\n        return []int{}\n\
    \    }\n    factors := []int{}\n    for n > 1 {\n        if n % 2 == 0 {\n   \
    \         factors = append(factors, 2)\n            n /= 2\n        } else if\
    \ n % 3 == 0 {\n            factors = append(factors, 3)\n            n /= 3\n\
    \        } else if n % 5 == 0 {\n            factors = append(factors, 5)\n  \
    \          n /= 5\n        } else if n % 7 == 0 {\n            factors = append(factors,\
    \ 7)\n            n /= 7\n        } else {\n            // number is not divisible\
    \ by any primes.\n            // no more prime factors\n            factors =\
    \ append(factors, n)\n            break\n        }\n    }\n    return factors\n\
    }\n", "\tresult := []int{}\n\tfor n > 1 {\n\t\tfor i := 2; i <= n; i++ {\n\t\t\
    \tif n % i == 0 {\n\t\t\t\tresult = append(result, i)\n\t\t\t\tn = n / i\n\t\t\
    \t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n", "    factors := []int{}\n\
    \    i := 2\n    for n > 1 {\n        for n % i == 0 {\n            factors =\
    \ append(factors, i)\n            n /= i\n        }\n        i++\n    }\n    return\
    \ factors\n}\n", "    var result []int\n\n    // 2 to infinity is the only possible\
    \ numbers\n    for i := 2; i <= n; i++ {\n        // If the last digit is 0, then\
    \ i is divisible by 10 and therefore also by 2\n        // If the last digit is\
    \ 2, 4, 6, or 8, then i is divisible by 2\n        // If the last digit is 5,\
    \ then i is divisible by 5\n        // If the last two digits are divisible by\
    \ 4, then i is divisible by 4\n        // If the sum of the digits of i is divisible\
    \ by 3, then i is divisible by 3\n        // If the last digit is 0 or 5, then\
    \ i is divisible by 5\n        // If the sum of the digits is divisible by 9,\
    \ then i is divisible by 9\n        // If the sum of the digits is divisible by\
    \ 11, then i is divisible by 11\n        // If i is divisible by a prime p, then\
    \ i is divisible by any power of p\n        for n % i == 0 {\n            result\
    \ = append(result, i)\n            n /= i\n        }\n    }\n\n    return result\n\
    }\n", "    var res []int\n    for _, v := range factors(n) {\n        for i :=\
    \ 0; i < v.power; i++ {\n            res = append(res, v.factor)\n        }\n\
    \    }\n    return res\n}\n", "    factors := []int{}\n    for n % 2 == 0 {\n\
    \        factors = append(factors, 2)\n        n /= 2\n    }\n    for i := 3;\
    \ i <= n; i += 2 {\n        for n % i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n        }\n    }\n    return factors\n}\n", "    var\
    \ result []int\n    if n == 1 {\n        return []int{1}\n    }\n    divisor :=\
    \ 2\n    for n > 1 {\n        if n % divisor == 0 {\n            result = append(result,\
    \ divisor)\n            n = n / divisor\n        } else {\n            divisor\
    \ += 1\n        }\n    }\n    return result\n}\n", "    factors := []int{}\n \
    \   factor := 2\n    for n > 1 {\n        for n % factor == 0 {\n            factors\
    \ = append(factors, factor)\n            n /= factor\n        }\n        factor\
    \ += 1\n    }\n    return factors\n}\n", "    factors := []int{}\n    if n ==\
    \ 1 {\n        return factors\n    }\n    factor := 2\n    for ; n != 1; factor++\
    \ {\n        for n % factor == 0 {\n            factors = append(factors, factor)\n\
    \            n /= factor\n        }\n    }\n    return factors\n}\n", "    var\
    \ factors []int\n    current_factor := 2\n    for n > 1 {\n        if n % current_factor\
    \ == 0 {\n            factors = append(factors, current_factor)\n            n\
    \ = n / current_factor\n        } else {\n            current_factor += 1\n  \
    \      }\n    }\n    return factors\n}\n", "    factors := []int{}\n    for i\
    \ := 2; i <= n; i++ {\n        for n % i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n        }\n    }\n    return factors\n}\n", "    factors\
    \ := []int{}\n    if n < 0 {\n        n = -n\n    }\n    if n == 0 {\n       \
    \ return factors\n    }\n    // find first two factors - they are always present\n\
    \    divisor := 2\n    if n % divisor == 0 {\n        factors = append(factors,\
    \ divisor)\n        n /= divisor\n    }\n    divisor = 3\n    if n % divisor ==\
    \ 0 {\n        factors = append(factors, divisor)\n        n /= divisor\n    }\n\
    \    // find the rest using candidates of form 6i +- 1\n    divisor = 5\n    for\
    \ n != 1 {\n        if n % divisor == 0 {\n            factors = append(factors,\
    \ divisor)\n            n /= divisor\n        } else {\n            divisor +=\
    \ 2\n            if n % divisor == 0 {\n                factors = append(factors,\
    \ divisor)\n                n /= divisor\n            } else {\n             \
    \   divisor += 4\n            }\n        }\n    }\n    return factors\n}\n", " \
    \   result := []int{}\n    d := 2\n    for n > 1 {\n        for n % d == 0 {\n\
    \            result = append(result, d)\n            n /= d\n        }\n     \
    \   d++\n    }\n    return result\n}\n", "    var factors []int\n    for i :=\
    \ 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors,\
    \ i)\n            n = n / i\n            i = i - 1\n        }\n    }\n    return\
    \ factors\n}\n", "\tfactors := []int{}\n\tif n == 1 {\n\t\treturn factors\n\t\
    }\n\tfor i := 2; i <= n; i++ {\n\t\tif n % i == 0 {\n\t\t\tfactors = append(factors,\
    \ i)\n\t\t\tfactors = append(factors, factorize(n/i)...)\n\t\t\tbreak\n\t\t}\n\
    \t}\n\treturn factors\n}\n", "\treturn nil\n}\n", "    if n < 2 {\n        return\
    \ []int{}\n    }\n    factors := []int{}\n    for i := 2; i <= n; i++ {\n    \
    \    for n % i == 0 {\n            factors = append(factors, i)\n            n\
    \ /= i\n        }\n    }\n    return factors\n}\n", "    res := []int{}\n    p\
    \ := 2\n    for n > 1 {\n        if n % p == 0 {\n            res = append(res,\
    \ p)\n            n /= p\n        } else {\n            p++\n        }\n    }\n\
    \    return res\n}\n", "    factors := []int{}\n    i := 2\n    for n > 1 {\n\
    \        for n % i == 0 {\n            factors = append(factors, i)\n        \
    \    n /= i\n        }\n        i++\n    }\n    return factors\n}\n", "    factors\
    \ := []int{}\n    return factors\n}\n", "    var result []int\n    if n == 1 {\n\
    \        return []int{1}\n    }\n    for i := 2; i <= n; i++ {\n        if n %\
    \ i == 0 {\n            result = append(result, i)\n            result = append(result,\
    \ factorize(n / i)...)\n            break\n        }\n    }\n    return result\n\
    }\n", "    factors := []int{}\n    i := 2\n    for n > 1 {\n        for n % i\
    \ == 0 {\n            factors = append(factors, i)\n            n /= i\n     \
    \   }\n        i++\n    }\n    return factors\n}\n", "    factorization := []int{}\n\
    \    for i := 2; i <= n; i++ {\n        for n % i == 0 {\n            factorization\
    \ = append(factorization, i)\n            n /= i\n        }\n    }\n    return\
    \ factorization\n}\n", "    factors := []int{}\n    for n > 1 {\n        for i\
    \ := 2; i <= n; i++ {\n            if n % i == 0 {\n                factors =\
    \ append(factors, i)\n                n = n / i\n                break\n     \
    \       }\n        }\n    }\n    return factors\n}\n", "    var primes []int\n\
    \    var prime int = 2\n    for n > 1 {\n        if n % prime == 0 {\n       \
    \     primes = append(primes, prime)\n            n = n / prime\n        } else\
    \ {\n            prime = nextPrime(prime)\n        }\n    }\n    return primes\n\
    }\n", "    result := []int{}\n    for ; n != 1; {\n        for i := 2; i <= n;\
    \ i++ {\n            if n % i == 0 {\n                result = append(result,\
    \ i)\n                n /= i\n                break\n            }\n        }\n\
    \    }\n    return result\n}\n", "    factors := []int{}\n    for i := 2; i <=\
    \ n; i++ {\n        for n % i == 0 {\n            factors = append(factors, i)\n\
    \            n /= i\n        }\n    }\n    return factors\n}\n", "    // Multiply\
    \ primes to check if we get back to input n.\n    var primes []int\n    // Count\
    \ each time a prime number is factored out.\n    var prime_counts []int\n    divisor\
    \ := 2\n    // Loop until n == 1 to account for all factors.\n    for n > 1 {\n\
    \        // Count how many times the divisor is a factor of n.\n        count\
    \ := 0\n        for n % divisor == 0 {\n            count += 1\n            n\
    \ /= divisor\n        }\n        // If count is 0, this means that the divisor\
    \ is not a factor.\n        if count != 0 {\n            // If it is a factor,\
    \ add the divisor to primes and add the count to prime_counts.\n            primes\
    \ = append(primes, divisor)\n            prime_counts = append(prime_counts, count)\n\
    \        }\n        // Increase divisor until it is no longer a factor, then try\
    \ next number.\n        divisor += 1\n    }\n    // Multiply the primes with their\
    \ counts to get their factorization.\n    var factors []int\n    for i := 0; i\
    \ < len(primes); i++ {\n        for j := 0; j < prime_counts[i]; j++ {\n     \
    \       factors = append(factors, primes[i])\n        }\n    }\n    return factors\n\
    }\n", "    // Write your code here\n    return []int{}\n}\n", "    // slice of\
    \ factors\n    factors := []int{}\n    // slice of primes.\n    // primes: 2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97, ...\n    // prime numbers are numbers that have exactly two\
    \ distinct positive divisors: 1 and itself.\n    primes := []int{2, 3, 5, 7, 11,\
    \ 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\
    \ 97}\n    // index in primes slice\n    primeIndex := 0\n    // indicate if we\
    \ are done\n    done := false\n    // check for primes and add them to factors\
    \ slice until number is 1.\n    for !done {\n        // check current prime\n\
    \        if n % primes[primeIndex] == 0 {\n            // add prime to factors\n\
    \            factors = append(factors, primes[primeIndex])\n            // divide\
    \ n by prime\n            n = n / primes[primeIndex]\n            // if after\
    \ division number is 1, then we are done\n            if n == 1 {\n          \
    \      done = true\n            }\n        } else {\n            // if current\
    \ prime is not a factor, then check next prime\n            if primeIndex < len(primes)\
    \ - 1 {\n                primeIndex++\n            } else {\n                //\
    \ if we have checked all primes, then add number to slice of factors\n       \
    \         factors = append(factors, n)\n                done = true\n        \
    \    }\n        }\n    }\n    return factors\n}\n", "    factors := []int{}\n\
    \    for i := 2; i <= n; i++ {\n        for n % i == 0 {\n            factors\
    \ = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n\
    }\n", "    factors := []int{}\n    for i := 2; i <= n; i++ {\n        for n %\
    \ i == 0 {\n            factors = append(factors, i)\n            n /= i\n   \
    \     }\n    }\n    return factors\n}\n", "    res := []int{}\n    for i := 2;\
    \ i <= n; i++ {\n        for n % i == 0 {\n            res = append(res, i)\n\
    \            n /= i\n        }\n    }\n    return res\n}\n", "    if n <= 1 {\n\
    \        return []int{}\n    }\n    factors := []int{}\n    for n%2 == 0 {\n \
    \       factors = append(factors, 2)\n        n /= 2\n    }\n    for i := 3; i\
    \ <= n; i += 2 {\n        for n%i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n        }\n    }\n    return factors\n}\n", "    factors\
    \ := []int{}\n    for i := 2; i <= n; i++ {\n        for {\n            if n %\
    \ i == 0 {\n                factors = append(factors, i)\n                n /=\
    \ i\n            } else {\n                break\n            }\n        }\n \
    \   }\n    return factors\n}\n", "    facs := []int{}\n    // edge cases\n   \
    \ if n == 0 {\n        return facs\n    }\n    if n == 1 {\n        facs = append(facs,\
    \ 1)\n        return facs\n    }\n    // remove all factors of 2\n    for n %\
    \ 2 == 0 {\n        facs = append(facs, 2)\n        n = n / 2\n    }\n    // now\
    \ n is odd, so we can increment i by 2\n    for i := 3; i <= n; i = i + 2 {\n\
    \        // this while loop removes all factors of i\n        for n % i == 0 {\n\
    \            facs = append(facs, i)\n            n = n / i\n        }\n    }\n\
    \    return facs\n}\n", "    divisor := 2\n    factors := []int{}\n    for divisor\
    \ * divisor <= n {\n        for n % divisor == 0 {\n            factors = append(factors,\
    \ divisor)\n            n /= divisor\n        }\n        divisor += 1\n    }\n\
    \    if n > 1 {\n        factors = append(factors, n)\n    }\n    return factors\n\
    }\n", "    factors := []int{}\n    for i := 2; i <= n; i++ {\n        for n %\
    \ i == 0 {\n            factors = append(factors, i)\n            n /= i\n   \
    \     }\n    }\n    return factors\n}\n", "    factors := []int{}\n    for i :=\
    \ 2; i <= n; i++ {\n        for n % i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n        }\n    }\n    return factors\n}\n", "    if\
    \ n == 1 {\n        return []int{}\n    }\n    for i := 2; i < n; i++ {\n    \
    \    if n % i == 0 {\n            return append(factorize(i), factorize(n / i)...)\n\
    \        }\n    }\n    return []int{n}\n}\n", "\tvar f []int\n\td := 2\n\tfor\
    \ n > 1 {\n\t\tfor n%d == 0 {\n\t\t\tf = append(f, d)\n\t\t\tn /= d\n\t\t}\n\t\
    \td++\n\t}\n\treturn f\n}\n", "    if n <= 0 {\n        return []int{}\n    }\n\
    \    factors := []int{}\n    i := 2\n    for n > 1 {\n        if n % i == 0 {\n\
    \            factors = append(factors, i)\n            n /= i\n        } else\
    \ {\n            i++\n        }\n    }\n    return factors\n}\n", "    factors\
    \ := []int{}\n    divisor := 2\n    for n > 1 {\n        if n % divisor == 0 {\n\
    \            factors = append(factors, divisor)\n            n /= divisor\n  \
    \      } else {\n            divisor += 1\n        }\n    }\n    return factors\n\
    }\n", "    res := []int{}\n    for i := 2; i * i <= n; i++ {\n        for n %\
    \ i == 0 {\n            res = append(res, i)\n            n /= i\n        }\n\
    \    }\n    if n > 1 {\n        res = append(res, n)\n    }\n    return res\n\
    }\n", "    if n <= 0 {\n        return []int{}\n    }\n    i := 2\n    max :=\
    \ n\n    factors := []int{}\n    for i * i <= max {\n        for n % i == 0 {\n\
    \            factors = append(factors, i)\n            n /= i\n        }\n   \
    \     i += 1\n    }\n    if n > 1 {\n        factors = append(factors, n)\n  \
    \  }\n    return factors\n}\n", "    if n == 1 {\n        return []int{}\n   \
    \ }\n    for i := 2; i <= n/2; i++ {\n        if n % i == 0 {\n            return\
    \ append(factorize(i), factorize(n/i)...)\n        }\n    }\n    return []int{n}\n\
    }\n", "    var factors []int\n    factor := 2\n    for ; n > 1; {\n        if\
    \ n % factor == 0 {\n            factors = append(factors, factor)\n         \
    \   n /= factor\n        } else {\n            factor++\n        }\n    }\n  \
    \  return factors\n}\n", "\tvar a, b int = 1, 2\n\tfactors := []int{}\n\tfor ;\
    \ a * b < n; b++ {\n\t\tif n % b == 0 {\n\t\t\ta = n / b\n\t\t\tfactors = append(factors,\
    \ b)\n\t\t\tfmt.Println(factors)\n\t\t}\n\t}\n\tfmt.Println(factors)\n\treturn\
    \ factors\n}\n", "    // put your code here\n    return []int{2, 3, 4}\n}\n",
  "    factors := []int{}\n    for i := 2; i <= n; i++ {\n        for n % i == 0 {\n\
    \            factors = append(factors, i)\n            n /= i\n        }\n   \
    \ }\n    return factors\n}\n", "    var result []int\n    for i := 2; i <= n;\
    \ i++ {\n        for n % i == 0 {\n            result = append(result, i)\n  \
    \          n /= i\n        }\n    }\n    return result\n}\n", "    result := []int{}\n\
    \    prime := 2\n    for n >= prime * prime {\n        if n % prime == 0 {\n \
    \           result = append(result, prime)\n            n /= prime\n        }\
    \ else {\n            prime += 1\n        }\n    }\n    result = append(result,\
    \ n)\n    return result\n}\n", "    if n < 2 {\n        return []int{}\n    }\n\
    \    var factors []int\n    for i := 2; i <= n; i++ {\n        for n % i == 0\
    \ {\n            factors = append(factors, i)\n            n /= i\n        }\n\
    \    }\n    return factors\n}\n", "    if n < 2 {\n        return []int{}\n  \
    \  }\n    factors := []int{}\n    for i := 2; i <= n; i++ {\n        for n % i\
    \ == 0 {\n            factors = append(factors, i)\n            n /= i\n     \
    \   }\n    }\n    return factors\n}\n", "    return []int{}\n}\n", "    if n <=\
    \ 1 {\n        return []int{}\n    }\n    factor := 2\n    if n == 2 {\n     \
    \   return []int{2}\n    }\n    if n % factor == 0 {\n        return append([]int{factor},\
    \ factorize(n / factor)...)\n    }\n    factor++\n    return append([]int{factor},\
    \ factorize(n / factor)...)\n}\n", "    factors := []int{}\n    for i := 2; i\
    \ <= n; i++ {\n        for n % i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n        }\n    }\n    return factors\n}\n", "    if\
    \ n == 1 {\n        return []int{}\n    }\n    divisor := 2\n    for {\n     \
    \   if n % divisor == 0 {\n            return append(factorize(n / divisor), divisor)\n\
    \        }\n        divisor++\n    }\n}\n", "    result := []int{}\n    for i\
    \ := 2; i <= n; i++ {\n        for n % i == 0 {\n            result = append(result,\
    \ i)\n            n /= i\n        }\n    }\n    return result\n}\n", "    return\
    \ nil\n}\n", "    factors := []int{}\n    factor := 2\n    for n > 1 {\n     \
    \   if n % factor == 0 {\n            factors = append(factors, factor)\n    \
    \        n /= factor\n        } else {\n            factor++\n        }\n    }\n\
    \    return factors\n}\n", "    factors := []int{}\n    d := 2\n    for n > 1\
    \ {\n        for n % d == 0 {\n            factors = append(factors, d)\n    \
    \        n /= d\n        }\n        d = d + 1\n        if d * d > n {\n      \
    \      if n > 1 {\n                factors = append(factors, n)\n            }\n\
    \            break\n        }\n    }\n    return factors\n}\n", "    return []int{}\n\
    }\n", "    var factors []int\n    for i := 2; i <= n; i++ {\n        for ;n %\
    \ i == 0; n /= i {\n            factors = append(factors, i)\n        }\n    }\n\
    \    return factors\n}\n", "    //fmt.Printf(\"n=%d\\n\", n)\n    if n < 2 {\n\
    \        return []int{}\n    }\n    rv := []int{}\n    for i := 2; i <= n; i++\
    \ {\n        if n % i == 0 {\n            rv = append(rv, i)\n            rv =\
    \ append(rv, factorize(n / i)...)\n            break\n        }\n    }\n    return\
    \ rv\n}\n", "    var r []int\n    for n % 2 == 0 {\n        r = append(r, 2)\n\
    \        n /= 2\n    }\n    for i := 3; i * i <= n; i += 2 {\n        for n %\
    \ i == 0 {\n            r = append(r, i)\n            n /= i\n        }\n    }\n\
    \    if n > 2 {\n        r = append(r, n)\n    }\n    return r\n}\n", "    var\
    \ factors []int\n    for n%2 == 0 {\n        factors = append(factors, 2)\n  \
    \      n = n / 2\n    }\n    if n > 1 {\n        factors = append(factors, n)\n\
    \    }\n    return factors\n}\n", "    factors := []int{}\n    i := 2\n    for\
    \ n > 1 {\n        for n % i == 0 {\n            factors = append(factors, i)\n\
    \            n /= i\n        }\n        i++\n    }\n    return factors\n}\n",
  "    if n == 1 {\n        return []int{}\n    }\n    for i := 2; i <= n; i++ {\n\
    \        if n % i == 0 {\n            return append([]int{i}, factorize(n / i)...)\n\
    \        }\n    }\n    return []int{}\n}\n", "    return []int{}\n}\n", "    var\
    \ factors []int\n    // Check 2 factor\n    if n % 2 == 0 {\n        factors =\
    \ append(factors, 2)\n        n = n / 2\n    }\n    // Check other factor\n  \
    \  var factor int = 3\n    for n > 1 {\n        if n % factor == 0 {\n       \
    \     factors = append(factors, factor)\n            n = n / factor\n        }\
    \ else {\n            factor = factor + 2\n        }\n    }\n    return factors\n\
    }\n", "    return nil\n}\n", "    factors := []int{}\n    for i := 2; i <= n;\
    \ i++ {\n        for n % i == 0 {\n            factors = append(factors, i)\n\
    \            n /= i\n        }\n    }\n    return factors\n}\n", "    factors\
    \ := []int{}\n    for i := 2; i <= n; i++ {\n        for n % i == 0 {\n      \
    \      factors = append(factors, i)\n            n /= i\n        }\n    }\n  \
    \  return factors\n}\n", "    // Check if the input is a valid number\n    if\
    \ n <= 0 {\n        panic(\"input should be a positive integer\")\n    }\n\n \
    \   // Check if the input is a prime number\n    if isPrime(n) {\n        return\
    \ []int{n}\n    }\n\n    // Output\n    output := []int{}\n\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors of a number.\n    // TODO: create\
    \ a function to get the list of all prime factors", "    factors := []int{}\n\
    \    for ; n%2 == 0; n = n/2 {\n        factors = append(factors, 2)\n    }\n\
    \    for i := 3; i <= n; i += 2 {\n        for ; n%i == 0; n = n/i {\n       \
    \     factors = append(factors, i)\n        }\n    }\n    return factors\n}\n",
  "    res := []int{}\n    divisor := 2\n    for n > 1 {\n        for n % divisor\
    \ == 0 {\n            res = append(res, divisor)\n            n /= divisor\n \
    \       }\n        divisor++\n    }\n    return res\n}\n", "    factors := []int{}\n\
    \    for i := 2; i <= n; i++ {\n        for n % i == 0 {\n            factors\
    \ = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n\
    }\n", "    factors := []int{}\n    d := 2\n    for n > 1 {\n        for n % d\
    \ == 0 {\n            factors = append(factors, d)\n            n /= d\n     \
    \   }\n        d = d + 1\n        if d * d > n {\n            if n > 1 {\n   \
    \             factors = append(factors, n)\n            }\n            break\n\
    \        }\n    }\n    return factors\n}\n", "    if n == 1 {\n        return\
    \ []int{}\n    }\n    i := 2\n    for ; i <= n; i++ {\n        if n % i == 0 {\n\
    \            break\n        }\n    }\n    return append([]int{i}, factorize(n\
    \ / i)...)\n}\n", "    var factors []int\n    for i := 2; i * i <= n; i++ {\n\
    \        for ; n % i == 0; n /= i {\n            factors = append(factors, i)\n\
    \        }\n    }\n    if n > 1 {\n        factors = append(factors, n)\n    }\n\
    \    return factors\n}\n", "    factors := []int{}\n    i := 2\n    for i <= n\
    \ {\n        if n % i == 0 {\n            factors = append(factors, i)\n     \
    \       n = n / i\n        } else {\n            i += 1\n        }\n    }\n  \
    \  return factors\n}\n", "    var factors []int\n    if n < 2 {\n        return\
    \ factors\n    }\n    var i int = 2\n    for n > 1 {\n        for n % i == 0 {\n\
    \            factors = append(factors, i)\n            n /= i\n        }\n   \
    \     i++\n    }\n    return factors\n}\n", "    factors := []int{}\n    i :=\
    \ 2\n    for n > 1 {\n        if n % i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n        } else {\n            i++\n        }\n    }\n\
    \    return factors\n}\n", "    factors := []int{}\n    d := 2\n    for n > 1\
    \ {\n        for n % d == 0 {\n            factors = append(factors, d)\n    \
    \        n /= d\n        }\n        d += 1\n    }\n    return factors\n}\n", " \
    \   var res []int\n    for n % 2 == 0 {\n        res = append(res, 2)\n      \
    \  n /= 2\n    }\n    i := 3\n    for ; n > 1; i += 2 {\n        for n % i ==\
    \ 0 {\n            res = append(res, i)\n            n /= i\n        }\n    }\n\
    \    return res\n}\n", "    if n <= 0 {\n        panic(\"Factorize for negative\
    \ numbers is not defined\")\n    }\n\n    factors := make([]int, 0)\n    for i\
    \ := 2; i < n; i++ {\n        if n % i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n            i = 1\n        }\n    }\n    factors = append(factors,\
    \ n)\n    return factors\n}\n", "    factors := []int{}\n    prime := 2\n    for\
    \ n > 1 {\n        for n % prime == 0 {\n            factors = append(factors,\
    \ prime)\n            n /= prime\n        }\n        prime += 1\n    }\n    return\
    \ factors\n}\n", "    factors := []int{}\n    for n % 2 == 0 {\n        factors\
    \ = append(factors, 2)\n        n /= 2\n    }\n    for i := 3; i * i <= n; i +=\
    \ 2 {\n        for n % i == 0 {\n            factors = append(factors, i)\n  \
    \          n /= i\n        }\n    }\n    if n > 2 {\n        factors = append(factors,\
    \ n)\n    }\n    return factors\n}\n", "    out := []int{}\n    for {\n      \
    \  if n%2 == 0 {\n            out = append(out, 2)\n            n /= 2\n     \
    \   } else {\n            break\n        }\n    }\n    for i := 3; i < n+1; i+=2\
    \ {\n        for {\n            if n%i == 0 {\n                out = append(out,\
    \ i)\n                n /= i\n            } else {\n                break\n  \
    \          }\n        }\n    }\n    return out\n}\n", "    // \u0432\u0435\u0440\
    \u043D\u0443\u0442\u044C \u043F\u0440\u043E\u0441\u0442\u044B\u0435 \u043C\u043D\
    \u043E\u0436\u0438\u0442\u0435\u043B\u0438 \u0447\u0438\u0441\u043B\u0430 n\n\
    \    var f []int\n    for i := 2; i <= n; i++ {\n        for n % i == 0 {\n  \
    \          f = append(f, i)\n            n /= i\n        }\n    }\n    return\
    \ f\n}\n", "    // Insert your code here.\n    return []int{}\n}\n", "    if n\
    \ <= 1 {\n        return []int{}\n    }\n    factors := []int{}\n    i := 2\n\
    \    for n > 1 {\n        if n % i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n        } else {\n            i++\n        }\n    }\n\
    \    return factors\n}\n", "    p := make([]int, 0)\n    for i := 2; i < n; i++\
    \ {\n        for n % i == 0 {\n            p = append(p, i)\n            n /=\
    \ i\n        }\n    }\n    return p\n}\n", "    var factors []int\n    for i :=\
    \ 2; i <= n; i++ {\n        for n % i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n        }\n    }\n    return factors\n}\n", "    factors\
    \ := []int{}\n    d := 2\n    for n > 1 {\n        for n % d == 0 {\n        \
    \    factors = append(factors, d)\n            n /= d\n        }\n        d +=\
    \ 1\n    }\n    return factors\n}\n", "    var result []int\n    divider := 2\n\
    \    for n > 1 {\n        if n % divider == 0 {\n            result = append(result,\
    \ divider)\n            n /= divider\n        } else {\n            divider++\n\
    \        }\n    }\n    return result\n}\n", "    primes := []int{2, 3, 5, 7, 11,\
    \ 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\
    \ 97}\n    factors := []int{}\n    for _, prime := range primes {\n        if\
    \ n == 1 {\n            break\n        }\n        if n % prime == 0 {\n      \
    \      factors = append(factors, prime)\n            n = n / prime\n        }\n\
    \    }\n    return factors\n}\n", "\tfactor := []int{}\n\tfor ; n > 1; {\n\t\t\
    for i := 2; i <= n; i++ {\n\t\t\tif n % i == 0 {\n\t\t\t\tfactor = append(factor,\
    \ i)\n\t\t\t\tn = n / i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn factor\n\
    }\n", "    if n < 2 {\n        return []int{}\n    }\n    res := []int{}\n   \
    \ d := 2\n    for n > 1 {\n        for n % d == 0 {\n            res = append(res,\
    \ d)\n            n /= d\n        }\n        d += 1\n    }\n    return res\n}\n",
  "    return factorizeRec(n, 2)\n}\n", "    prime := 2\n    factors := []int{}\n\
    \    for n > 1 {\n        if n % prime == 0 {\n            factors = append(factors,\
    \ prime)\n            n /= prime\n        } else {\n            prime += 1\n \
    \       }\n    }\n    return factors\n}\n", "    res := []int{}\n    for i :=\
    \ 2; i <= n; i++ {\n        for n % i == 0 {\n            res = append(res, i)\n\
    \            n /= i\n        }\n    }\n    return res\n}\n", "    factors := []int{}\n\
    \    for i := 2; i <= n; i++ {\n        for n % i == 0 {\n            factors\
    \ = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n\
    }\n", "    var primes []int\n    var pl []int\n    var i, v int\n\n    if n ==\
    \ 1 {\n        return []int{}\n    }\n\n    i = 2\n    v = n\n    for v >= i {\n\
    \        if v % i == 0 {\n            pl = append(pl, i)\n            v = v /\
    \ i\n        } else {\n            i++\n        }\n    }\n\n    for i = 0; i <\
    \ len(pl); i++ {\n        for j := i; j < len(pl); j++ {\n            if pl[i]\
    \ > pl[j] {\n                primes = append(primes, pl[j])\n            } else\
    \ {\n                primes = append(primes, pl[i])\n            }\n        }\n\
    \    }\n\n    // for i = 0; i < len(pl); i++ {\n    //     for j := i; j < len(pl);\
    \ j++ {\n    //         if pl[i] == pl[j] {\n    //             pl[i] = 0\n  \
    \  //         }\n    //     }\n    // }\n\n    // for i = 0; i < len(pl); i++\
    \ {\n    //     if pl[i] != 0 {\n    //         primes = append(primes, pl[i])\n\
    \    //     }\n    // }\n\n    return primes\n}\n", "    // Algorithm:\n    //\
    \ 1. start with the smallest prime and divide it out of the number\n    // 2.\
    \ continue dividing out by the next prime until can't divide anymore\n    // 3.\
    \ repeat 1-2 until number is 1\n    primes := []int{2, 3, 5, 7, 11, 13, 17, 19,\
    \ 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n    result\
    \ := []int{}\n    for n > 1 {\n        for _, p := range primes {\n          \
    \  if n % p == 0 {\n                result = append(result, p)\n             \
    \   n = n / p\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n", "    if n <= 0 {\n        panic(\"invalid input: \" + string(n))\n\
    \    }\n\n    if n == 1 {\n        return []int{}\n    }\n\n    return append(factorize(n\
    \ / 2), 2)\n}\n", "    var factors []int\n    for i := 2; i <= n; i++ {\n    \
    \    for n % i == 0 {\n            factors = append(factors, i)\n            n\
    \ /= i\n        }\n    }\n    return factors\n}\n", "    var result []int\n  \
    \  x := n\n    for x > 1 {\n        for i := 2; i <= x; i++ {\n            if\
    \ x % i == 0 {\n                result = append(result, i)\n                x\
    \ = x / i\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n", "    f := make([]int, 0)\n    i := 2\n    for n > 1 {\n      \
    \  for n % i == 0 {\n            f = append(f, i)\n            n /= i\n      \
    \  }\n        i++\n    }\n    return f\n}\n", "    factors := []int{}\n    for\
    \ i := 2; i <= n; i++ {\n        for n % i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n        }\n    }\n    return factors\n}\n", "    if\
    \ n <= 0 {\n        return []int{}\n    }\n    factors := []int{}\n    p := 2\n\
    \    for p * p <= n {\n        if n % p == 0 {\n            factors = append(factors,\
    \ p)\n            n /= p\n        } else {\n            p += 1\n        }\n  \
    \  }\n    factors = append(factors, n)\n    return factors\n}\n", "    factors\
    \ := []int{}\n    if n < 2 {\n        return factors\n    }\n    div := 2\n  \
    \  for {\n        if n == 1 {\n            break\n        }\n        if n % div\
    \ == 0 {\n            factors = append(factors, div)\n            n = n / div\n\
    \        } else {\n            div += 1\n        }\n    }\n    return factors\n\
    }\n", "    var factors []int\n    if n > 1 {\n        factors = append(factors,\
    \ 2)\n        for n%2 == 0 {\n            n /= 2\n        }\n        for i :=\
    \ 3; i <= n; i += 2 {\n            if n%i == 0 {\n                factors = append(factors,\
    \ i)\n                for n%i == 0 {\n                    n /= i\n           \
    \     }\n            }\n        }\n    }\n    return factors\n}\n", "    factors\
    \ := []int{}\n    for n % 2 == 0 {\n        factors = append(factors, 2)\n   \
    \     n /= 2\n    }\n    for i := 3; i*i <= n; i += 2 {\n        for n % i ==\
    \ 0 {\n            factors = append(factors, i)\n            n /= i\n        }\n\
    \    }\n    if n > 2 {\n        factors = append(factors, n)\n    }\n    return\
    \ factors\n}\n", "    factors := []int{}\n    maxFactor := int(n/2) + 1\n\n  \
    \  for i := 2; i < maxFactor; i++ {\n        for n % i == 0 {\n            factors\
    \ = append(factors, i)\n            n = n / i\n        }\n    }\n\n    return\
    \ factors\n}\n", "    var factors []int\n    var f int\n    for n > 1 {\n    \
    \    f = 2\n        for n % f != 0 {\n            f++\n        }\n        factors\
    \ = append(factors, f)\n        n /= f\n    }\n    return factors\n}\n", "   \
    \ var factors []int\n    for i := 2; i <= n; i++ {\n        if n % i == 0 {\n\
    \            factors = append(factors, i)\n            n = n / i\n           \
    \ i = 1\n        }\n    }\n    return factors\n}\n", "    factors := []int{}\n\
    \    // You can make a slice of slices (for example [[1, 2], [3, 4]]) by putting\
    \ a slice in the first position,\n    // but when you append something it will\
    \ not be put inside the slice but just appended to the slice slice\n    // >>>\
    \ a := []int{1, 2}\n    // >>> b := [][]int{a}\n    // >>> b\n    // [[1, 2]]\n\
    \    // >>> b = append(b, a)\n    // >>> b\n    // [[1, 2], [1, 2]]\n    for i\
    \ := 2; i <= n; i++ {\n        if n % i == 0 {\n            factors = append(factors,\
    \ i)\n            j := i\n            for j > 1 {\n                if n % j ==\
    \ 0 {\n                    factors = append(factors, j)\n                    j--\n\
    \                } else {\n                    break\n                }\n    \
    \        }\n        }\n    }\n    return factors\n}\n", "    return []int{}\n\
    }\n", "    var divider int = 2\n    var factors []int\n    for {\n        if n\
    \ <= 1 {\n            break\n        }\n        if n % divider == 0 {\n      \
    \      factors = append(factors, divider)\n            n = n / divider\n     \
    \   } else {\n            divider += 1\n        }\n    }\n    return factors\n\
    }\n", "    // lazy approach\n    var result []int\n    for i := 2; i <= n; i++\
    \ {\n        for n % i == 0 {\n            result = append(result, i)\n      \
    \      n /= i\n        }\n    }\n    return result\n}\n", "    factors := []int{}\n\
    \    // find first prime factor\n    factor := 2\n    for {\n        if n % factor\
    \ == 0 {\n            factors = append(factors, factor)\n            n = n / factor\n\
    \        } else {\n            factor++\n        }\n        if n == 1 {\n    \
    \        break\n        }\n    }\n    return factors\n}\n", "    factors := []int{}\n\
    \    for i := 2; i <= n; i++ {\n        for n % i == 0 {\n            factors\
    \ = append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n\
    }\n", "    m := n\n    factors := []int{}\n    for i := 2; m > 1; i++ {\n    \
    \    for m % i == 0 {\n            factors = append(factors, i)\n            m\
    \ /= i\n        }\n    }\n    return factors\n}\n", "    factors := []int{}\n\
    \    factor := 2\n    for n > 1 {\n        for n % factor == 0 {\n           \
    \ factors = append(factors, factor)\n            n /= factor\n        }\n    \
    \    factor += 1\n    }\n    return factors\n}\n", "    factors := []int{}\n \
    \   for i := 2; i <= n; i++ {\n        for n % i == 0 {\n            factors =\
    \ append(factors, i)\n            n /= i\n        }\n    }\n    return factors\n\
    }\n", "    var res []int\n    for n % 2 == 0 {\n        res = append(res, 2)\n\
    \        n /= 2\n    }\n    for i := 3; i*i <= n; i += 2 {\n        for n % i\
    \ == 0 {\n            res = append(res, i)\n            n /= i\n        }\n  \
    \  }\n    if n > 2 {\n        res = append(res, n)\n    }\n    return res\n}\n",
  "    factors := []int{}\n    q := n\n    for i := 2; i <= q; i++ {\n        if q\
    \ % i == 0 {\n            factors = append(factors, i)\n            q = q / i\n\
    \            i = 1\n        }\n    }\n    return factors\n}\n", "    // your code\
    \ here\n    return []int{}\n}\n", "    factors := []int{}\n    for i := 2; i <=\
    \ n; i++ {\n        // fmt.Println(i)\n        for ; n % i == 0; n /= i {\n  \
    \          factors = append(factors, i)\n        }\n    }\n    return factors\n\
    }\n", "    var factors []int\n    for i := 2; i <= n; i++ {\n        for ; n %\
    \ i == 0; n /= i {\n            factors = append(factors, i)\n        }\n    }\n\
    \    return factors\n}\n", "    factors := []int{}\n    for n % 2 == 0 {\n   \
    \     factors = append(factors, 2)\n        n /= 2\n    }\n    for i := 3; i <=\
    \ n; i += 2 {\n        for n % i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n        }\n    }\n    return factors\n}\n", "    out\
    \ := []int{}\n    var f int\n    for n % 2 == 0 {\n        f = 2\n        out\
    \ = append(out, f)\n        n = n / f\n    }\n    for i := 3; i < n; i += 2 {\n\
    \        for n % i == 0 {\n            f = i\n            out = append(out, f)\n\
    \            n = n / f\n        }\n    }\n    if n > 2 {\n        out = append(out,\
    \ n)\n    }\n    return out\n}\n", "    factors := []int{}\n    for n % 2 == 0\
    \ {\n        factors = append(factors, 2)\n        n /= 2\n    }\n    for i :=\
    \ 3; i*i <= n; i += 2 {\n        for n % i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n        }\n    }\n    if n > 2 {\n        factors =\
    \ append(factors, n)\n    }\n    return factors\n}\n", "    res := []int{}\n \
    \   for i := 2; i <= n; i++ {\n        for n % i == 0 {\n            res = append(res,\
    \ i)\n            n /= i\n        }\n    }\n    return res\n}\n", "    var res\
    \ []int\n    // TODO: implement here!\n    return res\n}\n", "    if n == 1 {\n\
    \        return []int{1}\n    }\n\n    var result []int\n    for i := 2; i <=\
    \ n; i++ {\n        for n % i == 0 {\n            result = append(result, i)\n\
    \            n /= i\n        }\n    }\n    return result\n}\n", "    return []int{}\n\
    }\n", "    factors := []int{}\n    f := 2\n    for n > 1 {\n        if n % f ==\
    \ 0 {\n            factors = append(factors, f)\n            n /= f\n        }\
    \ else {\n            f += 1\n        }\n    }\n    return factors\n}\n", "  \
    \  r := []int{}\n    t := 2\n    if n <= 0 {\n        return r\n    }\n    for\
    \ n > 1 {\n        for n % t == 0 {\n            r = append(r, t)\n          \
    \  n /= t\n        }\n        t++\n    }\n    return r\n}\n", "    // Create list\
    \ of all prime factors\n    // Maybe there's a smarter way to do this?\n    factorList\
    \ := []int{}\n    current := n\n    // While we still have something left to divide\n\
    \    for current > 1 {\n        // Search for factor\n        factor := smallestFactor(current)\n\
    \        // Append it to the list\n        factorList = append(factorList, factor)\n\
    \        // Divide by factor\n        current = current / factor\n    }\n    return\
    \ factorList\n}\n", "    var result []int\n    current := n\n    for i := 2; i\
    \ <= current; i++ {\n        if (current % i) == 0 {\n            result = append(result,\
    \ i)\n            current = current / i\n            i = i - 1\n        }\n  \
    \  }\n    return result\n}\n", "    var factors []int\n    for i := 2; i <= n;\
    \ i++ {\n        for n % i == 0 {\n            factors = append(factors, i)\n\
    \            n /= i\n        }\n    }\n    return factors\n}\n", "    factors\
    \ := []int{}\n    for i := 2; i <= n; i++ {\n        for n % i == 0 {\n      \
    \      factors = append(factors, i)\n            n /= i\n        }\n    }\n  \
    \  return factors\n}\n", "    return []int{2, 2, 2}\n}\n", "    p := 2\n    f\
    \ := make([]int, 0)\n    for p*p <= n {\n        if n % p == 0 {\n           \
    \ f = append(f, p)\n            n /= p\n        } else {\n            p++\n  \
    \      }\n    }\n    if n > 1 {\n        f = append(f, n)\n    }\n    return f\n\
    }\n", "    factors := []int{}\n    for n % 2 == 0 {\n        factors = append(factors,\
    \ 2)\n        n /= 2\n    }\n    for i := 3; i * i <= n; i += 2 {\n        for\
    \ n % i == 0 {\n            factors = append(factors, i)\n            n /= i\n\
    \        }\n    }\n    if n > 2 {\n        factors = append(factors, n)\n    }\n\
    \    return factors\n}\n", "    var factorList []int\n    var i int\n    i = 2\n\
    \    for n > 1 {\n        if n % i == 0 {\n            factorList = append(factorList,\
    \ i)\n            n = n / i\n        } else {\n            i = i + 1\n       \
    \ }\n    }\n    return factorList\n}\n", "    factors := []int{}\n    for i :=\
    \ 2; i <= n; i++ {\n        for n % i == 0 {\n            factors = append(factors,\
    \ i)\n            n /= i\n        }\n    }\n    return factors\n}\n", "    var\
    \ factors []int\n    for n > 1 {\n        for i := 2; i <= n; i++ {\n        \
    \    if n % i == 0 {\n                factors = append(factors, i)\n         \
    \       n = n / i\n                break\n            }\n        }\n    }\n  \
    \  return factors\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
