name: HumanEval_8_sum_product
language: go_test.go
prompt: "package sum_product_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // For a given list of integers, return a list consisting of a sum and a product\
  \ of all the integers in a list.\n// Empty sum should be equal to 0 and empty product\
  \ should be equal to 1.\n// >>> sum_product(float64{})\n// []interface{}{0, 1}\n\
  // >>> sum_product([]int{1, 2, 3, 4})\n// []interface{}{10, 24}\nfunc sum_product(numbers\
  \ []int) []interface{} {\n"
tests: "func TestSum_Product(t *testing.T) {\n  candidate := sum_product\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate([]int{}), expected: []interface{}{0, 1} },\n\
  \     { actual: candidate([]int{1, 1, 1}), expected: []interface{}{3, 1} },\n  \
  \   { actual: candidate([]int{100, 0}), expected: []interface{}{100, 0} },\n   \
  \  { actual: candidate([]int{3, 5, 7}), expected: []interface{}{15, 105} },\n  \
  \   { actual: candidate([]int{10}), expected: []interface{}{10, 10} },\n   }\n\n\
  \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
  \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\",\
  \ tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
  \t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    sum := 0\n    product := 1\n    for _, i := range numbers {\n \
    \       sum += i\n        product *= i\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    sum := 0\n    product := 1\n    for _, v := range numbers {\n     \
    \   sum += v\n        product *= v\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    sum := 0\n    product := 1\n    for _, n := range numbers {\n     \
    \   sum += n\n        product *= n\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    var sum int\n    var product int\n    for _, n := range numbers {\n\
    \        sum += n\n        if product == 0 {\n            product = n\n      \
    \  } else {\n            product *= n\n        }\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    var sum, product int\n    if len(numbers) == 0 {\n    \
    \    return []interface{}{0, 1}\n    }\n    for _, n := range numbers {\n    \
    \    sum += n\n        product *= n\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    sum := 0\n    product := 1\n    for _, number := range numbers {\n\
    \        sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    for _, v := range numbers\
    \ {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, num := range numbers {\n\
    \        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    return []interface{}{sum(numbers), product(numbers)}\n\
    }\n", "    sum := 0\n    product := 1\n    for _, n := range numbers {\n     \
    \   sum += n\n        product *= n\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    sum := 0\n    product := 1\n    for _, number := range numbers {\n\
    \        sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, n := range numbers {\n\
    \        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    fmt.Println(numbers)\n    if len(numbers) == 0 {\n    \
    \    return []interface{}{0, 1}\n    }\n    sum := 0\n    product := 1\n    for\
    \ _, n := range numbers {\n        sum += n\n        product *= n\n    }\n   \
    \ return []interface{}{sum, product}\n}\n", "    var sum int\n    var product\
    \ int = 1\n    for _, num := range numbers {\n        sum += num\n        product\
    \ *= num\n    }\n    return []interface{}{sum, product}\n}\n", "    sum := 0\n\
    \    product := 1\n    for _, number := range numbers {\n        sum += number\n\
    \        product *= number\n    }\n    return []interface{}{sum, product}\n}\n",
  "    var sum, product int\n    sum = 0\n    product = 1\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= number\n    }\n    return\
    \ []interface{}{sum, product}\n}\n", "    if len(numbers) == 0 {\n        return\
    \ []interface{}{0, 1}\n    }\n    var sum int\n    var product int\n    for _,\
    \ v := range numbers {\n        sum += v\n        product *= v\n    }\n    return\
    \ []interface{}{sum, product}\n}\n", "    sum := 0\n    product := 1\n    if len(numbers)\
    \ == 0 {\n        return []interface{}{sum, product}\n    }\n\n    for _, v :=\
    \ range numbers {\n        sum += v\n        product *= v\n    }\n\n    return\
    \ []interface{}{sum, product}\n}\n", "    var sum, product int\n    for _, v :=\
    \ range numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, n := range numbers {\n\
    \        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    var sum int\n    var product int\n    switch len(numbers)\
    \ {\n    case 0:\n        sum = 0\n        product = 1\n    default:\n       \
    \ sum = numbers[0]\n        product = numbers[0]\n        for _, i := range numbers[1:]\
    \ {\n            sum += i\n            product *= i\n        }\n    }\n    return\
    \ []interface{}{sum, product}\n}\n", "    sum := 0\n    product := 1\n    for\
    \ _, n := range numbers {\n        sum += n\n        product *= n\n    }\n   \
    \ return []interface{}{sum, product}\n}\n", "    var sum, product int\n    for\
    \ _, value := range numbers {\n        sum += value\n        product *= value\n\
    \    }\n    return []interface{}{sum, product}\n}\n", "    // your code here\n\
    \    sum := 0\n    product := 1\n    for _, num := range numbers {\n        sum\
    \ += num\n        product *= num\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    sum := 0\n    product := 1\n    for _, value := range numbers {\n \
    \       sum += value\n        product *= value\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= number\n    }\n    return\
    \ []interface{}{sum, product}\n}\n", "    if len(numbers) == 0 {\n        return\
    \ []interface{}{0, 1}\n    }\n    sum := 0\n    product := 1\n    for _, v :=\
    \ range numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    var sum int\n    var product int\n    for _, number :=\
    \ range numbers {\n        sum += number\n        if product == 0 {\n        \
    \    product = number\n        } else {\n            product *= number\n     \
    \   }\n    }\n    return []interface{}{sum, product}\n}\n", "    return nil\n\
    }\n", "    var sum int = 0\n    var product int = 1\n    for _, x := range numbers\
    \ {\n        sum += x\n        product *= x\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    var sum, product int\n    for _, n := range numbers {\n\
    \        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    for _, num := range numbers\
    \ {\n        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    s := 0\n    p := 1\n    for _, val := range numbers {\n\
    \        s += val\n        p *= val\n    }\n    return []interface{}{s, p}\n}\n",
  "    var sum int = 0\n    var product int = 1\n    if len(numbers) == 0 {\n    \
    \    return []interface{}{sum, product}\n    }\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    var sum int\n    var product int = 1\n    for _, number\
    \ := range numbers {\n        sum += number\n        product *= number\n    }\n\
    \    return []interface{}{sum, product}\n}\n", "    sum := 0\n    product := 1\n\
    \    for _, number := range numbers {\n        sum += number\n        product\
    \ *= number\n    }\n    return []interface{}{sum, product}\n}\n", "    sum :=\
    \ 0\n    product := 1\n    for _, number := range numbers {\n        sum += number\n\
    \        product *= number\n    }\n    return []interface{}{sum, product}\n}\n",
  "    sum := 0\n    product := 1\n    for _, value := range numbers {\n        sum\
    \ += value\n        product *= value\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    if len(numbers) == 0 {\n        return []interface{}{0, 1}\n    }\n\
    \    var sum int\n    var product int\n    for _, num := range numbers {\n   \
    \     sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    res := make([]interface{}, 2)\n    for _, num := range\
    \ numbers {\n        res[0] = res[0].(int) + num\n        res[1] = res[1].(int)\
    \ * num\n    }\n    return res\n}\n", "    if len(numbers) == 0 {\n        return\
    \ []interface{}{0, 1}\n    }\n\n    sum := 0\n    product := 1\n    for _, number\
    \ := range numbers {\n        sum += number\n        product *= number\n    }\n\
    \n    return []interface{}{sum, product}\n}\n", "    var sum, product int\n  \
    \  for _, v := range numbers {\n        sum += v\n        product *= v\n    }\n\
    \    return []interface{}{sum, product}\n}\n", "    sum := 0\n    product := 1\n\
    \    for _, number := range numbers {\n        sum += number\n        product\
    \ *= number\n    }\n    return []interface{}{sum, product}\n}\n", "    var result\
    \ []interface{}\n    sum := 0\n    product := 1\n    for _, num := range numbers\
    \ {\n        sum += num\n        product *= num\n    }\n    result = append(result,\
    \ sum, product)\n    return result\n}\n", "    result := make([]interface{}, 2)\n\
    \    sum := 0\n    product := 1\n    for _, number := range numbers {\n      \
    \  sum += number\n        product *= number\n    }\n    result[0] = sum\n    result[1]\
    \ = product\n    return result\n}\n", "    return nil\n}\n", "    sum := 0\n \
    \   product := 1\n    for _, number := range numbers {\n        sum += number\n\
    \        product *= number\n    }\n    return []interface{}{sum, product}\n}\n",
  "    sum := 0\n    product := 1\n    for _, number := range numbers {\n        sum\
    \ += number\n        product *= number\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    if len(numbers) == 0 {\n        return []interface{}{0, 1}\n    }\n\
    \    sum := 0\n    product := 1\n    for _, i := range numbers {\n        sum\
    \ += i\n        product *= i\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    var sum int\n    var product int = 1\n    for _, n := range numbers\
    \ {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    for _, num := range numbers\
    \ {\n        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    return []interface{}{0, 1}\n}\n", "    sum := 0\n    product\
    \ := 1\n    for _,v := range numbers {\n        sum += v\n        product *= v\n\
    \    }\n    return []interface{}{sum, product}\n}\n", "    if len(numbers) ==\
    \ 0 {\n        return []interface{}{0, 1}\n    }\n\n    sum := 0\n    product\
    \ := 1\n    for _, number := range numbers {\n        sum += number\n        product\
    \ *= number\n    }\n\n    return []interface{}{sum, product}\n}\n", "    sum :=\
    \ 0\n    product := 1\n    for _, v := range numbers {\n        sum += v\n   \
    \     product *= v\n    }\n    return []interface{}{sum, product}\n}\n", "   \
    \ if len(numbers) == 0 {\n        return []interface{}{0, 1}\n    }\n\n    sum\
    \ := 0\n    product := 1\n    for _, i := range numbers {\n        sum += i\n\
    \        product *= i\n    }\n\n    return []interface{}{sum, product}\n}\n",
  "    sum := 0\n    product := 1\n    for _, v := range numbers {\n        sum +=\
    \ v\n        product *= v\n    }\n    return []interface{}{sum, product}\n}\n",
  "    var sum int\n    var product int = 1\n    for _, v := range numbers {\n   \
    \     sum += v\n        product *= v\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    var sum = 0\n    var product = 1\n    for _, value := range numbers\
    \ {\n        sum += value\n        product *= value\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= number\n    }\n    return\
    \ []interface{}{sum, product}\n}\n", "    // YOUR CODE HERE\n    return []interface{}{0,\
    \ 0}\n}\n", "    var sum, product int\n    for _, v := range numbers {\n     \
    \   sum += v\n        product *= v\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    s := 0\n    p := 1\n    for _, v := range numbers {\n        s += v\n\
    \        p *= v\n    }\n    return []interface{}{s, p}\n}\n", "    for _, v :=\
    \ range numbers {\n        sum := sum + v\n        product = product * v\n   \
    \ }\n    return []interface{}{sum, product}\n}\n", "    sum := 0\n    product\
    \ := 1\n    for _, v := range numbers {\n        sum += v\n        product *=\
    \ v\n    }\n    return []interface{}{sum, product}\n}\n", "    return nil\n}\n",
  "    if len(numbers) == 0 {\n        return []interface{}{0, 1}\n    }\n\n    sum\
    \ := 0\n    product := 1\n    for _, v := range numbers {\n        sum += v\n\
    \        product *= v\n    }\n\n    return []interface{}{sum, product}\n}\n",
  "    sum := 0\n    product := 1\n    if len(numbers) == 0 {\n        return []interface{}{sum,\
    \ product}\n    }\n    for _, num := range numbers {\n        sum += num\n   \
    \     product *= num\n    }\n    return []interface{}{sum, product}\n}\n", " \
    \   sum := 0\n    product := 1\n    for _, number := range numbers {\n       \
    \ sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    for _, n := range numbers\
    \ {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    var sum int\n    var product int = 1\n    for _, value\
    \ := range numbers {\n        sum += value\n        product *= value\n    }\n\
    \    return []interface{}{sum, product}\n}\n", "    length := len(numbers)\n \
    \   if length == 0 {\n        return []interface{}{0, 1}\n    }\n    sum := 0\n\
    \    product := 1\n    for _, num := range numbers {\n        sum += num\n   \
    \     product *= num\n    }\n    return []interface{}{sum, product}\n}\n", " \
    \   var sum, product int\n    for _, value := range numbers {\n        sum +=\
    \ value\n        product *= value\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    // return []interface{}{}\n    sum := 0\n    prod := 1\n    for _,\
    \ num := range numbers {\n        sum += num\n        prod *= num\n    }\n   \
    \ return []interface{}{sum, prod}\n}\n", "    sum := 0\n    product := 1\n   \
    \ for _, number := range numbers {\n        sum += number\n        product *=\
    \ number\n    }\n    return []interface{}{sum, product}\n}\n", "    var sum, product\
    \ int = 0, 1\n    for _, n := range numbers {\n        sum += n\n        product\
    \ *= n\n    }\n    return []interface{}{sum, product}\n}\n", "    sum := 0\n \
    \   product := 1\n    for _, x := range numbers {\n        sum += x\n        product\
    \ *= x\n    }\n    return []interface{}{sum, product}\n}\n", "    sum := 0\n \
    \   product := 1\n    for _, n := range numbers {\n        sum += n\n        product\
    \ *= n\n    }\n    return []interface{}{sum, product}\n}\n", "    res := make([]interface{},\
    \ 2)\n    res[0] = 0\n    res[1] = 1\n    for _, number := range numbers {\n \
    \       res[0] = res[0].(int) + number\n        res[1] = res[1].(int) * number\n\
    \    }\n    return res\n}\n", "    sum := 0\n    product := 1\n    for _, v :=\
    \ range numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    var sum, product int\n    for _, num := range numbers {\n\
    \        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    var sum, product int\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    total := 0\n    product := 1\n    for _, num := range numbers\
    \ {\n        total += num\n        product *= num\n    }\n    return []interface{}{total,\
    \ product}\n}\n", "    var sum, product int\n    for _, v := range numbers {\n\
    \        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    var sum int\n    var product int\n    for _, n := range\
    \ numbers {\n        sum += n\n        if product == 0 {\n            product\
    \ = n\n        } else {\n            product *= n\n        }\n    }\n    return\
    \ []interface{}{sum, product}\n}\n", "    if len(numbers) == 0 {\n        return\
    \ []interface{}{0, 1}\n    }\n    sum := 0\n    product := 1\n    for _, v :=\
    \ range numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    var sum int\n    var product int = 1\n    for _, value\
    \ := range numbers {\n        sum += value\n        product *= value\n    }\n\
    \    return []interface{}{sum, product}\n}\n", "    sum := 0\n    product := 1\n\
    \    for _, number := range numbers {\n        sum += number\n        product\
    \ *= number\n    }\n    return []interface{}{sum, product}\n}\n", "    sum :=\
    \ 0\n    product := 1\n    for _, num := range numbers {\n        sum += num\n\
    \        product *= num\n    }\n    return []interface{}{sum, product}\n}\n",
  "    sum := 0\n    prod := 1\n    for _, v := range numbers {\n        sum += v\n\
    \        prod *= v\n    }\n    return []interface{}{sum, prod}\n}\n", "    //\
    \ Fill this in\n    sum := 0\n    product := 1\n    for _, n := range numbers\
    \ {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    for _, v := range numbers\
    \ {\n        sum += v\n        product *= v\n    }\n    var empty = []interface{}{}\n\
    \    if len(numbers) == 0 {\n        return append(empty, 0, 1)\n    }\n    return\
    \ append(empty, sum, product)\n}\n", "    s := 0\n    p := 1\n    for _, n :=\
    \ range numbers {\n        s += n\n        p *= n\n    }\n    return []interface{}{s,\
    \ p}\n}\n", "    var result []interface{}\n    var sum, product int\n    for _,\
    \ n := range numbers {\n        sum += n\n        product *= n\n    }\n    result\
    \ = append(result, sum, product)\n    return result\n}\n", "    var result []interface{}\n\
    \    result = append(result, 0)\n    result = append(result, 1)\n    for _, number\
    \ := range numbers {\n        result[0] = result[0].(int) + number\n        result[1]\
    \ = result[1].(int) * number\n    }\n    return result\n}\n", "    sum := 0\n\
    \    product := 1\n    for _, v := range numbers {\n        sum += v\n       \
    \ product *= v\n    }\n    return []interface{}{sum, product}\n}\n", "    sum\
    \ := 0\n    product := 1\n    for _, number := range numbers {\n        sum +=\
    \ number\n        product *= number\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    sum := 0\n    product := 1\n    for _, n := range numbers {\n     \
    \   sum += n\n        product *= n\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    sum := 0\n    product := 1\n    for _, v := range numbers {\n     \
    \   sum += v\n        product *= v\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    var sum = 0\n    var product = 1\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= number\n    }\n    return\
    \ []interface{}{sum, product}\n}\n", "    if len(numbers) == 0 {\n        return\
    \ []interface{}{0, 1}\n    }\n    sum := 0\n    product := 1\n    for _, n :=\
    \ range numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    r := []interface{}{0, 1}\n    for _, n := range numbers\
    \ {\n        r[0] = r[0].(int) + n\n        r[1] = r[1].(int) * n\n    }\n   \
    \ return r\n}\n", "    sum := 0\n    product := 1\n    for _, num := range numbers\
    \ {\n        sum += num\n        product *= num\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= number\n    }\n    return\
    \ []interface{}{sum, product}\n}\n", "    if len(numbers) == 0 {\n        return\
    \ []interface{}{0, 1}\n    }\n    sum := 0\n    product := 1\n    for _, val :=\
    \ range numbers {\n        sum += val\n        product *= val\n    }\n    return\
    \ []interface{}{sum, product}\n}\n", "    return []interface{}{0, 1}\n}\n", " \
    \   sum := 0\n    product := 1\n    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    for _, number := range numbers {\n        sum += number\n   \
    \     product *= number\n    }\n    return []interface{}{sum, product}\n}\n",
  "    if len(numbers) == 0 {\n        return []interface{}{0, 1}\n    }\n    sum\
    \ := 0\n    product := 1\n    for _, number := range numbers {\n        sum +=\
    \ number\n        product *= number\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    var sum, product int\n    for _, n := range numbers {\n        sum\
    \ += n\n        product *= n\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    var sum int\n    product := 1\n    for _, v := range numbers {\n  \
    \      sum += v\n        product *= v\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    var sum = 0\n    var product = 1\n    for _, n := range numbers {\n\
    \        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    var sum int = 0\n    var product int = 1\n    for _,n :=\
    \ range numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= number\n    }\n    return\
    \ []interface{}{sum, product}\n}\n", "    sum := 0\n    product := 1\n    for\
    \ _, number := range numbers {\n        sum += number\n        product *= number\n\
    \    }\n    return []interface{}{sum, product}\n}\n", "    sum := 0\n    product\
    \ := 1\n    for _, number := range numbers {\n        sum += number\n        product\
    \ *= number\n    }\n    return []interface{}{sum, product}\n}\n", "    if len(numbers)\
    \ == 0 {\n        return []interface{}{0, 1}\n    }\n    sum := 0\n    product\
    \ := 1\n    for _, number := range numbers {\n        sum += number\n        product\
    \ *= number\n    }\n    return []interface{}{sum, product}\n}\n", "    return\
    \ []interface{}{}\n}\n", "    return []interface{}{sum(numbers), product(numbers)}\n\
    }\n", "    return nil\n}\n", "    var sum int = 0\n    var product int = 1\n \
    \   for _, number := range numbers {\n        sum += number\n        product *=\
    \ number\n    }\n    return []interface{}{sum, product}\n}\n", "    sum := 0\n\
    \    product := 1\n    for _, number := range numbers {\n        sum += number\n\
    \        product *= number\n    }\n    return []interface{}{sum, product}\n}\n",
  "    s := 0\n    p := 1\n    for _, i := range numbers {\n        s += i\n     \
    \   p *= i\n    }\n    return []interface{}{s, p}\n}\n", "    sum := 0\n    product\
    \ := 1\n    for _, num := range numbers {\n        sum += num\n        product\
    \ *= num\n    }\n    return []interface{}{sum, product}\n}\n", "    sum := 0\n\
    \    product := 1\n    for _, num := range numbers {\n        sum += num\n   \
    \     product *= num\n    }\n    return []interface{}{sum, product}\n}\n", " \
    \   sum := 0\n    product := 1\n    for _, number := range numbers {\n       \
    \ sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    result := make([]interface{},\
    \ 2)\n    for _, number := range numbers {\n        sum += number\n        product\
    \ *= number\n    }\n    result[0] = sum\n    result[1] = product\n    return result\n\
    }\n", "    sum := 0\n    product := 1\n    for _, v := range numbers {\n     \
    \   sum += v\n        product *= v\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    if len(numbers) == 0 {\n        return []interface{}{0, 1}\n    }\n\
    \    sum := 0\n    product := 1\n    for _, number := range numbers {\n      \
    \  sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    var sum int\n    var product int\n    if len(numbers) ==\
    \ 0 {\n        return []interface{}{0, 1}\n    }\n    for _, v := range numbers\
    \ {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    var sum, product int\n    for _, number := range numbers {\n\
    \        sum += number\n        product *= number\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    for _, n := range numbers\
    \ {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    var sum int\n    var product int\n    sum = 0\n    product\
    \ = 1\n    for _, n := range numbers {\n        sum += n\n        product *= n\n\
    \    }\n    return []interface{}{sum, product}\n}\n", "    sum := 0\n    product\
    \ := 1\n    for _, n := range numbers {\n        sum += n\n        product *=\
    \ n\n    }\n    return []interface{}{sum, product}\n}\n\ntype TestCase ", "  \
    \  sum := 0\n    product := 1\n    for _, num := range numbers {\n        sum\
    \ += num\n        product *= num\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    return []interface{}{\n        sum(numbers),\n        product(numbers),\n\
    \    }\n}\n", "    sum := 0\n    product := 1\n    for _, n := range numbers {\n\
    \        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    result := make([]interface{},\
    \ 2)\n    for _, value := range numbers {\n        sum += value\n        product\
    \ *= value\n    }\n    result[0] = sum\n    result[1] = product\n    return result\n\
    }\n", "    var result []interface{}\n    result = append(result, 0)\n    result\
    \ = append(result, 1)\n    for _, n := range numbers {\n        result[0] = result[0].(int)\
    \ + n\n        result[1] = result[1].(int) * n\n    }\n    return result\n}\n",
  "    sum := 0\n    product := 1\n    for _, v := range numbers {\n        sum +=\
    \ v\n        product *= v\n    }\n    return []interface{}{sum, product}\n}\n",
  "    sum := 0\n    product := 1\n    for _, v := range numbers {\n        sum +=\
    \ v\n        product *= v\n    }\n    return []interface{}{sum, product}\n}\n",
  "    var sum, product int\n    for _, x := range numbers {\n        sum += x\n \
    \       product *= x\n    }\n    return []interface{}{sum, product}\n}\n", " \
    \   var result []interface{}\n    sum := 0\n    product := 1\n    for _, v :=\
    \ range numbers {\n        sum += v\n        product *= v\n    }\n    result =\
    \ append(result, sum, product)\n    return result\n}\n", "    result := make([]interface{},\
    \ 2)\n    result[0] = 0\n    result[1] = 1\n    for _, number := range numbers\
    \ {\n        result[0] = result[0].(int) + number\n        result[1] = result[1].(int)\
    \ * number\n    }\n    return result\n}\n", "    sum := 0\n    product := 1\n\
    \    for _, v := range numbers {\n        sum += v\n        product *= v\n   \
    \ }\n    return []interface{}{sum, product}\n}\n\ntype testCase ", "    sum :=\
    \ 0\n    product := 1\n    for _, v := range numbers {\n        sum += v\n   \
    \     product *= v\n    }\n    return []interface{}{sum, product}\n}\n", "   \
    \ sum := 0\n    product := 1\n    result := make([]interface{}, 2)\n    for _,\
    \ n := range numbers {\n        sum += n\n        product *= n\n    }\n    result[0]\
    \ = sum\n    result[1] = product\n    return result\n}\n", "    sum := 0\n   \
    \ product := 1\n    for _, number := range numbers {\n        sum += number\n\
    \        product *= number\n    }\n    return []interface{}{sum, product}\n}\n",
  "    s := 0\n    p := 1\n    for _, n := range numbers {\n        s += n\n     \
    \   p *= n\n    }\n    return []interface{}{s, p}\n}\n", "    product := 1\n \
    \   sum := 0\n    for _, number := range numbers {\n        product *= number\n\
    \        sum += number\n    }\n    return []interface{}{sum, product}\n}\n", " \
    \   var sum int = 0\n    var product int = 1\n    for _, v := range numbers {\n\
    \        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    res := make([]interface{}, 2)\n    res[0] = 0\n    res[1]\
    \ = 1\n    for _, num := range numbers {\n        res[0] = res[0].(int) + num\n\
    \        res[1] = res[1].(int) * num\n    }\n    return res\n}\n", "    return\
    \ []interface{}{sum(numbers), product(numbers)}\n}\n", "    var result []interface{}\n\
    \    var sum int\n    var product int\n    if len(numbers) == 0 {\n        sum\
    \ = 0\n        product = 1\n    } else {\n        for _, v := range numbers {\n\
    \            sum += v\n            if product == 0 {\n                product\
    \ = v\n            } else {\n                product *= v\n            }\n   \
    \     }\n    }\n    result = append(result, sum)\n    result = append(result,\
    \ product)\n    return result\n}\n", "    if len(numbers) == 0 {\n        return\
    \ []interface{}{0, 1}\n    }\n\n    sum := 0\n    product := 1\n    for _, number\
    \ := range numbers {\n        sum += number\n        product *= number\n    }\n\
    \n    return []interface{}{sum, product}\n}\n", "    sum := 0\n    product :=\
    \ 1\n    result := make([]interface{}, 2)\n    for _, n := range numbers {\n \
    \       sum += n\n        product *= n\n    }\n    result[0] = sum\n    result[1]\
    \ = product\n    return result\n}\n", "    var sum, product int = 0, 1\n    for\
    \ _, i := range numbers {\n        sum += i\n        product *= i\n    }\n   \
    \ return []interface{}{sum, product}\n}\n", "    sum := 0\n    product := 1\n\
    \    for _, number := range numbers {\n        sum += number\n        product\
    \ *= number\n    }\n    return []interface{}{sum, product}\n}\n", "    sum :=\
    \ 0\n    product := 1\n    for _, i := range numbers {\n        sum += i\n   \
    \     product *= i\n    }\n    return []interface{}{sum, product}\n}\n", "   \
    \ var sum int = 0\n    var product int = 1\n    for _,n := range numbers {\n \
    \       sum += n\n        product *= n\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    return nil\n}\n", "    sum := 0\n    product := 1\n    for _, v :=\
    \ range numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n\n    sum := 0\n    product := 1\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n", "    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    sum := 0\n    product := 1\n    for _, v := range numbers {\n\
    \        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= number\n    }\n    return\
    \ []interface{}{sum, product}\n}\n", "    sum := 0\n    product := 1\n    for\
    \ _, v := range numbers {\n        sum += v\n        product *= v\n    }\n   \
    \ return []interface{}{sum, product}\n}\n\ntype TestData ", "    sum := 0\n  \
    \  product := 1\n    for _, num := range numbers {\n        sum += num\n     \
    \   product *= num\n    }\n    return []interface{}{sum, product}\n}\n", "   \
    \ sum := 0\n    product := 1\n    for _, number := range numbers {\n        sum\
    \ += number\n        product *= number\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    var empty_float64 []float64\n    var empty_int []int\n    float_slice\
    \ := make([]float64, len(numbers))\n    for idx, value := range numbers {\n  \
    \      float_slice[idx] = float64(value)\n    }\n    var result []interface{}\n\
    \    result = append(result, sum(float_slice))\n    result = append(result, product(float_slice))\n\
    \    return result\n}\n", "    sum := 0\n    product := 1\n    for _, v := range\
    \ numbers {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    for _, n := range numbers\
    \ {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    // your code here\n    var res []interface{}\n    var sum\
    \ int = 0\n    var product int = 1\n    for _, number := range numbers {\n   \
    \     sum += number\n        product *= number\n    }\n    res = append(res, sum)\n\
    \    res = append(res, product)\n    return res\n}\n", "    res := make([]interface{},\
    \ 2)\n    res[0] = 0\n    res[1] = 1\n    for _, v := range numbers {\n      \
    \  res[0] = res[0].(int) + v\n        res[1] = res[1].(int) * v\n    }\n    return\
    \ res\n}\n", "    result := make([]interface{}, 2)\n    result[0] = 0\n    result[1]\
    \ = 1\n    for _, number := range numbers {\n        result[0] = result[0].(int)\
    \ + number\n        result[1] = result[1].(int) * number\n    }\n    return result\n\
    }\n", "    var sum int = 0\n    var product int = 1\n    for _, i := range numbers\
    \ {\n        sum += i\n        product *= i\n    }\n    return []interface{}{sum,\
    \ product}\n}\n\ntype testpair ", "    sum := 0\n    product := 1\n    for _,\
    \ v := range numbers {\n        sum += v\n        product *= v\n    }\n    return\
    \ []interface{}{sum, product}\n}\n", "    if len(numbers) == 0 {\n        return\
    \ []interface{}{0, 1}\n    }\n\n    sum := 0\n    product := 1\n    for _, num\
    \ := range numbers {\n        sum += num\n        product *= num\n    }\n\n  \
    \  return []interface{}{sum, product}\n}\n", "    // your code goes here\n   \
    \ return nil\n}\n", "    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n\n    sum := 0\n    product := 1\n    for _, number := range numbers\
    \ {\n        sum += number\n        product *= number\n    }\n\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    for _, v := range numbers\
    \ {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    for _, v := range numbers\
    \ {\n        sum += v\n        product *= v\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    var sum int\n    var product int = 1\n    for _, n := range\
    \ numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    prod := 1\n    for _, val := range numbers\
    \ {\n        sum += val\n        prod *= val\n    }\n    return []interface{}{sum,\
    \ prod}\n}\n\ntype TestCase ", "    sum := 0\n    product := 1\n    for _, n :=\
    \ range numbers {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    for _, n := range numbers\
    \ {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    for _, value := range numbers\
    \ {\n        sum += value\n        product *= value\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= number\n    }\n    return\
    \ []interface{}{sum, product}\n}\n", "    sum := 0\n    product := 1\n    for\
    \ _, number := range numbers {\n        sum += number\n        product *= number\n\
    \    }\n    return []interface{}{sum, product}\n}\n", "    var result []interface{}\n\
    \    result = append(result, 0)\n    result = append(result, 1)\n    for _, n\
    \ := range numbers {\n        result[0] = result[0].(int) + n\n        result[1]\
    \ = result[1].(int) * n\n    }\n    return result\n}\n", "    var s, p int\n \
    \   var res []interface{}\n    for _, n := range numbers {\n        s += n\n \
    \       p *= n\n    }\n    res = append(res, s, p)\n    return res\n}\n", "  \
    \  sum := 0\n    product := 1\n    for _, number := range numbers {\n        sum\
    \ += number\n        product *= number\n    }\n    return []interface{}{sum, product}\n\
    }\n", "    sum := 0\n    product := 1\n    for _, value := range numbers {\n \
    \       sum += value\n        product *= value\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    var sum = 0\n    var product = 1\n    for _, value := range\
    \ numbers {\n        sum += value\n        product *= value\n    }\n    return\
    \ []interface{}{sum, product}\n}\n", "    var sum int\n    var product int = 1\n\
    \    for _, v := range numbers {\n        sum += v\n        product *= v\n   \
    \ }\n    return []interface{}{sum, product}\n}\n", "    res := make([]interface{},\
    \ 2)\n    sum := 0\n    prod := 1\n    for _, num := range numbers {\n       \
    \ sum += num\n        prod *= num\n    }\n    res[0] = sum\n    res[1] = prod\n\
    \    return res\n}\n", "    sum := 0\n    product := 1\n    for _, item := range\
    \ numbers {\n        sum += item\n        product *= item\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    sum := 0\n    product := 1\n    for _, n := range numbers\
    \ {\n        sum += n\n        product *= n\n    }\n    return []interface{}{sum,\
    \ product}\n}\n", "    if len(numbers) == 0 {\n        return []interface{}{0,\
    \ 1}\n    }\n    var sum int\n    var product int\n    for _, number := range\
    \ numbers {\n        sum += number\n        product *= number\n    }\n    return\
    \ []interface{}{sum, product}\n}\n", "    return []interface{}{1, 2}\n}\n", " \
    \   var sum, product int\n    for _, n := range numbers {\n        sum += n\n\
    \        product *= n\n    }\n    return []interface{}{sum, product}\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
