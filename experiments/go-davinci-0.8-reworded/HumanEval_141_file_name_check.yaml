name: HumanEval_141_file_name_check
language: go_test.go
prompt: "package file_name_check_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// Create a function which takes a string representing a file's name, and returns\n\
  // 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n// A file's\
  \ name is considered to be valid if and only if all the following conditions \n\
  // are met:\n// - There should not be more than three digits ('0'-'9') in the file's\
  \ name.\n// - The file's name contains exactly one dot '.'\n// - The substring before\
  \ the dot should not be empty, and it starts with a letter from \n// the latin alphapet\
  \ ('a'-'z' and 'A'-'Z').\n// - The substring after the dot should be one of these:\
  \ ['txt', 'exe', 'dll']\n// Examples:\n// >>> file_name_check(\"example.txt\")\n\
  // \"Yes\"\n// >>> file_name_check(\"1example.dll\")\n// \"No\"\nfunc file_name_check(file_name\
  \ string) string {\n"
tests: "func TestFile_Name_Check(t *testing.T) {\n  candidate := file_name_check\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"example.txt\"), expected: \"Yes\"\
  \ },\n     { actual: candidate(\"1example.dll\"), expected: \"No\" },\n     { actual:\
  \ candidate(\"s1sdf3.asd\"), expected: \"No\" },\n     { actual: candidate(\"K.dll\"\
  ), expected: \"Yes\" },\n     { actual: candidate(\"MY16FILE3.exe\"), expected:\
  \ \"Yes\" },\n     { actual: candidate(\"His12FILE94.exe\"), expected: \"No\" },\n\
  \     { actual: candidate(\"_Y.txt\"), expected: \"No\" },\n     { actual: candidate(\"\
  ?aREYA.exe\"), expected: \"No\" },\n     { actual: candidate(\"/this_is_valid.dll\"\
  ), expected: \"No\" },\n     { actual: candidate(\"this_is_valid.wow\"), expected:\
  \ \"No\" },\n     { actual: candidate(\"this_is_valid.txt\"), expected: \"Yes\"\
  \ },\n     { actual: candidate(\"this_is_valid.txtexe\"), expected: \"No\" },\n\
  \     { actual: candidate(\"#this2_i4s_5valid.ten\"), expected: \"No\" },\n    \
  \ { actual: candidate(\"@this1_is6_valid.exe\"), expected: \"No\" },\n     { actual:\
  \ candidate(\"this_is_12valid.6exe4.txt\"), expected: \"No\" },\n     { actual:\
  \ candidate(\"all.exe.txt\"), expected: \"No\" },\n     { actual: candidate(\"I563_No.exe\"\
  ), expected: \"Yes\" },\n     { actual: candidate(\"Is3youfault.txt\"), expected:\
  \ \"Yes\" },\n     { actual: candidate(\"no_one#knows.dll\"), expected: \"Yes\"\
  \ },\n     { actual: candidate(\"1I563_Yes3.exe\"), expected: \"No\" },\n     {\
  \ actual: candidate(\"I563_Yes3.txtt\"), expected: \"No\" },\n     { actual: candidate(\"\
  final..txt\"), expected: \"No\" },\n     { actual: candidate(\"final132\"), expected:\
  \ \"No\" },\n     { actual: candidate(\"_f4indsartal132.\"), expected: \"No\" },\n\
  \     { actual: candidate(\".txt\"), expected: \"No\" },\n     { actual: candidate(\"\
  s.\"), expected: \"No\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    num_of_dots := 0\n    num_of_digits := 0\n    for _, r := range\
    \ file_name {\n        if '0' <= r && r <= '9' {\n            num_of_digits++\n\
    \        } else if r == '.' {\n            num_of_dots++\n        }\n    }\n \
    \   if num_of_dots != 1 || num_of_digits > 3 {\n        return \"No\"\n    }\n\
    \    // I'll assume that the file name is not empty\n    dot_idx := 0\n    for\
    \ idx, r := range file_name {\n        if r == '.' {\n            dot_idx = idx\n\
    \            break\n        }\n    }\n    ext := file_name[dot_idx + 1:]\n   \
    \ if ext != \"txt\" && ext != \"exe\" && ext != \"dll\" {\n        return \"No\"\
    \n    }\n    if !(('a' <= file_name[0] && file_name[0] <= 'z') || ('A' <= file_name[0]\
    \ && file_name[0] <= 'Z')) {\n        return \"No\"\n    }\n    return \"Yes\"\
    \n}\n", "    return \"\"\n}\n", "    return \"\"\n}\n", "    // skip leading spaces\n\
    \    for len(file_name) > 0 && file_name[0] == ' ' {\n        file_name = file_name[1:]\n\
    \    }\n    // skip trailing spaces\n    for len(file_name) > 0 && file_name[len(file_name)-1]\
    \ == ' ' {\n        file_name = file_name[:len(file_name)-1]\n    }\n    // empty\
    \ name\n    if len(file_name) == 0 {\n        return \"No\"\n    }\n    // leading\
    \ invalid character\n    if (file_name[0] < 'a' || file_name[0] > 'z') && (file_name[0]\
    \ < 'A' || file_name[0] > 'Z') {\n        return \"No\"\n    }\n    // check for\
    \ the valid substring before the dot\n    for i := 1; i < len(file_name); i++\
    \ {\n        if file_name[i] == '.' {\n            break\n        }\n        if\
    \ file_name[i] < 'a' || file_name[i] > 'z' {\n            if file_name[i] < 'A'\
    \ || file_name[i] > 'Z' {\n                if file_name[i] < '0' || file_name[i]\
    \ > '9' {\n                    return \"No\"\n                }\n            }\n\
    \        }\n    }\n    // check the valid file extension\n    if file_name[len(file_name)-4:]\
    \ != \".txt\" && file_name[len(file_name)-4:] != \".exe\" && file_name[len(file_name)-4:]\
    \ != \".dll\" {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n", "   \
    \ var count_digits int = 0\n    var count_dots int = 0\n    var substring_length\
    \ int = 0\n    var substring_length_after_dot int = 0\n    var substring_before_dot\
    \ string = \"\"\n    var substring_after_dot string = \"\"\n    var extension\
    \ string = \"\"\n    for i := 0; i < len(file_name); i++ {\n        if file_name[i]\
    \ == '.' {\n            count_dots += 1\n            substring_before_dot = file_name[:i]\n\
    \            substring_after_dot = file_name[i+1:]\n            substring_length\
    \ = len(substring_before_dot)\n            substring_length_after_dot = len(substring_after_dot)\n\
    \        } else if file_name[i] >= '0' && file_name[i] <= '9' {\n            count_digits\
    \ += 1\n        }\n    }\n    if count_dots == 1 && count_digits <= 3 && substring_length\
    \ > 0 && \n        substring_length_after_dot > 0 {\n        if substring_before_dot[0]\
    \ >= 'a' && substring_before_dot[0] <= 'z' ||\n            substring_before_dot[0]\
    \ >= 'A' && substring_before_dot[0] <= 'Z' {\n            extension = substring_after_dot\n\
    \            if extension == \"txt\" || extension == \"exe\" || extension == \"\
    dll\" {\n                return \"Yes\"\n            }\n        }\n    }\n   \
    \ return \"No\"\n}\n", "    // TODO: Implement this method.\n    if n := len(file_name);\
    \ n < 5 || n > 12 {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n", " \
    \   return \"\"\n}\n", "    num_digits := 0\n    num_dots := 0\n    first_dot_pos\
    \ := 0\n    extension := \"\"\n    cur_pos := 0\n    for c := range file_name\
    \ {\n        if c >= '0' && c <= '9' {\n            num_digits++\n        } else\
    \ if c == '.' {\n            num_dots++\n            first_dot_pos = cur_pos\n\
    \        }\n        cur_pos++\n    }\n    if num_digits > 3 || num_dots != 1 {\n\
    \        return \"No\"\n    }\n    extension = file_name[first_dot_pos+1:]\n \
    \   if extension != \"txt\" && extension != \"exe\" && extension != \"dll\" {\n\
    \        return \"No\"\n    }\n    prefix := file_name[:first_dot_pos]\n    if\
    \ len(prefix) == 0 {\n        return \"No\"\n    }\n    first_char := prefix[0]\n\
    \    if first_char < 'a' || first_char > 'z' && first_char < 'A' || first_char\
    \ > 'Z' {\n        return \"No\"\n    }\n    return \"Yes\"\n}\n", "    dots :=\
    \ 0\n    digits := 0\n    for _, c := range file_name {\n        if c == '.' {\n\
    \            dots++\n        } else if '0' <= c && c <= '9' {\n            digits++\n\
    \        }\n    }\n    if dots != 1 || digits > 3 {\n        return \"No\"\n \
    \   }\n    pos := 0\n    for ; pos < len(file_name); pos++ {\n        if file_name[pos]\
    \ == '.' {\n            break\n        }\n    }\n    if pos == 0 || pos == len(file_name)\
    \ - 1 {\n        return \"No\"\n    }\n    var c byte = file_name[pos - 1]\n \
    \   if 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z' {\n        c = file_name[pos\
    \ + 1]\n        if c == 't' || c == 'e' || c == 'd' {\n            return \"Yes\"\
    \n        }\n    }\n    return \"No\"\n}\n", "    return \"Yes\"\n}\n", "    //\
    \ YOUR CODE HERE\n    return \"\"\n}\n", "    var num_count int\n    var has_dot\
    \ int\n    var char_count int\n    var file_type bool\n\n    for _, v := range\
    \ file_name {\n        if v >= '0' && v <= '9' {\n            num_count++\n  \
    \      } else if v == '.' {\n            has_dot++\n        } else if v >= 'a'\
    \ && v <= 'z' || v >= 'A' && v <= 'Z' {\n            char_count++\n        }\n\
    \    }\n\n    if num_count <= 3 && has_dot == 1 && char_count > 0 {\n        switch\
    \ file_name[len(file_name)-3:] {\n        case \"txt\":\n            file_type\
    \ = true\n        case \"exe\":\n            file_type = true\n        case \"\
    dll\":\n            file_type = true\n        default:\n            file_type\
    \ = false\n        }\n    } else {\n        file_type = false\n    }\n\n    if\
    \ file_type {\n        return \"Yes\"\n    } else {\n        return \"No\"\n \
    \   }\n}\n", "    // Put your code here\n    return \"No\"\n}\n", "    count :=\
    \ 0\n    for _, v := range file_name {\n        if v >= '0' && v <= '9' {\n  \
    \          count += 1\n        }\n    }\n    if count > 3 {\n        return \"\
    No\"\n    }\n    if file_name[0] < 'a' || file_name[0] > 'z' {\n        return\
    \ \"No\"\n    }\n    files := []string{\"txt\", \"exe\", \"dll\"}\n    flag :=\
    \ false\n    index := -1\n    for i, v := range file_name {\n        if v == '.'\
    \ {\n            index = i\n            break\n        }\n    }\n    if index\
    \ == -1 {\n        return \"No\"\n    }\n    for _, v := range files {\n     \
    \   if file_name[index+1:] == v {\n            flag = true\n            break\n\
    \        }\n    }\n    if flag {\n        return \"Yes\"\n    }\n    return \"\
    No\"\n}\n", "    // Write your code here\n    return \"Yes\"\n}\n", "    return\
    \ \"\"\n}\n", "    return \"\"\n}\n", "    r := file_name[0]\n    if ((r >= 65\
    \ && r <= 90) || (r >= 97 && r <= 122)) {\n        chars := []rune(file_name)\n\
    \        point := len(chars)\n        digits := 0\n        for i := 0; i < len(chars);\
    \ i++ {\n            if (chars[i] == 46) {\n                point = i\n      \
    \          break\n            }\n            if (chars[i] >= 48 && chars[i] <=\
    \ 57) {\n                digits += 1\n            }\n        }\n        if (digits\
    \ <= 3 && point != len(chars)) {\n            if (point > 1) {\n             \
    \   file_ext := string(chars[point+1:])\n                if (file_ext == \"txt\"\
    \ || file_ext == \"exe\" || file_ext == \"dll\") {\n                    return\
    \ \"Yes\"\n                }\n            }\n        }\n    }\n    return \"No\"\
    \n}\n", "    file_name_length := len(file_name)\n    if file_name_length < 4 {\n\
    \        return \"No\"\n    }\n    dot_count := 0\n    for i := 0; i < file_name_length;\
    \ i++ {\n        if file_name[i] == '.' {\n            dot_count++\n        }\n\
    \    }\n    if dot_count != 1 {\n        return \"No\"\n    }\n    tmp_l := file_name[:file_name_length-4]\n\
    \    if len(tmp_l) == 0 {\n        return \"No\"\n    }\n    if tmp_l[0] < 'a'\
    \ || (tmp_l[0] > 'z' && tmp_l[0] < 'A') || tmp_l[0] > 'Z' {\n        return \"\
    No\"\n    }\n    three_digits_count := 0\n    for i := 0; i < len(tmp_l); i++\
    \ {\n        if tmp_l[i] >= '0' && tmp_l[i] <= '9' {\n            three_digits_count++\n\
    \        }\n    }\n    if three_digits_count > 3 {\n        return \"No\"\n  \
    \  }\n    tmp_r := file_name[file_name_length-3:]\n    if tmp_r != \"txt\" &&\
    \ tmp_r != \"exe\" && tmp_r != \"dll\" {\n        return \"No\"\n    }\n    return\
    \ \"Yes\"\n}\n", "    return \"\"\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
