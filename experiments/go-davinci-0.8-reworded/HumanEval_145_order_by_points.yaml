name: HumanEval_145_order_by_points
language: go_test.go
prompt: "package order_by_points_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// Write a function which sorts the given list of integers\n// in ascending\
  \ order according to the sum of their digits.\n// Note: if there are several items\
  \ with similar sum of their digits,\n// order them based on their index in original\
  \ list.\n// For example:\n// >>> order_by_points([]int{1, 11, -1, -11, -12})\n//\
  \ []int{-1, -11, 1, -12, 11}\n// >>> order_by_points([]int{})\n// PATCH list\nfunc\
  \ order_by_points(nums []int) []int {\n"
tests: "func TestOrder_By_Points(t *testing.T) {\n  candidate := order_by_points\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate([]int{1, 11, -1, -11, -12}), expected:\
  \ []int{-1, -11, 1, -12, 11} },\n     { actual: candidate([]int{1234, 423, 463,\
  \ 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46}), expected: []int{0, 2, 3, 6,\
  \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457} },\n     { actual: candidate([]int{}),\
  \ expected: []int{} },\n     { actual: candidate([]int{1, -11, -32, 43, 54, -98,\
  \ 2, -3}), expected: []int{-3, -32, -98, -11, 1, 2, 43, 54} },\n     { actual: candidate([]int{1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}), expected: []int{1, 10, 2, 11, 3, 4, 5, 6, 7,\
  \ 8, 9} },\n     { actual: candidate([]int{0, 6, 6, -76, -21, 23, 4}), expected:\
  \ []int{-76, -21, 0, 4, 23, 6, 6} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
  t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
  %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
  \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    // returns a list of integer with the order changed\n\n    if len(nums)\
    \ == 0 {\n        return []int{}\n    }\n\n    // a list of slices with two values\
    \ each: sum of digits and index of the integer in nums\n    s := make([][]int,\
    \ len(nums))\n\n    for i, num := range nums {\n        s[i] = []int{sum_digits(num),\
    \ i}\n    }\n\n    // sort the slices in the list s according to their sum of\
    \ digits\n    sort.Slice(s, func(i, j int) bool { return s[i][0] < s[j][0] })\n\
    \n    // place items from nums in a new list in the order given by the sorted\
    \ list s\n    sorted_nums := make([]int, len(nums))\n    for i, slice := range\
    \ s {\n        sorted_nums[i] = nums[slice[1]]\n    }\n\n    return sorted_nums\n\
    }\n", "    var results []int\n    return results\n}\n", "    if len(nums) == 0\
    \ {\n        return nums\n    }\n    // Insertion sort\n    for i := 1; i < len(nums);\
    \ i++ {\n        j := i\n        for j > 0 && nums[j] < nums[j-1] {\n        \
    \    nums[j], nums[j-1] = nums[j-1], nums[j]\n            j--\n        }\n   \
    \ }\n    return nums\n}\n", "    patch := make([]int, len(nums))\n    // you code\
    \ here...\n    return patch\n}\n", "    if len(nums) == 0 {\n        return nums\n\
    \    }\n    points := make([]int, len(nums))\n    for i, v := range nums {\n \
    \       points[i] = sum_digits(v)\n    }\n    for i := 0; i < len(nums) - 1; i++\
    \ {\n        for j := 0; j < len(nums) - 1 - i; j++ {\n            if points[j]\
    \ > points[j + 1] {\n                points[j], points[j + 1] = points[j + 1],\
    \ points[j]\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n   \
    \         }\n        }\n    }\n    return nums\n}\n", "    // Write your code\
    \ here\n    return []int{}\n}\n", "    new_nums := nums\n    for i := 1; i < len(new_nums);\
    \ i++ {\n        for j := 0; j < len(new_nums)-i; j++ {\n            a := abs(new_nums[j])\n\
    \            b := abs(new_nums[j+1])\n            if (sum_digits(a) > sum_digits(b))\
    \ || (sum_digits(a) == sum_digits(b) && a > b) {\n                new_nums[j],\
    \ new_nums[j+1] = new_nums[j+1], new_nums[j]\n            }\n        }\n    }\n\
    \    return new_nums\n}\n", "    return nil\n}\n", "    points := map[int]int{}\n\
    \    for index, num := range nums {\n        points[index] = countPoints(num)\n\
    \    }\n    fmt.Println(points)\n    return nil\n}\n", "    return nums\n}\n",
  "    return []int{}\n}\n", "    var indexSlice []int\n    var valueSlice []int\n\
    \    var resultSlice []int\n    index := 0\n    for _, num := range nums {\n \
    \       if num < 0 {\n            num = -num\n        }\n        indexSlice =\
    \ append(indexSlice, index)\n        index++\n        valueSlice = append(valueSlice,\
    \ num)\n    }\n    for i := 0; i < len(valueSlice); i++ {\n        for j := i;\
    \ j < len(valueSlice); j++ {\n            if valueSlice[i] > valueSlice[j] {\n\
    \                temp := valueSlice[i]\n                valueSlice[i] = valueSlice[j]\n\
    \                valueSlice[j] = temp\n                temp = indexSlice[i]\n\
    \                indexSlice[i] = indexSlice[j]\n                indexSlice[j]\
    \ = temp\n            }\n        }\n    }\n    for _, index := range indexSlice\
    \ {\n        resultSlice = append(resultSlice, nums[index])\n    }\n    return\
    \ resultSlice\n}\n", "    // Write your code here\n    return []int{}\n}\n", " \
    \   if len(nums) == 0 {\n        return nums\n    }\n    var numsMap = make(map[int][]int)\n\
    \    for i, num := range nums {\n        var sum = sumDigits(num)\n        if\
    \ _, ok := numsMap[sum]; !ok {\n            numsMap[sum] = []int{}\n        }\n\
    \        numsMap[sum] = append(numsMap[sum], i)\n    }\n    var sortedNums = make([]int,\
    \ len(nums))\n    var i = 0\n    for _, indices := range sortKeys(numsMap) {\n\
    \        for _, index := range indices {\n            sortedNums[i] = nums[index]\n\
    \            i++\n        }\n    }\n    return sortedNums\n}\n", "    // Your\
    \ code goes here!\n    return nil\n}\n", "    // First we make a map of number->Sum(Digits(number))\n\
    \    scores := make(map[int]int)\n    for _, num := range nums {\n        var\
    \ sum int\n        for _, digit := range fmt.Sprintf(\"%d\", num) {\n        \
    \    sum += int(digit - '0')\n        }\n        scores[num] = sum\n    }\n\n\
    \    // Then we sort the numbers based on the score\n    var ordered []int\n \
    \   for _, num := range nums {\n        ordered = append(ordered, num)\n    }\n\
    \    for i := 0; i < len(ordered); i++ {\n        for j := 0; j < len(ordered)\
    \ - 1; j++ {\n            if scores[ordered[j]] > scores[ordered[j+1]] {\n   \
    \             ordered[j], ordered[j+1] = ordered[j+1], ordered[j]\n          \
    \  }\n        }\n    }\n    return ordered\n}\n", "    return nums\n}\n", "  \
    \  return []int{}\n}\n", "    return nil\n}\n", "    return nums\n}\n", "    sumArr\
    \ := make([]int, len(nums))\n    for i, v := range nums {\n        sumArr[i] =\
    \ SumOf(v)\n    }\n    mergeSort(nums, sumArr, 0, len(nums)-1)\n    return nums\n\
    }\n", "    for i := 0; i < len(nums) - 1; i++ {\n        for j := i + 1; j < len(nums);\
    \ j++ {\n            if sum(nums[i]) > sum(nums[j]) {\n                nums[i],\
    \ nums[j] = nums[j], nums[i]\n            }\n        }\n    }\n    return nums\n\
    }\n", "    // your code here\n    return nil\n}\n", "    // replace code below\
    \ with your code\n    for i := range nums {\n        for j := range nums {\n \
    \           if nums[i] % 10 + nums[i] / 10 < nums[j] % 10 + nums[j] / 10 {\n \
    \               nums[i], nums[j] = nums[j], nums[i]\n            }\n        }\n\
    \    }\n    return nums\n}\n", "    // # patch here\n    return nums\n}\n", " \
    \   sums := make(map[int]int)\n    for _, num := range nums {\n        digits\
    \ := numToSlice(num)\n        var sum int\n        for _, digit := range digits\
    \ {\n            sum += digit\n        }\n        sums[num] = sum\n    }\n   \
    \ ordered_sums := sliceOfInts(sums)\n    min := minOfSlice(ordered_sums)\n   \
    \ result := make([]int, 0)\n    for i := 0; i < len(ordered_sums); i++ {\n   \
    \     if ordered_sums[i] == min {\n            for key, value := range sums {\n\
    \                if value == min {\n                    result = append(result,\
    \ key)\n                }\n            }\n        }\n    }\n    return result\n\
    }\n", "    var sum [][]int\n    for k,v := range nums {\n        s := 0\n    \
    \    for _,v1 := range fmt.Sprintf(\"%d\", v) {\n            s += int(v1 - '0')\n\
    \        }\n        sum = append(sum, []int{k, s})\n    }\n    for i := 0; i <\
    \ len(sum); i++ {\n        for j := 0; j < len(sum) - i - 1; j++ {\n         \
    \   if sum[j][1] > sum[j+1][1] {\n                sum[j], sum[j+1] = sum[j+1],\
    \ sum[j]\n            }\n        }\n    }\n    res := make([]int, len(nums))\n\
    \    for k,v := range sum {\n        res[k] = nums[v[0]]\n    }\n    return res\n\
    }\n", "    // sort.Slice(nums, func(i, j int) bool {\n    //     return nums[i]\
    \ < nums[j]\n    // })\n    return nums\n}\n", "    if len(nums) == 0 {\n    \
    \    return []int{}\n    }\n\n    for i := 0; i < len(nums); i++ {\n        for\
    \ j := i + 1; j < len(nums); j++ {\n            if sum(nums[i]) > sum(nums[j])\
    \ {\n                nums[i], nums[j] = nums[j], nums[i]\n            }\n    \
    \    }\n    }\n\n    return nums\n}\n", "    // your code here\n    return nums\n\
    }\n", "    return []int{}\n}\n", "    if len(nums) <= 1 {\n        return nums\n\
    \    }\n    pivot := nums[0]\n    l, r := 0, len(nums) - 1\n    for l < r {\n\
    \        for l < r && points(nums[r]) < points(pivot) {\n            r--\n   \
    \     }\n        nums[l] = nums[r]\n        for l < r && points(nums[l]) >= points(pivot)\
    \ {\n            l++\n        }\n        nums[r] = nums[l]\n    }\n    nums[l]\
    \ = pivot\n    order_by_points(nums[:l])\n    order_by_points(nums[l+1:])\n  \
    \  return nums\n}\n", "    var newNums []int\n\n    for _, number := range nums\
    \ {\n        var sumDigits int\n\n        if number < 0 {\n            number\
    \ = number * -1\n        }\n\n        for number > 0 {\n            sumDigits\
    \ += number % 10\n            number /= 10\n        }\n\n        newNums = append(newNums,\
    \ sumDigits)\n    }\n\n    for i := 0; i < len(newNums); i++ {\n        for j\
    \ := 0; j < len(newNums); j++ {\n            if newNums[i] < newNums[j] {\n  \
    \              temp := newNums[i]\n                newNums[i] = newNums[j]\n \
    \               newNums[j] = temp\n\n                temp = nums[i]\n        \
    \        nums[i] = nums[j]\n                nums[j] = temp\n            }\n  \
    \      }\n    }\n\n    return nums\n}\n", "    indices := map[int][]int{}\n  \
    \  for index, value := range nums {\n        digitSum := 0\n        for value\
    \ > 0 {\n            digitSum += value % 10\n            value /= 10\n       \
    \ }\n        indices[digitSum] = append(indices[digitSum], index)\n    }\n   \
    \ output := make([]int, len(nums))\n    index := 0\n    for digitSum, indexes\
    \ := range indices {\n        for _, originalIndex := range indexes {\n      \
    \      output[index] = nums[originalIndex]\n            index++\n        }\n \
    \   }\n    return output\n}\n", "    // sort.SliceStable()\n    fmt.Println(nums)\n\
    \    return nums\n}\n", "    // PATCH: Implement the function\n    return nums\n\
    }\n", "    return []int{}\n}\n", "    // your code here\n    return nil\n}\n",
  "    mapping := map[int][]int{}\n    sumMap := map[int]int{}\n    result := []int{}\n\
    \    for i, n := range nums {\n        mapping[n] = append(mapping[n], i)\n  \
    \      if _, ok := sumMap[n]; !ok {\n            sumMap[n] = getSumOfDigits(n)\n\
    \        }\n    }\n    fmt.Println(mapping)\n    fmt.Println(sumMap)\n    for\
    \ i := 0; i < len(nums); i++ {\n        min := int(^uint(0) >> 1)\n        var\
    \ minN int\n        for _, n := range nums {\n            if len(mapping[n]) ==\
    \ 0 {\n                continue\n            }\n            if _, ok := sumMap[n];\
    \ !ok {\n                sumMap[n] = getSumOfDigits(n)\n            }\n      \
    \      if sumMap[n] < min {\n                min = sumMap[n]\n               \
    \ minN = n\n            }\n        }\n        result = append(result, minN)\n\
    \        delete(mapping, minN)\n    }\n    return result\n}\n", "    // TODO:\
    \ your code here\n    return nums\n}\n", "    // TODO: Implement this function\n\
    \    for i:=0; i<len(nums); i++ {\n        for j:=i+1; j<len(nums); j++ {\n  \
    \          sum_i := getSumOfDigits(nums[i])\n            sum_j := getSumOfDigits(nums[j])\n\
    \            if sum_i > sum_j {\n                nums[i], nums[j] = nums[j], nums[i]\n\
    \            }\n        }\n    }\n    return nums\n}\n", "    return nums\n}\n",
  "    return nil\n}\n", "    sum := make(map[int]int)\n    for i, v := range nums\
    \ {\n        if v < 0 {\n            v = -v\n        }\n        for v > 0 {\n\
    \            sum[i] += v % 10\n            v /= 10\n        }\n    }\n    result\
    \ := make([]int, len(nums))\n    copy(result, nums)\n    for i := 0; i < len(result);\
    \ i++ {\n        for j := i + 1; j < len(result); j++ {\n            if sum[i]\
    \ > sum[j] || (sum[i] == sum[j] && i > j) {\n                result[i], result[j]\
    \ = result[j], result[i]\n                sum[i], sum[j] = sum[j], sum[i]\n  \
    \          }\n        }\n    }\n    return result\n}\n", "    if len(nums) ==\
    \ 0 {\n        return nums\n    }\n    return nums\n}\n", "    // Write your code\
    \ here.\n    return nil\n}\n", "    // assume nums is not nil\n    var order =\
    \ make([]int, len(nums))\n    var sums = make([]int, len(nums))\n    for i, num\
    \ := range nums {\n        sums[i] = sum_of_digits(num)\n    }\n    for i, _ :=\
    \ range order {\n        k := find_min(sums)\n        order[i] = nums[k]\n   \
    \     sums[k] = math.MaxInt64\n    }\n    return order\n}\n", "    sums := make(map[int]int)\n\
    \    for _, v := range nums {\n        sums[v] = sum_of_digits(v)\n    }\n   \
    \ var keys []int\n    for k := range sums {\n        keys = append(keys, k)\n\
    \    }\n    sort_ints(keys, func(i, j int) bool {\n        return sums[keys[i]]\
    \ < sums[keys[j]]\n    })\n    return keys\n}\n", "    // YOUR CODE HERE\n   \
    \ return nil\n}\n", "    return []int{}\n}\n", "    return []int{}\n}\n", "  \
    \  count := len(nums)\n    if count == 0 {\n        return nil\n    }\n    points\
    \ := make([]int, count)\n    index := make([]int, count)\n    for i, num := range\
    \ nums {\n        for num != 0 {\n            points[i] += num % 10\n        \
    \    num /= 10\n        }\n        index[i] = i\n    }\n    for i := 0; i < count;\
    \ i++ {\n        for j := i + 1; j < count; j++ {\n            if points[i] >\
    \ points[j] || (points[i] == points[j] && index[i] > index[j]) {\n           \
    \     points[i], points[j] = points[j], points[i]\n                index[i], index[j]\
    \ = index[j], index[i]\n                nums[i], nums[j] = nums[j], nums[i]\n\
    \            }\n        }\n    }\n    return nums\n}\n", "    // TODO write code\
    \ here\n    return nums\n}\n", "\treturn []int{}\n}\n", "    panic(\"not implemented\"\
    )\n}\n", "    // PATCH: Implement order_by_points\n    return []int{}\n}\n", " \
    \   return make([]int, 0)\n}\n", "    // Your code here\n    return nums\n}\n",
  "    numMap := make(map[int][]int)\n    for index, num := range nums {\n       \
    \ if _, ok := numMap[sumOfDigits(num)]; !ok {\n            numMap[sumOfDigits(num)]\
    \ = []int{}\n        }\n        numMap[sumOfDigits(num)] = append(numMap[sumOfDigits(num)],\
    \ index)\n    }\n    var tmp []int\n    for key := range numMap {\n        tmp\
    \ = append(tmp, key)\n    }\n    // sort.Ints(tmp)\n    qSort(tmp, 0, len(tmp)\
    \ - 1)\n    sortNums := make([]int, len(nums))\n    for _, key := range tmp {\n\
    \        for _, index := range numMap[key] {\n            sortNums[index] = nums[index]\n\
    \        }\n    }\n    return sortNums\n}\n", "    var sort_f = func(a, b int)\
    \ bool {\n        if (a < 0) {\n            a = -a\n        }\n        if (b <\
    \ 0) {\n            b = -b\n        }\n        a1 := a % 10\n        b1 := b %\
    \ 10\n        a2 := a / 10\n        b2 := b / 10\n        return a1 + a2 < b1\
    \ + b2\n    }\n    for i := 0; i < len(nums) - 1; i++ {\n        for j := i +\
    \ 1; j < len(nums); j++ {\n            if sort_f(nums[i], nums[j]) {\n       \
    \         nums[i], nums[j] = nums[j], nums[i]\n            }\n        }\n    }\n\
    \    return nums\n}\n", "    num_lens := len(nums)\n    result := make([]int,\
    \ num_lens)\n    for i := 0; i < num_lens; i++ {\n        result[i] = nums[i]\n\
    \    }\n    for i := 0; i < num_lens; i++ {\n        for j := i + 1; j < num_lens;\
    \ j++ {\n            a := nums[i]\n            b := nums[j]\n            sa :=\
    \ 0\n            sb := 0\n            for a != 0 {\n                sa += a %\
    \ 10\n                a /= 10\n            }\n            for b != 0 {\n     \
    \           sb += b % 10\n                b /= 10\n            }\n           \
    \ if sa > sb {\n                result[i], result[j] = result[j], result[i]\n\
    \            }\n        }\n    }\n    return result\n}\n", "    // your code here\n\
    \    return nil\n}\n", "    var b []int\n    m := make(map[int][]int)\n    for\
    \ i, v := range nums {\n        v_str := fmt.Sprintf(\"%d\", v)\n        var sum\
    \ int\n        for _, r := range v_str {\n            sum += int(r - '0')\n  \
    \      }\n        m[sum] = append(m[sum], v)\n    }\n    for i := 0; ; i++ {\n\
    \        for _, v := range m[i] {\n            b = append(b, v)\n        }\n \
    \       if len(b) == len(nums) {\n            break\n        }\n    }\n    return\
    \ b\n}\n", "    return []int{}\n}\n", "    return nil\n}\n", "    return []int{}\n\
    }\n", "    sort_nums := make([]int, len(nums))\n    copy(sort_nums, nums)\n  \
    \  var tmp int\n    var index int\n    for i := 0; i < len(sort_nums); i++ {\n\
    \        index = i\n        for j := i + 1; j < len(sort_nums); j++ {\n      \
    \      if get_digit_sum(sort_nums[index]) > get_digit_sum(sort_nums[j]) {\n  \
    \              index = j\n            }\n        }\n        tmp = sort_nums[i]\n\
    \        sort_nums[i] = sort_nums[index]\n        sort_nums[index] = tmp\n   \
    \ }\n    return sort_nums\n}\n", "    fmt.Println(nums)\n    return nums\n}\n",
  "    // Write your code here\n    return nums\n}\n", "    return nums\n}\n", " \
    \   // TODO\n    return nums\n}\n", "    // Write your code here\n    return nums\n\
    }\n", "    for i := 0; i < len(nums); i++ {\n        for j := i + 1; j < len(nums);\
    \ j++ {\n            if (getSum(nums[i]) > getSum(nums[j])) {\n              \
    \  nums[i], nums[j] = nums[j], nums[i]\n            }\n        }\n    }\n    return\
    \ nums\n}\n", "    return []int{}\n}\n", "    if len(nums) <= 1 {\n        return\
    \ nums\n    }\n    return nums\n}\n", "    return nums\n}\n", "    // WRITE YOUR\
    \ CODE HERE\n    return nums\n}\n", "    // your code here\n    return nil\n}\n",
  "    return order_by_points_v1(nums)\n}\n", "    for i := range nums {\n       \
    \ for j := range nums {\n            if sum(nums[i]) < sum(nums[j]) {\n      \
    \          tmp := nums[i]\n                nums[i] = nums[j]\n               \
    \ nums[j] = tmp\n            }\n        }\n    }\n    return nums\n}\n", "   \
    \ panic(\"Not implemented\")\n}\n", "    return nil\n}\n", "    var res []int\n\
    \    for len(nums) > 0 {\n        var curMin int\n        for _, v := range nums\
    \ {\n            if curMin > v {\n                curMin = v\n            }\n\
    \        }\n        var index int\n        for i, v := range nums {\n        \
    \    if v == curMin {\n                index = i\n                break\n    \
    \        }\n        }\n        res = append(res, curMin)\n        nums = append(nums[:index],\
    \ nums[index+1:]...)\n    }\n    return res\n}\n", "    if nums == nil {\n   \
    \     return nil\n    }\n    if len(nums) == 0 {\n        return nil\n    }\n\
    \    fmt.Println(nums)\n    for i := 0; i < len(nums); i++ {\n        for j :=\
    \ i; j < len(nums); j++ {\n            n1 := getSum(nums[i])\n            n2 :=\
    \ getSum(nums[j])\n            if n1 > n2 {\n                nums[i], nums[j]\
    \ = nums[j], nums[i]\n            }\n        }\n    }\n    return nums\n}\n",
  "    numMap := make(map[int][]int)\n    for i, n := range nums {\n        sum :=\
    \ 0\n        for n > 0 {\n            sum += n % 10\n            n /= 10\n   \
    \     }\n        numMap[sum] = append(numMap[sum], i)\n    }\n    sortedIdx :=\
    \ make([]int, len(nums))\n    i := 0\n    for _, v := range numMap {\n       \
    \ for _, idx := range v {\n            sortedIdx[i] = idx\n            i++\n \
    \       }\n    }\n    sortedNums := make([]int, len(nums))\n    for i, idx :=\
    \ range sortedIdx {\n        sortedNums[i] = nums[idx]\n    }\n    return sortedNums\n\
    }\n", "    return nums\n}\n", "    return nums\n}\n", "    // generate a new array\
    \ to return results\n    var newArr []int\n    // if array length is 0 or 1, return\
    \ the original array\n    if len(nums) <= 1 {\n        return nums\n    }\n  \
    \  // loop the array\n    for i := 0; i < len(nums); i++ {\n        // loop the\
    \ new array\n        for j := 0; j < len(newArr); j++ {\n            // if the\
    \ sum of newArray is bigger than the new number,\n            // put the new number\
    \ before the old number\n            if sum(newArr[j]) > sum(nums[i]) {\n    \
    \            newArr = append(newArr[:j], append([]int{nums[i]}, newArr[j:]...)...)\n\
    \                break\n            }\n            // if the sum of newArray is\
    \ equal to the new number,\n            // put the new number before the old number\
    \ if\n            // the index of the new number is smaller than the old number\n\
    \            if sum(newArr[j]) == sum(nums[i]) {\n                if i < findIndex(nums,\
    \ newArr[j]) {\n                    newArr = append(newArr[:j], append([]int{nums[i]},\
    \ newArr[j:]...)...)\n                    break\n                }\n         \
    \   }\n            // if it is the last one, append the new number to new array\n\
    \            if j == len(newArr) - 1 {\n                newArr = append(newArr,\
    \ nums[i])\n                break\n            }\n        }\n        // if the\
    \ new array has not been created, append the first number to new array\n     \
    \   if len(newArr) == 0 {\n            newArr = append(newArr, nums[i])\n    \
    \    }\n    }\n    return newArr\n}\n", "    //TODO your code here\n    return\
    \ nums\n}\n", "    if len(nums) == 0 {\n        return nums\n    }\n    var sum\
    \ []int\n    for i := 0; i < len(nums); i++ {\n        if nums[i] < 0 {\n    \
    \        sum = append(sum, -(getSum(-nums[i])))\n        } else {\n          \
    \  sum = append(sum, getSum(nums[i]))\n        }\n    }\n    fmt.Println(sum)\n\
    \    fmt.Println(nums)\n    for i := 0; i < len(nums); i++ {\n        for j :=\
    \ i + 1; j < len(nums); j++ {\n            if sum[i] > sum[j] {\n            \
    \    temp := sum[i]\n                sum[i] = sum[j]\n                sum[j] =\
    \ temp\n                temp = nums[i]\n                nums[i] = nums[j]\n  \
    \              nums[j] = temp\n            }\n        }\n    }\n    return nums\n\
    }\n", "    var numsOrderByPoints []int\n\n    return numsOrderByPoints\n}\n",
  "    return []int{}\n}\n", "    sum_digits := make(map[int]int)\n    for _, num\
    \ := range nums {\n        sum_digits[num] = 0\n        for _, digit := range\
    \ fmt.Sprintf(\"%d\", num) {\n            sum_digits[num] += int(digit - '0')\n\
    \        }\n    }\n    for i := 0; i < len(nums); i++ {\n        for j := i +\
    \ 1; j < len(nums); j++ {\n            if sum_digits[nums[i]] > sum_digits[nums[j]]\
    \ {\n                nums[i], nums[j] = nums[j], nums[i]\n            }\n    \
    \    }\n    }\n    return nums\n}\n", "    // your code here\n    return nums\n\
    }\n", "    sums := make(map[int]int)\n    for _, n := range nums {\n        sum\
    \ := n\n        if n < 0 {\n            sum = n * -1\n        }\n        sums[n]\
    \ = sum\n    }\n    points := make(map[int]int)\n    for _, s := range sums {\n\
    \        sum := 0\n        for _, n := range fmt.Sprintf(\"%d\", s) {\n      \
    \      sum += int(n - '0')\n        }\n        points[s] = sum\n    }\n    for\
    \ i := 0; i < len(nums); i++ {\n        for j := i + 1; j < len(nums); j++ {\n\
    \            if points[nums[i]] > points[nums[j]] {\n                continue\n\
    \            } else if points[nums[i]] == points[nums[j]] {\n                if\
    \ nums[i] > nums[j] {\n                    continue\n                }\n     \
    \       }\n            nums[i], nums[j] = nums[j], nums[i]\n        }\n    }\n\
    \    return nums\n}\n", "    return nums\n}\n", "    sum_nums := make(map[int]int)\n\
    \    for i, n := range nums {\n        sum_nums[i] = sum_digits(n)\n    }\n  \
    \  quick_sort(nums, sum_nums, 0, len(nums)-1)\n    return nums\n}\n", "    if\
    \ nums == nil {\n        return []int{}\n    }\n    type abc ", "    var res []int\n\
    \    counts := make(map[int]int)\n    if len(nums) == 0 {\n        return res\n\
    \    }\n    for i, val := range nums {\n        cnt := digit_sum(val)\n      \
    \  if _, ok := counts[cnt]; !ok {\n            counts[cnt] = i\n        }\n  \
    \  }\n    for _, val := range nums {\n        cnt := digit_sum(val)\n        res\
    \ = append(res, nums[counts[cnt]])\n        counts[cnt]++\n    }\n    return res\n\
    }\n", "    if nums == nil {\n        return nil\n    }\n    if len(nums) == 0\
    \ {\n        return []int{}\n    }\n    for i:=0; i<len(nums); i++ {\n       \
    \ for j:=i+1; j<len(nums); j++ {\n            if nums[i] > nums[j] {\n       \
    \         nums[i], nums[j] = nums[j], nums[i]\n            }\n        }\n    }\n\
    \    return nums\n}\n", "    if nums == nil {\n        return nil\n    }\n   \
    \ if len(nums) < 2 {\n        return nums\n    }\n    list := make([]int, len(nums))\n\
    \    copy(list, nums)\n    values := make([]int, len(nums))\n    for index, n\
    \ := range list {\n        value := 0\n        for n != 0 {\n            value\
    \ += n % 10\n            n /= 10\n        }\n        values[index] = value\n \
    \   }\n    // bubble sort\n    for i := 0; i < len(list); i++ {\n        for j\
    \ := 0; j < len(list) - i - 1; j++ {\n            if values[j] > values[j + 1]\
    \ {\n                list[j], list[j + 1] = list[j + 1], list[j]\n           \
    \     values[j], values[j + 1] = values[j + 1], values[j]\n            }\n   \
    \     }\n    }\n    return list\n}\n", "    return nil\n}\n", "\tvar point []int\n\
    \tvar order_nums []int\n\tfor i, x := range nums {\n\t\tsum := calc_sum(x)\n\t\
    \tpoint = append(point, sum)\n\t\tif i == 0 {\n\t\t\torder_nums = append(order_nums,\
    \ x)\n\t\t} else {\n\t\t\tvar p_i int\n\t\t\tvar p_x int\n\t\t\tfor j, p := range\
    \ point {\n\t\t\t\tif j == i {\n\t\t\t\t\tp_x = p\n\t\t\t\t} else {\n\t\t\t\t\t\
    p_i = p\n\t\t\t\t}\n\t\t\t}\n\t\t\tif p_x < p_i {\n\t\t\t\torder_nums = append(order_nums,\
    \ x)\n\t\t\t} else {\n\t\t\t\torder_nums = append([]int{x}, order_nums...)\n\t\
    \t\t}\n\t\t}\n\t}\n\treturn order_nums\n}\n", "    return []int{}\n}\n", "   \
    \ // Write your code here\n    return []int{}\n}\n", "    var arr []int\n    fmt.Println(nums)\n\
    \    for i, item := range nums {\n        sum := 0\n        for ; item > 0; item\
    \ /= 10 {\n            sum += item % 10\n        }\n        arr = append(arr,\
    \ sum)\n        fmt.Println(arr)\n    }\n    for i := 0; i < len(arr)-1; i++ {\n\
    \        for j := i + 1; j < len(arr); j++ {\n            if arr[i] > arr[j] {\n\
    \                arr[i], arr[j] = arr[j], arr[i]\n                nums[i], nums[j]\
    \ = nums[j], nums[i]\n            }\n        }\n    }\n    return nums\n}\n",
  "    res := []int{}\n    m := map[int][]int{}\n    for i, v := range nums {\n  \
    \      m[sumDigits(v)] = append(m[sumDigits(v)], i)\n    }\n    for i := 0; i\
    \ < len(nums); i++ {\n        for j := 0; j < len(m[i]); j++ {\n            res\
    \ = append(res, nums[m[i][j]])\n        }\n    }\n    return res\n}\n", "    maxP\
    \ := 0\n    for _, n := range nums {\n        if p := points(n); p > maxP {\n\
    \            maxP = p\n        }\n    }\n    bucket := make([][]int, maxP+1)\n\
    \    for _, n := range nums {\n        p := points(n)\n        bucket[p] = append(bucket[p],\
    \ n)\n    }\n    ret := make([]int, 0, len(nums))\n    for _, b := range bucket\
    \ {\n        ret = append(ret, b...)\n    }\n    return ret\n}\n", "    return\
    \ order_by_points(nums)\n}\n", "    fmt.Println(nums)\n    return nums\n}\n",
  "    //write your code here\n    return nums\n}\n", "    if nums == nil {\n    \
    \    return []int{}\n    }\n    numMap := make(map[int]int)\n    for _, num :=\
    \ range nums {\n        numMap[num] = sum(num)\n    }\n    sort(nums, numMap)\n\
    \    return nums\n}\n", "\t// check if nums is empty\n\tif len(nums) == 0 {\n\t\
    \treturn nil\n\t}\n\n\t// convert every element in nums to array of integers\n\
    \tfor i, v := range nums {\n\t\tnums[i] = v / 10\n\t}\n\n\t// implement bubble\
    \ sort algorithm\n\tfor i := 0; i < len(nums)-1; i++ {\n\t\tfor j := 0; j < len(nums)-i-1;\
    \ j++ {\n\t\t\tif nums[j] > nums[j+1] {\n\t\t\t\ttemp := nums[j]\n\t\t\t\tnums[j]\
    \ = nums[j+1]\n\t\t\t\tnums[j+1] = temp\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nums\n\
    }\n", "\tmap_num := make(map[int]int)\n\tfor i := 0; i < len(nums); i++ {\n\t\t\
    n := nums[i]\n\t\tif n < 0 {\n\t\t\tn = -n\n\t\t}\n\t\ts := 0\n\t\tfor n > 0 {\n\
    \t\t\ts += n % 10\n\t\t\tn /= 10\n\t\t}\n\t\tmap_num[i] = s\n\t}\n\tlist := make([]int,\
    \ len(nums))\n\tfor i := 0; i < len(nums); i++ {\n\t\tlist[i] = i\n\t}\n\tfmt.Println(map_num)\n\
    \tquick_sort_int(list, map_num, 0, len(list) - 1)\n\tfmt.Println(list)\n\tres\
    \ := make([]int, len(nums))\n\tfor i := 0; i < len(nums); i++ {\n\t\tres[i] =\
    \ nums[list[i]]\n\t}\n\treturn res\n}\n", "    return []int{}\n}\n", "    for\
    \ i, _ := range nums {\n        for j, _ := range nums {\n            if GetDigitSum(nums[i])\
    \ < GetDigitSum(nums[j]) {\n                // Swap\n                nums[i],\
    \ nums[j] = nums[j], nums[i]\n            }\n        }\n    }\n    return nums\n\
    }\n", "    // If no numbers, leave the slice unaltered.\n    if len(nums) == 0\
    \ {\n        return nums\n    }\n\n    // Create a new slice holding key:value\
    \ pairs of sum:index for the input slice.\n    sum_map := make([]map[int]int,\
    \ len(nums))\n    for i, num := range nums {\n        sum := sum_digits(num)\n\
    \        sum_map[i] = map[int]int{sum: i}\n    }\n\n    // Sort the slice of maps\
    \ by keys.\n    sort_by_key(sum_map)\n\n    // Create a new slice with the sorted\
    \ keys and return it.\n    sorted_nums := make([]int, len(nums))\n    for i, m\
    \ := range sum_map {\n        for k, _ := range m {\n            sorted_nums[i]\
    \ = nums[k]\n        }\n    }\n    return sorted_nums\n}\n", "    // YOUR CODE\
    \ HERE\n    return nil\n}\n", "    fmt.Println(nums)\n    return nums\n}\n", " \
    \   if nums == nil {\n        return nil\n    }\n    if len(nums) == 0 {\n   \
    \     return nil\n    }\n    var (\n        n   = len(nums)\n        sum []int\n\
    \    )\n    for i := 0; i < n; i++ {\n        sum = append(sum, getSum(nums[i]))\n\
    \    }\n    for i := 0; i < n-1; i++ {\n        for j := i+1; j < n; j++ {\n \
    \           if sum[i] > sum[j] {\n                swap(sum, i, j)\n          \
    \      swap(nums, i, j)\n            }\n        }\n    }\n    return nums\n}\n",
  "    // your code here\n    return nums\n}\n", "    for i := 0; i < len(nums); i++\
    \ {\n        for j := len(nums) - 1; j > i; j-- {\n            if sum(nums[j-1])\
    \ > sum(nums[j]) {\n                nums[j-1], nums[j] = nums[j], nums[j-1]\n\
    \            }\n        }\n    }\n    return nums\n}\n", "    m := map[int][]int{}\n\
    \    for i, v := range nums {\n        s := 0\n        for v > 0 {\n         \
    \   s += v % 10\n            v /= 10\n        }\n        if l, ok := m[s]; ok\
    \ {\n            m[s] = append(l, i)\n        } else {\n            m[s] = []int{i}\n\
    \        }\n    }\n    for i := 1; i < len(m); i++ {\n        for j := 0; j <\
    \ len(m) - i; j++ {\n            if m[j][0] > m[j + 1][0] {\n                m[j],\
    \ m[j + 1] = m[j + 1], m[j]\n            }\n        }\n    }\n    n := make([]int,\
    \ len(nums))\n    i := 0\n    for _, v := range m {\n        for _, e := range\
    \ v {\n            n[i] = nums[e]\n            i++\n        }\n    }\n    return\
    \ n\n}\n", "    d := make(map[int][]int)\n    for i, n := range nums {\n     \
    \   sum := sum_digits(n)\n        if _, ok := d[sum]; !ok {\n            d[sum]\
    \ = []int{}\n        }\n        d[sum] = append(d[sum], i)\n    }\n    m := make(map[int]int)\n\
    \    var keys []int\n    for k := range d {\n        keys = append(keys, k)\n\
    \    }\n    sort.Ints(keys)\n    for i, k := range keys {\n        for _, pos\
    \ := range d[k] {\n            m[pos] = i\n        }\n    }\n    sort.Slice(nums,\
    \ func(i, j int) bool {\n        return m[i] < m[j]\n    })\n    return nums\n\
    }\n", "    numMap := make(map[int][]int)\n    for idx, n := range nums {\n   \
    \     digitSum := 0\n        for _, digit := range fmt.Sprintf(\"%d\", n) {\n\
    \            digitSum += int(digit - '0')\n        }\n        numMap[digitSum]\
    \ = append(numMap[digitSum], idx)\n    }\n    digitSums := make([]int, 0, len(numMap))\n\
    \    for digitSum := range numMap {\n        digitSums = append(digitSums, digitSum)\n\
    \    }\n    insertionSort(digitSums)\n    sorted := make([]int, len(nums))\n \
    \   for _, digitSum := range digitSums {\n        for _, idx := range numMap[digitSum]\
    \ {\n            sorted[idx] = nums[idx]\n        }\n    }\n    return sorted\n\
    }\n", "    return nums\n}\n", "    for i, _ := range nums {\n        for j, _\
    \ := range nums {\n            if sum_digits(nums[i]) < sum_digits(nums[j]) {\n\
    \                nums[i], nums[j] = nums[j], nums[i]\n            }\n        }\n\
    \    }\n    return nums\n}\n", "\tfmt.Println(nums)\n\tfor i := 0; i < len(nums);\
    \ i++ {\n\t\tfor j := i + 1; j < len(nums); j++ {\n\t\t\tsum1 := sumOfDigits(nums[i])\n\
    \t\t\tsum2 := sumOfDigits(nums[j])\n\t\t\tif sum1 > sum2 {\n\t\t\t\tnums[i], nums[j]\
    \ = nums[j], nums[i]\n\t\t\t}\n\t\t}\n\t}\n\treturn nums\n}\n", "    // your code\
    \ here\n    n := len(nums)\n    if n <= 1 {\n        return nums\n    }\n    for\
    \ i := 0; i < n-1; i++ {\n        for j := 0; j < n-1-i; j++ {\n            if\
    \ sumDigits(nums[j]) > sumDigits(nums[j+1]) {\n                nums[j], nums[j+1]\
    \ = nums[j+1], nums[j]\n            }\n        }\n    }\n    return nums\n}\n",
  "    return nil\n}\n", "    // YOUR CODE HERE\n    panic(\"Not implemented\")\n\
    }\n", "    // TODO: implement this function\n    return nil\n}\n", "    if len(nums)\
    \ == 0 {\n        return []int{}\n    }\n    var nums_map = make(map[int][]int)\n\
    \    for index, i := range nums {\n        key := 0\n        if i >= 0 {\n   \
    \         key = i % 10 + i / 10\n        } else {\n            key = i % 10 -\
    \ i / 10\n        }\n        nums_map[key] = append(nums_map[key], i)\n    }\n\
    \    var keys []int\n    for k := range nums_map {\n        keys = append(keys,\
    \ k)\n    }\n    bubble_sort(keys)\n    var result []int\n    for _, k := range\
    \ keys {\n        for _, v := range nums_map[k] {\n            result = append(result,\
    \ v)\n        }\n    }\n    return result\n}\n", "    panic(\"Implement me!\"\
    )\n}\n", "    var result []int\n    if len(nums) == 0 {\n        return result\n\
    \    }\n\n    points := make(map[int]int)\n    for _, num := range nums {\n  \
    \      points[num] = sumDigits(num)\n    }\n\n    var pointList []Point\n    for\
    \ k, v := range points {\n        pointList = append(pointList, Point{k, v})\n\
    \    }\n\n    quickSort(pointList, 0, len(pointList)-1)\n\n    for _, point :=\
    \ range pointList {\n        result = append(result, point.Val)\n    }\n\n   \
    \ return result\n}\n", "    return nums\n}\n", "    // If nums is empty, return\
    \ it\n    if len(nums) == 0 {\n        return nums\n    }\n\n    // Create a dictionary\
    \ to hold the digit sums for each number\n    digitSums := make(map[int]int)\n\
    \n    // Loop through the list of integers\n    for i := 0; i < len(nums); i++\
    \ {\n        // Get the current number\n        num := nums[i]\n\n        // Loop\
    \ through the number to get the digit sum\n        digitSum := 0\n        for\
    \ num > 0 {\n            digitSum += num % 10\n            num /= 10\n       \
    \ }\n\n        // Insert the digit sum into the dictionary\n        digitSums[i]\
    \ = digitSum\n    }\n\n    // Create a bubble sort function to sort the array\n\
    \    sort := func(left, right int) bool {\n        // Determine if the left digit\
    \ sum is less than the right digit sum\n        if digitSums[left] < digitSums[right]\
    \ {\n            return true\n        } else if digitSums[left] == digitSums[right]\
    \ {\n            // If equal, determine if the left index is less than the right\
    \ index\n            return left < right\n        } else {\n            return\
    \ false\n        }\n    }\n\n    // Sort the list of integers\n    bubbleSort(sort,\
    \ len(nums), nums)\n\n    // Return the sorted list\n    return nums\n}\n", " \
    \   // PATCH !!!\n    return []int{}\n}\n", "    // TODO: implement\n    return\
    \ nil\n}\n\n//#############################################################\n\
    //#                        MY SOLUTIONS                       #\n//#############################################################\n\
    \n\n", "\tif len(nums) == 0 {\n\t\treturn nums\n\t}\n\tnum_sum := make(map[int]int)\n\
    \tsum := 0\n\tfor _, n := range nums {\n\t\tsum = 0\n\t\tfor n != 0 {\n\t\t\t\
    sum += n % 10\n\t\t\tn /= 10\n\t\t}\n\t\tnum_sum[sum] = num_sum[sum] + 1\n\t}\n\
    \tpoints := make([]int, 0, len(num_sum))\n\tfor k, _ := range num_sum {\n\t\t\
    points = append(points, k)\n\t}\n\tsort.Ints(points)\n\tres := make([]int, len(nums))\n\
    \tidx := 0\n\tfor _, p := range points {\n\t\tfor i := 0; i < num_sum[p]; i++\
    \ {\n\t\t\tres[idx] = nums[i]\n\t\t\tidx++\n\t\t}\n\t}\n\treturn res\n}\n", " \
    \   // BEGIN\n    // END\n}\n", "    return nums\n}\n", "    l := len(nums)\n\
    \    if l <= 1 {\n        return nums\n    }\n    for i := 0; i < l; i++ {\n \
    \       for j := i + 1; j < l; j++ {\n            if get_sum(nums[i]) > get_sum(nums[j])\
    \ {\n                nums[i], nums[j] = nums[j], nums[i]\n            }\n    \
    \    }\n    }\n    return nums\n}\n", "    // copy the given list of integers\n\
    \    ordered := make([]int, len(nums))\n    copy(ordered, nums)\n\n    // create\
    \ an ordered list of sums of their digits\n    sums := make([]int, len(nums))\n\
    \    for i, num := range nums {\n        for num != 0 {\n            sums[i] +=\
    \ num % 10\n            num /= 10\n        }\n    }\n\n    // sort the given list\
    \ by the list of sums\n    for i := 0; i < len(ordered); i++ {\n        min :=\
    \ i\n        for j := i + 1; j < len(ordered); j++ {\n            if sums[j] <\
    \ sums[min] {\n                min = j\n            }\n        }\n        sums[i],\
    \ sums[min] = sums[min], sums[i]\n        ordered[i], ordered[min] = ordered[min],\
    \ ordered[i]\n    }\n\n    return ordered\n}\n", "    if len(nums) == 0 {\n  \
    \      return []int{}\n    }\n    sorted_nums := make([]int, len(nums))\n    copy(sorted_nums,\
    \ nums)\n    sum_digits := make([]int, len(nums))\n    for index, num := range\
    \ nums {\n        sum_digits[index] = sum_digit(num)\n    }\n    for i := range\
    \ sorted_nums {\n        for j := 0; j < len(sorted_nums)-1; j++ {\n         \
    \   if sum_digits[j] > sum_digits[j+1] {\n                sum_digits[j], sum_digits[j+1]\
    \ = sum_digits[j+1], sum_digits[j]\n                sorted_nums[j], sorted_nums[j+1]\
    \ = sorted_nums[j+1], sorted_nums[j]\n            }\n        }\n    }\n    return\
    \ sorted_nums\n}\n", "    return []int{}\n}\n", "\tif nums == nil {\n\t\treturn\
    \ nil\n\t}\n\tif len(nums) == 0 {\n\t\treturn []int{}\n\t}\n\tfor i := 0; i <\
    \ len(nums); i++ {\n\t\ttemp := nums[i]\n\t\tsum := getSum(temp)\n\t\tindex :=\
    \ i\n\t\tfor j := i + 1; j < len(nums); j++ {\n\t\t\tif getSum(nums[j]) < sum\
    \ {\n\t\t\t\tsum = getSum(nums[j])\n\t\t\t\tindex = j\n\t\t\t}\n\t\t}\n\t\tif\
    \ index != i {\n\t\t\tnums[i] = nums[index]\n\t\t\tnums[index] = temp\n\t\t}\n\
    \t}\n\treturn nums\n}\n", "    return []int{}\n}\n", "    return nil\n}\n", " \
    \   // convert each int to an array of ints\n    var ints [][]int\n    for _,\
    \ v := range nums {\n        ints = append(ints, int_to_slice(v))\n    }\n   \
    \ // sort the ints\n    for i := 0; i < len(ints); i++ {\n        for j := i +\
    \ 1; j < len(ints); j++ {\n            if sum(ints[i]) > sum(ints[j]) {\n    \
    \            temp := ints[i]\n                ints[i] = ints[j]\n            \
    \    ints[j] = temp\n            }\n        }\n    }\n    // convert back to ints\n\
    \    var sorted []int\n    for _, v := range ints {\n        sorted = append(sorted,\
    \ slice_to_int(v))\n    }\n    return sorted\n}\n", "    if len(nums) < 2 {\n\
    \        return nums\n    }\n    pointMap := make(map[int][]int)\n    for i, n\
    \ := range nums {\n        p := getPoint(n)\n        if pointMap[p] == nil {\n\
    \            pointMap[p] = []int{}\n        }\n        pointMap[p] = append(pointMap[p],\
    \ i)\n    }\n    sortedList := make([]int, len(nums))\n    for i, p := range sortMapKeys(pointMap)\
    \ {\n        for _, idx := range pointMap[p] {\n            sortedList[i] = nums[idx]\n\
    \            i++\n        }\n    }\n    return sortedList\n}\n", "    // PATCH:\
    \ Implement order_by_points function\n    return []int{}\n}\n", "    // New map\
    \ to store the sum of each integer.\n    sums := make(map[int]int)\n    for _,\
    \ num := range nums {\n        num = abs(num)\n        sum := 0\n        for num\
    \ > 0 {\n            sum += num % 10\n            num /= 10\n        }\n     \
    \   sums[sum] = sum\n    }\n\n    // Generate a list of all the keys in the map.\n\
    \    keys := make([]int, 0, len(sums))\n    for k := range sums {\n        keys\
    \ = append(keys, k)\n    }\n\n    // Sort the keys ascendingly.\n    // For example,\
    \ the sum of the keys will be [1, 2, 4, 10].\n    sort(keys)\n\n    // Append\
    \ all values to the new list.\n    newList := make([]int, 0, len(nums))\n    for\
    \ _, k := range keys {\n        // Find the integer that matches to the sum of\
    \ the key,\n        // and append it to the new list.\n        for _, v := range\
    \ nums {\n            sum := 0\n            num := abs(v)\n            for num\
    \ > 0 {\n                sum += num % 10\n                num /= 10\n        \
    \    }\n            if sum == k {\n                newList = append(newList, v)\n\
    \            }\n        }\n    }\n\n    return newList\n}\n", "    // TODO: implement\
    \ this function\n    return nil\n}\n", "    if len(nums) == 0 {\n        return\
    \ []int{}\n    }\n\n    numsMap := make(map[int][]int)\n    for idx, num := range\
    \ nums {\n        sumOfDigits := getSumOfDigits(num)\n        numsMap[sumOfDigits]\
    \ = append(numsMap[sumOfDigits], num)\n    }\n\n    for _, nums := range numsMap\
    \ {\n        for i := len(nums)/2 - 1; i >= 0; i-- {\n            reverse(nums,\
    \ i)\n        }\n    }\n\n    var sortedNums []int\n    for index := 0; len(sortedNums)\
    \ < len(nums); index++ {\n        sortedNums = append(sortedNums, numsMap[index]...)\n\
    \    }\n\n    return sortedNums\n}\n", "\t\n\treturn nums\n}\n", "    if len(nums)\
    \ == 0 {\n        return nums\n    }\n    // sort list by points\n    for i :=\
    \ 0; i < len(nums); i++ {\n        for j := i; j < len(nums); j++ {\n        \
    \    if SumOfDigits(nums[i]) > SumOfDigits(nums[j]) {\n                nums[i],\
    \ nums[j] = nums[j], nums[i]\n            }\n        }\n    }\n    // sort list\
    \ if sum is equal\n    for i := 0; i < len(nums); i++ {\n        for j := i; j\
    \ < len(nums); j++ {\n            if SumOfDigits(nums[i]) == SumOfDigits(nums[j])\
    \ && nums[i] > nums[j] {\n                nums[i], nums[j] = nums[j], nums[i]\n\
    \            }\n        }\n    }\n    return nums\n}\n", "    return nil\n}\n",
  "    return nums\n}\n", "    // YOUR CODE HERE\n    return nums\n}\n", "    temp\
    \ := make(map[int][]int)\n    for i, v := range nums {\n        n := abs(v)\n\
    \        var s int\n        for n > 0 {\n            s += n % 10\n           \
    \ n /= 10\n        }\n        if _, ok := temp[s]; !ok {\n            temp[s]\
    \ = make([]int, 0)\n        }\n        temp[s] = append(temp[s], i)\n    }\n \
    \   keys := make([]int, 0)\n    for k, _ := range temp {\n        keys = append(keys,\
    \ k)\n    }\n    sort(keys)\n    result := make([]int, len(nums))\n    for _,\
    \ k := range keys {\n        for _, i := range temp[k] {\n            result[i]\
    \ = nums[i]\n        }\n    }\n    return result\n}\n", "    return nil\n}\n",
  "    // write your code in Go 1.4\n    var result []int\n    var mapPoints = make(map[int]int)\n\
    \    var points []int\n    for i, v := range nums {\n        points = append(points,\
    \ sumDigits(v))\n        mapPoints[points[i]] = i\n    }\n    fmt.Println(points)\n\
    \    fmt.Println(mapPoints)\n    points = sort(points)\n    fmt.Println(points)\n\
    \    for _, v := range points {\n        result = append(result, nums[mapPoints[v]])\n\
    \    }\n    return result\n}\n", "    // result := make([]int, len(nums))\n  \
    \  // for i, _ := range result {\n    //     result[i] = -1\n    // }\n    //\
    \ var digits_sum []int\n    // for _, num := range nums {\n    //     digits_sum\
    \ = append(digits_sum, sum_digits(num))\n    // }\n    // fmt.Println(digits_sum)\n\
    \    // for i, sum := range digits_sum {\n    //     for j, _ := range result\
    \ {\n    //         if sum == 0 {\n    //             result[j] = nums[i]\n  \
    \  //             break\n    //         }\n    //         if sum > 0 && result[j]\
    \ == -1 {\n    //             result[j] = nums[i]\n    //             break\n\
    \    //         }\n    //         if sum > 0 && result[j] != -1 && sum_digits(result[j])\
    \ > sum {\n    //             result = insert(result, j, nums[i])\n    //    \
    \         break\n    //         }\n    //     }\n    // }\n    // return result\n\
    \    return nums\n}\n", "    return nil\n}\n", "    res := make([]int, len(nums))\n\
    \    index := make([]int, len(nums))\n    for i := 0; i < len(nums); i++ {\n \
    \       res[i] = sum_digits(nums[i])\n        index[i] = i\n    }\n    fmt.Println(res)\n\
    \    fmt.Println(index)\n    // Bubble Sort\n    for i := 0; i < len(res); i++\
    \ {\n        for j := 0; j < len(res)-i-1; j++ {\n            if res[j] > res[j+1]\
    \ {\n                // swap elements\n                swap(&res[j], &res[j+1])\n\
    \                swap(&index[j], &index[j+1])\n            }\n        }\n    }\n\
    \    fmt.Println(res)\n    fmt.Println(index)\n    for i := 0; i < len(index);\
    \ i++ {\n        res[i] = nums[index[i]]\n    }\n    return res\n}\n", "    res\
    \ := make([]int, len(nums))\n    copy(res, nums)\n    if len(res) == 0 {\n   \
    \     return res\n    }\n    for i := 0; i < len(res) - 1; i++ {\n        for\
    \ j := i + 1; j < len(res); j++ {\n            if sum(res[i]) > sum(res[j]) {\n\
    \                res[i], res[j] = res[j], res[i]\n            }\n        }\n \
    \   }\n    return res\n}\n", "    return nums\n}\n", "    if len(nums) == 0 {\n\
    \        return []int{}\n    }\n    // Calculate the sum of digits\n    sum_digits\
    \ := []int{}\n    for _, num := range nums {\n        sum_digits = append(sum_digits,\
    \ sumDigits(num))\n    }\n    // Use map to store digits and index\n    sum_digits_map\
    \ := map[int][]int{}\n    for i, sum_digit := range sum_digits {\n        if sum_digits_map[sum_digit]\
    \ == nil {\n            sum_digits_map[sum_digit] = []int{}\n        }\n     \
    \   sum_digits_map[sum_digit] = append(sum_digits_map[sum_digit], i)\n    }\n\
    \    // Sort keys of map\n    sum_digits_key := []int{}\n    for key, _ := range\
    \ sum_digits_map {\n        sum_digits_key = append(sum_digits_key, key)\n   \
    \ }\n    for i := 0; i < len(sum_digits_key) - 1; i++ {\n        for j := i +\
    \ 1; j < len(sum_digits_key); j++ {\n            if sum_digits_key[i] > sum_digits_key[j]\
    \ {\n                sum_digits_key[i], sum_digits_key[j] = sum_digits_key[j],\
    \ sum_digits_key[i]\n            }\n        }\n    }\n    // Get the sorted index\
    \ of numbers\n    sorted_index := []int{}\n    for _, key := range sum_digits_key\
    \ {\n        sorted_index = append(sorted_index, sum_digits_map[key]...)\n   \
    \ }\n    // Get the sorted result\n    result := []int{}\n    for _, index :=\
    \ range sorted_index {\n        result = append(result, nums[index])\n    }\n\
    \    return result\n}\n", "    return nums\n}\n", "    for i := 0; i < len(nums);\
    \ i++ {\n        for j := i + 1; j < len(nums); j++ {\n            if sumDigits(nums[i])\
    \ > sumDigits(nums[j]) {\n                nums[i], nums[j] = nums[j], nums[i]\n\
    \            }\n        }\n    }\n    return nums\n}\n", "    // your code here\n\
    \    return nums\n}\n", "    return nums\n}\n", "    // your code here\n    return\
    \ nums\n}\n", "    ds := make(map[int][]int)\n    for i, x := range nums {\n \
    \       n := x\n        s := 0\n        for n != 0 {\n            s += n % 10\n\
    \            n /= 10\n        }\n        ds[s] = append(ds[s], i)\n    }\n   \
    \ result := make([]int, len(nums))\n    for k, v := range ds {\n        for _,\
    \ i := range v {\n            result[i] = k\n        }\n    }\n    return result\n\
    }\n", "    return []int{}\n}\n", "    // TODO - Add your code here\n    return\
    \ nil\n}\n", "\tif len(nums) == 0 {\n\t\treturn nums\n\t}\n\treturn order_by_pointsHelper(nums,\
    \ 0, len(nums)-1)\n}\n", "    // PATCH: Implement\n    // BEGIN\n    if len(nums)\
    \ == 0 {\n        return nums\n    }\n    var points []int\n    for _, v := range\
    \ nums {\n        points = append(points, sumDigits(v))\n    }\n    var result\
    \ []int\n    for len(result) < len(nums) {\n        best := 0\n        var index\
    \ int\n        for i, v := range points {\n            if v > best {\n       \
    \         best = v\n                index = i\n            }\n        }\n    \
    \    result = append(result, nums[index])\n        points[index] = -1\n    }\n\
    \    return result\n    // END\n}\n", "    if len(nums) <= 1 {\n        return\
    \ nums\n    }\n    // 1. find the max sum of digits\n    sumOfDigits := make([]int,\
    \ len(nums))\n    maxSumOfDigits := 0\n    for i, num := range nums {\n      \
    \  sumOfDigits[i] = digitSum(num)\n        if sumOfDigits[i] > maxSumOfDigits\
    \ {\n            maxSumOfDigits = sumOfDigits[i]\n        }\n    }\n    // 2.\
    \ create buckets for each possible sum\n    bucket := make([][]int, maxSumOfDigits\
    \ + 1)\n    for i, num := range nums {\n        sum := sumOfDigits[i]\n      \
    \  bucket[sum] = append(bucket[sum], num)\n    }\n    // 3. traverse the bucket\
    \ in ascending order, append items to the result list\n    result := make([]int,\
    \ 0, len(nums))\n    for _, nums := range bucket {\n        result = append(result,\
    \ nums...)\n    }\n    return result\n}\n", "    // map to keep sorted points\n\
    \    points := make(map[int][]int)\n    // total number of points\n    min, max\
    \ := 0, 0\n    // iterate over nums\n    for i, n := range nums {\n        //\
    \ get points\n        p := abs(sum(digits(n)))\n        // first element, set\
    \ min and max\n        if i == 0 {\n            min, max = p, p\n        }\n \
    \       // set min and max points\n        if p < min {\n            min = p\n\
    \        }\n        if p > max {\n            max = p\n        }\n        // set\
    \ points\n        points[p] = append(points[p], n)\n    }\n    // slice to return\n\
    \    res := make([]int, len(nums))\n    // write sorted points to slice\n    for\
    \ p := min; p <= max; p++ {\n        // check if points map contains this point\n\
    \        if _, ok := points[p]; ok {\n            // iterate over values\n   \
    \         for _, v := range points[p] {\n                res = append(res, v)\n\
    \            }\n        }\n    }\n    return res\n}\n", "    if len(nums) == 0\
    \ {\n        return nums\n    }\n    int_map := make(map[int][]int)\n    // create\
    \ map\n    for _, num := range nums {\n        int_map[sum_int_digits(num)] =\
    \ append(int_map[sum_int_digits(num)], num)\n    }\n    // sort values in map\n\
    \    for _, values := range int_map {\n        for i := range values {\n     \
    \       for j := i+1; j < len(values); j++ {\n                if values[i] > values[j]\
    \ {\n                    // swap\n                    temp := values[i]\n    \
    \                values[i] = values[j]\n                    values[j] = temp\n\
    \                }\n            }\n        }\n    }\n    // assemble result\n\
    \    result := make([]int, 0)\n    for i := 0; i < len(nums); i++ {\n        for\
    \ _, num := range int_map[i] {\n            result = append(result, num)\n   \
    \     }\n    }\n    return result\n}\n", "    if nums == nil {\n        return\
    \ nil\n    }\n    if len(nums) == 0 {\n        return []int{}\n    }\n    var\
    \ newNums = make([]int, len(nums))\n    copy(newNums, nums)\n    //fmt.Println(nums)\n\
    \    //fmt.Println(newNums)\n    //fmt.Println(len(nums))\n    //fmt.Println(len(newNums))\n\
    \    //fmt.Println(nums[1:])\n    //fmt.Println(newNums[1:])\n    for index, _\
    \ := range newNums {\n        num := 0\n        n := nums[index]\n        if n\
    \ < 0 {\n            n = -n\n        }\n        for n > 0 {\n            num +=\
    \ n % 10\n            n /= 10\n        }\n        newNums[index] = num\n    }\n\
    \    //fmt.Println(nums)\n    //fmt.Println(newNums)\n    for index, _ := range\
    \ newNums {\n        for j := index + 1; j < len(newNums); j++ {\n           \
    \ if newNums[index] > newNums[j] {\n                newNums[index], newNums[j]\
    \ = newNums[j], newNums[index]\n                nums[index], nums[j] = nums[j],\
    \ nums[index]\n            }\n        }\n    }\n    return nums\n}\n", "    var\
    \ m = make(map[int][]int)\n    for i, n := range nums {\n        if n < 0 {\n\
    \            n = -n\n        }\n        if n < 10 {\n            m[n] = append(m[n],\
    \ i)\n        } else {\n            var c = 0\n            for ; n > 0; n /= 10\
    \ {\n                c += n % 10\n            }\n            m[c] = append(m[c],\
    \ i)\n        }\n    }\n    var res = make([]int, len(nums))\n    var c = 0\n\
    \    for i := 0; i < len(m); i++ {\n        for _, n := range m[i] {\n       \
    \     res[c] = nums[n]\n            c++\n        }\n    }\n    return res\n}\n",
  "    return []int{}\n}\n", "    //TODO: implement the function\n    return []int{}\n\
    }\n", "    // Your code goes here.\n    return nums\n}\n", "    return nil\n}\n",
  "    order_map := make(map[int][]int)\n    for i, val := range nums {\n        if\
    \ val < 0 {\n            val = -val\n        }\n        s := val % 10\n      \
    \  for val > 0 {\n            val /= 10\n            s += val % 10\n        }\n\
    \        if order_map[s] == nil {\n            order_map[s] = make([]int, 0)\n\
    \        }\n        order_map[s] = append(order_map[s], i)\n    }\n    var (\n\
    \        result = make([]int, len(nums))\n        i      = 0\n    )\n    for s\
    \ := 0; s < len(nums); s++ {\n        if order_map[s] == nil {\n            continue\n\
    \        }\n        for _, j := range order_map[s] {\n            result[i] =\
    \ nums[j]\n            i++\n        }\n    }\n    return result\n}\n", "    return\
    \ nil\n}\n", "    // PATCH\n    return nums\n}\n", "    if len(nums) <= 1 {\n\
    \        return nums\n    }\n    // Create a map to store the sum of digits: index\
    \ pair\n    index := 0\n    var keys []int\n    sumDigits := make(map[int][]int)\n\
    \    for _, value := range nums {\n        sum := 0\n        for _, v := range\
    \ fmt.Sprintf(\"%d\", value) {\n            sum += int(v - '0')\n        }\n \
    \       keys = append(keys, sum)\n        sumDigits[sum] = append(sumDigits[sum],\
    \ index)\n        index++\n    }\n    // Sort keys\n    sort.Ints(keys)\n    //\
    \ Return the sorted array\n    result := make([]int, len(nums))\n    i := 0\n\
    \    for _, value := range keys {\n        for _, v := range sumDigits[value]\
    \ {\n            result[i] = nums[v]\n            i++\n        }\n    }\n    return\
    \ result\n}\n", "    // replace the code below\n    return nums\n}\n", "    for\
    \ i := 0; i < len(nums); i++ {\n        for j := i + 1; j < len(nums); j++ {\n\
    \            if sum(nums[i]) > sum(nums[j]) {\n                nums[i], nums[j]\
    \ = nums[j], nums[i]\n            }\n        }\n    }\n    return nums\n}\n",
  "    if len(nums) == 0 {\n        return nums\n    }\n    /* \n    // \n    // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n\
    \    // sort() \u65B9\u6CD5\u4F1A\u5BF9\u6570\u7EC4\u7684\u5143\u7D20\u8FDB\u884C\
    \u6392\u5E8F\uFF0C\u5E76\u8FD4\u56DE\u6392\u5E8F\u540E\u7684\u6570\u7EC4\u3002\
    \u9ED8\u8BA4\u6392\u5E8F\u987A\u5E8F\u662F\u6839\u636E\u5B57\u7B26\u4E32Unicode\u7801\
    \u70B9\u3002\n    // \u5728\u4F7F\u7528\u573A\u666F\u4E2D\uFF0C\u6211\u4EEC\u5F80\
    \u5F80\u9700\u8981\u6839\u636E\u81EA\u5DF1\u7684\u9700\u6C42\uFF0C\u5BF9\u6570\
    \u7EC4\u8FDB\u884C\u6392\u5E8F\u3002\n    // \u8BED\u6CD5 arr.sort([compareFunction])\n\
    \    // \u63CF\u8FF0 compareFunction \u53EF\u9009\u3002\u7528\u6765\u6307\u5B9A\
    \u6309\u67D0\u79CD\u987A\u5E8F\u8FDB\u884C\u6392\u5217\u7684\u51FD\u6570\u3002\
    \n    // \u5982\u679C\u7701\u7565\uFF0C\u5143\u7D20\u6309\u7167\u8F6C\u6362\u4E3A\
    \u7684\u5B57\u7B26\u4E32\u7684\u5404\u4E2A\u5B57\u7B26\u7684Unicode\u4F4D\u70B9\
    \u8FDB\u884C\u6392\u5E8F\u3002\n    // \n    // \u8BF4\u660E\uFF1A\n    // compareFunction\uFF1A\
    \u6307\u5B9A\u6309\u67D0\u79CD\u987A\u5E8F\u8FDB\u884C\u6392\u5217\u7684\u51FD\
    \u6570\n    // \n    // \u9ED8\u8BA4\u6392\u5E8F\u987A\u5E8F\u662F\u6839\u636E\
    \u5B57\u7B26\u4E32Unicode\u7801\u70B9\n    // \u5982\u679CcompareFunction\uFF08\
    \u6BD4\u8F83\u51FD\u6570\uFF09\u8FD4\u56DE\u503C\u662F\u5C0F\u4E8E 0 \u7684",
  "    points := map[int]int{}\n    for i, v := range nums {\n        points[i] =\
    \ v\n    }\n    sortedKeys := make([]int, 0, len(points))\n    for k := range\
    \ points {\n        sortedKeys = append(sortedKeys, k)\n    }\n    // Reverse\
    \ sort the list of keys\n    sort.Slice(sortedKeys, func(i, j int) bool {\n  \
    \      return points[sortedKeys[i]] > points[sortedKeys[j]]\n    })\n    sorted\
    \ := make([]int, len(nums))\n    for i, v := range sortedKeys {\n        sorted[i]\
    \ = points[v]\n    }\n    return sorted\n}\n", "    return nums\n}\n", "\t// your\
    \ code here\n\treturn nil\n}\n", "    // \u7B97\u51FA\u9663\u5217\u4E2D\u6BCF\u500B\
    \u6578\u5B57\u7684\u548C\n    sum := []int{}\n    index := 0\n    for _, num :=\
    \ range nums {\n        sum[index] = sumOfDigits(num)\n        index++\n    }\n\
    \    // \u6392\u5E8F\n    sort(sum)\n    // \u5C07\u6392\u5E8F\u5F8C\u7684\u9663\
    \u5217\u56DE\u50B3\n    return sum\n}\n", "    return nums\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
