name: HumanEval_145_order_by_points
language: go_test.go
prompt: "package order_by_points_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// Write a function which sorts the given list of integers\n// in ascending\
  \ order according to the sum of their digits.\n// Note: if there are several items\
  \ with similar sum of their digits,\n// order them based on their index in original\
  \ list.\n// For example:\n// >>> order_by_points([]int{1, 11, -1, -11, -12})\n//\
  \ []int{-1, -11, 1, -12, 11}\n// >>> order_by_points([]int{})\n// PATCH list\nfunc\
  \ order_by_points(nums []int) []int {\n"
tests: "func TestOrder_By_Points(t *testing.T) {\n  candidate := order_by_points\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate([]int{1, 11, -1, -11, -12}), expected:\
  \ []int{-1, -11, 1, -12, 11} },\n     { actual: candidate([]int{1234, 423, 463,\
  \ 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46}), expected: []int{0, 2, 3, 6,\
  \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457} },\n     { actual: candidate([]int{}),\
  \ expected: []int{} },\n     { actual: candidate([]int{1, -11, -32, 43, 54, -98,\
  \ 2, -3}), expected: []int{-3, -32, -98, -11, 1, 2, 43, 54} },\n     { actual: candidate([]int{1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}), expected: []int{1, 10, 2, 11, 3, 4, 5, 6, 7,\
  \ 8, 9} },\n     { actual: candidate([]int{0, 6, 6, -76, -21, 23, 4}), expected:\
  \ []int{-76, -21, 0, 4, 23, 6, 6} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
  t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
  %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
  \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    // returns a list of integer with the order changed\n\n    if len(nums)\
    \ == 0 {\n        return []int{}\n    }\n\n    // a list of slices with two values\
    \ each: sum of digits and index of the integer in nums\n    s := make([][]int,\
    \ len(nums))\n\n    for i, num := range nums {\n        s[i] = []int{sum_digits(num),\
    \ i}\n    }\n\n    // sort the slices in the list s according to their sum of\
    \ digits\n    sort.Slice(s, func(i, j int) bool { return s[i][0] < s[j][0] })\n\
    \n    // place items from nums in a new list in the order given by the sorted\
    \ list s\n    sorted_nums := make([]int, len(nums))\n    for i, slice := range\
    \ s {\n        sorted_nums[i] = nums[slice[1]]\n    }\n\n    return sorted_nums\n\
    }\n", "    var results []int\n    return results\n}\n", "    if len(nums) == 0\
    \ {\n        return nums\n    }\n    // Insertion sort\n    for i := 1; i < len(nums);\
    \ i++ {\n        j := i\n        for j > 0 && nums[j] < nums[j-1] {\n        \
    \    nums[j], nums[j-1] = nums[j-1], nums[j]\n            j--\n        }\n   \
    \ }\n    return nums\n}\n", "    patch := make([]int, len(nums))\n    // you code\
    \ here...\n    return patch\n}\n", "    if len(nums) == 0 {\n        return nums\n\
    \    }\n    points := make([]int, len(nums))\n    for i, v := range nums {\n \
    \       points[i] = sum_digits(v)\n    }\n    for i := 0; i < len(nums) - 1; i++\
    \ {\n        for j := 0; j < len(nums) - 1 - i; j++ {\n            if points[j]\
    \ > points[j + 1] {\n                points[j], points[j + 1] = points[j + 1],\
    \ points[j]\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n   \
    \         }\n        }\n    }\n    return nums\n}\n", "    // Write your code\
    \ here\n    return []int{}\n}\n", "    new_nums := nums\n    for i := 1; i < len(new_nums);\
    \ i++ {\n        for j := 0; j < len(new_nums)-i; j++ {\n            a := abs(new_nums[j])\n\
    \            b := abs(new_nums[j+1])\n            if (sum_digits(a) > sum_digits(b))\
    \ || (sum_digits(a) == sum_digits(b) && a > b) {\n                new_nums[j],\
    \ new_nums[j+1] = new_nums[j+1], new_nums[j]\n            }\n        }\n    }\n\
    \    return new_nums\n}\n", "    return nil\n}\n", "    points := map[int]int{}\n\
    \    for index, num := range nums {\n        points[index] = countPoints(num)\n\
    \    }\n    fmt.Println(points)\n    return nil\n}\n", "    return nums\n}\n",
  "    return []int{}\n}\n", "    var indexSlice []int\n    var valueSlice []int\n\
    \    var resultSlice []int\n    index := 0\n    for _, num := range nums {\n \
    \       if num < 0 {\n            num = -num\n        }\n        indexSlice =\
    \ append(indexSlice, index)\n        index++\n        valueSlice = append(valueSlice,\
    \ num)\n    }\n    for i := 0; i < len(valueSlice); i++ {\n        for j := i;\
    \ j < len(valueSlice); j++ {\n            if valueSlice[i] > valueSlice[j] {\n\
    \                temp := valueSlice[i]\n                valueSlice[i] = valueSlice[j]\n\
    \                valueSlice[j] = temp\n                temp = indexSlice[i]\n\
    \                indexSlice[i] = indexSlice[j]\n                indexSlice[j]\
    \ = temp\n            }\n        }\n    }\n    for _, index := range indexSlice\
    \ {\n        resultSlice = append(resultSlice, nums[index])\n    }\n    return\
    \ resultSlice\n}\n", "    // Write your code here\n    return []int{}\n}\n", " \
    \   if len(nums) == 0 {\n        return nums\n    }\n    var numsMap = make(map[int][]int)\n\
    \    for i, num := range nums {\n        var sum = sumDigits(num)\n        if\
    \ _, ok := numsMap[sum]; !ok {\n            numsMap[sum] = []int{}\n        }\n\
    \        numsMap[sum] = append(numsMap[sum], i)\n    }\n    var sortedNums = make([]int,\
    \ len(nums))\n    var i = 0\n    for _, indices := range sortKeys(numsMap) {\n\
    \        for _, index := range indices {\n            sortedNums[i] = nums[index]\n\
    \            i++\n        }\n    }\n    return sortedNums\n}\n", "    // Your\
    \ code goes here!\n    return nil\n}\n", "    // First we make a map of number->Sum(Digits(number))\n\
    \    scores := make(map[int]int)\n    for _, num := range nums {\n        var\
    \ sum int\n        for _, digit := range fmt.Sprintf(\"%d\", num) {\n        \
    \    sum += int(digit - '0')\n        }\n        scores[num] = sum\n    }\n\n\
    \    // Then we sort the numbers based on the score\n    var ordered []int\n \
    \   for _, num := range nums {\n        ordered = append(ordered, num)\n    }\n\
    \    for i := 0; i < len(ordered); i++ {\n        for j := 0; j < len(ordered)\
    \ - 1; j++ {\n            if scores[ordered[j]] > scores[ordered[j+1]] {\n   \
    \             ordered[j], ordered[j+1] = ordered[j+1], ordered[j]\n          \
    \  }\n        }\n    }\n    return ordered\n}\n", "    return nums\n}\n", "  \
    \  return []int{}\n}\n", "    return nil\n}\n", "    return nums\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
