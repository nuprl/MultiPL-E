language: go_test.go
name: HumanEval_127_intersection
results:
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != 2 || len(interval2) != 2 {\n        return\
    \ \"NO\"\n    }\n    switch interval1[0].(type) {\n    case int:\n        if interval1[0].(int)\
    \ > interval1[1].(int) {\n            return \"NO\"\n        }\n    case float64:\n\
    \        if interval1[0].(float64) > interval1[1].(float64) {\n            return\
    \ \"NO\"\n        }\n    default:\n        return \"NO\"\n    }\n    switch interval2[0].(type)\
    \ {\n    case int:\n        if interval2[0].(int) > interval2[1].(int) {\n   \
    \         return \"NO\"\n        }\n    case float64:\n        if interval2[0].(float64)\
    \ > interval2[1].(float64) {\n            return \"NO\"\n        }\n    default:\n\
    \        return \"NO\"\n    }\n    // fmt.Println(interval1[0], interval1[1],\
    \ interval2[0], interval2[1])\n    left := max(interval1[0], interval2[0])\n \
    \   right := min(interval1[1], interval2[1])\n    if left > right {\n        return\
    \ \"NO\"\n    }\n    if left == right {\n        return \"YES\"\n    }\n    if\
    \ left.(int) < 0 {\n        left = -left.(int)\n    }\n    if right.(int) < 0\
    \ {\n        right = -right.(int)\n    }\n    for i := left.(int); i <= right.(int);\
    \ i++ {\n        if i == 2 || i == 3 || i == 5 || i == 7 {\n            return\
    \ \"YES\"\n        }\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmbpvasxu_test.go:56:13: undefined: max

    /tmp/tmpmbpvasxu_test.go:57:14: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075338
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if (interval1[0].(int) > interval2[1].(int)) || (interval2[0].(int)\
    \ > interval1[1].(int)) {\n        return \"NO\"\n    }\n    var s int\n    var\
    \ e int\n    if interval1[0].(int) > interval2[0].(int) {\n        s = interval1[0].(int)\n\
    \    } else {\n        s = interval2[0].(int)\n    }\n    if interval1[1].(int)\
    \ < interval2[1].(int) {\n        e = interval1[1].(int)\n    } else {\n     \
    \   e = interval2[1].(int)\n    }\n    if (e - s) <= 0 {\n        return \"NO\"\
    \n    }\n    for i := 2; i < (e - s); i++ {\n        if (e - s) % i == 0 {\n \
    \           return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpvrunpd25_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpvrunpd25_test.go:74: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075338
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != 2 || len(interval2) != 2 {\n        return\
    \ \"INVALID\"\n    }\n    if interval1[0] == interval1[1] || interval2[0] == interval2[1]\
    \ {\n        return \"NO\"\n    }\n    var start, end int\n    if interval1[0].(int)\
    \ < interval2[0].(int) {\n        start = interval2[0].(int)\n    } else {\n \
    \       start = interval1[0].(int)\n    }\n    if interval1[1].(int) > interval2[1].(int)\
    \ {\n        end = interval2[1].(int)\n    } else {\n        end = interval1[1].(int)\n\
    \    }\n    if start >= end {\n        return \"NO\"\n    }\n    if start <= 1\
    \ {\n        return \"NO\"\n    }\n    if start == 2 {\n        return \"YES\"\
    \n    }\n    if start & 1 == 0 {\n        start++\n    }\n    for start <= end\
    \ {\n        var flag = false\n        for i := 3; i * i <= start; i += 2 {\n\
    \            if start % i == 0 {\n                flag = true\n              \
    \  break\n            }\n        }\n        if !flag {\n            return \"\
    YES\"\n        }\n        start += 2\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmp90r598kn_test.go:93: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmp90r598kn_test.go:93: expected\
    \ 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075338
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    s := start1\n    if start2 > start1\
    \ {\n        s = start2\n    }\n    e := end1\n    if end2 < end1 {\n        e\
    \ = end2\n    }\n    if isPrime(e - s + 1) {\n        return \"YES\"\n    }\n\
    \    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppqua_13f_test.go:49:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075338
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // handle negative values\n    var start1 int = -1\n    var end1\
    \ int = -1\n    if interval1[0].(int) < 0 {\n        start1 = interval1[0].(int)\
    \ * -1\n    } else {\n        start1 = interval1[0].(int)\n    }\n    if interval1[1].(int)\
    \ < 0 {\n        end1 = interval1[1].(int) * -1\n    } else {\n        end1 =\
    \ interval1[1].(int)\n    }\n    var start2 int = -1\n    var end2 int = -1\n\
    \    if interval2[0].(int) < 0 {\n        start2 = interval2[0].(int) * -1\n \
    \   } else {\n        start2 = interval2[0].(int)\n    }\n    if interval2[1].(int)\
    \ < 0 {\n        end2 = interval2[1].(int) * -1\n    } else {\n        end2 =\
    \ interval2[1].(int)\n    }\n    // handle when interval1 is less than interval2\n\
    \    if start1 > start2 {\n        start1, start2 = start2, start1\n        end1,\
    \ end2 = end2, end1\n    }\n    var intersectStart int = -1\n    var intersectEnd\
    \ int = -1\n    if end1 < start2 {\n        return \"NO\"\n    } else if end1\
    \ > start2 {\n        intersectStart = start2\n        if end1 > end2 {\n    \
    \        intersectEnd = end2\n        } else {\n            intersectEnd = end1\n\
    \        }\n    } else {\n        intersectStart = start2\n        intersectEnd\
    \ = end2\n    }\n    //fmt.Println(intersectStart, intersectEnd)\n    var diff\
    \ int = intersectEnd - intersectStart\n    if diff == 0 {\n        return \"NO\"\
    \n    }\n    if diff < 0 {\n        diff = diff * -1\n    }\n    if diff == 1\
    \ {\n        return \"YES\"\n    }\n    if diff == 2 {\n        return \"NO\"\n\
    \    }\n    for i := 2; i < diff; i++ {\n        if diff %\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6ar74tq__test.go:89:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    x1 := interval1[0].(int)\n    x2 := interval1[1].(int)\n    y1\
    \ := interval2[0].(int)\n    y2 := interval2[1].(int)\n    if x1 > x2 {\n    \
    \    x1, x2 = x2, x1\n    }\n    if y1 > y2 {\n        y1, y2 = y2, y1\n    }\n\
    \    if x2 < y1 || y2 < x1 {\n        return \"NO\"\n    }\n    x := max(x1, y1)\n\
    \    y := min(x2, y2)\n    for i := 2; i < y; i++ {\n        if x % i == 0 {\n\
    \            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpchw4qw98_test.go:41:10: undefined: max

    /tmp/tmpchw4qw98_test.go:42:10: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075338
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // if interval2[0] < interval1[0] {\n    //     interval1, interval2\
    \ = interval2, interval1\n    // }\n    start := Max(interval1[0], interval2[0])\n\
    \    end := Min(interval1[1], interval2[1])\n    length := end.(int) - start.(int)\
    \ + 1\n    if length <= 0 {\n        return \"NO\"\n    }\n    for i := 2; i <\
    \ length; i++ {\n        if length % i == 0 {\n            return \"NO\"\n   \
    \     }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvnqbawmd_test.go:31:14: undefined: Max

    /tmp/tmpvnqbawmd_test.go:32:12: undefined: Min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075338
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    fmt.Println(interval1, interval2)\n    return \"YES\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "[1 2] [2 3]\n[-1 1] [0 4]\n[-3 -1] [-5 5]\n[-2 2] [-4 0]\n[-11 2] [-1 -1]\n\
    [1 2] [3 5]\n[1 2] [1 2]\n[-2 -2] [-3 -2]\n--- FAIL: TestIntersection (0.00s)\n\
    \    --- FAIL: TestIntersection/test_num__0 (0.00s)\n        tmpkp9f05m6_test.go:52:\
    \ expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__1 (0.00s)\n\
    \        tmpkp9f05m6_test.go:52: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpkp9f05m6_test.go:52: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpkp9f05m6_test.go:52: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n      \
    \  tmpkp9f05m6_test.go:52: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpkp9f05m6_test.go:52: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075338
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    fmt.Println(interval1, interval2)\n    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    var start int\n    var end int\n    if start1 < start2\
    \ {\n        start = start2\n    } else {\n        start = start1\n    }\n   \
    \ if end1 < end2 {\n        end = end1\n    } else {\n        end = end2\n   \
    \ }\n    if start > end {\n        return \"NO\"\n    }\n    if start == end {\n\
    \        return \"YES\"\n    }\n    isPrime := true\n    for i := 2; i <= end;\
    \ i++ {\n        if start % i == 0 {\n            isPrime = false\n          \
    \  break\n        }\n    }\n    if isPrime {\n        return \"YES\"\n    }\n\
    \    return \"NO\"\n}\n\ntype TestCase \nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpaaja0nk5_test.go:64:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n\n    if interval1[0].(int)\
    \ <= interval2[0].(int) {\n        start := interval2[0].(int)\n    } else {\n\
    \        start := interval1[0].(int)\n    }\n\n    if interval1[1].(int) <= interval2[1].(int)\
    \ {\n        end := interval1[1].(int)\n    } else {\n        end := interval2[1].(int)\n\
    \    }\n\n    length := end - start + 1\n    if isPrime(length) {\n        return\
    \ \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqt4qdcow_test.go:33:9: start declared but not used

    /tmp/tmpqt4qdcow_test.go:35:9: start declared but not used

    /tmp/tmpqt4qdcow_test.go:39:9: end declared but not used

    /tmp/tmpqt4qdcow_test.go:41:9: end declared but not used

    /tmp/tmpqt4qdcow_test.go:44:15: undefined: end

    /tmp/tmpqt4qdcow_test.go:44:21: undefined: start

    /tmp/tmpqt4qdcow_test.go:45:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075338
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) < 2 || len(interval2) < 2 {\n        return\
    \ \"NO\"\n    }\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    start := start1\n\
    \    if start2 > start1 {\n        start = start2\n    }\n    end := end1\n  \
    \  if end2 < end1 {\n        end = end2\n    }\n    if start > end {\n       \
    \ return \"NO\"\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    diff := end - start + 1\n    for i := 2; i < diff; i++ {\n        if diff\
    \ % i == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n\
    }\n\ntype testData \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_6e60x7l_test.go:61:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075337
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    s1 := interval1[0].(int)\n    e1 := interval1[1].(int)\n    s2\
    \ := interval2[0].(int)\n    e2 := interval2[1].(int)\n    s := max(s1, s2)\n\
    \    e := min(e1, e2)\n    if e < s {\n        return \"NO\"\n    }\n    if isPrime(e\
    \ - s + 1) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3pt0qo3g_test.go:32:10: undefined: max

    /tmp/tmp3pt0qo3g_test.go:33:10: undefined: min

    /tmp/tmp3pt0qo3g_test.go:37:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075338
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmp1ihwkvrw_test.go:51: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmp1ihwkvrw_test.go:51: expected\
    \ 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075230
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    int1Start := interval1[0].(int)\n    int1End := interval1[1].(int)\n\
    \    int2Start := interval2[0].(int)\n    int2End := interval2[1].(int)\n    var\
    \ start int\n    var end int\n    if int1Start <= int2Start {\n        start =\
    \ int2Start\n    } else {\n        start = int1Start\n    }\n    if int1End >=\
    \ int2End {\n        end = int2End\n    } else {\n        end = int1End\n    }\n\
    \    //fmt.Println(start, end)\n    if start >= end {\n        return \"NO\"\n\
    \    }\n    if isPrime(end - start) {\n        return \"YES\"\n    }\n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3x2m9d48_test.go:48:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075338
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    i1 := interval1[0].(int)\n    i2 := interval1[1].(int)\n    j1\
    \ := interval2[0].(int)\n    j2 := interval2[1].(int)\n    if i1 > i2 {\n    \
    \    i1, i2 = i2, i1\n    }\n    if j1 > j2 {\n        j1, j2 = j2, j1\n    }\n\
    \    if i2 < j1 || j2 < i1 {\n        return \"NO\"\n    }\n    // i1 <= i2, j1\
    \ <= j2\n    s := i2\n    if j2 < i2 {\n        s = j2\n    }\n    e := i1\n \
    \   if j1 > i1 {\n        e = j1\n    }\n    for i := s; i > e; i-- {\n      \
    \  if isPrime(i) {\n            return \"YES\"\n        }\n    }\n    return \"\
    NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxttw31y2_test.go:51:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075338
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    _interval1 := [2]int{interval1[0].(int), interval1[1].(int)}\n\
    \    _interval2 := [2]int{interval2[0].(int), interval2[1].(int)}\n    fmt.Println(_interval1,\
    \ _interval2)\n    if _interval1[0] > _interval2[1] || _interval2[0] > _interval1[1]\
    \ {\n        return \"NO\"\n    }\n    start := max(_interval1[0], _interval2[0])\n\
    \    end := min(_interval1[1], _interval2[1])\n    length := end - start + 1\n\
    \    for i := 2; i < length; i++ {\n        if length % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0ufaeu4s_test.go:34:14: undefined: max

    /tmp/tmp0ufaeu4s_test.go:35:12: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075338
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start < start2\
    \ {\n        start = start2\n    }\n    end := end1\n    if end > end2 {\n   \
    \     end = end2\n    }\n    length := end - start\n    if length == 0 {\n   \
    \     return \"NO\"\n    }\n    if length == 1 {\n        return \"YES\"\n   \
    \ }\n    if length == 2 {\n        return \"NO\"\n    }\n    for i := 2; i < length;\
    \ i++ {\n        if length % i == 0 {\n            return \"NO\"\n        }\n\
    \    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpn09nyzzn_test.go:87: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmpn09nyzzn_test.go:87: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmpn09nyzzn_test.go:87: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpn09nyzzn_test.go:87: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075338
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // interval1 = [1, 2]\n    // interval2 = [2, 3]\n    start1 :=\
    \ interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n\
    \    end2 := interval2[1].(int)\n    intersect := make([]int, 0)\n    if start1\
    \ > end2 || start2 > end1 {\n        return \"NO\"\n    }\n    if start1 > start2\
    \ {\n        start1 = start2\n    }\n    if end1 < end2 {\n        end1 = end2\n\
    \    }\n    for i := start1; i <= end1; i++ {\n        intersect = append(intersect,\
    \ i)\n    }\n    // fmt.Println(intersect)\n    for _, i := range intersect {\n\
    \        for j := 2; j < i; j++ {\n            if i % j == 0 {\n             \
    \   return \"NO\"\n            }\n        }\n    }\n    return \"YES\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp1cn6xdu4_test.go:78: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmp1cn6xdu4_test.go:78: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp1cn6xdu4_test.go:78: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp1cn6xdu4_test.go:78: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmp1cn6xdu4_test.go:78: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075338
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n    if isPrime(interval1[1].(int)\
    \ - interval2[0].(int)) {\n        return \"YES\"\n    }\n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_f23sva7_test.go:31:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075338
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var ival1, ival2 *Interval\n\n    ival1 = NewInterval(interval1)\n\
    \    ival2 = NewInterval(interval2)\n\n    if ival1.Intersects(ival2) {\n    \
    \    if _, ok := PrimeNumbersMap[ival1.IntersectionLength(ival2)]; ok {\n    \
    \        return \"YES\"\n        }\n    }\n\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp4cz6v44_test.go:28:23: undefined: Interval

    /tmp/tmpp4cz6v44_test.go:30:13: undefined: NewInterval

    /tmp/tmpp4cz6v44_test.go:31:13: undefined: NewInterval

    /tmp/tmpp4cz6v44_test.go:34:21: undefined: PrimeNumbersMap

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075338
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var start, end int\n    if interval1[0].(int) > interval2[0].(int)\
    \ {\n        start = interval1[0].(int)\n    } else {\n        start = interval2[0].(int)\n\
    \    }\n    if interval1[1].(int) < interval2[1].(int) {\n        end = interval1[1].(int)\n\
    \    } else {\n        end = interval2[1].(int)\n    }\n    if start > end {\n\
    \        return \"NO\"\n    }\n    length := end - start + 1\n    if length ==\
    \ 2 {\n        return \"YES\"\n    }\n    for i := 2; i < length; i++ {\n    \
    \    if length % i == 0 {\n            return \"NO\"\n        }\n    }\n    return\
    \ \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp66uqrarj_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp66uqrarj_test.go:74: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp66uqrarj_test.go:74: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp66uqrarj_test.go:74: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmp66uqrarj_test.go:74: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075338
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n\ta, b := interval1[0].(int), interval1[1].(int)\n\tc, d := interval2[0].(int),\
    \ interval2[1].(int)\n\tintersect := []int{}\n\tif a < c {\n\t\tif b < c {\n\t\
    \t\treturn \"NO\"\n\t\t} else if b > d {\n\t\t\tintersect = []int{c, d}\n\t\t\
    } else {\n\t\t\tintersect = []int{c, b}\n\t\t}\n\t} else {\n\t\tif a > d {\n\t\
    \t\treturn \"NO\"\n\t\t} else if b > d {\n\t\t\tintersect = []int{a, d}\n\t\t\
    } else {\n\t\t\tintersect = []int{a, b}\n\t\t}\n\t}\n\tif isPrime(intersect[1]\
    \ - intersect[0]) {\n\t\treturn \"YES\"\n\t}\n\treturn \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8z28z_zf_test.go:48:5: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075338
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // Your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpwnkqnclb_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpwnkqnclb_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpwnkqnclb_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpwnkqnclb_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpwnkqnclb_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpwnkqnclb_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpwnkqnclb_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpwnkqnclb_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075338
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    start := 0\n    end := 0\n  \
    \  if start1 <= start2 {\n        start = start2\n    } else {\n        start\
    \ = start1\n    }\n    if end1 >= end2 {\n        end = end2\n    } else {\n \
    \       end = end1\n    }\n    if start > end {\n        return \"NO\"\n    }\n\
    \    if start == end {\n        if start <= 1 {\n            return \"NO\"\n \
    \       }\n        if start == 2 {\n            return \"YES\"\n        }\n  \
    \      for i := 2; i < start; i++ {\n            if start % i == 0 {\n       \
    \         return \"NO\"\n            }\n        }\n        return \"YES\"\n  \
    \  }\n    //length\n    length := end - start + 1\n    if length <= 1 {\n    \
    \    return \"NO\"\n    }\n    if length == 2 {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < length; i++ {\n        if length % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpdumt6uo1_test.go:103: expected 'NO', got 'YES'\n    ---\
    \ FAIL: TestIntersection/test_num__1 (0.00s)\n        tmpdumt6uo1_test.go:103:\
    \ expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n\
    \        tmpdumt6uo1_test.go:103: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075338
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    if interval1Start <= interval2Start {\n        return isIntersectionPrime(interval1Start,\
    \ interval1End, interval2Start, interval2End)\n    } else {\n        return isIntersectionPrime(interval2Start,\
    \ interval2End, interval1Start, interval1End)\n    }\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz6bz735k_test.go:33:16: undefined: isIntersectionPrime

    /tmp/tmpz6bz735k_test.go:35:16: undefined: isIntersectionPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075339
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    i1 := interval1[0].(int)\n    i2 := interval1[1].(int)\n    j1\
    \ := interval2[0].(int)\n    j2 := interval2[1].(int)\n    if i1 > i2 {\n    \
    \    i1, i2 = i2, i1\n    }\n    if j1 > j2 {\n        j1, j2 = j2, j1\n    }\n\
    \    if i2 < j1 || j2 < i1 {\n        return \"NO\"\n    }\n    if j1 < i1 {\n\
    \        i1 = j1\n    }\n    if j2 < i2 {\n        i2 = j2\n    }\n    return\
    \ isPrime(i2 - i1 + 1)\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfu21k8tq_test.go:47:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075339
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string = \"NO\"\n    if interval1[0].(int) >= interval2[0].(int)\
    \ && interval1[0].(int) <= interval2[1].(int) {\n        if isPrime(interval2[1].(int)\
    \ - interval1[0].(int)) {\n            result = \"YES\"\n        }\n    } else\
    \ if interval2[0].(int) >= interval1[0].(int) && interval2[0].(int) <= interval1[1].(int)\
    \ {\n        if isPrime(interval1[1].(int) - interval2[0].(int)) {\n         \
    \   result = \"YES\"\n        }\n    }\n    return result\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprhr4tf9s_test.go:30:12: undefined: isPrime

    /tmp/tmprhr4tf9s_test.go:34:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075339
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != 2 || len(interval2) != 2 {\n        return\
    \ \"NO\"\n    }\n    inter1start := interval1[0].(int)\n    inter1end := interval1[1].(int)\n\
    \    inter2start := interval2[0].(int)\n    inter2end := interval2[1].(int)\n\
    \    inter1start, inter1end = normInterval(inter1start, inter1end)\n    inter2start,\
    \ inter2end = normInterval(inter2start, inter2end)\n    if inter1start > inter2end\
    \ || inter2start > inter1end {\n        return \"NO\"\n    }\n    interStart :=\
    \ inter1start\n    if interStart < inter2start {\n        interStart = inter2start\n\
    \    }\n    interEnd := inter1end\n    if interEnd > inter2end {\n        interEnd\
    \ = inter2end\n    }\n    interLen := interEnd - interStart + 1\n    if interLen\
    \ <= 1 {\n        return \"NO\"\n    }\n    return isPrime(interLen)\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvd52whvi_test.go:35:30: undefined: normInterval

    /tmp/tmpvd52whvi_test.go:36:30: undefined: normInterval

    /tmp/tmpvd52whvi_test.go:52:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075340
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n    var start, end int\n\
    \    if interval1[0].(int) >= interval2[0].(int) {\n        start = interval1[0].(int)\n\
    \    } else {\n        start = interval2[0].(int)\n    }\n    if interval1[1].(int)\
    \ <= interval2[1].(int) {\n        end = interval1[1].(int)\n    } else {\n  \
    \      end = interval2[1].(int)\n    }\n    if start == end {\n        return\
    \ \"YES\"\n    }\n    for i := start; i <= end; i++ {\n        if i == 2 || i\
    \ == 3 || i == 5 || i == 7 {\n            return \"YES\"\n        }\n    }\n \
    \   return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpewpze_18_test.go:73: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmpewpze_18_test.go:73: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmpewpze_18_test.go:73: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpewpze_18_test.go:73: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpewpze_18_test.go:73: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmpewpze_18_test.go:73: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075340
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var (\n        start1 = int(interval1[0].(float64))\n        end1\
    \ = int(interval1[1].(float64))\n        start2 = int(interval2[0].(float64))\n\
    \        end2 = int(interval2[1].(float64))\n        start, end int\n    )\n \
    \   if start1 < start2 {\n        start = start2\n    } else {\n        start\
    \ = start1\n    }\n    if end1 > end2 {\n        end = end2\n    } else {\n  \
    \      end = end1\n    }\n    if start > end {\n        return \"NO\"\n    }\n\
    \    var arr = make([]int, end - start + 1)\n    for i := 0; i < len(arr); i++\
    \ {\n        arr[i] = start + i\n    }\n    for i := 2; i <= end / 2; i++ {\n\
    \        isPrime := true\n        for j := 0; j < len(arr); j++ {\n          \
    \  if arr[j] % i == 0 {\n                isPrime = false\n                break\n\
    \            }\n        }\n        if isPrime {\n            return \"YES\"\n\
    \        }\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\npanic: interface conversion: interface\
    \ {} is int, not float64 [recovered]\n\tpanic: interface conversion: interface\
    \ {} is int, not float64\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x503ea0,\
    \ 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503ea0, 0xc0000103f0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.intersection({0xc0000f5cc0?, 0x2?, 0x2?},\
    \ {0xc0000f5ca0?, 0x2?, 0x2?})\n\t/tmp/tmpjsfewotf_test.go:29 +0x217\ncommand-line-arguments_test.TestIntersection(0x0?)\n\
    \t/tmp/tmpjsfewotf_test.go:74 +0xe7\ntesting.tRunner(0xc0001a01a0, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075340
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start < start2\
    \ {\n        start = start2\n    }\n    end := end1\n    if end > end2 {\n   \
    \     end = end2\n    }\n    length := end - start\n    if length == 0 {\n   \
    \     return \"NO\"\n    }\n    if length == 1 {\n        return \"YES\"\n   \
    \ }\n    if length == 2 {\n        return \"NO\"\n    }\n    if length % 2 ==\
    \ 0 {\n        return \"NO\"\n    }\n    for i := 3; i < length; i += 2 {\n  \
    \      if length % i == 0 {\n            return \"NO\"\n        }\n    }\n   \
    \ return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmp924ihr9n_test.go:90: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmp924ihr9n_test.go:90: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmp924ihr9n_test.go:90: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp924ihr9n_test.go:90: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075340
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if end1 < start2 || end2 < start1\
    \ {\n        return \"NO\"\n    }\n    for i := start1; i <= end1; i++ {\n   \
    \     if i >= start2 && i <= end2 {\n            if i == 1 {\n               \
    \ return \"NO\"\n            }\n            if i == 2 {\n                return\
    \ \"YES\"\n            }\n            if i%2 == 0 {\n                return \"\
    NO\"\n            }\n            for j := 3; j <= i/2; j += 2 {\n            \
    \    if i%j == 0 {\n                    return \"NO\"\n                }\n   \
    \         }\n            return \"YES\"\n        }\n    }\n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp9c2z08ww_test.go:83: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmp9c2z08ww_test.go:83: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp9c2z08ww_test.go:83: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075340
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // your code here\n    // check is not intersect, return \"NO\"\
    \n    if interval1[1].(int) < interval2[0].(int) || interval2[1].(int) < interval1[0].(int)\
    \ {\n        return \"NO\"\n    }\n    // convert to prime\n    interval := interval1\n\
    \    if interval1[0].(int) > interval2[0].(int) {\n        interval = interval2\n\
    \    }\n    start, end := interval[0].(int), interval[1].(int)\n    if interval1[0].(int)\
    \ < interval2[0].(int) {\n        end = interval2[0].(int)\n    } else {\n   \
    \     start = interval2[1].(int)\n    }\n    return prime(start, end)\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpol4zidwb_test.go:44:12: undefined: prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075340
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    isPrime := func(n int) bool {\n        if n <= 1 {\n         \
    \   return false\n        }\n        for i := 2; i * i <= n; i++ {\n         \
    \   if n % i == 0 {\n                return false\n            }\n        }\n\
    \        return true\n    }\n    if len(interval1) != 2 || len(interval2) != 2\
    \ {\n        return \"NO\"\n    }\n    var start1, end1, start2, end2 int\n  \
    \  switch interval1[0].(type) {\n    case int:\n        start1 = interval1[0].(int)\n\
    \        end1 = interval1[1].(int)\n    case float64:\n        start1 = int(interval1[0].(float64))\n\
    \        end1 = int(interval1[1].(float64))\n    }\n    switch interval2[0].(type)\
    \ {\n    case int:\n        start2 = interval2[0].(int)\n        end2 = interval2[1].(int)\n\
    \    case float64:\n        start2 = int(interval2[0].(float64))\n        end2\
    \ = int(interval2[1].(float64))\n    }\n    if start1 > end1 || start2 > end2\
    \ {\n        return \"NO\"\n    }\n    if end1 < start2 || end2 < start1 {\n \
    \       return \"NO\"\n    }\n    if start1 > start2 {\n        start1, start2\
    \ = start2, start1\n    }\n    if end1 < end2 {\n        end1, end2 = end2, end1\n\
    \    }\n    if isPrime(end1 - start2 + 1) {\n        return \"YES\"\n    }\n \
    \   return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp53pfwizd_test.go:97: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp53pfwizd_test.go:97: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n      \
    \  tmp53pfwizd_test.go:97: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp53pfwizd_test.go:97: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075340
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ <= start2 {\n        if end1 < start2 {\n            return \"NO\"\n       \
    \ }\n        return isPrime(end1 - start2 + 1)\n    }\n    if end2 < start1 {\n\
    \        return \"NO\"\n    }\n    return isPrime(end2 - start1 + 1)\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz2frikhl_test.go:36:16: undefined: isPrime

    /tmp/tmpz2frikhl_test.go:41:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075340
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 == end1 || start2 ==\
    \ end2 {\n        return \"NO\"\n    }\n    var is_prime = func(n int) bool {\n\
    \        if n < 2 {\n            return false\n        }\n        if n == 2 {\n\
    \            return true\n        }\n        for i := 2; i <= n / 2; i++ {\n \
    \           if n % i == 0 {\n                return false\n            }\n   \
    \     }\n        return true\n    }\n    if start1 > end2 || start2 > end1 {\n\
    \        return \"NO\"\n    }\n    var min, max int\n    if start1 > start2 {\n\
    \        min = start1\n    } else {\n        min = start2\n    }\n    if end1\
    \ > end2 {\n        max = end2\n    } else {\n        max = end1\n    }\n    if\
    \ is_prime(max - min + 1) {\n        return \"YES\"\n    }\n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpp48ar9b6_test.go:95: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpp48ar9b6_test.go:95: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075340
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    s1 := interval1[0].(int)\n    e1 := interval1[1].(int)\n    s2\
    \ := interval2[0].(int)\n    e2 := interval2[1].(int)\n    if (s1 <= s2 && s2\
    \ <= e1) || (s2 <= s1 && s1 <= e2) {\n        // Intersects.\n        start :=\
    \ max(s1, s2)\n        end := min(e1, e2)\n        n := end - start + 1\n    \
    \    if n <= 0 {\n            return \"NO\"\n        }\n        if n == 1 {\n\
    \            return \"YES\"\n        }\n        if n % 2 == 0 {\n            return\
    \ \"NO\"\n        }\n        if n % 3 == 0 {\n            return \"NO\"\n    \
    \    }\n        // Test all primes until n.\n        for p := 5; p <= n; p +=\
    \ 2 {\n            if n % p == 0 {\n                return \"NO\"\n          \
    \  }\n        }\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgouzqpvt_test.go:34:18: undefined: max

    /tmp/tmpgouzqpvt_test.go:35:16: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075340
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    int1 := interval1[0].(int)\n    int2 := interval1[1].(int)\n \
    \   int3 := interval2[0].(int)\n    int4 := interval2[1].(int)\n    start := int1\n\
    \    end := int2\n    if int1 > int3 {\n        start = int3\n    }\n    if int2\
    \ < int4 {\n        end = int2\n    }\n    if start > end {\n        return \"\
    NO\"\n    }\n    flag := true\n    if start <= 2 && end >= 2 {\n        flag =\
    \ false\n    }\n    for i := start; i <= end; i++ {\n        if i != 2 && i !=\
    \ 3 && i != 5 && i != 7 {\n            flag = false\n        }\n    }\n    if\
    \ flag {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmp4l46vd4l_test.go:78: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmp4l46vd4l_test.go:78: expected\
    \ 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075340
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    max := func(a, b int) int {\n        if a > b {\n            return\
    \ a\n        }\n        return b\n    }\n    min := func(a, b int) int {\n   \
    \     if a < b {\n            return a\n        }\n        return b\n    }\n \
    \   isPrime := func(n int) bool {\n        if n < 2 {\n            return false\n\
    \        }\n        for i := 2; i * i <= n; i++ {\n            if n % i == 0 {\n\
    \                return false\n            }\n        }\n        return true\n\
    \    }\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n   \
    \ start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    start := max(start1,\
    \ start2)\n    end := min(end1, end2)\n    if start > end {\n        return \"\
    NO\"\n    }\n    return map[bool]string{true: \"YES\", false: \"NO\"}[isPrime(end\
    \ - start + 1)]\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpz3ah3x2v_test.go:83: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpz3ah3x2v_test.go:83: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075340
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    s := []int{interval1[0].(int), interval2[0].(int)}\n    e := []int{interval1[1].(int),\
    \ interval2[1].(int)}\n    maxStart := max(s[0], s[1])\n    minEnd := min(e[0],\
    \ e[1])\n    interLen := minEnd - maxStart\n    if interLen < 0 {\n        return\
    \ \"NO\"\n    }\n    if isPrime(interLen) {\n        return \"YES\"\n    }\n \
    \   return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt3q45xig_test.go:30:17: undefined: max

    /tmp/tmpt3q45xig_test.go:31:15: undefined: min

    /tmp/tmpt3q45xig_test.go:36:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075340
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    int1 := toIntSlice(interval1)\n    int2 := toIntSlice(interval2)\n\
    \    if int1[0] <= int2[0] {\n        if int1[1] < int2[0] {\n            return\
    \ \"NO\"\n        }\n        if int1[1] <= int2[1] {\n            return isPrime(int2[0]\
    \ - int1[1])\n        }\n        return isPrime(int2[0] - int2[1])\n    }\n  \
    \  if int2[1] < int1[0] {\n        return \"NO\"\n    }\n    if int2[1] <= int1[1]\
    \ {\n        return isPrime(int1[0] - int2[1])\n    }\n    return isPrime(int1[0]\
    \ - int1[1])\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph_wevrjo_test.go:28:13: undefined: toIntSlice

    /tmp/tmph_wevrjo_test.go:29:13: undefined: toIntSlice

    /tmp/tmph_wevrjo_test.go:35:20: undefined: isPrime

    /tmp/tmph_wevrjo_test.go:37:16: undefined: isPrime

    /tmp/tmph_wevrjo_test.go:43:16: undefined: isPrime

    /tmp/tmph_wevrjo_test.go:45:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075340
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n\treturn \"\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpj9x7swki_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpj9x7swki_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpj9x7swki_test.go:51:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpj9x7swki_test.go:51: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpj9x7swki_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpj9x7swki_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpj9x7swki_test.go:51:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpj9x7swki_test.go:51: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075341
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // Write your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp5sf2j70y_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp5sf2j70y_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp5sf2j70y_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp5sf2j70y_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp5sf2j70y_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp5sf2j70y_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp5sf2j70y_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp5sf2j70y_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075341
- exit_code: 0
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    var s,\
    \ e int\n    if start1 < start2 {\n        s = start2\n    } else {\n        s\
    \ = start1\n    }\n    if end1 < end2 {\n        e = end1\n    } else {\n    \
    \    e = end2\n    }\n    if s >= e {\n        return \"NO\"\n    }\n    l :=\
    \ e - s\n    if l <= 1 {\n        return \"NO\"\n    }\n    if l == 2 {\n    \
    \    return \"YES\"\n    }\n    for i := 2; i < l; i++ {\n        if l % i ==\
    \ 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075341
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if end1\
    \ < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    if start1 <=\
    \ start2 {\n        if end1 <= end2 {\n            return isPrime(end1 - start2\
    \ + 1)\n        } else {\n            return isPrime(end2 - start2 + 1)\n    \
    \    }\n    } else {\n        if end1 <= end2 {\n            return isPrime(end1\
    \ - start1 + 1)\n        } else {\n            return isPrime(end2 - start1 +\
    \ 1)\n        }\n    }\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd2e9c73b_test.go:37:20: undefined: isPrime

    /tmp/tmpd2e9c73b_test.go:39:20: undefined: isPrime

    /tmp/tmpd2e9c73b_test.go:43:20: undefined: isPrime

    /tmp/tmpd2e9c73b_test.go:45:20: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075340
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if isDisjoint(interval1, interval2) {\n        return \"NO\"\n\
    \    }\n    if !isIntersect(interval1, interval2) {\n        return \"NO\"\n \
    \   }\n    if isDisjoint(interval1, interval2) {\n        return \"NO\"\n    }\n\
    \    start := max(interval1[0].(int), interval2[0].(int))\n    end := min(interval1[1].(int),\
    \ interval2[1].(int))\n    if start > end {\n        return \"NO\"\n    }\n  \
    \  if start == end {\n        return \"YES\"\n    }\n    if isPrime(end - start)\
    \ {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_atf5hm0_test.go:28:8: undefined: isDisjoint

    /tmp/tmp_atf5hm0_test.go:31:9: undefined: isIntersect

    /tmp/tmp_atf5hm0_test.go:34:8: undefined: isDisjoint

    /tmp/tmp_atf5hm0_test.go:37:14: undefined: max

    /tmp/tmp_atf5hm0_test.go:38:12: undefined: min

    /tmp/tmp_atf5hm0_test.go:45:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075340
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start := max(interval1[0].(int), interval2[0].(int))\n    end\
    \ := min(interval1[1].(int), interval2[1].(int))\n    if start > end {\n     \
    \   return \"NO\"\n    }\n    return isPrime(end - start + 1)\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpntn69f7r_test.go:28:14: undefined: max

    /tmp/tmpntn69f7r_test.go:29:12: undefined: min

    /tmp/tmpntn69f7r_test.go:33:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075340
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if (start1\
    \ < start2) {\n        start1, start2 = start2, start1\n        end1, end2 = end2,\
    \ end1\n    }\n    if (start1 > end2) {\n        return \"NO\"\n    }\n    start\
    \ := start1\n    end := end2\n    if (end > end1) {\n        end = end1\n    }\n\
    \    if (start <= end) {\n        return fmt.Sprintf(\"%v\", end - start)\n  \
    \  }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp6t9wnotd_test.go:70: expected 'NO', got '0'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp6t9wnotd_test.go:70: expected\
    \ 'NO', got '1'\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp6t9wnotd_test.go:70:\
    \ expected 'YES', got '2'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp6t9wnotd_test.go:70: expected 'YES', got '2'\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp6t9wnotd_test.go:70: expected 'NO', got '0'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmp6t9wnotd_test.go:70: expected\
    \ 'NO', got '1'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n        tmp6t9wnotd_test.go:70:\
    \ expected 'NO', got '0'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075342
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    if end1 < start2\
    \ || end2 < start1 {\n        return \"NO\"\n    }\n    left := start1\n    if\
    \ start2 > start1 {\n        left = start2\n    }\n    right := end1\n    if end2\
    \ < end1 {\n        right = end2\n    }\n    if left == right {\n        return\
    \ \"YES\"\n    }\n    if isPrime(right - left) {\n        return \"YES\"\n   \
    \ }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp33_iii6e_test.go:49:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075341
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // your code here\n    // lets take the intersection as a slice\n\
    \    inter := []int{}\n    // I really just need to find the first element and\
    \ last element of the \n    // intersection\n    // First:\n    // We know the\
    \ first element cant be higher than the interval that starts first\n    // So\
    \ we find the smaller of the two\n    // Second:\n    // We know the last element\
    \ cant be lower than the interval that starts last\n    // So we find the greater\
    \ of the two\n    // With the first and last elements of the intersection, we\
    \ can determine\n    // the length of the intersection by taking the difference\
    \ between the two\n    first := 0\n    if interval1[0].(int) < interval2[0].(int)\
    \ {\n        first = interval1[0].(int)\n    } else {\n        first = interval2[0].(int)\n\
    \    }\n    last := 0\n    if interval1[1].(int) > interval2[1].(int) {\n    \
    \    last = interval1[1].(int)\n    } else {\n        last = interval2[1].(int)\n\
    \    }\n    if first > last {\n        return \"NO\"\n    }\n    inter = append(inter,\
    \ first)\n    inter = append(inter, last)\n    // Now we have the intersection,\
    \ we need to determine if the length of the\n    // intersection is a prime number\n\
    \    // To do this, we will have a function that determines if a number is prime\n\
    \    // and we will call that function on the length of the intersection\n   \
    \ if isPrime(last - first) {\n        return \"YES\"\n    }\n    return \"NO\"\
    \n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4_pxr3fm_test.go:62:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075341
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmp1ihwkvrw_test.go:51: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmp1ihwkvrw_test.go:51: expected\
    \ 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075230
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n\tstart := max(interval1[0].(int), interval2[0].(int))\n\tend := min(interval1[1].(int),\
    \ interval2[1].(int))\n\tif end < start {\n\t\treturn \"NO\"\n\t}\n\treturn isPrime(end\
    \ - start + 1)\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_u_ba7wv_test.go:28:11: undefined: max

    /tmp/tmp_u_ba7wv_test.go:29:9: undefined: min

    /tmp/tmp_u_ba7wv_test.go:33:9: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075342
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if (interval1[0].(int) > interval2[1].(int)) || (interval2[0].(int)\
    \ > interval1[1].(int)) {\n        return \"NO\"\n    }\n\n    start := interval1[0].(int)\n\
    \    if interval2[0].(int) > start {\n        start = interval2[0].(int)\n   \
    \ }\n\n    end := interval1[1].(int)\n    if interval2[1].(int) < end {\n    \
    \    end = interval2[1].(int)\n    }\n\n    if start == end {\n        return\
    \ \"YES\"\n    }\n\n    n := end - start\n    count := 0\n    for i := 2; i <\
    \ n; i++ {\n        if n % i == 0 {\n            count++\n        }\n    }\n\n\
    \    if count > 0 {\n        return \"NO\"\n    }\n\n    return \"YES\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpvoeo9669_test.go:81: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpvoeo9669_test.go:81: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpvoeo9669_test.go:81: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpvoeo9669_test.go:81: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpvoeo9669_test.go:81: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075342
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var start, end int\n    // the length of intersection\n    var\
    \ length int\n    if v, ok := interval1[0].(int); ok {\n        start = v\n  \
    \  }\n    if v, ok := interval1[1].(int); ok {\n        end = v\n    }\n    //\
    \ fmt.Println(start, end)\n    if v, ok := interval2[0].(int); ok {\n        if\
    \ v > start {\n            start = v\n        }\n    }\n    if v, ok := interval2[1].(int);\
    \ ok {\n        if v < end {\n            end = v\n        }\n    }\n    // fmt.Println(start,\
    \ end)\n    if start > end {\n        return \"NO\"\n    }\n    length = end -\
    \ start\n    if isPrime(length) {\n        return \"YES\"\n    }\n    return \"\
    NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk_5za91__test.go:53:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075342
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start := 0\n    end := 0\n    if interval1[0].(int) > interval2[0].(int)\
    \ {\n        start = interval1[0].(int)\n    } else {\n        start = interval2[0].(int)\n\
    \    }\n    if interval1[1].(int) < interval2[1].(int) {\n        end = interval1[1].(int)\n\
    \    } else {\n        end = interval2[1].(int)\n    }\n    if start > end {\n\
    \        return \"NO\"\n    }\n    if start == end {\n        return \"YES\"\n\
    \    }\n    if isPrime(end - start) {\n        return \"YES\"\n    }\n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_os40ht__test.go:46:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075342
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    t1 := interval1[0].(int)\n    t2 := interval1[1].(int)\n    t3\
    \ := interval2[0].(int)\n    t4 := interval2[1].(int)\n    // fmt.Println(t1,\
    \ t2, t3, t4)\n    if (t1 > t2) { t1, t2 = t2, t1 }\n    if (t3 > t4) { t3, t4\
    \ = t4, t3 }\n    if (t1 > t4 || t2 < t3) { return \"NO\" }\n    if (t1 <= t3\
    \ && t2 >= t4) {\n        return isPrime(t4 - t3 + 1)\n    }\n    if (t1 >= t3\
    \ && t2 <= t4) {\n        return isPrime(t2 - t1 + 1)\n    }\n    if (t1 >= t3\
    \ && t1 <= t4 && t2 >= t4) {\n        return isPrime(t4 - t1 + 1)\n    }\n   \
    \ if (t1 <= t3 && t2 >= t3 && t2 <= t4) {\n        return isPrime(t2 - t3 + 1)\n\
    \    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzwradp53_test.go:37:16: undefined: isPrime

    /tmp/tmpzwradp53_test.go:40:16: undefined: isPrime

    /tmp/tmpzwradp53_test.go:43:16: undefined: isPrime

    /tmp/tmpzwradp53_test.go:46:16: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075342
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    len1 := end1 - start1\n    len2 :=\
    \ end2 - start2\n    if len1 < len2 {\n        start1, end1, start2, end2 = start2,\
    \ end2, start1, end1\n    }\n    for {\n        if start1 > end2 {\n         \
    \   return \"NO\"\n        }\n        if start1 >= start2 && start1 <= end2 {\n\
    \            return checkPrime(start1 - start2 + 1)\n        }\n        start1++\n\
    \    }\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2s70_6bu_test.go:51:20: undefined: checkPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075343
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n\n    // fmt.Println(interval1[0].(int))\n\
    \    // fmt.Println(interval1[1].(int))\n    // fmt.Println(interval2[0].(int))\n\
    \    // fmt.Println(interval2[1].(int))\n\n    start := max(interval1[0].(int),\
    \ interval2[0].(int))\n    end := min(interval1[1].(int), interval2[1].(int))\n\
    \n    // fmt.Println(start)\n    // fmt.Println(end)\n\n    if start == end {\n\
    \        return \"YES\"\n    }\n\n    for i := start + 1; i < end; i++ {\n   \
    \     if isPrime(i) {\n            return \"YES\"\n        }\n    }\n\n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpol3mfbbi_test.go:37:14: undefined: max

    /tmp/tmpol3mfbbi_test.go:38:12: undefined: min

    /tmp/tmpol3mfbbi_test.go:48:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075343
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    return \"\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpucj46pv2_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpucj46pv2_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpucj46pv2_test.go:51:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpucj46pv2_test.go:51: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpucj46pv2_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpucj46pv2_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpucj46pv2_test.go:51:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpucj46pv2_test.go:51: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075343
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var start, end int\n    if interval1[0].(int) > interval2[0].(int)\
    \ {\n        start = interval1[0].(int)\n    } else {\n        start = interval2[0].(int)\n\
    \    }\n    if interval1[1].(int) < interval2[1].(int) {\n        end = interval1[1].(int)\n\
    \    } else {\n        end = interval2[1].(int)\n    }\n    if start >= end {\n\
    \        return \"NO\"\n    }\n    if isPrime(end - start) {\n        return \"\
    YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprc3dx5hr_test.go:42:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075343
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n    var start, end int\n\
    \    if interval1[0].(int) >= interval2[0].(int) {\n        start = interval1[0].(int)\n\
    \    } else {\n        start = interval2[0].(int)\n    }\n    if interval1[1].(int)\
    \ <= interval2[1].(int) {\n        end = interval1[1].(int)\n    } else {\n  \
    \      end = interval2[1].(int)\n    }\n    if end - start == 1 {\n        return\
    \ \"YES\"\n    }\n    for i := start + 1; i < end; i++ {\n        for j := 2;\
    \ j < i; j++ {\n            if i % j == 0 {\n                return \"NO\"\n \
    \           }\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp4js4_riy_test.go:75: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp4js4_riy_test.go:75: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp4js4_riy_test.go:75: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp4js4_riy_test.go:75: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmp4js4_riy_test.go:75: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075343
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string = \"NO\"\n    var start int = 0\n    var end\
    \ int = 0\n    if interval1[0].(int) < interval2[0].(int) {\n        start = interval2[0].(int)\n\
    \    } else {\n        start = interval1[0].(int)\n    }\n    if interval1[1].(int)\
    \ < interval2[1].(int) {\n        end = interval1[1].(int)\n    } else {\n   \
    \     end = interval2[1].(int)\n    }\n    if start < end {\n        result =\
    \ \"YES\"\n    }\n    return result\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpk62fgusq_test.go:67: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpk62fgusq_test.go:67: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075343
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != 2 || len(interval2) != 2 {\n        return\
    \ \"NO\"\n    }\n    start1, ok := interval1[0].(int)\n    if !ok {\n        return\
    \ \"NO\"\n    }\n    end1, ok := interval1[1].(int)\n    if !ok {\n        return\
    \ \"NO\"\n    }\n    start2, ok := interval2[0].(int)\n    if !ok {\n        return\
    \ \"NO\"\n    }\n    end2, ok := interval2[1].(int)\n    if !ok {\n        return\
    \ \"NO\"\n    }\n    if start1 >= end1 || start2 >= end2 {\n        return \"\
    NO\"\n    }\n    if start1 <= start2 && end1 >= start2 {\n        if end1 < end2\
    \ {\n            if end1 - start2 == 1 {\n                return \"YES\"\n   \
    \         }\n            return \"NO\"\n        }\n        if end1 >= end2 {\n\
    \            if end2 - start2 == 1 {\n                return \"YES\"\n       \
    \     }\n            return \"NO\"\n        }\n    }\n    if start2 <= start1\
    \ && end2 >= start1 {\n        if end2 < end1 {\n            if end2 - start1\
    \ == 1 {\n                return \"YES\"\n            }\n            return \"\
    NO\"\n        }\n        if end2 >= end1 {\n            if end1 - start1 == 1\
    \ {\n                return \"YES\"\n            }\n            return \"NO\"\n\
    \        }\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpkyi9cl3j_test.go:101: expected 'NO', got 'YES'\n    ---\
    \ FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpkyi9cl3j_test.go:101:\
    \ expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpkyi9cl3j_test.go:101: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpkyi9cl3j_test.go:101: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075343
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    return fmt.Sprintf(\"YES\")\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpldn6a6_v_test.go:51: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpldn6a6_v_test.go:51: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpldn6a6_v_test.go:51: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__5\
    \ (0.00s)\n        tmpldn6a6_v_test.go:51: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpldn6a6_v_test.go:51: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmpldn6a6_v_test.go:51: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075343
- exit_code: 0
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    int1 := interval1[0].(int)\n    int2 := interval1[1].(int)\n \
    \   int3 := interval2[0].(int)\n    int4 := interval2[1].(int)\n    start := 0\n\
    \    end := 0\n    isIntersect := false\n    if int1 <= int3 && int3 <= int2 {\n\
    \        start = int3\n        isIntersect = true\n    } else if int3 <= int1\
    \ && int1 <= int4 {\n        start = int1\n        isIntersect = true\n    }\n\
    \    if int1 <= int4 && int4 <= int2 {\n        end = int4\n        isIntersect\
    \ = true\n    } else if int3 <= int2 && int2 <= int4 {\n        end = int2\n \
    \       isIntersect = true\n    }\n    if !isIntersect {\n        return \"NO\"\
    \n    }\n    res := end - start\n    if res <= 1 {\n        return \"NO\"\n  \
    \  }\n    if res == 2 {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075343
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    a := interval1[0].(int)\n    b := interval1[1].(int)\n    c :=\
    \ interval2[0].(int)\n    d := interval2[1].(int)\n    if b < c || a > d {\n \
    \       return \"NO\"\n    }\n    l := b - c\n    if l < 0 {\n        l = -l\n\
    \    }\n    return isPrime(l)\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1h4zvucx_test.go:39:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075343
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var start, end, a, b int\n\n    start = interval1[0].(int)\n \
    \   end = interval1[1].(int)\n    a = interval2[0].(int)\n    b = interval2[1].(int)\n\
    \n    if start > end {\n        start, end = end, start\n    }\n    if a > b {\n\
    \        a, b = b, a\n    }\n\n    if a > end || b < start {\n        return \"\
    NO\"\n    }\n\n    // Found the intersection.\n    // Now start computation.\n\
    \    if b < end {\n        end = b\n    }\n    if a > start {\n        start =\
    \ a\n    }\n\n    for i := start; i <= end; i++ {\n        if i % 2 == 0 {\n \
    \           return \"NO\"\n        }\n    }\n\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmp86ft8ua__test.go:84: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmp86ft8ua__test.go:84: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp86ft8ua__test.go:84: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075343
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n    start := max(interval1[0].(int),\
    \ interval2[0].(int))\n    end := min(interval1[1].(int), interval2[1].(int))\n\
    \    length := end - start + 1\n    prime := true\n    for i := 2; i < length;\
    \ i++ {\n        if length % i == 0 {\n            prime = false\n           \
    \ break\n        }\n    }\n    if prime {\n        return \"YES\"\n    }\n   \
    \ return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph8w6cxyn_test.go:31:14: undefined: max

    /tmp/tmph8w6cxyn_test.go:32:12: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075343
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if end1\
    \ < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    if start1 <=\
    \ start2 {\n        if end1 <= end2 {\n            return isPrime(end1 - start2\
    \ + 1)\n        } else {\n            return isPrime(end2 - start2 + 1)\n    \
    \    }\n    } else {\n        if end1 <= end2 {\n            return isPrime(end1\
    \ - start1 + 1)\n        } else {\n            return isPrime(end2 - start1 +\
    \ 1)\n        }\n    }\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd2e9c73b_test.go:37:20: undefined: isPrime

    /tmp/tmpd2e9c73b_test.go:39:20: undefined: isPrime

    /tmp/tmpd2e9c73b_test.go:43:20: undefined: isPrime

    /tmp/tmpd2e9c73b_test.go:45:20: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075340
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // Write your code here\n    // To print results to the standard\
    \ output you can use fmt.Println()\n    // Example: fmt.Println(\"Hello world!\"\
    )\n    return \"\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmplkct3vnb_test.go:54: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmplkct3vnb_test.go:54: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmplkct3vnb_test.go:54:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmplkct3vnb_test.go:54: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmplkct3vnb_test.go:54: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmplkct3vnb_test.go:54: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmplkct3vnb_test.go:54:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmplkct3vnb_test.go:54: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075343
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    left := max(interval1[0].(int), interval2[0].(int))\n    right\
    \ := min(interval1[1].(int), interval2[1].(int))\n    if right <= left {\n   \
    \     return \"NO\"\n    }\n    if isPrime(right - left) {\n        return \"\
    YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7d7lelf1_test.go:28:13: undefined: max

    /tmp/tmp7d7lelf1_test.go:29:14: undefined: min

    /tmp/tmp7d7lelf1_test.go:33:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075343
- exit_code: 0
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    length := end - start\n    if length <= 1 {\n  \
    \      return \"NO\"\n    }\n    for i := 2; i < length; i++ {\n        if length\
    \ % i == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075343
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // arr := toIntSlice(interval1)\n    if IsIntersected(interval1,\
    \ interval2) {\n        if isPrime(IntersectionSize(interval1, interval2)) {\n\
    \            return \"YES\"\n        }\n        return \"NO\"\n    }\n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpby5c4wl3_test.go:29:8: undefined: IsIntersected

    /tmp/tmpby5c4wl3_test.go:30:12: undefined: isPrime

    /tmp/tmpby5c4wl3_test.go:30:20: undefined: IntersectionSize

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075343
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    i1 := interval1[0].(int)\n    i2 := interval1[1].(int)\n    i3\
    \ := interval2[0].(int)\n    i4 := interval2[1].(int)\n    max := func(a, b int)\
    \ int {\n        if a > b {\n            return a\n        }\n        return b\n\
    \    }\n    min := func(a, b int) int {\n        if a < b {\n            return\
    \ a\n        }\n        return b\n    }\n    if (i1 < i2 && i3 < i4) && (max(i1,\
    \ i3) <= min(i2, i4)) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpf9qxkkld_test.go:70: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpf9qxkkld_test.go:70: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n      \
    \  tmpf9qxkkld_test.go:70: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075344
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    fmt.Println(interval1, interval2)\n    return \"wrong answer\"\
    \n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "[1 2] [2 3]\n[-1 1] [0 4]\n[-3 -1] [-5 5]\n[-2 2] [-4 0]\n[-11 2] [-1 -1]\n\
    [1 2] [3 5]\n[1 2] [1 2]\n[-2 -2] [-3 -2]\n--- FAIL: TestIntersection (0.00s)\n\
    \    --- FAIL: TestIntersection/test_num__0 (0.00s)\n        tmpzzj4of8c_test.go:52:\
    \ expected 'NO', got 'wrong answer'\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpzzj4of8c_test.go:52: expected 'NO', got 'wrong answer'\n\
    \    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpzzj4of8c_test.go:52:\
    \ expected 'YES', got 'wrong answer'\n    --- FAIL: TestIntersection/test_num__3\
    \ (0.00s)\n        tmpzzj4of8c_test.go:52: expected 'YES', got 'wrong answer'\n\
    \    --- FAIL: TestIntersection/test_num__4 (0.00s)\n        tmpzzj4of8c_test.go:52:\
    \ expected 'NO', got 'wrong answer'\n    --- FAIL: TestIntersection/test_num__5\
    \ (0.00s)\n        tmpzzj4of8c_test.go:52: expected 'NO', got 'wrong answer'\n\
    \    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpzzj4of8c_test.go:52:\
    \ expected 'NO', got 'wrong answer'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpzzj4of8c_test.go:52: expected 'NO', got 'wrong answer'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075344
- exit_code: 0
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    //fmt.Println(start1,\
    \ end1, start2, end2)\n    if end1 < start2 || end2 < start1 {\n        return\
    \ \"NO\"\n    }\n    start := start1\n    if start1 < start2 {\n        start\
    \ = start2\n    }\n    end := end1\n    if end1 > end2 {\n        end = end2\n\
    \    }\n    length := end - start\n    if length <= 1 {\n        return \"NO\"\
    \n    }\n    if length == 2 {\n        return \"YES\"\n    }\n    if length %\
    \ 2 == 0 {\n        return \"NO\"\n    }\n    for i := 3; i < length / 2; i +=\
    \ 2 {\n        if length % i == 0 {\n            return \"NO\"\n        }\n  \
    \  }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075344
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // NOTE: x and y are assumed to be small positive integers.\n\
    \    x, y := interval1[0].(int), interval1[1].(int)\n    p, q := interval2[0].(int),\
    \ interval2[1].(int)\n    if y < p || q < x {\n        return \"NO\"\n    }\n\
    \    start, end := x, y\n    if p > x {\n        start = p\n    }\n    if q <\
    \ y {\n        end = q\n    }\n    for i := start; i <= end; i++ {\n        if\
    \ isPrime(i) {\n            return \"YES\"\n        }\n    }\n    return \"NO\"\
    \n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpshp5vp6m_test.go:42:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075344
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 >= end2 || start2 >=\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if end - start == 1 {\n        return \"YES\"\n\
    \    }\n    if end - start < 1 {\n        return \"NO\"\n    }\n    prime := []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97}\n    for _, p := range prime {\n        if p == end - start\
    \ {\n            return \"YES\"\n        }\n    }\n    return \"NO\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpej25e5nb_test.go:84: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpej25e5nb_test.go:84: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075345
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    return \"\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpucj46pv2_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpucj46pv2_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpucj46pv2_test.go:51:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpucj46pv2_test.go:51: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpucj46pv2_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpucj46pv2_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpucj46pv2_test.go:51:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpucj46pv2_test.go:51: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075343
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var prime bool = true\n    for i := interval1[0].(int); i <= interval1[1].(int);\
    \ i++ {\n        for j := interval2[0].(int); j <= interval2[1].(int); j++ {\n\
    \            if i == j {\n                // fmt.Println(i)\n                for\
    \ k := 2; k < i; k++ {\n                    if i % k == 0 {\n                \
    \        prime = false\n                        break\n                    }\n\
    \                }\n                if prime {\n                    return \"\
    YES\"\n                }\n            }\n        }\n    }\n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpnp0ycovs_test.go:68: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpnp0ycovs_test.go:68: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpnp0ycovs_test.go:68: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpnp0ycovs_test.go:68: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpnp0ycovs_test.go:68: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075345
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    a, b := interval1[0].(int), interval1[1].(int)\n    c, d := interval2[0].(int),\
    \ interval2[1].(int)\n    if a > b {\n        a, b = b, a\n    }\n    if c > d\
    \ {\n        c, d = d, c\n    }\n    e, f := max(a, c), min(b, d)\n    if e >\
    \ f {\n        return \"NO\"\n    }\n    if e == f {\n        return \"YES\"\n\
    \    }\n    return isPrime(f - e + 1)\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2o92_7pr_test.go:36:13: undefined: max

    /tmp/tmp2o92_7pr_test.go:36:24: undefined: min

    /tmp/tmp2o92_7pr_test.go:43:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075345
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int)\
    \ < interval2[0].(int) {\n        interval1[0] = interval2[0]\n    }\n    if interval1[1].(int)\
    \ > interval2[1].(int) {\n        interval1[1] = interval2[1]\n    }\n    interval1[0]\
    \ = interval1[0].(int) - interval1[1].(int)\n    if interval1[0].(int) < 0 {\n\
    \        interval1[0] = interval1[0].(int) * -1\n    }\n    interval1[0] = interval1[0].(int)\
    \ + 1\n    if interval1[0].(int) <= 1 {\n        return \"NO\"\n    }\n    for\
    \ i := 2; i < interval1[0].(int); i++ {\n        if interval1[0].(int) % i ==\
    \ 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpp4mn3jai_test.go:73: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpp4mn3jai_test.go:73: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075345
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // check input\n    if len(interval1) != 2 || len(interval2) !=\
    \ 2 {\n        return \"NO\"\n    }\n    // get start and end points\n    start1\
    \ := int(interval1[0].(float64))\n    end1 := int(interval1[1].(float64))\n  \
    \  start2 := int(interval2[0].(float64))\n    end2 := int(interval2[1].(float64))\n\
    \    // check if the two intervals intersect\n    if start1 >= end2 || start2\
    \ >= end1 {\n        return \"NO\"\n    }\n    // calculate the intersection\n\
    \    start := start1\n    if start1 < start2 {\n        start = start2\n    }\n\
    \    end := end1\n    if end1 > end2 {\n        end = end2\n    }\n    // if the\
    \ length of the intersection is prime, return \"YES\", otherwise return \"NO\"\
    \n    if isPrime(end - start) {\n        return \"YES\"\n    }\n    return \"\
    NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7qwf8kl5_test.go:51:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075345
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if end1 < start2 || end2 < start1\
    \ {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if end == start {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < end - start; i++ {\n        if (end - start) % i == 0 {\n\
    \            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpmjbjabyx_test.go:80: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpmjbjabyx_test.go:80: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpmjbjabyx_test.go:80: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpmjbjabyx_test.go:80: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpmjbjabyx_test.go:80: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075345
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    fmt.Println(start1,\
    \ end1, start2, end2)\n    var intersectionStart, intersectionEnd int\n    if\
    \ start1 < start2 {\n        intersectionStart = start2\n    } else {\n      \
    \  intersectionStart = start1\n    }\n    if end1 < end2 {\n        intersectionEnd\
    \ = end1\n    } else {\n        intersectionEnd = end2\n    }\n    length := intersectionEnd\
    \ - intersectionStart\n    if length == 0 {\n        return \"NO\"\n    }\n  \
    \  for i := 2; i < length; i++ {\n        if length % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "1 2 2 3\n-1 1 0 4\n-3 -1 -5 5\n-2 2 -4 0\n-11 2 -1 -1\n1 2 3 5\n1 2 1 2\n\
    -2 -2 -3 -2\n--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpvluuhcb4_test.go:76: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpvluuhcb4_test.go:76: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n      \
    \  tmpvluuhcb4_test.go:76: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075345
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    return \"\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpucj46pv2_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpucj46pv2_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpucj46pv2_test.go:51:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpucj46pv2_test.go:51: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpucj46pv2_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpucj46pv2_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpucj46pv2_test.go:51:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpucj46pv2_test.go:51: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075343
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    //your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp7h32ajct_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp7h32ajct_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp7h32ajct_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp7h32ajct_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp7h32ajct_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp7h32ajct_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp7h32ajct_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp7h32ajct_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075345
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n\n    var intersection_start,\
    \ intersection_end int\n    if interval1[0].(int) < interval2[0].(int) {\n   \
    \     intersection_start = interval2[0].(int)\n    } else {\n        intersection_start\
    \ = interval1[0].(int)\n    }\n\n    if interval1[1].(int) < interval2[1].(int)\
    \ {\n        intersection_end = interval1[1].(int)\n    } else {\n        intersection_end\
    \ = interval2[1].(int)\n    }\n\n    var length = intersection_end - intersection_start\n\
    \    if length == 1 {\n        return \"NO\"\n    } else if length == 2 {\n  \
    \      return \"YES\"\n    }\n\n    for i := 3; i < length; i += 2 {\n       \
    \ if length % i == 0 {\n            return \"NO\"\n        }\n    }\n\n    return\
    \ \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp6kj9x4yt_test.go:81: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__4 (0.00s)\n        tmp6kj9x4yt_test.go:81: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmp6kj9x4yt_test.go:81: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075346
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    start :=\
    \ 0\n    end := 0\n    if start1 > start2 {\n        start = start1\n    } else\
    \ {\n        start = start2\n    }\n    if end1 < end2 {\n        end = end1\n\
    \    } else {\n        end = end2\n    }\n    if start > end {\n        return\
    \ \"NO\"\n    }\n    len := end - start + 1\n    for i := 2; i < len; i++ {\n\
    \        if len % i == 0 {\n            return \"NO\"\n        }\n    }\n    return\
    \ \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpp6imt2rz_test.go:76: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpp6imt2rz_test.go:76: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpp6imt2rz_test.go:76: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpp6imt2rz_test.go:76: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpp6imt2rz_test.go:76: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075346
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // your code here\n    fmt.Println(interval1, interval2)\n   \
    \ return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "[1 2] [2 3]\n[-1 1] [0 4]\n[-3 -1] [-5 5]\n[-2 2] [-4 0]\n[-11 2] [-1 -1]\n\
    [1 2] [3 5]\n[1 2] [1 2]\n[-2 -2] [-3 -2]\n--- FAIL: TestIntersection (0.00s)\n\
    \    --- FAIL: TestIntersection/test_num__0 (0.00s)\n        tmpc01a1wgn_test.go:53:\
    \ expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__1 (0.00s)\n\
    \        tmpc01a1wgn_test.go:53: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpc01a1wgn_test.go:53: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpc01a1wgn_test.go:53: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n      \
    \  tmpc01a1wgn_test.go:53: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpc01a1wgn_test.go:53: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075346
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if interval1[0].(int) <= interval2[0].(int) {\n        if interval1[1].(int)\
    \ < interval2[0].(int) {\n            return \"NO\"\n        }\n        if interval1[1].(int)\
    \ > interval2[1].(int) {\n            return isPrime(interval2[1].(int) - interval2[0].(int)\
    \ + 1)\n        }\n        return isPrime(interval1[1].(int) - interval2[0].(int)\
    \ + 1)\n    } else {\n        if interval2[1].(int) < interval1[0].(int) {\n \
    \           return \"NO\"\n        }\n        if interval2[1].(int) > interval1[1].(int)\
    \ {\n            return isPrime(interval1[1].(int) - interval1[0].(int) + 1)\n\
    \        }\n        return isPrime(interval2[1].(int) - interval1[0].(int) + 1)\n\
    \    }\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwa0qkbi0_test.go:33:20: undefined: isPrime

    /tmp/tmpwa0qkbi0_test.go:35:16: undefined: isPrime

    /tmp/tmpwa0qkbi0_test.go:41:20: undefined: isPrime

    /tmp/tmpwa0qkbi0_test.go:43:16: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075345
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    start :=\
    \ Max(start1, start2)\n    end := Min(end1, end2)\n    if start > end {\n    \
    \    return \"NO\"\n    }\n    for i := start; i <= end; i++ {\n        if IsPrime(i)\
    \ {\n            return \"YES\"\n        }\n    }\n    return \"NO\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbko5fj7v_test.go:32:14: undefined: Max

    /tmp/tmpbko5fj7v_test.go:33:12: undefined: Min

    /tmp/tmpbko5fj7v_test.go:38:12: undefined: IsPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075345
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    fmt.Println(start1,\
    \ end1, start2, end2)\n    if start1 > end1 || start2 > end2 {\n        return\
    \ \"NO\"\n    }\n    if start1 <= start2 && end1 <= end2 {\n        return isPrime(start2\
    \ - end1)\n    }\n    if start1 >= start2 && end1 >= end2 {\n        return isPrime(end2\
    \ - start1)\n    }\n    if start1 >= start2 && end1 <= end2 {\n        return\
    \ isPrime(end1 - start1)\n    }\n    if start1 <= start2 && end1 >= end2 {\n \
    \       return isPrime(end2 - start2)\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpatw_2sbp_test.go:37:16: undefined: isPrime

    /tmp/tmpatw_2sbp_test.go:40:16: undefined: isPrime

    /tmp/tmpatw_2sbp_test.go:43:16: undefined: isPrime

    /tmp/tmpatw_2sbp_test.go:46:16: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075345
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    return \"\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpucj46pv2_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpucj46pv2_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpucj46pv2_test.go:51:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpucj46pv2_test.go:51: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpucj46pv2_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpucj46pv2_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpucj46pv2_test.go:51:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpucj46pv2_test.go:51: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075343
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != 2 || len(interval2) != 2 {\n        return\
    \ \"NO\"\n    }\n    var int1, int2 []int\n    for _, num := range interval1 {\n\
    \        int1 = append(int1, num.(int))\n    }\n    for _, num := range interval2\
    \ {\n        int2 = append(int2, num.(int))\n    }\n    if int1[0] > int1[1] ||\
    \ int2[0] > int2[1] {\n        return \"NO\"\n    }\n    if int1[0] > int2[1]\
    \ || int2[0] > int1[1] {\n        return \"NO\"\n    }\n    if int1[0] == int1[1]\
    \ && int2[0] == int2[1] {\n        if int1[0] == int2[0] {\n            return\
    \ \"YES\"\n        } else {\n            return \"NO\"\n        }\n    }\n   \
    \ if int1[0] <= int2[0] {\n        if int1[1] >= int2[1] {\n            return\
    \ checkIntersection(int2[0], int2[1])\n        } else {\n            return checkIntersection(int2[0],\
    \ int1[1])\n        }\n    } else {\n        if int2[1] >= int1[1] {\n       \
    \     return checkIntersection(int1[0], int1[1])\n        } else {\n         \
    \   return checkIntersection(int1[0], int2[1])\n        }\n    }\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnai_81ku_test.go:53:20: undefined: checkIntersection

    /tmp/tmpnai_81ku_test.go:55:20: undefined: checkIntersection

    /tmp/tmpnai_81ku_test.go:59:20: undefined: checkIntersection

    /tmp/tmpnai_81ku_test.go:61:20: undefined: checkIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075345
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    a := interval1[0].(int)\n    b := interval1[1].(int)\n    c :=\
    \ interval2[0].(int)\n    d := interval2[1].(int)\n    if b < c || d < a {\n \
    \       return \"NO\"\n    }\n    if d < b {\n        b = d\n    }\n    if c <\
    \ a {\n        a = c\n    }\n    length := b - a + 1\n    for i := 2; i <= length\
    \ / 2; i++ {\n        if length % i == 0 {\n            return \"NO\"\n      \
    \  }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpvp62ltrj_test.go:70: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpvp62ltrj_test.go:70: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpvp62ltrj_test.go:70: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpvp62ltrj_test.go:70: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpvp62ltrj_test.go:70: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075346
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != 2 || len(interval2) != 2 {\n        return\
    \ \"NO\"\n    }\n    x := interval1[0].(int)\n    y := interval1[1].(int)\n  \
    \  a := interval2[0].(int)\n    b := interval2[1].(int)\n    // fmt.Println(x,\
    \ y, a, b)\n    // fmt.Println(max(x, a), min(y, b))\n    if x > y || a > b {\n\
    \        return \"NO\"\n    }\n    c := max(x, a)\n    d := min(y, b)\n    //\
    \ fmt.Println(c, d)\n    // c := interval1[0].(int)\n    // d := interval1[1].(int)\n\
    \    if c > d {\n        return \"NO\"\n    }\n    if d - c < 2 {\n        return\
    \ \"NO\"\n    }\n    for i := 2; i < d - c; i++ {\n        if (d - c) % i == 0\
    \ {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjs0a2tzy_test.go:40:10: undefined: max

    /tmp/tmpjs0a2tzy_test.go:41:10: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075345
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if (len(interval1) != 2 || len(interval2) != 2) {\n        return\
    \ \"NO\"\n    }\n    // convert data type\n    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    // check intersection\n    if (start1 > end2 || start2\
    \ > end1) {\n        return \"NO\"\n    }\n    // find intersection\n    var start\
    \ int\n    var end int\n    if (start1 < start2) {\n        start = start2\n \
    \   } else {\n        start = start1\n    }\n    if (end1 < end2) {\n        end\
    \ = end1\n    } else {\n        end = end2\n    }\n    // check prime\n    if\
    \ isPrime(end - start) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphzlq8p5q_test.go:54:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075346
- exit_code: 0
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if end1\
    \ < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    start := start1\n\
    \    if start < start2 {\n        start = start2\n    }\n    end := end1\n   \
    \ if end > end2 {\n        end = end2\n    }\n    length := end - start\n    if\
    \ length <= 0 {\n        return \"NO\"\n    }\n    fmt.Println(length)\n    if\
    \ length == 1 {\n        return \"NO\"\n    }\n    for i := 2; i <= length / 2;\
    \ i++ {\n        if length % i == 0 {\n            return \"NO\"\n        }\n\
    \    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075346
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n\n    int1Start := interval1[0].(int)\n\
    \    int1End := interval1[1].(int)\n    int2Start := interval2[0].(int)\n    int2End\
    \ := interval2[1].(int)\n\n    if int1Start > int2Start {\n        int1Start =\
    \ int2Start\n    }\n    if int1End < int2End {\n        int1End = int2End\n  \
    \  }\n\n    return intersection([]interface{}{int1Start, int1End}, []interface{}{int2Start,\
    \ int2End})\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e03b0\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x52034d?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.intersection({0xc0201e0430?,\
    \ 0x2?, 0x2?}, {0xc0201e0410?, 0x2?, 0x2?})\n\t/tmp/tmpwzpzxbun_test.go:27 +0x21d\
    \ fp=0xc0201e03c0 sp=0xc0201e03b8 pc=0x4ef87d\ncommand-line-arguments_test.intersection({0xc0201e04d0?,\
    \ 0x0?, 0x0?}, {0xc0201e04b0?, 0x0?, 0x0?})\n\t/tmp/tmpwzpzxbun_test.go:44 +0x17d\
    \ fp=0xc0201e0460 sp=0xc0201e03c0 pc=0x4ef7dd\ncommand-line-arguments_test.intersection({0xc0201e0570?,\
    \ 0x0?, 0x0?}, {0xc0201e0550?, 0x0?, 0x0?})\n\t/tmp/tmpwzpzxbun_test.go:44 +0x17d\
    \ fp=0xc0201e0500 sp=0xc0201e0460 pc=0x4ef7dd\ncommand-line-arguments_test.intersection({0xc0201e0610?,\
    \ 0x0?, 0x0?}, {0xc0201e05f0?, 0x0?, 0x0?})\n\t/tmp/tmpwzpzxbun_test.go:44 +0x17d\
    \ fp=0xc0201e05a0 sp=0xc0201e0500 pc=0x4ef7dd\ncommand-line-arguments_test.intersection({0xc0201e06b0?,\
    \ 0x0?, 0x0?}, {0xc0201e0690?, 0x0?, 0x0?})\n\t/tmp/tmpwzpzxbun_test.go:44 +0x17d\
    \ fp=0xc0201e0640 sp=0xc0201e05a0 pc=0x4ef7dd\ncommand-line-arguments_test.intersection({0xc0201e0750?,\
    \ 0x0?, 0x0?}, {0xc0201e0730?, 0x0?, 0x0?})\n\t/tmp/tmpwzpzxbun_test.go:44 +0x17d\
    \ fp=0xc0201e06e0 sp=0xc0201e0640 pc=0x4ef7dd\ncommand-line-arguments_test.intersection({0xc0201e07f0?,\
    \ 0x0?, 0x0?}, {0xc0201e07d0?, 0x0?, 0x0?})\n\t/tmp/tmpwzpzxbun_test.go:44 +0x17d\
    \ fp=0xc0201e0780 sp=0xc0201e06e0 pc=0x4ef7dd\ncommand-line-arguments_test.intersection({0xc0201e0890?,\
    \ 0x0?, 0x0?}, {0xc0201e0870?, 0x0?, 0x0?})\n\t/tmp/tmpwzpzxbun_test.go:44 +0x17d\
    \ fp=0xc0201e0820 sp=0xc0201e0780 pc=0x4ef7dd\ncommand-line-arguments_test.intersection({0xc0201e0930?,\
    \ 0x0?, 0x0?}, {0xc0201e0910?, 0x0?, 0x0?})\n\t/tmp/tmpwzpzxbun_test.go:44 +0x17d\
    \ fp=0xc020"
  timestamp: 1660075347
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ <= start2 {\n        if end1 < start2 {\n            return \"NO\"\n       \
    \ }\n        if end1 >= end2 {\n            return judgeIsPrime(end2 - start2)\n\
    \        }\n        return judgeIsPrime(end1 - start2)\n    }\n    if start1 >\
    \ end2 {\n        return \"NO\"\n    }\n    if end1 >= end2 {\n        return\
    \ judgeIsPrime(end2 - start1)\n    }\n    return judgeIsPrime(end1 - start1)\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptfxwgmgn_test.go:37:20: undefined: judgeIsPrime

    /tmp/tmptfxwgmgn_test.go:39:16: undefined: judgeIsPrime

    /tmp/tmptfxwgmgn_test.go:45:16: undefined: judgeIsPrime

    /tmp/tmptfxwgmgn_test.go:47:12: undefined: judgeIsPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075346
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // your code goes here\n    a := interval1[0].(int)\n    b :=\
    \ interval1[1].(int)\n    c := interval2[0].(int)\n    d := interval2[1].(int)\n\
    \    if a > b {\n        a, b = b, a\n    }\n    if c > d {\n        c, d = d,\
    \ c\n    }\n    if a > d || b < c {\n        return \"NO\"\n    }\n    e := max(a,\
    \ c)\n    f := min(b, d)\n    g := f - e + 1\n    if g == 1 {\n        return\
    \ \"NO\"\n    }\n    for i := 2; i < g; i++ {\n        if g % i == 0 {\n     \
    \       return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw8odcnx7_test.go:42:10: undefined: max

    /tmp/tmpw8odcnx7_test.go:43:10: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075346
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    return \"\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpucj46pv2_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpucj46pv2_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpucj46pv2_test.go:51:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpucj46pv2_test.go:51: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpucj46pv2_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpucj46pv2_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpucj46pv2_test.go:51:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpucj46pv2_test.go:51: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075343
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    t := func(x interface{}) int {\n        return x.(int)\n    }\n\
    \    start1, end1 := t(interval1[0]), t(interval1[1])\n    start2, end2 := t(interval2[0]),\
    \ t(interval2[1])\n    if start1 > end1 {\n        start1, end1 = end1, start1\n\
    \    }\n    if start2 > end2 {\n        start2, end2 = end2, start2\n    }\n \
    \   start := max(start1, start2)\n    end := min(end1, end2)\n    if start >=\
    \ end {\n        return \"NO\"\n    }\n    for i := 2; i < start; i++ {\n    \
    \    if end % i == 0 {\n            return \"NO\"\n        }\n    }\n    return\
    \ \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg2y65csu_test.go:39:14: undefined: max

    /tmp/tmpg2y65csu_test.go:40:12: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075347
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // find length of the intersection\n    // check if prime\n  \
    \  return \"NO\"\n}\n\ntype testingCase \nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfs4q6kr9_test.go:33:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075346
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ <= start2 {\n        if end1 <= start2 {\n            return \"NO\"\n      \
    \  } else if end1 <= end2 {\n            return isPrime(end1 - start2)\n     \
    \   } else {\n            return isPrime(end2 - start2)\n        }\n    } else\
    \ {\n        if end2 <= start1 {\n            return \"NO\"\n        } else if\
    \ end2 <= end1 {\n            return isPrime(end2 - start1)\n        } else {\n\
    \            return isPrime(end1 - start1)\n        }\n    }\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa5s7iwg1_test.go:36:20: undefined: isPrime

    /tmp/tmpa5s7iwg1_test.go:38:20: undefined: isPrime

    /tmp/tmpa5s7iwg1_test.go:44:20: undefined: isPrime

    /tmp/tmpa5s7iwg1_test.go:46:20: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075347
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    length\
    \ := 0\n    // fmt.Println(start1, end1, start2, end2)\n    if start1 > end1 ||\
    \ start2 > end2 {\n        return \"NO\"\n    }\n    if end1 < start2 || end2\
    \ < start1 {\n        return \"NO\"\n    }\n    if start1 > start2 {\n       \
    \ if end1 > end2 {\n            length = end2 - start1 + 1\n        } else {\n\
    \            length = end1 - start1 + 1\n        }\n    } else {\n        if end1\
    \ > end2 {\n            length = end2 - start2 + 1\n        } else {\n       \
    \     length = end1 - start2 + 1\n        }\n    }\n    if length <= 1 {\n   \
    \     return \"NO\"\n    }\n    if length == 2 {\n        return \"YES\"\n   \
    \ }\n    for i := 2; i < length; i++ {\n        if length % i == 0 {\n       \
    \     return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpnxtyxemo_test.go:87: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpnxtyxemo_test.go:87: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075347
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    // check\
    \ if the two intervals intersect.\n    if start1 > end2 || start2 > end1 {\n \
    \       return \"NO\"\n    }\n    // get the start and end of the intersection\
    \ interval.\n    left := start1\n    if start2 > start1 {\n        left = start2\n\
    \    }\n    right := end1\n    if end2 < end1 {\n        right = end2\n    }\n\
    \    // check if the length of the intersection is a prime number.\n    length\
    \ := right - left + 1\n    var isPrime bool = true\n    for i := 2; i < length;\
    \ i++ {\n        if length % i == 0 {\n            isPrime = false\n         \
    \   break\n        }\n    }\n    if isPrime {\n        return \"YES\"\n    }\n\
    \    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp88ktrpwy_test.go:80: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp88ktrpwy_test.go:80: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp88ktrpwy_test.go:80: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp88ktrpwy_test.go:80: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmp88ktrpwy_test.go:80: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075347
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var (\n        start1, end1 = interval1[0].(int), interval1[1].(int)\n\
    \        start2, end2 = interval2[0].(int), interval2[1].(int)\n        start,\
    \ end int\n    )\n    if start1 <= start2 {\n        start = start2\n    } else\
    \ {\n        start = start1\n    }\n    if end1 <= end2 {\n        end = end1\n\
    \    } else {\n        end = end2\n    }\n    if start > end {\n        return\
    \ \"NO\"\n    }\n    if start == end {\n        return \"YES\"\n    }\n    if\
    \ start == 1 {\n        return \"NO\"\n    }\n    if start == 2 {\n        return\
    \ \"YES\"\n    }\n    if start == 3 {\n        return \"YES\"\n    }\n    if start\
    \ % 2 == 0 {\n        return \"NO\"\n    }\n    if start % 3 == 0 {\n        return\
    \ \"NO\"\n    }\n    tmp := 5\n    if start % tmp == 0 {\n        return \"NO\"\
    \n    }\n    for tmp*tmp <= start {\n        if start % tmp == 0 {\n         \
    \   return \"NO\"\n        }\n        tmp += 2\n        if start % tmp == 0 {\n\
    \            return \"NO\"\n        }\n        tmp += 4\n    }\n    return \"\
    YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp2qpjj_32_test.go:101: expected 'NO', got 'YES'\n    ---\
    \ FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp2qpjj_32_test.go:101:\
    \ expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp2qpjj_32_test.go:101: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp2qpjj_32_test.go:101: expected 'NO', got 'YES'\n    ---\
    \ FAIL: TestIntersection/test_num__7 (0.00s)\n        tmp2qpjj_32_test.go:101:\
    \ expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075347
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if end1\
    \ < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    if end1 >= start2\
    \ && end1 <= end2 {\n        if end1 - start2 <= 1 {\n            return \"NO\"\
    \n        }\n        for i := 2; i < end1 - start2; i++ {\n            if (end1\
    \ - start2) % i == 0 {\n                return \"NO\"\n            }\n       \
    \ }\n        return \"YES\"\n    }\n    if end2 >= start1 && end2 <= end1 {\n\
    \        if end2 - start1 <= 1 {\n            return \"NO\"\n        }\n     \
    \   for i := 2; i < end2 - start1; i++ {\n            if (end2 - start1) % i ==\
    \ 0 {\n                return \"NO\"\n            }\n        }\n        return\
    \ \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmp0eip9cmo_test.go:80: expected 'YES', got 'NO'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075347
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmp1ihwkvrw_test.go:51: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmp1ihwkvrw_test.go:51: expected\
    \ 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075230
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    isPrime := func(x int) bool {\n        if x <= 1 {\n         \
    \   return false\n        }\n        for i := 2; i * i <= x; i++ {\n         \
    \   if x % i == 0 {\n                return false\n            }\n        }\n\
    \        return true\n    }\n    if interval1[0].(int) > interval1[1].(int) {\n\
    \        interval1[0], interval1[1] = interval1[1], interval1[0]\n    }\n    if\
    \ interval2[0].(int) > interval2[1].(int) {\n        interval2[0], interval2[1]\
    \ = interval2[1], interval2[0]\n    }\n    if interval1[1].(int) < interval2[0].(int)\
    \ || interval2[1].(int) < interval1[0].(int) {\n        return \"NO\"\n    }\n\
    \    if interval1[0].(int) <= interval2[0].(int) {\n        if interval1[1].(int)\
    \ >= interval2[1].(int) {\n            return \"YES\"\n        }\n        return\
    \ \"NO\"\n    }\n    if interval1[1].(int) >= interval2[1].(int) {\n        return\
    \ \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxg5hbbyg_test.go:28:5: isPrime declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075347
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var overlap = overlapLength(interval1, interval2)\n    return\
    \ isPrime(overlap)\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_6m87bvu_test.go:28:19: undefined: overlapLength

    /tmp/tmp_6m87bvu_test.go:29:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075347
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    fmt.Println(start1,\
    \ end1, start2, end2)\n    // the end is not included in the interval so calculate\
    \ with end + 1\n    length1 := end1 - start1 + 1\n    length2 := end2 - start2\
    \ + 1\n    max := length1\n    if length2 > length1 {\n        max = length2\n\
    \    }\n    for i := 1; i <= max; i++ {\n        if (start1 + i) >= start2 &&\
    \ (start1 + i) <= end2 {\n            if isPrime(i) {\n                return\
    \ \"YES\"\n            }\n        }\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpivm4q8_i_test.go:42:16: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075347
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < end; i++ {\n        if (end - start) % i == 0 {\n       \
    \     return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp_275uuw2_test.go:80: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp_275uuw2_test.go:80: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp_275uuw2_test.go:80: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp_275uuw2_test.go:80: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmp_275uuw2_test.go:80: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmp1ihwkvrw_test.go:51: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmp1ihwkvrw_test.go:51: expected\
    \ 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075230
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    fmt.Println(interval1, interval2)\n    if (interval1[0].(int)\
    \ >= interval2[1].(int)) ||\n        (interval2[0].(int) >= interval1[1].(int))\
    \ {\n        return \"NO\"\n    }\n    start := interval1[0].(int)\n    if interval2[0].(int)\
    \ > start {\n        start = interval2[0].(int)\n    }\n    end := interval1[1].(int)\n\
    \    if interval2[1].(int) < end {\n        end = interval2[1].(int)\n    }\n\
    \    length := end - start + 1\n    if isPrime(length) {\n        return \"YES\"\
    \n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1ekxphz2_test.go:42:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075347
- exit_code: 0
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var start1 int = interval1[0].(int)\n    var end1 int = interval1[1].(int)\n\
    \    var start2 int = interval2[0].(int)\n    var end2 int = interval2[1].(int)\n\
    \    var start, end int\n    var isIntersecting bool\n    if start1 <= start2\
    \ {\n        start = start2\n        if end1 < start2 {\n            isIntersecting\
    \ = false\n        } else {\n            isIntersecting = true\n        }\n  \
    \  } else {\n        start = start1\n        if end2 < start1 {\n            isIntersecting\
    \ = false\n        } else {\n            isIntersecting = true\n        }\n  \
    \  }\n    if isIntersecting {\n        if end1 <= end2 {\n            end = end1\n\
    \        } else {\n            end = end2\n        }\n        if end - start <=\
    \ 1 {\n            return \"NO\"\n        }\n        if end - start <= 3 {\n \
    \           return \"YES\"\n        }\n        if end - start % 2 == 0 {\n   \
    \         return \"NO\"\n        }\n        for i := 3; i * i <= end - start;\
    \ i += 2 {\n            if (end - start) % i == 0 {\n                return \"\
    NO\"\n            }\n        }\n        return \"YES\"\n    }\n    return \"NO\"\
    \n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075348
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    fmt.Println(start1,\
    \ end1, start2, end2)\n    if end1 < start2 || end2 < start1 {\n        return\
    \ \"NO\"\n    }\n\n    start := start1\n    if start1 < start2 {\n        start\
    \ = start2\n    }\n    end := end1\n    if end1 > end2 {\n        end = end2\n\
    \    }\n    fmt.Println(start, end)\n    length := end - start + 1\n    if length\
    \ <= 1 {\n        return \"NO\"\n    }\n    for i := 2; i < length; i++ {\n  \
    \      if length % i == 0 {\n            return \"NO\"\n        }\n    }\n   \
    \ return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "1 2 2 3\n2 2\n-1 1 0 4\n0 1\n-3 -1 -5 5\n-3 -1\n-2 2 -4 0\n-2 0\n-11 2\
    \ -1 -1\n-1 -1\n1 2 3 5\n1 2 1 2\n1 2\n-2 -2 -3 -2\n-2 -2\n--- FAIL: TestIntersection\
    \ (0.00s)\n    --- FAIL: TestIntersection/test_num__1 (0.00s)\n        tmpauhbmrjb_test.go:78:\
    \ expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n\
    \        tmpauhbmrjb_test.go:78: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075348
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // in the form [start, end]\n    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    if end1 < start2 || end2 < start1 {\n        return\
    \ \"NO\"\n    }\n    if start1 < start2 {\n        start1 = start2\n    }\n  \
    \  if end1 > end2 {\n        end1 = end2\n    }\n    if end1 - start1 == 1 {\n\
    \        return \"YES\"\n    }\n    for i := 2; i < end1 - start1; i++ {\n   \
    \     if (end1 - start1) % i == 0 {\n            return \"NO\"\n        }\n  \
    \  }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpem3lnkne_test.go:73: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpem3lnkne_test.go:73: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpem3lnkne_test.go:73: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpem3lnkne_test.go:73: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpem3lnkne_test.go:73: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075348
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    a := interval1[0].(int)\n    b := interval1[1].(int)\n    c :=\
    \ interval2[0].(int)\n    d := interval2[1].(int)\n    if b < c || d < a {\n \
    \       return \"NO\"\n    }\n    if a < c {\n        a = c\n    }\n    if b >\
    \ d {\n        b = d\n    }\n    r := b - a + 1\n    for i := 2; i * i <= r; i++\
    \ {\n        if r % i == 0 {\n            return \"NO\"\n        }\n    }\n  \
    \  return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpsguarf5y_test.go:70: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpsguarf5y_test.go:70: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpsguarf5y_test.go:70: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpsguarf5y_test.go:70: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpsguarf5y_test.go:70: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075348
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmp1ihwkvrw_test.go:51: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmp1ihwkvrw_test.go:51: expected\
    \ 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075230
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // Code here\n    return \"\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpyljoy9oc_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpyljoy9oc_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpyljoy9oc_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpyljoy9oc_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpyljoy9oc_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpyljoy9oc_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpyljoy9oc_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpyljoy9oc_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075348
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    v1 := interval1[0].(int)\n    v2 := interval1[1].(int)\n    if\
    \ v1 > v2 {\n        v1, v2 = v2, v1\n    }\n    v3 := interval2[0].(int)\n  \
    \  v4 := interval2[1].(int)\n    if v3 > v4 {\n        v3, v4 = v4, v3\n    }\n\
    \    var v5, v6 int\n    if v1 < v3 {\n        v5 = v3\n    } else {\n       \
    \ v5 = v1\n    }\n    if v2 < v4 {\n        v6 = v2\n    } else {\n        v6\
    \ = v4\n    }\n    v7 := v6 - v5 + 1\n    if v7 <= 0 {\n        return \"NO\"\n\
    \    }\n    var count int\n    for i := 2; i < v7; i++ {\n        if v7 % i ==\
    \ 0 {\n            count++\n        }\n    }\n    if count > 0 {\n        return\
    \ \"NO\"\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpyjua4not_test.go:85: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpyjua4not_test.go:85: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpyjua4not_test.go:85: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpyjua4not_test.go:85: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpyjua4not_test.go:85: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075348
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if end1 < start2 || end2 < start1\
    \ {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    length := end - start + 1\n    // For each given interval, it is assumed\
    \ that its start is less or equal its end.\n    if length == 2 {\n        return\
    \ \"NO\"\n    }\n    for i := 2; i < length; i++ {\n        if length % i == 0\
    \ {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpwqb8jzjx_test.go:85: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__4 (0.00s)\n        tmpwqb8jzjx_test.go:85: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmpwqb8jzjx_test.go:85: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075348
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // TODO\n    return \"\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp7u5fc0tq_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp7u5fc0tq_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp7u5fc0tq_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp7u5fc0tq_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp7u5fc0tq_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp7u5fc0tq_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp7u5fc0tq_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp7u5fc0tq_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075348
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var s1 int = interval1[0].(int)\n    var e1 int = interval1[1].(int)\n\
    \    var s2 int = interval2[0].(int)\n    var e2 int = interval2[1].(int)\n  \
    \  var s, e int\n    var d int\n    var n bool\n    // for s1, s2, e1, e2 < 0\n\
    \    if (s1 <= 0 && s2 <= 0 && e1 <= 0 && e2 <= 0) {\n        s = max(s1, s2)\n\
    \        e = min(e1, e2)\n        d = e - s\n        n = isPrime(d)\n        return\
    \ fmt.Sprintf(\"%v\", n)\n    }\n    // for s1, s2, e1, e2 > 0\n    if (s1 >=\
    \ 0 && s2 >= 0 && e1 >= 0 && e2 >= 0) {\n        s = max(s1, s2)\n        e =\
    \ min(e1, e2)\n        d = e - s\n        n = isPrime(d)\n        return fmt.Sprintf(\"\
    %v\", n)\n    }\n    // for s1, s2 > 0, e1, e2 < 0\n    if (s1 >= 0 && s2 >= 0\
    \ && e1 <= 0 && e2 <= 0) {\n        s = min(s1, s2)\n        e = max(e1, e2)\n\
    \        d = e - s\n        n = isPrime(d)\n        return fmt.Sprintf(\"%v\"\
    , n)\n    }\n    // for s1, s2 < 0, e1, e2 > 0\n    if (s1 <= 0 && s2 <= 0 &&\
    \ e1 >= 0 && e2 >= 0) {\n        s = min(s1, s2)\n        e = max(e1, e2)\n  \
    \      d = e - s\n        n = isPrime(d)\n        return fmt.Sprintf(\"%v\", n)\n\
    \    }\n    // for s1, s2 > 0, e1, e2 > 0, 0 < s1 <= s2\n    if (s1 >= 0 && s2\
    \ >=\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp14wtzycj_test.go:69:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075347
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int)\
    \ > interval2[0].(int) {\n        interval1, interval2 = interval2, interval1\n\
    \    }\n    intersec := interval2[0].(int) - interval1[1].(int)\n    switch intersec\
    \ {\n    case 0:\n        return \"NO\"\n    case 1:\n        return \"YES\"\n\
    \    default:\n        for i := 2; i < intersec; i++ {\n            if intersec\
    \ % i == 0 {\n                return \"NO\"\n            }\n        }\n      \
    \  return \"YES\"\n    }\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpc8goh8m3_test.go:70: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__4 (0.00s)\n        tmpc8goh8m3_test.go:70: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n      \
    \  tmpc8goh8m3_test.go:70: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075348
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    s1 := interval1[0].(int)\n    e1 := interval1[1].(int)\n    s2\
    \ := interval2[0].(int)\n    e2 := interval2[1].(int)\n    if s1 > e1 {\n    \
    \    s1, e1 = e1, s1\n    }\n    if s2 > e2 {\n        s2, e2 = e2, s2\n    }\n\
    \    if s1 > e2 || s2 > e1 {\n        return \"NO\"\n    }\n    i1 := s1\n   \
    \ i2 := s2\n    if s2 < s1 {\n        i1 = s2\n    }\n    if s1 < s2 {\n     \
    \   i2 = s1\n    }\n    if e1 < e2 {\n        i1 = e1\n    }\n    if e2 < e1 {\n\
    \        i2 = e2\n    }\n    //fmt.Println(i1, i2)\n    for i:=i1; i<=i2; i++\
    \ {\n        if i == 1 {\n            continue\n        }\n        flag := false\n\
    \        for j:=2; j<i; j++ {\n            if i % j == 0 {\n                flag\
    \ = true\n                break\n            }\n        }\n        if !flag {\n\
    \            return \"YES\"\n        }\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmpr9973g3b_test.go:94: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__4 (0.00s)\n        tmpr9973g3b_test.go:94: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmpr9973g3b_test.go:94: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075349
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    minStart\
    \ := min(start1, start2)\n    maxEnd := max(end1, end2)\n    if minStart > maxEnd\
    \ {\n        return \"NO\"\n    }\n    start, end := max(start1, start2), min(end1,\
    \ end2)\n    if isPrime(end - start + 1) {\n        return \"YES\"\n    }\n  \
    \  return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5cdedbyn_test.go:32:17: undefined: min

    /tmp/tmp5cdedbyn_test.go:33:15: undefined: max

    /tmp/tmp5cdedbyn_test.go:37:19: undefined: max

    /tmp/tmp5cdedbyn_test.go:37:40: undefined: min

    /tmp/tmp5cdedbyn_test.go:38:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075348
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var result string = \"NO\"\n    var start, end int\n    var length\
    \ int\n    if len(interval1) == 2 && len(interval2) == 2 {\n        start = max(interval1[0].(int),\
    \ interval2[0].(int))\n        end = min(interval1[1].(int), interval2[1].(int))\n\
    \        if end >= start {\n            length = end - start + 1\n           \
    \ if isPrime(length) {\n                result = \"YES\"\n            }\n    \
    \    }\n    }\n    return result\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9pq4bg99_test.go:32:17: undefined: max

    /tmp/tmp9pq4bg99_test.go:33:15: undefined: min

    /tmp/tmp9pq4bg99_test.go:36:16: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075348
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmp1ihwkvrw_test.go:51: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmp1ihwkvrw_test.go:51: expected\
    \ 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075230
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    minStart := min(start1, start2)\n\
    \    maxEnd := max(end1, end2)\n    if start1 <= start2 && end1 >= start2 {\n\
    \        if start1 <= end2 && end1 >= end2 {\n            return \"YES\"\n   \
    \     } else {\n            return \"NO\"\n        }\n    } else if start2 <=\
    \ start1 && end2 >= start1 {\n        if start2 <= end1 && end2 >= end1 {\n  \
    \          return \"YES\"\n        } else {\n            return \"NO\"\n     \
    \   }\n    } else {\n        return \"NO\"\n    }\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwfzsqba8_test.go:38:17: undefined: min

    /tmp/tmpwfzsqba8_test.go:39:15: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075349
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var start, end int\n    var i1, i2 = interval1[0].(int), interval2[0].(int)\n\
    \    var j1, j2 = interval1[1].(int), interval2[1].(int)\n    if i1 > i2 {\n \
    \       start = i1\n    } else {\n        start = i2\n    }\n    if j1 < j2 {\n\
    \        end = j1\n    } else {\n        end = j2\n    }\n    if start > end {\n\
    \        return \"NO\"\n    }\n    if isPrime(end - start + 1) {\n        return\
    \ \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp52vwnbnr_test.go:44:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075349
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int)\
    \ < interval2[0].(int) {\n        return isPrime(interval2[0].(int) - interval1[1].(int))\n\
    \    }\n    return isPrime(interval1[0].(int) - interval2[1].(int))\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj47af83g_test.go:32:16: undefined: isPrime

    /tmp/tmpj47af83g_test.go:34:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075349
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n\n    if isPrime(interval1[1].(int)\
    \ - interval2[0].(int)) {\n        return \"YES\"\n    }\n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_fr825y__test.go:32:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075349
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    fmt.Println(interval1, interval2)\n    int1 := interval1[0].(int)\n\
    \    int2 := interval1[1].(int)\n    int3 := interval2[0].(int)\n    int4 := interval2[1].(int)\n\
    \    if int2 < int3 || int1 > int4 {\n        return \"NO\"\n    }\n    start\
    \ := int1\n    if int3 > int1 {\n        start = int3\n    }\n    end := int2\n\
    \    if int4 < int2 {\n        end = int4\n    }\n    length := end - start\n\
    \    if length == 0 {\n        return \"NO\"\n    }\n    for i := 2; i < length;\
    \ i++ {\n        if length % i == 0 {\n            return \"NO\"\n        }\n\
    \    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "[1 2] [2 3]\n[-1 1] [0 4]\n[-3 -1] [-5 5]\n[-2 2] [-4 0]\n[-11 2] [-1 -1]\n\
    [1 2] [3 5]\n[1 2] [1 2]\n[-2 -2] [-3 -2]\n--- FAIL: TestIntersection (0.00s)\n\
    \    --- FAIL: TestIntersection/test_num__1 (0.00s)\n        tmpsz8r8ka3_test.go:76:\
    \ expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n\
    \        tmpsz8r8ka3_test.go:76: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075349
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) == 0 || len(interval2) == 0 {\n        return\
    \ \"NO\"\n    }\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    l1 := end1\
    \ - start1\n    l2 := end2 - start2\n    if start1 > end1 || start2 > end2 {\n\
    \        return \"NO\"\n    }\n    if start1 < start2 {\n        start1, start2\
    \ = start2, start1\n        end1, end2 = end2, end1\n        l1, l2 = l2, l1\n\
    \    }\n    if start1 > end2 {\n        return \"NO\"\n    }\n    if end1 <= end2\
    \ {\n        l1 = end1 - start2\n    }\n    if isPrime(l1) {\n        return \"\
    YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplgavff21_test.go:51:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075349
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    return \"\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpucj46pv2_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpucj46pv2_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpucj46pv2_test.go:51:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpucj46pv2_test.go:51: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpucj46pv2_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpucj46pv2_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpucj46pv2_test.go:51:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpucj46pv2_test.go:51: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075343
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    return \"\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpucj46pv2_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpucj46pv2_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpucj46pv2_test.go:51:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpucj46pv2_test.go:51: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpucj46pv2_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpucj46pv2_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpucj46pv2_test.go:51:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpucj46pv2_test.go:51: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075343
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n\n    if isPrime(int(interval1[1].(int)\
    \ - interval2[0].(int))) {\n        return \"YES\"\n    }\n\n    return \"NO\"\
    \n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnlggqutg_test.go:32:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075349
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if end1\
    \ < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    start := start1\n\
    \    if start2 > start1 {\n        start = start2\n    }\n    end := end1\n  \
    \  if end2 < end1 {\n        end = end2\n    }\n    if isPrime(end - start) {\n\
    \        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt2gs1y2z_test.go:43:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    return \"\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpucj46pv2_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpucj46pv2_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpucj46pv2_test.go:51:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpucj46pv2_test.go:51: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpucj46pv2_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpucj46pv2_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpucj46pv2_test.go:51:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpucj46pv2_test.go:51: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075343
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    a, b := interval1[0].(int), interval1[1].(int)\n    c, d := interval2[0].(int),\
    \ interval2[1].(int)\n    // if (b < c) || (d < a) {\n    //     return \"NO\"\
    \n    // }\n    start := max(a, c)\n    end := min(b, d)\n    if start > end {\n\
    \        return \"NO\"\n    }\n    if end - start == 1 {\n        return \"YES\"\
    \n    }\n    for i := 2; i < end; i++ {\n        if (end - start) % i == 0 {\n\
    \            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbhfl56u7_test.go:33:14: undefined: max

    /tmp/tmpbhfl56u7_test.go:34:12: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075349
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    primeMap := map[int]bool{\n        2: true,\n        3: true,\n\
    \        5: true,\n        7: true,\n        11: true,\n        13: true,\n  \
    \      17: true,\n        19: true,\n        23: true,\n        29: true,\n  \
    \      31: true,\n        37: true,\n        41: true,\n        43: true,\n  \
    \      47: true,\n        53: true,\n        59: true,\n        61: true,\n  \
    \      67: true,\n        71: true,\n        73: true,\n        79: true,\n  \
    \      83: true,\n        89: true,\n        97: true,\n    }\n    var start,\
    \ end int\n    if interval1[0].(int) <= interval2[0].(int) {\n        start =\
    \ interval2[0].(int)\n    } else {\n        start = interval1[0].(int)\n    }\n\
    \    if interval1[1].(int) >= interval2[1].(int) {\n        end = interval2[1].(int)\n\
    \    } else {\n        end = interval1[1].(int)\n    }\n    if _, ok := primeMap[end\
    \ - start + 1]; ok {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpeead7610_test.go:92: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpeead7610_test.go:92: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075350
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if (len(interval1) != 2 || len(interval2) != 2) {\n        return\
    \ \"NO\"\n    }\n    a1, a2 := interval1[0].(int), interval1[1].(int)\n    b1,\
    \ b2 := interval2[0].(int), interval2[1].(int)\n    if a1 > a2 || b1 > b2 {\n\
    \        return \"NO\"\n    }\n    if (a1 <= b1 && b1 <= a2 && a2 <= b2) {\n \
    \       return PrimeOrNot(a2 - b1 + 1)\n    }\n    if (b1 <= a1 && a1 <= b2 &&\
    \ b2 <= a2) {\n        return PrimeOrNot(b2 - a1 + 1)\n    }\n    if (a1 <= b1\
    \ && b1 <= b2 && b2 <= a2) {\n        return PrimeOrNot(b2 - b1 + 1)\n    }\n\
    \    if (b1 <= a1 && a1 <= a2 && a2 <= b2) {\n        return PrimeOrNot(a2 - a1\
    \ + 1)\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpomzwjihn_test.go:37:16: undefined: PrimeOrNot

    /tmp/tmpomzwjihn_test.go:40:16: undefined: PrimeOrNot

    /tmp/tmpomzwjihn_test.go:43:16: undefined: PrimeOrNot

    /tmp/tmpomzwjihn_test.go:46:16: undefined: PrimeOrNot

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075349
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n\n    if interval1[0].(int)\
    \ > interval2[0].(int) {\n        return isPrime(interval1[0].(int) - interval2[1].(int))\n\
    \    } else {\n        return isPrime(interval2[0].(int) - interval1[1].(int))\n\
    \    }\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx2kgdkpw_test.go:33:16: undefined: isPrime

    /tmp/tmpx2kgdkpw_test.go:35:16: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075349
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // Happy coding!\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpbq52ynan_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpbq52ynan_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpbq52ynan_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpbq52ynan_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpbq52ynan_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpbq52ynan_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpbq52ynan_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpbq52ynan_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075350
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ >= end2 || start2 >= end1 {\n        return \"NO\"\n    }\n\n    start := start1\n\
    \    if start2 > start1 {\n        start = start2\n    }\n    end := end1\n  \
    \  if end2 < end1 {\n        end = end2\n    }\n    if start == end {\n      \
    \  return \"YES\"\n    }\n    if start+1 == end {\n        return \"NO\"\n   \
    \ }\n    for i := start+1; i < end; i++ {\n        for j := 2; j < i; j++ {\n\
    \            if i % j == 0 {\n                return \"NO\"\n            }\n \
    \       }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpa0hn4ges_test.go:80: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075350
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    a, b := interval1[0].(int), interval1[1].(int)\n    c, d := interval2[0].(int),\
    \ interval2[1].(int)\n    if b < c || d < a {\n        return \"NO\"\n    }\n\
    \    start, end := max(a, c), min(b, d)\n    length := end - start + 1\n    if\
    \ length <= 1 {\n        return \"NO\"\n    }\n    if length == 2 {\n        return\
    \ \"YES\"\n    }\n    if length % 2 == 0 {\n        return \"NO\"\n    }\n   \
    \ for i := 3; i * i <= length; i += 2 {\n        if length % i == 0 {\n      \
    \      return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp328cmtza_test.go:33:19: undefined: max

    /tmp/tmp328cmtza_test.go:33:30: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075350
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    i1 := interval1[0].(int)\n    i2 := interval1[1].(int)\n    j1\
    \ := interval2[0].(int)\n    j2 := interval2[1].(int)\n    switch {\n    case\
    \ i1 > j2 || j1 > i2:\n        return \"NO\"\n    case i1 < j1:\n        return\
    \ isPrime(j1 - i2)\n    default:\n        return isPrime(j2 - i1)\n    }\n}\n\n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqqcfe1s2_test.go:36:16: undefined: isPrime

    /tmp/tmpqqcfe1s2_test.go:38:16: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075350
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    int1 := []int{interval1[0].(int), interval1[1].(int)}\n    int2\
    \ := []int{interval2[0].(int), interval2[1].(int)}\n    min, max := int1[0], int1[1]\n\
    \    if min > int2[0] {\n        min = int2[0]\n    }\n    if max < int2[1] {\n\
    \        max = int2[1]\n    }\n    if min > max {\n        return \"NO\"\n   \
    \ }\n    if max - min < 2 {\n        return \"YES\"\n    }\n    if max - min <\
    \ 4 {\n        return \"NO\"\n    }\n    if max - min < 6 {\n        return \"\
    YES\"\n    }\n    if max - min < 9 {\n        return \"NO\"\n    }\n    for i\
    \ := 7; i <= max - min; i += 2 {\n        if (max - min) % i == 0 {\n        \
    \    return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpe8j4_tiu_test.go:80: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmpe8j4_tiu_test.go:80: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__5 (0.00s)\n      \
    \  tmpe8j4_tiu_test.go:80: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpe8j4_tiu_test.go:80: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmpe8j4_tiu_test.go:80: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075350
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // set interval1 as first interval\n    if interval1[0].(int)\
    \ > interval2[0].(int) {\n        interval1, interval2 = interval2, interval1\n\
    \    }\n    if interval1[1].(int) < interval2[0].(int) {\n        return \"NO\"\
    \n    }\n    start := interval2[0].(int)\n    if interval1[0].(int) > start {\n\
    \        start = interval1[0].(int)\n    }\n    end := interval2[1].(int)\n  \
    \  if interval1[1].(int) < end {\n        end = interval1[1].(int)\n    }\n  \
    \  if start == end {\n        return \"NO\"\n    }\n    if end - start == 1 {\n\
    \        return \"YES\"\n    }\n    for i := 2; i < end - start; i++ {\n     \
    \   if (end - start) % i == 0 {\n            return \"NO\"\n        }\n    }\n\
    \    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpajvv9q8k_test.go:77: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpajvv9q8k_test.go:77: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075350
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if end1\
    \ < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    intersectionStart\
    \ := start1\n    if start2 > start1 {\n        intersectionStart = start2\n  \
    \  }\n    intersectionEnd := end1\n    if end2 < end1 {\n        intersectionEnd\
    \ = end2\n    }\n    length := intersectionEnd - intersectionStart\n    if length\
    \ == 0 {\n        return \"NO\"\n    }\n    if length == 1 {\n        return \"\
    YES\"\n    }\n    if length % 2 == 0 {\n        return \"NO\"\n    }\n    for\
    \ i := 3; i * i <= length; i += 2 {\n        if length % i == 0 {\n          \
    \  return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpmzxn5eqh_test.go:81: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmpmzxn5eqh_test.go:81: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmpmzxn5eqh_test.go:81: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpmzxn5eqh_test.go:81: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075350
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    intersects := false\n    if start1\
    \ < start2 {\n        if end1 >= start2 {\n            intersects = true\n   \
    \     }\n    } else {\n        if end2 >= start1 {\n            intersects = true\n\
    \        }\n    }\n    if !intersects {\n        return \"NO\"\n    }\n    if\
    \ end1 < start2 {\n        end1 = start2\n    }\n    if end2 < start1 {\n    \
    \    end2 = start1\n    }\n    l := end1 - start1 + 1\n    if l == 1 {\n     \
    \   return \"NO\"\n    }\n    for i := 2; i <= l / 2; i++ {\n        if l % i\
    \ == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpi6rgxdcf_test.go:89: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpi6rgxdcf_test.go:89: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n      \
    \  tmpi6rgxdcf_test.go:89: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075350
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    max :=\
    \ func(a, b int) int {\n        if a > b {\n            return a\n        }\n\
    \        return b\n    }\n    min := func(a, b int) int {\n        if a < b {\n\
    \            return a\n        }\n        return b\n    }\n    if max(start1,\
    \ start2) > min(end1, end2) {\n        return \"NO\"\n    }\n    left := max(start1,\
    \ start2)\n    right := min(end1, end2)\n    length := right - left + 1\n    prime\
    \ := true\n    for i := 2; i < length; i++ {\n        if length % i == 0 {\n \
    \           prime = false\n            break\n        }\n    }\n    if prime {\n\
    \        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp26miptyl_test.go:83: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp26miptyl_test.go:83: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp26miptyl_test.go:83: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp26miptyl_test.go:83: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmp26miptyl_test.go:83: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075350
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    a := min(end1,\
    \ end2)\n    b := max(start1, start2)\n    if a < b {\n        return \"NO\"\n\
    \    }\n    len := a - b + 1\n    for i := 2; i * i <= len; i++ {\n        if\
    \ len % i == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\
    \n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7kzs_ukl_test.go:32:10: undefined: min

    /tmp/tmp7kzs_ukl_test.go:33:10: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075350
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    length := 0\n    start := interval1[0].(int)\n    end := interval1[1].(int)\n\
    \    for i := interval2[0].(int); i <= interval2[1].(int); i++ {\n        if start\
    \ <= i && i <= end {\n            length++\n        }\n    }\n    if length ==\
    \ 0 {\n        return \"NO\"\n    }\n    for i := 2; i < length; i++ {\n     \
    \   if length % i == 0 {\n            return \"NO\"\n        }\n    }\n    return\
    \ \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp99czg7l4_test.go:67: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp99czg7l4_test.go:67: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmp99czg7l4_test.go:67: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmp99czg7l4_test.go:67: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__7 (0.00s)\n        tmp99czg7l4_test.go:67: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075351
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if len(interval1) != 2 || len(interval2) != 2 {\n        return\
    \ \"Invalid input\"\n    }\n    if interval1[0] == interval1[1] || interval2[0]\
    \ == interval2[1] {\n        return \"Invalid input\"\n    }\n    if interval1[0].(int)\
    \ > interval1[1].(int) {\n        interval1[0], interval1[1] = interval1[1], interval1[0]\n\
    \    }\n    if interval2[0].(int) > interval2[1].(int) {\n        interval2[0],\
    \ interval2[1] = interval2[1], interval2[0]\n    }\n    a := interval1[0].(int)\n\
    \    b := interval1[1].(int)\n    c := interval2[0].(int)\n    d := interval2[1].(int)\n\
    \    if a > d || b < c {\n        return \"NO\"\n    }\n    e := a\n    f := b\n\
    \    if c > e {\n        e = c\n    }\n    if d < f {\n        f = d\n    }\n\
    \    k := f - e\n    if k == 0 {\n        return \"NO\"\n    }\n    var i int\n\
    \    flag := true\n    for i = 2; i < k; i++ {\n        if k % i == 0 {\n    \
    \        flag = false\n            break\n        }\n    }\n    if flag {\n  \
    \      return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpjy7skv2k_test.go:93: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__4 (0.00s)\n        tmpjy7skv2k_test.go:93: expected\
    \ 'NO', got 'Invalid input'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n\
    \        tmpjy7skv2k_test.go:93: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpjy7skv2k_test.go:93: expected 'NO', got 'Invalid input'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075351
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n\n    interval := []int{}\n\
    \    if interval1[0].(int) < interval2[0].(int) {\n        interval = []int{interval2[0].(int),\
    \ interval1[1].(int)}\n    } else {\n        interval = []int{interval1[0].(int),\
    \ interval2[1].(int)}\n    }\n\n    for i := 2; i < interval[1] - interval[0];\
    \ i++ {\n        if (interval[1] - interval[0]) % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpjl88ttza_test.go:68: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpjl88ttza_test.go:68: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n      \
    \  tmpjl88ttza_test.go:68: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpjl88ttza_test.go:68: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpjl88ttza_test.go:68: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmpjl88ttza_test.go:68: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075351
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n    if isPrime(int(interval1[1].(int)\
    \ - interval2[0].(int))) {\n        return \"YES\"\n    }\n    return \"NO\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqv813cvx_test.go:31:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075351
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    first := interval1[0].(int)\n    second := interval1[1].(int)\n\
    \    first1 := interval2[0].(int)\n    second1 := interval2[1].(int)\n    start\
    \ := 0\n    end := 0\n    if first <= first1 {\n        start = first1\n    }\
    \ else {\n        start = first\n    }\n    if second <= second1 {\n        end\
    \ = second\n    } else {\n        end = second1\n    }\n    for i := start; i\
    \ <= end; i++ {\n        if start != end {\n            return \"NO\"\n      \
    \  }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T) {\n\
    \  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpaiqiz593_test.go:72: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmpaiqiz593_test.go:72: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmpaiqiz593_test.go:72: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpaiqiz593_test.go:72: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpaiqiz593_test.go:72: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmpaiqiz593_test.go:72: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075351
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    fmt.Println(interval1, interval2)\n    return \"NO\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "[1 2] [2 3]\n[-1 1] [0 4]\n[-3 -1] [-5 5]\n[-2 2] [-4 0]\n[-11 2] [-1 -1]\n\
    [1 2] [3 5]\n[1 2] [1 2]\n[-2 -2] [-3 -2]\n--- FAIL: TestIntersection (0.00s)\n\
    \    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpytlhfga5_test.go:52:\
    \ expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpytlhfga5_test.go:52: expected 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075351
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if end1\
    \ < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    if start1 <=\
    \ start2 {\n        if end1 >= end2 {\n            start1 = start2\n         \
    \   end1 = end2\n        } else {\n            start1 = start2\n        }\n  \
    \  } else {\n        if end1 >= end2 {\n            end1 = end2\n        }\n \
    \   }\n    return isPrime(end1 - start1 + 1)\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwystxc2r_test.go:47:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075351
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    fmt.Println(interval1)\n    fmt.Println(interval2)\n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "[1 2]\n[2 3]\n[-1 1]\n[0 4]\n[-3 -1]\n[-5 5]\n[-2 2]\n[-4 0]\n[-11 2]\n\
    [-1 -1]\n[1 2]\n[3 5]\n[1 2]\n[1 2]\n[-2 -2]\n[-3 -2]\n--- FAIL: TestIntersection\
    \ (0.00s)\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpl78bmbze_test.go:53:\
    \ expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpl78bmbze_test.go:53: expected 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075351
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmp1ihwkvrw_test.go:51: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmp1ihwkvrw_test.go:51: expected\
    \ 'YES', got 'NO'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075230
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n    a := interval1[0].(int)\n\
    \    b := interval1[1].(int)\n    c := interval2[0].(int)\n    d := interval2[1].(int)\n\
    \    if c > a {\n        a = c\n    }\n    if d < b {\n        b = d\n    }\n\
    \    if a == b {\n        return \"YES\"\n    }\n    if a + 1 == b {\n       \
    \ return \"NO\"\n    }\n    for i := 2; i <= a; i++ {\n        if a % i == 0 &&\
    \ b % i == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\
    \n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpdp3cho7u_test.go:75: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__4 (0.00s)\n        tmpdp3cho7u_test.go:75: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmpdp3cho7u_test.go:75: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075351
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    s, e :=\
    \ max(start1, start2), min(end1, end2)\n    if s >= e {\n        return \"NO\"\
    \n    }\n    if isPrime(e - s) {\n        return \"YES\"\n    }\n    return \"\
    NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9pzajgem_test.go:32:13: undefined: max

    /tmp/tmp9pzajgem_test.go:32:34: undefined: min

    /tmp/tmp9pzajgem_test.go:36:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075351
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // this is really not a go solution to the challenge, because\
    \ of interface{}\n    // a better solution would be to create a proper data \n\
    func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp13qmjjx6_test.go:30:6: expected ''('', found TestIntersection

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075351
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // your code here\n    var start, end int\n    var i1, i2 []int\n\
    \    if interval1[0].(int) <= interval2[0].(int) {\n        start = interval2[0].(int)\n\
    \        i1 = interval1\n        i2 = interval2\n    } else {\n        start =\
    \ interval1[0].(int)\n        i1 = interval2\n        i2 = interval1\n    }\n\
    \    if i1[1].(int) < i2[0].(int) {\n        return \"NO\"\n    }\n    if i1[1].(int)\
    \ < i2[1].(int) {\n        end = i1[1].(int)\n    } else {\n        end = i2[1].(int)\n\
    \    }\n    if end <= start {\n        return \"NO\"\n    }\n    if end - start\
    \ == 1 {\n        return \"YES\"\n    }\n    for i := start + 1; i < end; i++\
    \ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n         \
    \       return \"NO\"\n            }\n        }\n    }\n    return \"YES\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy3jwq7ku_test.go:33:14: cannot use interval1 (variable of type []interface{})
    as type []int in assignment

    /tmp/tmpy3jwq7ku_test.go:34:14: cannot use interval2 (variable of type []interface{})
    as type []int in assignment

    /tmp/tmpy3jwq7ku_test.go:37:14: cannot use interval2 (variable of type []interface{})
    as type []int in assignment

    /tmp/tmpy3jwq7ku_test.go:38:14: cannot use interval1 (variable of type []interface{})
    as type []int in assignment

    /tmp/tmpy3jwq7ku_test.go:40:8: invalid operation: i1[1] (variable of type int)
    is not an interface

    /tmp/tmpy3jwq7ku_test.go:40:22: invalid operation: i2[0] (variable of type int)
    is not an interface

    /tmp/tmpy3jwq7ku_test.go:43:8: invalid operation: i1[1] (variable of type int)
    is not an interface

    /tmp/tmpy3jwq7ku_test.go:43:22: invalid operation: i2[1] (variable of type int)
    is not an interface

    /tmp/tmpy3jwq7ku_test.go:44:15: invalid operation: i1[1] (variable of type int)
    is not an interface

    /tmp/tmpy3jwq7ku_test.go:46:15: invalid operation: i2[1] (variable of type int)
    is not an interface

    /tmp/tmpy3jwq7ku_test.go:46:15: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075351
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ <= start2 {\n        if end1 < start2 {\n            return \"NO\"\n       \
    \ }\n        if end1 < end2 {\n            if isPrime(end1 - start2 + 1) {\n \
    \               return \"YES\"\n            }\n            return \"NO\"\n   \
    \     }\n        if isPrime(end2 - start2 + 1) {\n            return \"YES\"\n\
    \        }\n        return \"NO\"\n    }\n    if end2 < start1 {\n        return\
    \ \"NO\"\n    }\n    if end2 < end1 {\n        if isPrime(end2 - start1 + 1) {\n\
    \            return \"YES\"\n        }\n        return \"NO\"\n    }\n    if isPrime(end1\
    \ - start1 + 1) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0dvq2u3a_test.go:37:16: undefined: isPrime

    /tmp/tmp0dvq2u3a_test.go:42:12: undefined: isPrime

    /tmp/tmp0dvq2u3a_test.go:51:12: undefined: isPrime

    /tmp/tmp0dvq2u3a_test.go:56:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075351
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // TODO: test if the intervals are valid\n    // if empty\n  \
    \  // if not valid\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    if start1 > end2\
    \ || start2 > end1 {\n        return \"NO\"\n    }\n    // find the interval that\
    \ starts first\n    if start1 < start2 {\n        if end1 < start2 {\n       \
    \     return \"NO\"\n        }\n        return isPrime(start2 - end1)\n    }\n\
    \    if end2 < start1 {\n        return \"NO\"\n    }\n    return isPrime(start1\
    \ - end2)\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnyrjdel4_test.go:46:16: undefined: isPrime

    /tmp/tmpnyrjdel4_test.go:51:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075351
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    iStart\
    \ := max(start1, start2)\n    iEnd := min(end1, end2)\n    if iStart > iEnd {\n\
    \        return \"NO\"\n    }\n    if isPrime(iEnd - iStart + 1) {\n        return\
    \ \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg3no62jz_test.go:32:15: undefined: max

    /tmp/tmpg3no62jz_test.go:33:13: undefined: min

    /tmp/tmpg3no62jz_test.go:37:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075351
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    first_begin := interval1[0].(int)\n    first_end := interval1[1].(int)\n\
    \    second_begin := interval2[0].(int)\n    second_end := interval2[1].(int)\n\
    \    if first_begin > first_end {\n        return \"NO\"\n    }\n    if second_begin\
    \ > second_end {\n        return \"NO\"\n    }\n    if first_begin > second_end\
    \ || second_begin > first_end {\n        return \"NO\"\n    }\n    begin := first_begin\n\
    \    if begin < second_begin {\n        begin = second_begin\n    }\n    end :=\
    \ first_end\n    if end > second_end {\n        end = second_end\n    }\n    if\
    \ begin > end {\n        return \"NO\"\n    }\n    if end - begin == 0 {\n   \
    \     return \"YES\"\n    }\n    if end - begin == 1 {\n        return \"NO\"\n\
    \    }\n    for i := 2; i < end; i++ {\n        if (end - begin) % i == 0 {\n\
    \            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpm3tfn5n0_test.go:86: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__4 (0.00s)\n        tmpm3tfn5n0_test.go:86: expected\
    \ 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n      \
    \  tmpm3tfn5n0_test.go:86: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075352
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start := interval1[0].(int)\n    end := interval1[1].(int)\n \
    \   interval := interval2[0].(int)\n    if interval < start {\n        start =\
    \ interval\n    }\n    interval = interval2[1].(int)\n    if interval > end {\n\
    \        end = interval\n    }\n    if start < end {\n        if (end - start)\
    \ == 1 {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n\
    \    return \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate :=\
    \ intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__2\
    \ (0.00s)\n        tmpsoycvieu_test.go:67: expected 'YES', got 'NO'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmpsoycvieu_test.go:67: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n      \
    \  tmpsoycvieu_test.go:67: expected 'NO', got 'YES'\n    --- FAIL: TestIntersection/test_num__7\
    \ (0.00s)\n        tmpsoycvieu_test.go:67: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075352
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    v1, v2 := interval1[0].(int), interval1[1].(int)\n    w1, w2 :=\
    \ interval2[0].(int), interval2[1].(int)\n    if v1 > v2 {\n        v1, v2 = v2,\
    \ v1\n    }\n    if w1 > w2 {\n        w1, w2 = w2, w1\n    }\n    var x, y int\n\
    \    if v1 > w1 {\n        x = v1\n    } else {\n        x = w1\n    }\n    if\
    \ v2 < w2 {\n        y = v2\n    } else {\n        y = w2\n    }\n    if x > y\
    \ {\n        return \"NO\"\n    }\n    if y == 1 {\n        return \"YES\"\n \
    \   }\n    if y == 2 {\n        return \"NO\"\n    }\n    if y == 3 {\n      \
    \  return \"YES\"\n    }\n    if y % 2 == 0 {\n        return \"NO\"\n    }\n\
    \    for i := 3; i * i <= y; i = i + 2 {\n        if y % i == 0 {\n          \
    \  return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpq6x5g9ww_test.go:90: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__3 (0.00s)\n        tmpq6x5g9ww_test.go:90: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__4 (0.00s)\n      \
    \  tmpq6x5g9ww_test.go:90: expected 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075352
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // Write your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmp5sf2j70y_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmp5sf2j70y_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmp5sf2j70y_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmp5sf2j70y_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmp5sf2j70y_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmp5sf2j70y_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmp5sf2j70y_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmp5sf2j70y_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075341
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if end1\
    \ < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    max := start1\n\
    \    if start2 > max {\n        max = start2\n    }\n    min := end1\n    if end2\
    \ < min {\n        min = end2\n    }\n    len := min - max\n    if len == 0 {\n\
    \        return \"NO\"\n    }\n    if len == 1 {\n        return \"YES\"\n   \
    \ }\n    for i := 2; i < len; i++ {\n        if len % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc TestIntersection(t *testing.T)\
    \ {\n  candidate := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpqgga_azj_test.go:78: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpqgga_azj_test.go:78: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075352
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // TODO: Implement the solution\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpm_bje8em_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpm_bje8em_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpm_bje8em_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpm_bje8em_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpm_bje8em_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpm_bje8em_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpm_bje8em_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpm_bje8em_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075352
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    var start = interval1[0].(int)\n    var end = interval1[1].(int)\n\
    \    var i1 = []int{start, end}\n    start = interval2[0].(int)\n    end = interval2[1].(int)\n\
    \    var i2 = []int{start, end}\n    if i1[0] > i2[1] || i2[0] > i1[1] {\n   \
    \     return \"NO\"\n    }\n    start = max(i1[0], i2[0])\n    end = min(i1[1],\
    \ i2[1])\n    var isPrime = true\n    for i := 2; i <= end / 2; i++ {\n      \
    \  if end % i == 0 {\n            isPrime = false\n            break\n       \
    \ }\n    }\n    if isPrime {\n        return \"YES\"\n    }\n    return \"NO\"\
    \n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8wmldfq__test.go:37:13: undefined: max

    /tmp/tmp8wmldfq__test.go:38:11: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075352
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    int1 := interval1[0].(int)\n    int2 := interval1[1].(int)\n \
    \   int3 := interval2[0].(int)\n    int4 := interval2[1].(int)\n    if int1 >\
    \ int2 {\n        int1, int2 = int2, int1\n    }\n    if int3 > int4 {\n     \
    \   int3, int4 = int4, int3\n    }\n    if int1 > int4 || int2 < int3 {\n    \
    \    return \"NO\"\n    }\n    if int3 <= int1 && int2 <= int4 {\n        if int2\
    \ - int1 == 1 {\n            return \"YES\"\n        }\n        return \"NO\"\n\
    \    }\n    if int1 <= int3 && int4 <= int2 {\n        if int4 - int3 == 1 {\n\
    \            return \"YES\"\n        }\n        return \"NO\"\n    }\n    if int1\
    \ <= int3 && int3 <= int2 && int2 <= int4 {\n        if int2 - int3 == 1 {\n \
    \           return \"YES\"\n        }\n        return \"NO\"\n    }\n    if int1\
    \ <= int3 && int3 <= int4 && int4 <= int2 {\n        if int4 - int3 == 1 {\n \
    \           return \"YES\"\n        }\n        return \"NO\"\n    }\n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpxp7fueww_test.go:88: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__2 (0.00s)\n        tmpxp7fueww_test.go:88: expected\
    \ 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n      \
    \  tmpxp7fueww_test.go:88: expected 'YES', got 'NO'\n    --- FAIL: TestIntersection/test_num__6\
    \ (0.00s)\n        tmpxp7fueww_test.go:88: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075352
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // your code here\n    return \"\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpy9uje9cj_test.go:52: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpy9uje9cj_test.go:52: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpy9uje9cj_test.go:52:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpy9uje9cj_test.go:52: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    return \"\";\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate\
    \ := intersection\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{2, 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1,\
    \ 1}, []interface{}{0, 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3,\
    \ -1}, []interface{}{-5, 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2,\
    \ 2}, []interface{}{-4, 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11,\
    \ 2}, []interface{}{-1, -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{3, 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1,\
    \ 2}, []interface{}{1, 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2,\
    \ -2}, []interface{}{-3, -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__0\
    \ (0.00s)\n        tmpymdulw8i_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__1 (0.00s)\n        tmpymdulw8i_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__2 (0.00s)\n        tmpymdulw8i_test.go:51:\
    \ expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__3 (0.00s)\n\
    \        tmpymdulw8i_test.go:51: expected 'YES', got ''\n    --- FAIL: TestIntersection/test_num__4\
    \ (0.00s)\n        tmpymdulw8i_test.go:51: expected 'NO', got ''\n    --- FAIL:\
    \ TestIntersection/test_num__5 (0.00s)\n        tmpymdulw8i_test.go:51: expected\
    \ 'NO', got ''\n    --- FAIL: TestIntersection/test_num__6 (0.00s)\n        tmpymdulw8i_test.go:51:\
    \ expected 'NO', got ''\n    --- FAIL: TestIntersection/test_num__7 (0.00s)\n\
    \        tmpymdulw8i_test.go:51: expected 'NO', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075352
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // your code here\n    var start1, end1, start2, end2 int\n  \
    \  for i, v := range interval1 {\n        switch i {\n        case 0:\n      \
    \      start1 = v.(int)\n        case 1:\n            end1 = v.(int)\n       \
    \ }\n    }\n    for i, v := range interval2 {\n        switch i {\n        case\
    \ 0:\n            start2 = v.(int)\n        case 1:\n            end2 = v.(int)\n\
    \        }\n    }\n    if start1 > end1 || start2 > end2 {\n        return \"\
    NO\"\n    }\n    interStart := start1\n    if start2 > start1 {\n        interStart\
    \ = start2\n    }\n    interEnd := end1\n    if end2 < end1 {\n        interEnd\
    \ = end2\n    }\n    if interStart > interEnd {\n        return \"NO\"\n    }\n\
    \    length := interEnd - interStart + 1\n    if length == 1 {\n        return\
    \ \"NO\"\n    }\n    for i := 2; i < length; i++ {\n        if length % i == 0\
    \ {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\nfunc\
    \ TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__1\
    \ (0.00s)\n        tmpkdlav7pb_test.go:92: expected 'NO', got 'YES'\n    --- FAIL:\
    \ TestIntersection/test_num__6 (0.00s)\n        tmpkdlav7pb_test.go:92: expected\
    \ 'NO', got 'YES'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075352
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    i1, i2 := interval1[0].(int), interval1[1].(int)\n    i3, i4 :=\
    \ interval2[0].(int), interval2[1].(int)\n    var start, end int\n    if i1 >\
    \ i3 {\n        start = i1\n    } else {\n        start = i3\n    }\n    if i2\
    \ < i4 {\n        end = i2\n    } else {\n        end = i4\n    }\n    if start\
    \ > end {\n        return \"NO\"\n    }\n    return isPrime(end - start + 1)\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnyn77lfk_test.go:44:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075352
- exit_code: 1
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    // your code goes here\n    var a, b, c, d int\n    a = interval1[0].(int)\n\
    \    b = interval1[1].(int)\n    c = interval2[0].(int)\n    d = interval2[1].(int)\n\
    \    var min, max int\n    if a > b {\n        min = b\n        max = a\n    }\
    \ else {\n        min = a\n        max = b\n    }\n    var e, f int\n    if c\
    \ > d {\n        e = d\n        f = c\n    } else {\n        e = c\n        f\
    \ = d\n    }\n    var isect_max int\n    if max < f {\n        isect_max = max\n\
    \    } else {\n        isect_max = f\n    }\n    var isect_min int\n    if min\
    \ > e {\n        isect_min = min\n    } else {\n        isect_min = e\n    }\n\
    \    length := isect_max - isect_min\n    if length == 0 {\n        return \"\
    NO\"\n    }\n    if length == 1 {\n        return \"NO\"\n    }\n    if length\
    \ == 2 {\n        return \"YES\"\n    }\n    if length % 2 == 0 {\n        return\
    \ \"NO\"\n    }\n    for i := 3; i <= length / 2; i++ {\n        if length % i\
    \ == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\
    \nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestIntersection (0.00s)\n    --- FAIL: TestIntersection/test_num__5\
    \ (0.00s)\n        tmpw9wfhq6d_test.go:103: expected 'NO', got 'YES'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075352
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    // interval 1 is left to interval\
    \ 2\n    if end1 < start2 {\n        return \"NO\"\n    }\n    // interval 1 is\
    \ right to interval 2\n    if start1 > end2 {\n        return \"NO\"\n    }\n\
    \    // interval 1 contains interval 2\n    if start1 <= start2 && end1 >= end2\
    \ {\n        // the length of interval2 is a prime number\n        if prime(end2\
    \ - start2 + 1) {\n            return \"YES\"\n        }\n        return \"NO\"\
    \n    }\n    // interval 2 contains interval 1\n    if start2 <= start1 && end2\
    \ >= end1 {\n        // the length of interval1 is a prime number\n        if\
    \ prime(end1 - start1 + 1) {\n            return \"YES\"\n        }\n        return\
    \ \"NO\"\n    }\n    // interval 1 is overlapping interval 2\n    start := start1\n\
    \    if start1 < start2 {\n        start = start2\n    }\n    end := end1\n  \
    \  if end1 > end2 {\n        end = end2\n    }\n    if prime(end - start + 1)\
    \ {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n\nfunc TestIntersection(t\
    \ *testing.T) {\n  candidate := intersection\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]interface{}{1, 2}, []interface{}{2, 3}), expected: \"NO\" },\n \
    \    { actual: candidate([]interface{}{-1, 1}, []interface{}{0, 4}), expected:\
    \ \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm3lh6605_test.go:49:12: undefined: prime

    /tmp/tmpm3lh6605_test.go:57:12: undefined: prime

    /tmp/tmpm3lh6605_test.go:71:8: undefined: prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075352
- exit_code: 0
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    length := end - start\n    if length <= 1 {\n  \
    \      return \"NO\"\n    }\n    for i := 2; i < length; i++ {\n        if length\
    \ % i == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n\
    }\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
    \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075343
- exit_code: 2
  program: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// You are given two intervals,\n// where each interval is a pair of integers.\
    \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
    \ which means that the interval (start, end)\n// includes both start and end.\n\
    // For each given interval, it is assumed that its start is less or equal its\
    \ end.\n// Your task is to determine whether the length of intersection of these\
    \ two \n// intervals is a prime number.\n// Example, the intersection of the intervals\
    \ (1, 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n\
    // If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
    \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n//\
    \ [input/output] samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2,\
    \ 3})\n// \"NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n\
    // \"NO\"\n// >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n\
    // \"YES\"\nfunc intersection(interval1 []interface{}, interval2 []interface{})\
    \ string {\n    s1 := interval1[0].(int)\n    e1 := interval1[1].(int)\n    s2\
    \ := interval2[0].(int)\n    e2 := interval2[1].(int)\n    if s1 > e1 {\n    \
    \    s1, e1 = e1, s1\n    }\n    if s2 > e2 {\n        s2, e2 = e2, s2\n    }\n\
    \    if e1 < s2 || e2 < s1 {\n        return \"NO\"\n    }\n    x := s1\n    if\
    \ s2 > x {\n        x = s2\n    }\n    y := e1\n    if e2 < y {\n        y = e2\n\
    \    }\n    if isPrime(y - x + 1) {\n        return \"YES\"\n    }\n    return\
    \ \"NO\"\n}\n\nfunc TestIntersection(t *testing.T) {\n  candidate := intersection\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2,\
    \ 3}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
    \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
    \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
    \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
    \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
    \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
    \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
    \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpctc1ag05_test.go:49:8: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075352
