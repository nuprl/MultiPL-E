name: HumanEval_64_vowels_count
language: go_test.go
prompt: "package vowels_count_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // Write a function vowels_count which takes a string representing\n// a word as\
  \ input and returns the number of vowels in the string.\n// Vowels in this case\
  \ are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n// vowel, but only when it is\
  \ at the end of the given word.\n// Example:\n// >>> vowels_count(\"abcde\")\n//\
  \ 2\n// >>> vowels_count(\"ACEDY\")\n// 3\nfunc vowels_count(s string) int {\n"
tests: "func TestVowels_Count(t *testing.T) {\n  candidate := vowels_count\n\ttype\
  \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
  \ := []test{\n     { actual: candidate(\"abcde\"), expected: 2 },\n     { actual:\
  \ candidate(\"Alone\"), expected: 3 },\n     { actual: candidate(\"key\"), expected:\
  \ 2 },\n     { actual: candidate(\"bye\"), expected: 1 },\n     { actual: candidate(\"\
  keY\"), expected: 2 },\n     { actual: candidate(\"bYe\"), expected: 1 },\n    \
  \ { actual: candidate(\"ACEDY\"), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
  \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif\
  \ fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\t\
  t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    var count int = 0\n    for _, c := range s {\n        if c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            count++\n   \
    \     }\n    }\n    return count\n}\n", "    count := 0\n    for _, v := range\
    \ s {\n        switch v {\n        case 'a', 'e', 'i', 'o', 'u':\n           \
    \ count += 1\n        case 'y':\n            if s[len(s)-1] == 'y' {\n       \
    \         count += 1\n            }\n        }\n    }\n    return count\n}\n",
  "\tvowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"}\n\tc := 0\n\tfor\
    \ _, letter := range s {\n\t\tif string(letter) == \"y\" && len(s) == 1 {\n\t\t\
    \tc++\n\t\t} else if len(s) > 1 && string(letter) == \"y\" && string(s[len(s)-1])\
    \ != \"y\" {\n\t\t\tcontinue\n\t\t} else if (string(letter) == \"y\" && string(s[len(s)-1])\
    \ == \"y\") || contains(vowels, string(letter)) {\n\t\t\tc++\n\t\t}\n\t}\n\treturn\
    \ c\n}\n", "    var count int = 0\n    var vowel string = \"aeiouy\"\n    var\
    \ y bool = false\n    var o []string\n    o = strings.Split(s, \"\")\n    for\
    \ _, x := range o {\n        if strings.Contains(vowel, x) {\n            count++\n\
    \        }\n        if x == \"y\" {\n            y = true\n        }\n    }\n\
    \    if y {\n        count--\n    }\n    return count\n}\n", "    num := 0\n \
    \   for i := 0; i < len(s); i++ {\n        if is_vowel(s[i]) {\n            num\
    \ += 1\n        }\n    }\n    return num\n}\n", "    m := make(map[rune]int)\n\
    \    m['a'] = 1\n    m['e'] = 1\n    m['i'] = 1\n    m['o'] = 1\n    m['u'] =\
    \ 1\n    m['y'] = 1\n    count := 0\n    y_count := 0\n    for _, c := range s\
    \ {\n        if m[c] == 1 {\n            count += 1\n        }\n        if m[c]\
    \ == 1 && c == 'y' {\n            y_count += 1\n        }\n    }\n    if y_count\
    \ > 0 && count > y_count {\n        count -= 1\n    }\n    return count\n}\n",
  "    // To convert a string to lowercase, use\n    // l_s := strings.ToLower(s)\n\
    \    count := 0\n    for _, c := range s {\n        switch c {\n        case 'a',\
    \ 'e', 'i', 'o', 'u':\n            count += 1\n        }\n    }\n    if count\
    \ > 0 && s[len(s)-1] == 'y' {\n        count += 1\n    }\n    return count\n}\n",
  "    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    count := 0\n   \
    \ for _, char := range s {\n        char_s := string(char)\n        if char_s\
    \ == \"y\" && count > 0 {\n            continue\n        }\n        for _, vowel\
    \ := range vowels {\n            if char_s == vowel {\n                count +=\
    \ 1\n            }\n        }\n    }\n    return count\n}\n", "    count := 0\n\
    \    for _, char := range s {\n        if is_vowel(char) {\n            count++\n\
    \        }\n    }\n    return count\n}\n", "\t// loop through string\n\t// check\
    \ if rune is a vowel\n\t// convert to lowercase\n\t// if count, add one to counter\n\
    \tcount := 0\n\tfor _, r := range s {\n\t\tif r == 'a' || r == 'e' || r == 'i'\
    \ || r == 'o' || r == 'u' || r == 'y' {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n\
    }\n", "\t// write your code here\n\treturn 0\n}\n", "    vowels := \"aeiou\"\n\
    \    count := 0\n    for _, c := range s {\n        if vowels[c - 'a'] != 0 {\n\
    \            count++\n        }\n    }\n    if s[len(s) - 1] == 'y' {\n      \
    \  count++\n    }\n    return count\n}\n", "    return 0\n}\n", "    vowels :=\
    \ map[rune]bool{\n        'a': true,\n        'e': true,\n        'i': true,\n\
    \        'o': true,\n        'u': true,\n    }\n    word := []rune(s)\n    count\
    \ := 0\n    for i, letter := range word {\n        if vowels[letter] {\n     \
    \       count++\n        }\n        if i == len(word) - 1 && letter == 'y' {\n\
    \            count++\n        }\n    }\n    return count\n}\n", "    vowels :=\
    \ \"aeiou\"\n    count := 0\n    for _, r := range s {\n        r = unicode.ToLower(r)\n\
    \        if strings.Contains(vowels, string(r)) {\n            count += 1\n  \
    \      }\n    }\n    return count\n}\n", "    // Your code here\n    return 0\n\
    }\n", "    r := make([]rune, len(s))\n    for i, c := range s {\n        r[i]\
    \ = c\n    }\n    vowels := []rune{'a', 'e', 'i', 'o', 'u', 'y'}\n    count :=\
    \ 0\n    for i, c := range r {\n        if string(c) == \"y\" && i == len(r)-1\
    \ {\n            count += 1\n        } else if contains(vowels, c) {\n       \
    \     count += 1\n        }\n    }\n    return count\n}\n", "    vowels := 0\n\
    \    last := \"\"\n    for _, ch := range s {\n        if ch == 'a' || ch == 'e'\
    \ || ch == 'i' || ch == 'o' || ch == 'u' {\n            vowels += 1\n        }\n\
    \        last = string(ch)\n    }\n    if last == \"y\" {\n        vowels += 1\n\
    \    }\n    return vowels\n}\n", "    count := 0\n    for _,c := range s {\n \
    \       switch string(c) {\n        case \"a\", \"e\", \"i\", \"o\", \"u\", \"\
    y\":\n            count++\n        }\n    }\n    return count\n}\n", "    count\
    \ := 0\n    for i, char := range s {\n        switch char {\n        case 'a',\
    \ 'e', 'i', 'o', 'u':\n            count += 1\n        case 'y':\n           \
    \ if i == len(s) - 1 {\n                count += 1\n            }\n        }\n\
    \    }\n    return count\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
