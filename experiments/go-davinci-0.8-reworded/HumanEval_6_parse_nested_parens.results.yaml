language: go_test.go
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    depths := make([]int, 0)\n    current_depth := 0\n    for\
    \ _, char := range paren_string {\n        if string(char) == \"(\" {\n      \
    \      current_depth += 1\n        } else if string(char) == \")\" {\n       \
    \     current_depth -= 1\n        } else if string(char) == \" \" {\n        \
    \    depths = append(depths, current_depth)\n            current_depth = 0\n \
    \       }\n    }\n    depths = append(depths, current_depth)\n    return depths\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmptsix8zw3_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmptsix8zw3_test.go:45:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmptsix8zw3_test.go:45: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var stack_depth []int\n\n    for\
    \ i, c := range paren_string {\n        if c == '(' {\n            stack_depth\
    \ = append(stack_depth, 0)\n        } else if c == ')' {\n            depth :=\
    \ stack_depth[len(stack_depth) - 1]\n            stack_depth = stack_depth[:len(stack_depth)\
    \ - 1]\n            if len(stack_depth) == 0 {\n                // This is the\
    \ only way to tell the end of a parenthesis.\n                result = append(result,\
    \ depth)\n            } else {\n                stack_depth[len(stack_depth) -\
    \ 1] = depth + 1\n            }\n        } else if c == ' ' {\n            if\
    \ len(stack_depth) == 0 {\n                // This is the only way to tell the\
    \ end of a parenthesis.\n                result = append(result, 0)\n        \
    \    }\n        }\n    }\n\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppywgnd8y_test.go:17:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n    // TODO - Add your code here\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpdeav17ms_test.go:34: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmpdeav17ms_test.go:34: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmpdeav17ms_test.go:34: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_level := 0\n    current_level := 0\n    levels := []int{}\n\
    \    for _, rune_value := range paren_string {\n        if string(rune_value)\
    \ == \"(\" {\n            current_level += 1\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if string(rune_value) == \")\" {\n            levels = append(levels, max_level)\n\
    \            current_level -= 1\n            if current_level > max_level {\n\
    \                max_level = current_level\n            }\n        }\n    }\n\
    \    return levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp6rf8fd6p_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=3)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp6rf8fd6p_test.go:49:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp6rf8fd6p_test.go:49: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Implement this placeholder.\n    return []int{0}\n}\n\
    \nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpw3br06w6_test.go:33: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpw3br06w6_test.go:33: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpw3br06w6_test.go:33: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    output := make([]int, 0)\n    for _, item := range paren_string\
    \ {\n        if item == ' ' {\n            continue\n        }\n        if item\
    \ == '(' {\n            output = append(output, 0)\n        } else {\n       \
    \     output[len(output) - 1] += 1\n        }\n    }\n    return output\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp4aiv0jft_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=3)\
    \ %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=2) %!s(int=1) %!s(int=2)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp4aiv0jft_test.go:43:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0)\
    \ %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp4aiv0jft_test.go:43: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // use a stack to keep track of the current deepest level\n\
    \    stack := make([]int, 0)\n    // append the depth of nesting 0 to the front\
    \ of the stack\n    stack = append(stack, 0)\n    result := make([]int, 0)\n \
    \   // iterate through each of the parenthesis\n    for _, paren := range paren_string\
    \ {\n        char := string(paren)\n        switch char {\n        case \"(\"\
    :\n            // if it's a left paren, append the current deepest level plus\
    \ one to the stack.\n            stack = append(stack, stack[len(stack)-1]+1)\n\
    \        case \")\":\n            // if it's a right paren, pop the value from\
    \ the stack, which is the deepest level for this group.\n            stack_len\
    \ := len(stack)\n            level := stack[stack_len-1]\n            stack =\
    \ stack[:stack_len-1]\n            result = append(result, level)\n        default:\n\
    \            // do nothing for spaces\n        }\n    }\n    return result\n}\n\
    \nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpuc0z3b6p_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpuc0z3b6p_test.go:54:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpuc0z3b6p_test.go:54: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_level := 0\n    current_level := 0\n    open_parens\
    \ := 0\n    result := make([]int, 0)\n    for _, c := range paren_string {\n \
    \       if c == '(' {\n            open_parens++\n            current_level++\n\
    \            if current_level > max_level {\n                max_level = current_level\n\
    \            }\n        } else if c == ')' {\n            open_parens--\n    \
    \        current_level--\n        } else if c == ' ' {\n            if open_parens\
    \ == 0 {\n                result = append(result, max_level)\n               \
    \ max_level = 0\n                current_level = 0\n            }\n        }\n\
    \    }\n    if open_parens == 0 {\n        result = append(result, max_level)\n\
    \    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n\
    \  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var output []int\n    var level int\n    for _, r := range\
    \ paren_string {\n        switch r {\n        case '(':\n            level++\n\
    \        case ')':\n            output = append(output, level)\n            level--\n\
    \        }\n    }\n    return output\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmphw3mxbvc_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmphw3mxbvc_test.go:43:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmphw3mxbvc_test.go:43: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // TODO: Implement this function\n    return []int{}\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpm6piimew_test.go:33: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmpm6piimew_test.go:33: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmpm6piimew_test.go:33: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074136
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var depth int = 0\n    var max_depth\
    \ int = 0\n    for _, c := range paren_string {\n        if c == '(' {\n     \
    \       depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if c == ')' {\n            depth -= 1\n\
    \        } else if c == ' ' {\n            result = append(result, max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result\
    \ = append(result, max_depth)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.007s\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n    parens := []rune(paren_string)\n\
    \    left := 0\n    right := 0\n    for _, paren := range parens {\n        if\
    \ paren == '(' {\n            left += 1\n        } else if paren == ')' {\n  \
    \          right += 1\n        } else if paren == ' ' {\n            result =\
    \ append(result, left - right)\n            left = 0\n            right = 0\n\
    \        }\n    }\n    if left - right != 0 {\n        result = append(result,\
    \ left - right)\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmprrxh9nor_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmprrxh9nor_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmprrxh9nor_test.go:50: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp1uls3cd__test.go:33: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmp1uls3cd__test.go:33: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmp1uls3cd__test.go:33: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var depth_array []int\n    depth := 0\n    for i := 0;\
    \ i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n        \
    \    depth++\n        } else if paren_string[i] == ')' {\n            depth_array\
    \ = append(depth_array, depth)\n            depth--\n        }\n    }\n    return\
    \ depth_array\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpjnhen9oa_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpjnhen9oa_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpjnhen9oa_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Split string by spaces.\n    paren_array := strings.Split(paren_string,\
    \ \" \")\n    result := make([]int, len(paren_array))\n    for i, paren := range\
    \ paren_array {\n        result[i] = find_deepest_level(paren)\n    }\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqkk0d8vh_test.go:15:20: undefined: strings

    /tmp/tmpqkk0d8vh_test.go:18:21: undefined: find_deepest_level

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    nest_levels := make([]int, 0)\n    nest_level := 0\n  \
    \  max_nest_level := 0\n    for _, c := range paren_string {\n        switch c\
    \ {\n        case '(':\n            nest_level += 1\n            if nest_level\
    \ > max_nest_level {\n                max_nest_level = nest_level\n          \
    \  }\n        case ')':\n            nest_level -= 1\n        case ' ':\n    \
    \        if nest_level == 0 {\n                nest_levels = append(nest_levels,\
    \ max_nest_level)\n                max_nest_level = 0\n            }\n       \
    \ }\n    }\n    return nest_levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp256tfupa_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=3) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp256tfupa_test.go:51: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp256tfupa_test.go:51: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n    for i, val := range paren_string\
    \ {\n        if string(val) == \"(\" {\n            temp_result := 0\n       \
    \     for i = i + 1; i < len(paren_string); i++ {\n                if string(paren_string[i])\
    \ == \"(\" {\n                    temp_result++\n                } else if string(paren_string[i])\
    \ == \")\" {\n                    temp_result--\n                }\n         \
    \       if temp_result == 0 {\n                    break\n                }\n\
    \            }\n            result = append(result, temp_result)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n\
    \  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp1orlqh81_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=-3) %!s(int=0) %!s(int=-2)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp1orlqh81_test.go:49:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=-4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n \
    \       tmp1orlqh81_test.go:49: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=-4)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var stack []int\n    var deep_levels []int\n    var level\
    \ int\n    for _, c := range paren_string {\n        if c == '(' {\n         \
    \   stack = append(stack, c)\n            level++\n        } else if c == ')'\
    \ {\n            stack = stack[:len(stack)-1]\n            level--\n        }\
    \ else if c == ' ' {\n            deep_levels = append(deep_levels, level)\n \
    \           level = 0\n        }\n    }\n    return deep_levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxprcc5af_test.go:19:35: cannot use c (variable of type rune) as type int
    in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp1uls3cd__test.go:33: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmp1uls3cd__test.go:33: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmp1uls3cd__test.go:33: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_nesting := 0\n    current_nesting := 0\n    max_nesting_per_parentheses\
    \ := []int{}\n    for _, c := range paren_string {\n        if c == '(' {\n  \
    \          current_nesting++\n            if current_nesting > max_nesting {\n\
    \                max_nesting = current_nesting\n            }\n        } else\
    \ if c == ')' {\n            max_nesting_per_parentheses = append(max_nesting_per_parentheses,\
    \ max_nesting)\n            current_nesting--\n            max_nesting = 0\n \
    \       }\n    }\n    return max_nesting_per_parentheses\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpfkglhhnr_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=3) %!s(int=0) %!s(int=2) %!s(int=2) %!s(int=0)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpfkglhhnr_test.go:47:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpfkglhhnr_test.go:47: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var count int\n    var deepest_depth []int\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            count++\n\
    \        } else if char == ')' {\n            deepest_depth = append(deepest_depth,\
    \ count)\n            count--\n        }\n    }\n    return deepest_depth\n}\n\
    \nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpj5_jes5j_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpj5_jes5j_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpj5_jes5j_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_levels := []int{}\n    current_level := 0\n    max_level\
    \ := 0\n    // Iterate over the string one rune at a time\n    for _, ch := range\
    \ paren_string {\n        // Keep track of the level of nesting\n        if ch\
    \ == '(' {\n            current_level += 1\n        } else if ch == ')' {\n  \
    \          current_level -= 1\n        } else if ch == ' ' {\n            // When\
    \ a space is encountered, record the maximum level of nesting\n            //\
    \ encountered for this group of parentheses\n            max_levels = append(max_levels,\
    \ max_level)\n            // Reset current_level and max_level for the next group\
    \ of parentheses\n            current_level = 0\n            max_level = 0\n \
    \       }\n        // If the level of nesting for the current group is greater\
    \ than the\n        // maximum level of nesting so far, update max_level\n   \
    \     if current_level > max_level {\n            max_level = current_level\n\
    \        }\n    }\n    return max_levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpfvzkzlar_test.go:56: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=3) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpfvzkzlar_test.go:56: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpfvzkzlar_test.go:56: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Insert code here.\n    return []int{}\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpr7eu60d1_test.go:33: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmpr7eu60d1_test.go:33: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmpr7eu60d1_test.go:33: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    level_vec := make([]int, 0)\n    level := 0\n    max_level\
    \ := 0\n    for _, val := range paren_string {\n        if string(val) == \"(\"\
    \ {\n            level += 1\n            if level > max_level {\n            \
    \    max_level = level\n            }\n        } else if string(val) == \")\"\
    \ {\n            level -= 1\n        } else if string(val) == \" \" {\n      \
    \      level_vec = append(level_vec, max_level)\n            max_level = 0\n \
    \           level = 0\n        }\n    }\n    level_vec = append(level_vec, max_level)\n\
    \    return level_vec\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074314
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_chars := []rune(paren_string)\n    max_nest_level\
    \ := 0\n    max_nest_levels := []int{}\n    current_nest_level := 0\n    for _,\
    \ paren_char := range paren_chars {\n        switch string(paren_char) {\n   \
    \     case \"(\":\n            current_nest_level++\n            if current_nest_level\
    \ > max_nest_level {\n                max_nest_level = current_nest_level\n  \
    \          }\n        case \")\":\n            current_nest_level--\n        \
    \    if current_nest_level == 0 {\n                max_nest_levels = append(max_nest_levels,\
    \ max_nest_level)\n                max_nest_level = 0\n            }\n       \
    \ case \" \":\n            // Ignore, space is used as a separator\n        default:\n\
    \            fmt.Printf(\"Not recognized character '%v'!\\n\", paren_char)\n \
    \       }\n    }\n    return max_nest_levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074314
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    for _, paren := range paren_string\
    \ {\n        fmt.Println(paren)\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "40\n40\n41\n40\n41\n41\n32\n40\n40\n40\n41\n41\n41\n32\n40\n41\n32\n40\n\
    40\n40\n41\n41\n40\n41\n40\n41\n41\n40\n41\n32\n40\n40\n41\n41\n32\n40\n40\n40\n\
    41\n41\n41\n32\n40\n40\n40\n40\n41\n41\n41\n41\n40\n40\n41\n40\n40\n41\n41\n40\n\
    40\n40\n41\n41\n41\n41\n--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__0 (0.00s)\n        tmprx4rl96i_test.go:36:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3)]', got '[]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmprx4rl96i_test.go:36:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmprx4rl96i_test.go:36:\
    \ expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074316
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    ans := make([]int, 0)\n    levels := make([]int, 0)\n \
    \   for _, char := range paren_string {\n        if char == '(' {\n          \
    \  levels = append(levels, 0)\n        } else if char == ')' {\n            level\
    \ := 0\n            for i := len(levels) - 1; i >= 0; i-- {\n                if\
    \ levels[i] == 0 {\n                    level = i + 1\n                    break\n\
    \                }\n            }\n            levels = levels[:level]\n     \
    \       ans = append(ans, level)\n        }\n    }\n    return ans\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpb0ch_q8u_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=3) %!s(int=3) %!s(int=6) %!s(int=6) %!s(int=6)\
    \ %!s(int=7) %!s(int=10) %!s(int=10) %!s(int=11) %!s(int=12) %!s(int=12)]'\n \
    \   --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpb0ch_q8u_test.go:49:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=3)\
    \ %!s(int=3) %!s(int=6) %!s(int=6) %!s(int=6) %!s(int=10) %!s(int=10) %!s(int=10)\
    \ %!s(int=10)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n \
    \       tmpb0ch_q8u_test.go:49: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=4)\
    \ %!s(int=4) %!s(int=7) %!s(int=7) %!s(int=7) %!s(int=7)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074316
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    res := make([]int, 0)\n    paren_depth := 0\n    max_depth\
    \ := 0\n    for _, ch := range paren_string {\n        if ch == '(' {\n      \
    \      paren_depth++\n            if paren_depth > max_depth {\n             \
    \   max_depth = paren_depth\n            }\n        } else if ch == ')' {\n  \
    \          paren_depth--\n        } else if ch == ' ' {\n            res = append(res,\
    \ max_depth)\n            max_depth = 0\n            paren_depth = 0\n       \
    \ }\n    }\n    res = append(res, max_depth)\n    return res\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074316
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    char_indices := make([]int, len(paren_string))\n    for\
    \ i, char := range paren_string {\n        char_indices[i] = int(char)\n    }\n\
    \    // Number of groups\n    groups := len(char_indices) / 6\n    // E.g. for\
    \ input \"(()()) ((())) () ((())()())\", char_indices will be [40, 40, 41, 41,\
    \ 40, 41, 32, 32, 40, 40, 41, 41, 41, 32, 32, 41, 32, 32, 40, 40, 41, 41, 41,\
    \ 41, 40, 41, 41, 41, 41]\n    // so groups = 6\n    //fmt.Println(char_indices)\n\
    \    paren_depth := make([]int, groups)\n    // Loop over each group\n    for\
    \ i := 0; i < groups; i++ {\n        // Index of the beginning of the group\n\
    \        group_index := i * 6\n        // Index of the first parentheses\n   \
    \     first_paren := group_index + 1\n        // Index of the second parentheses\n\
    \        second_paren := group_index + 4\n        // Index of the end of the group\n\
    \        end_group := group_index + 5\n        if (char_indices[group_index] ==\
    \ 40 && char_indices[end_group] == 41) {\n            // If there is a nested\
    \ parentheses, call this function on the nested parentheses, then add 1 to the\
    \ result\n            if (char_indices[first_paren] == 40 && char_indices[second_paren]\
    \ == 41) {\n                paren_depth[i] = parse_nested_parens(paren_string[first_paren\
    \ + 1:second_paren])[0] + 1\n            } else {\n                paren_depth[i]\
    \ = 1\n            }\n        }\n    }\n    return paren_depth\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\npanic: runtime error: index\
    \ out of range [0] with length 0 [recovered]\n\tpanic: runtime error: index out\
    \ of range [0] with length 0\n\ngoroutine 4 [running]:\ntesting.tRunner.func1.2({0x5136a0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136a0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_nested_parens({0x52339c, 0x1b})\n\t\
    /tmp/tmp92iud96u_test.go:37 +0x1ff\ncommand-line-arguments_test.TestParse_Nested_Parens(0x0?)\n\
    \t/tmp/tmp92iud96u_test.go:53 +0x4d\ntesting.tRunner(0xc000134000, 0x529008)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074317
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var current_level int = 0\n    var max_level int = 0\n\
    \    var outputs []int\n    for _, char := range paren_string {\n        if string(char)\
    \ == \"(\" {\n            current_level += 1\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if string(char) == \")\" {\n            current_level -= 1\n        } else if\
    \ string(char) == \" \" {\n            outputs = append(outputs, max_level)\n\
    \            max_level = 0\n            current_level = 0\n        }\n    }\n\
    \    outputs = append(outputs, max_level)\n    return outputs\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074317
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    current_nest := 0\n    max_nest :=\
    \ 0\n    for _, paren := range paren_string {\n        if paren == '(' {\n   \
    \         current_nest += 1\n            if current_nest > max_nest {\n      \
    \          max_nest = current_nest\n            }\n        } else if paren ==\
    \ ')' {\n            result = append(result, max_nest)\n            current_nest\
    \ -= 1\n            max_nest -= 1\n        }\n    }\n    return result\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpar8xh0r__test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpar8xh0r__test.go:47:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpar8xh0r__test.go:47: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074317
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    results := make([]int, 0)\n    level := 0\n    highest_level\
    \ := 0\n    for _, c := range paren_string {\n        if c == '(' {\n        \
    \    level++\n            if level > highest_level {\n                highest_level\
    \ = level\n            }\n        } else if c == ')' {\n            level--\n\
    \        } else if c == ' ' {\n            results = append(results, highest_level)\n\
    \            highest_level = 0\n            level = 0\n        }\n    }\n    results\
    \ = append(results, highest_level)\n    return results\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074317
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_levels := make([]int, 0)\n    for paren_index :=\
    \ 0; paren_index < len(paren_string); paren_index++ {\n        if paren_string[paren_index]\
    \ == '(' {\n            paren_level := 1\n            paren_index++\n        \
    \    for paren_index < len(paren_string) && paren_string[paren_index] != ' ' {\n\
    \                if paren_string[paren_index] == '(' {\n                    paren_level++\n\
    \                } else if paren_string[paren_index] == ')' {\n              \
    \      paren_level--\n                }\n                paren_index++\n     \
    \       }\n            paren_levels = append(paren_levels, paren_level)\n    \
    \    }\n    }\n    return paren_levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpksc9_x53_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpksc9_x53_test.go:48:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmpksc9_x53_test.go:48: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074317
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_depth := 0\n    depth := 0\n    depth_arr := []int{}\n\
    \    for _, x := range paren_string {\n        if x == '(' {\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if x == ')' {\n            depth -= 1\n       \
    \ } else if x == ' ' {\n            depth_arr = append(depth_arr, max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    depth_arr\
    \ = append(depth_arr, max_depth)\n    return depth_arr\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.009s\n"
  timestamp: 1660074317
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_depth := 0\n    current_depth := 0\n    depths := []int{}\n\
    \    for _, char := range paren_string {\n        if char == '(' {\n         \
    \   current_depth += 1\n            if current_depth > max_depth {\n         \
    \       max_depth = current_depth\n            }\n        } else if char == ')'\
    \ {\n            if current_depth > 0 {\n                current_depth -= 1\n\
    \            }\n        } else if char == ' ' {\n            depths = append(depths,\
    \ max_depth)\n            max_depth = 0\n            current_depth = 0\n     \
    \   }\n    }\n    depths = append(depths, max_depth)\n    return depths\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074317
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    if len(paren_string) == 0 {\n        return []int{}\n \
    \   }\n    paren_string_list := make([]string, 0)\n    cur_str := \"\"\n    for\
    \ _, val := range paren_string {\n        if val == ' ' {\n            paren_string_list\
    \ = append(paren_string_list, cur_str)\n            cur_str = \"\"\n        }\
    \ else {\n            cur_str += string(val)\n        }\n    }\n    paren_string_list\
    \ = append(paren_string_list, cur_str)\n    paren_count_list := make([]int, 0)\n\
    \    for _, val := range paren_string_list {\n        max_count := parse_nested_parens_util(val)\n\
    \        paren_count_list = append(paren_count_list, max_count)\n    }\n    return\
    \ paren_count_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa9qp88bv_test.go:30:22: undefined: parse_nested_parens_util

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074316
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    ret := make([]int, 0)\n    max_level := 0\n    count :=\
    \ 0\n    // Loop through the string, look for one group of parentheses.\n    for\
    \ _, v := range paren_string {\n        // If v is (, increase the level.\n  \
    \      if v == '(' {\n            count++\n            if count > max_level {\n\
    \                max_level = count\n            }\n        } else if v == ')'\
    \ {\n            // Else if v is ), decrease the level.\n            count--\n\
    \        } else if v == ' ' {\n            // Else if v is space, add the max\
    \ level of the previous\n            // group to the ret and reset the max level\
    \ to 0.\n            ret = append(ret, max_level)\n            max_level = 0\n\
    \        }\n    }\n    // Add the last group.\n    ret = append(ret, max_level)\n\
    \    return ret\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074317
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    left_paren := \"(\"\n    right_paren := \")\"\n    results\
    \ := make([]int, 0)\n    for len(paren_string) > 0 {\n        if paren_string[0]\
    \ != '(' {\n            paren_string = paren_string[1:]\n            continue\n\
    \        }\n        count := 0\n        for i, c := range paren_string {\n   \
    \         if string(c) == left_paren {\n                count += 1\n         \
    \   } else if string(c) == right_paren {\n                count -= 1\n       \
    \     }\n            if count == 0 {\n                results = append(results,\
    \ i + 1)\n                paren_string = paren_string[i + 1:]\n              \
    \  break\n            }\n        }\n    }\n    return results\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpv8y9495b_test.go:54: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=6) %!s(int=6) %!s(int=2) %!s(int=10)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpv8y9495b_test.go:54:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=2) %!s(int=4)\
    \ %!s(int=6) %!s(int=8)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmpv8y9495b_test.go:54: expected '[%!s(int=4)]', got '[%!s(int=14)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074317
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_depth := 0\n    current_depth := 0\n    result := make([]int,\
    \ 0)\n    for _, paren := range paren_string {\n        if paren == '(' {\n  \
    \          current_depth += 1\n            if current_depth > max_depth {\n  \
    \              max_depth = current_depth\n            }\n        } else if paren\
    \ == ')' {\n            result = append(result, max_depth)\n            current_depth\
    \ -= 1\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp9v920igw_test.go:46: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=3)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp9v920igw_test.go:46:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp9v920igw_test.go:46: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074317
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    results := make([]int, 0)\n    depth := 0\n    local_max\
    \ := 0\n    for _, char := range paren_string {\n        if char == '(' {\n  \
    \          depth += 1\n            if depth > local_max {\n                local_max\
    \ = depth\n            }\n        } else if char == ')' {\n            depth -=\
    \ 1\n        } else if char == ' ' {\n            results = append(results, local_max)\n\
    \            local_max = 0\n            depth = 0\n        }\n    }\n    if local_max\
    \ > 0 {\n        results = append(results, local_max)\n    }\n    return results\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074317
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // TODO: Implement\n    parens := []rune(paren_string)\n\
    \    level := 0\n    levels := []int{}\n    for _, paren := range parens {\n \
    \       if paren == '(' {\n            level += 1\n        } else if paren ==\
    \ ')' {\n            level -= 1\n        } else if paren == ' ' {\n          \
    \  levels = append(levels, level)\n            level = 0\n        }\n    }\n \
    \   return levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpvelaptru_test.go:46: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpvelaptru_test.go:46: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpvelaptru_test.go:46: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074317
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    ret := make([]int, 0)\n    for _, paren_group := range\
    \ paren_string {\n        if paren_group == ' ' {\n            continue\n    \
    \    }\n\n        count := 0\n        max_count := 0\n        for _, paren :=\
    \ range paren_group {\n            if paren == '(' {\n                count++\n\
    \            } else if paren == ')' {\n                count--\n            }\n\
    \n            if count > max_count {\n                max_count = count\n    \
    \        }\n        }\n\n        ret = append(ret, max_count)\n    }\n\n    return\
    \ ret\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg_9_1_so_test.go:22:31: cannot range over paren_group (variable of type
    rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074316
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_list := make([]int, 0)\n    paren_array := make([]rune,\
    \ 0)\n    // traverse through the string and create a list of parens and store\
    \ the deepest level of nesting\n    paren_depth := 0\n    max_paren_depth := 0\n\
    \    for _, char := range paren_string {\n        if char == '(' {\n         \
    \   paren_depth++\n            if paren_depth > max_paren_depth {\n          \
    \      max_paren_depth = paren_depth\n            }\n        } else if char ==\
    \ ')' {\n            paren_depth--\n        } else if char == ' ' {\n        \
    \    paren_list = append(paren_list, max_paren_depth)\n            max_paren_depth\
    \ = 0\n            paren_depth = 0\n        }\n    }\n    paren_list = append(paren_list,\
    \ max_paren_depth)\n    return paren_list\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwns0_dtp_test.go:15:5: paren_array declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074316
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    parens := []rune(paren_string)\n    deepest_nesting :=\
    \ 0\n    running_nesting := 0\n    nesting_levels := []int{}\n    for _, paren\
    \ := range parens {\n        if paren == '(' {\n            running_nesting++\n\
    \            if running_nesting > deepest_nesting {\n                deepest_nesting\
    \ = running_nesting\n            }\n        } else if paren == ')' {\n       \
    \     running_nesting--\n        } else if paren == ' ' {\n            nesting_levels\
    \ = append(nesting_levels, deepest_nesting)\n            deepest_nesting = 0\n\
    \            running_nesting = 0\n        }\n    }\n    return nesting_levels\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpxkz1i89x_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=3) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpxkz1i89x_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpxkz1i89x_test.go:50: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074317
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var ret []int\n    var depth int\n    depth = 0\n    //\
    \ TODO: implementation\n    ret = append(ret, depth)\n    return ret\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp029ihg55_test.go:37: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp029ihg55_test.go:37: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp029ihg55_test.go:37: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074317
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // TODO:\n    // 1. convert each of the group string to\
    \ int\n    // 2. store the converted int in a slice to return\n    // 3. return\
    \ the slice\n    return nil\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n\
    \  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpvn41a9_z_test.go:36: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmpvn41a9_z_test.go:36: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmpvn41a9_z_test.go:36: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074317
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    stack := make([]int, 0)\n    nmax := make([]int, 0)\n \
    \   var dnmax int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i]\
    \ == '(' {\n            stack = append(stack, i)\n        } else if paren_string[i]\
    \ == ')' {\n            if len(stack) == 0 {\n                return nil\n   \
    \         }\n            dnmax = i - stack[len(stack)-1]\n            nmax = append(nmax,\
    \ dnmax)\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return\
    \ nmax\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp39ytdmun_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=1) %!s(int=1) %!s(int=5) %!s(int=1) %!s(int=3) %!s(int=5)\
    \ %!s(int=1) %!s(int=1) %!s(int=3) %!s(int=1) %!s(int=1) %!s(int=9)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp39ytdmun_test.go:47:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=3) %!s(int=1) %!s(int=3) %!s(int=5) %!s(int=1) %!s(int=3) %!s(int=5)\
    \ %!s(int=7)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp39ytdmun_test.go:47: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=3) %!s(int=1) %!s(int=3) %!s(int=5) %!s(int=13)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074317
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var paren_stack []int\n    var result []int\n    current_max\
    \ := 0\n    var left_parens = map[string]int{\n        \"(\": 1,\n    }\n    var\
    \ right_parens = map[string]int{\n        \")\": -1,\n    }\n    var parens =\
    \ map[string]int{\n        \"(\": 1,\n        \")\": -1,\n    }\n    for _, c\
    \ := range paren_string {\n        val, exists := parens[string(c)]\n        if\
    \ exists {\n            paren_stack = append(paren_stack, val)\n            current_max\
    \ += val\n            if val == -1 {\n                result = append(result,\
    \ current_max)\n                current_max = 0\n            }\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n \
    \ candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm4kd33q__test.go:17:9: left_parens declared but not used

    /tmp/tmpm4kd33q__test.go:20:9: right_parens declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074316
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    if len(paren_string) == 0 {\n        return []int{}\n \
    \   }\n    results := []int{}\n    current_index := 0\n    current_max := 0\n\
    \    for _, char := range paren_string {\n        if char == '(' {\n         \
    \   current_index += 1\n            if current_index > current_max {\n       \
    \         current_max = current_index\n            }\n        } else if char ==\
    \ ')' {\n            current_index -= 1\n        } else if char == ' ' {\n   \
    \         results = append(results, current_max)\n            current_index =\
    \ 0\n            current_max = 0\n        }\n    }\n    results = append(results,\
    \ current_max)\n    return results\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074318
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var s string = paren_string\n    var res []int\n    for\
    \ len(s) > 0 {\n        var r int = 0\n        for i, v := range s {\n       \
    \     if v == '(' {\n                r++\n            } else if v == ')' {\n \
    \               r--\n            }\n            if r == 0 {\n                res\
    \ = append(res, i+1)\n                s = s[i+2:]\n                break\n   \
    \         }\n        }\n    }\n    return res\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\npanic: runtime error: slice\
    \ bounds out of range [11:10] [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [11:10]\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x5136a0,\
    \ 0xc0000fc000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136a0, 0xc0000fc000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_nested_parens(...)\n\t/tmp/tmpm198n4mx_test.go:26\n\
    command-line-arguments_test.TestParse_Nested_Parens(0x0?)\n\t/tmp/tmpm198n4mx_test.go:41\
    \ +0x876\ntesting.tRunner(0xc00009b860, 0x529008)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074318
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    count := 0\n    max := 0\n    result := []int{}\n    for\
    \ _, c := range paren_string {\n        if c == '(' {\n            count += 1\n\
    \            if count > max {\n                max = count\n            }\n  \
    \      } else if c == ')' {\n            count -= 1\n        } else if c == '\
    \ ' {\n            result = append(result, max)\n            max = 0\n       \
    \     count = 0\n        }\n    }\n    result = append(result, max)\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074318
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    fmt.Println(\"Input:\", paren_string)\n    if len(paren_string)\
    \ == 0 {\n        return []int{}\n    }\n    paren_depth := 0\n    group_depth\
    \ := []int{}\n    max_depth := 0\n    for _, c := range paren_string {\n     \
    \   if c == '(' {\n            paren_depth++\n            if paren_depth > max_depth\
    \ {\n                max_depth = paren_depth\n            }\n        } else if\
    \ c == ')' {\n            paren_depth--\n        } else if c == ' ' {\n      \
    \      group_depth = append(group_depth, max_depth)\n            max_depth = 0\n\
    \        }\n    }\n    group_depth = append(group_depth, max_depth)\n    return\
    \ group_depth\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074319
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var nestings []int\n    var current_nesting int = 0\n \
    \   var max_nesting int = 0\n    for _, c := range paren_string {\n        if\
    \ c == '(' {\n            current_nesting++\n            if current_nesting >\
    \ max_nesting {\n                max_nesting = current_nesting\n            }\n\
    \        } else if c == ')' {\n            current_nesting--\n        } else if\
    \ c == ' ' {\n            nestings = append(nestings, max_nesting)\n         \
    \   max_nesting = 0\n            current_nesting = 0\n        }\n    }\n    nestings\
    \ = append(nestings, max_nesting)\n    return nestings\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074319
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var (\n        char_array = []rune(paren_string)\n    \
    \    paren_level []int\n        current_level = 0\n    )\n    for _, c := range\
    \ char_array {\n        if c == '(' {\n            current_level++\n        }\
    \ else if c == ')' {\n            current_level--\n        } else if c == ' '\
    \ {\n            paren_level = append(paren_level, current_level)\n          \
    \  current_level = 0\n        }\n    }\n    paren_level = append(paren_level,\
    \ current_level)\n    return paren_level\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpmptj72em_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpmptj72em_test.go:48:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmpmptj72em_test.go:48: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074319
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    fmt.Println(\"input string is : \" + paren_string)\n  \
    \  paren_levels := make([]int, 0)\n    for _, paren_group := range Split(paren_string,\
    \ \" \") {\n        open_paren_count := 0\n        max_open_paren_count := 0\n\
    \        for _, paren := range paren_group {\n            if paren == '(' {\n\
    \                open_paren_count++\n                if open_paren_count > max_open_paren_count\
    \ {\n                    max_open_paren_count = open_paren_count\n           \
    \     }\n            } else if paren == ')' {\n                open_paren_count--\n\
    \            }\n        }\n        paren_levels = append(paren_levels, max_open_paren_count)\n\
    \    }\n    return paren_levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_5x9pyiz_test.go:16:33: undefined: Split

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074318
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // TODO: Implement the function\n    return nil\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmphl9veq9k_test.go:33: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmphl9veq9k_test.go:33: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmphl9veq9k_test.go:33: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074320
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    pos := 0\n    max_level := 0\n    levels := make([]int,\
    \ 0)\n    for _, r := range paren_string {\n        if r == '(' {\n          \
    \  pos++\n            if pos > max_level {\n                max_level = pos\n\
    \            }\n        } else if r == ')' {\n            levels = append(levels,\
    \ max_level)\n            pos--\n            if pos == 0 {\n                max_level\
    \ = 0\n            }\n        }\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpl7xqq6fi_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=3)\
    \ %!s(int=1) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=3)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpl7xqq6fi_test.go:49:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=2) %!s(int=3) %!s(int=3) %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=4)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpl7xqq6fi_test.go:49: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=3) %!s(int=4) %!s(int=4) %!s(int=4) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074320
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var ret []int\n    var current_level int\n    for _, ch\
    \ := range paren_string {\n        switch ch {\n        case '(':\n          \
    \  current_level += 1\n        case ')':\n            current_level -= 1\n   \
    \     case ' ':\n            ret = append(ret, current_level)\n            current_level\
    \ = 0\n        }\n    }\n    return ret\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpqt4836kt_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpqt4836kt_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpqt4836kt_test.go:45: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074320
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := make([]int, 0)\n    if paren_string == \"\" {\n\
    \        return levels\n    }\n    level := 0\n    for _, v := range paren_string\
    \ {\n        if v == '(' {\n            level += 1\n        } else if v == ')'\
    \ {\n            levels = append(levels, level)\n            level -= 1\n    \
    \    }\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmphilwl2jg_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmphilwl2jg_test.go:45:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmphilwl2jg_test.go:45: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074320
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_level := 0\n    max_levels := []int{}\n    current_level\
    \ := 0\n    for _, paren := range paren_string {\n        if paren == '(' {\n\
    \            current_level += 1\n            if current_level > max_level {\n\
    \                max_level = current_level\n            }\n        } else if paren\
    \ == ')' {\n            max_levels = append(max_levels, max_level)\n         \
    \   current_level -= 1\n            if current_level < max_level {\n         \
    \       max_level = current_level\n            }\n        }\n    }\n    return\
    \ max_levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate :=\
    \ parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((()))\
    \ () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp7wgl8drz_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp7wgl8drz_test.go:49:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp7wgl8drz_test.go:49: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074320
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    results := make([]int, 0)\n    for _, group := range paren_string\
    \ {\n        count := 0\n        max := 0\n        for _, paren := range group\
    \ {\n            if paren == '(' {\n                count++\n            } else\
    \ if paren == ')' {\n                count--\n            }\n            if count\
    \ > max {\n                max = count\n            }\n        }\n        results\
    \ = append(results, max)\n    }\n    return results\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkz__ey50_test.go:18:31: cannot range over group (variable of type rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074319
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var res []int\n    const left_paren = '('\n    const right_paren\
    \ = ')'\n    for _, group := range paren_string {\n        var count int\n   \
    \     var max int\n        for _, paren := range group {\n            if paren\
    \ == left_paren {\n                count += 1\n            } else if paren ==\
    \ right_paren {\n                count -= 1\n            }\n            if count\
    \ > max {\n                max = count\n            }\n        }\n        res\
    \ = append(res, max)\n    }\n    return res\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpul88_89u_test.go:20:31: cannot range over group (variable of type rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074319
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var output []int\n    parens := []byte(paren_string)\n\
    \    for i, _ := range parens {\n        max := 0\n        for parens[i] == '('\
    \ {\n            i++\n            max++\n        }\n        output = append(output,\
    \ max)\n    }\n    return output\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmptn1c08x0_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmptn1c08x0_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=0)\
    \ %!s(int=0) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=3)\
    \ %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=4)\
    \ %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmptn1c08x0_test.go:42:\
    \ expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=1) %!s(int=0) %!s(int=2) %!s(int=1)\
    \ %!s(int=0) %!s(int=0) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074320
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    res := make([]int, 0)\n    var count int = 0\n    for _,\
    \ c := range paren_string {\n        if c == '(' {\n            count++\n    \
    \    } else if c == ')' {\n            count--\n        } else if c == ' ' {\n\
    \            res = append(res, count)\n            count = 0\n        }\n    }\n\
    \    res = append(res, count)\n    return res\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpal35qx5f_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpal35qx5f_test.go:45:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmpal35qx5f_test.go:45: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074320
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var nesting_level []int\n    for _, paren := range paren_string\
    \ {\n        if paren == '(' {\n            nesting_level = append(nesting_level,\
    \ 1)\n        } else if paren == ')' {\n            nesting_level = append(nesting_level,\
    \ 0)\n        }\n    }\n    return nesting_level\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpl171txee_test.go:40: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpl171txee_test.go:40: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpl171txee_test.go:40:\
    \ expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=1)\
    \ %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074320
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    group_result := make([]int, 0)\n    group_stack := make([]int,\
    \ 0)\n    paren_stack := make([]byte, 0)\n    for _, ch := range paren_string\
    \ {\n        if ch == '(' {\n            paren_stack = append(paren_stack, byte(ch))\n\
    \        } else if ch == ')' {\n            if len(paren_stack) == 0 {\n     \
    \           panic(\"The string is not balanced\")\n            }\n           \
    \ paren_stack = paren_stack[:len(paren_stack)-1]\n        } else if ch == ' '\
    \ {\n            if len(paren_stack) > 0 {\n                panic(\"The string\
    \ is not balanced\")\n            }\n            if len(group_stack) == 0 {\n\
    \                group_stack = append(group_stack, 1)\n            } else {\n\
    \                group_stack = append(group_stack, group_stack[len(group_stack)-1]+1)\n\
    \            }\n        }\n    }\n    if len(paren_stack) > 0 {\n        panic(\"\
    The string is not balanced\")\n    }\n    for i := 0; i < len(group_stack); i++\
    \ {\n        group_result = append(group_result, group_stack[i]-i)\n    }\n  \
    \  return group_result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp5p7vmm7s_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp5p7vmm7s_test.go:60: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp5p7vmm7s_test.go:60: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074320
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var ret = make([]int, 0)\n    var current = 0\n    var\
    \ max_current = 0\n    for _, char := range paren_string {\n        if char ==\
    \ '(' {\n            current++\n            if current > max_current {\n     \
    \           max_current = current\n            }\n        } else if char == ')'\
    \ {\n            current--\n        } else if char == ' ' {\n            ret =\
    \ append(ret, max_current)\n            current = 0\n            max_current =\
    \ 0\n        }\n    }\n    return ret\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpaxad6nju_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=3) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpaxad6nju_test.go:49: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpaxad6nju_test.go:49: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074320
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_nesting_levels []int\n    var max_level int\n \
    \   var level int\n    for _, char := range paren_string {\n        if char ==\
    \ '(' {\n            level += 1\n        } else if char == ')' {\n           \
    \ level -= 1\n        } else if char == ' ' {\n            max_nesting_levels\
    \ = append(max_nesting_levels, max_level)\n            max_level = 0\n       \
    \     level = 0\n        }\n        if level > max_level {\n            max_level\
    \ = level\n        }\n    }\n    return max_nesting_levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpgcrpv4n4_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=3) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpgcrpv4n4_test.go:49: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpgcrpv4n4_test.go:49: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074320
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    n_paren_group := 0\n    for _, c := range paren_string\
    \ {\n        if c == ' ' {\n            n_paren_group += 1\n        }\n    }\n\
    \    if n_paren_group == 0 {\n        return []int{0}\n    }\n    results := make([]int,\
    \ n_paren_group)\n    idx := 0\n    nested_level := 0\n    for _, c := range paren_string\
    \ {\n        if c == '(' {\n            nested_level += 1\n        } else if c\
    \ == ')' {\n            nested_level -= 1\n        } else if c == ' ' {\n    \
    \        results[idx] = nested_level\n            idx += 1\n            nested_level\
    \ = 0\n        }\n    }\n    results[idx] = nested_level\n    return results\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\npanic: runtime error: index\
    \ out of range [3] with length 3 [recovered]\n\tpanic: runtime error: index out\
    \ of range [3] with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5126a0,\
    \ 0xc000014378})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5126a0, 0xc000014378})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_nested_parens({0x52239c, 0x1b})\n\t\
    /tmp/tmp6you5sen_test.go:37 +0x172\ncommand-line-arguments_test.TestParse_Nested_Parens(0x0?)\n\
    \t/tmp/tmp6you5sen_test.go:48 +0x4d\ntesting.tRunner(0xc0000cc1a0, 0x528008)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074320
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_depth := 0\n    curr_depth := 0\n    curr_result :=\
    \ []int{}\n    isLastWasRightParen := false\n    var result []int\n    for _,\
    \ r := range paren_string {\n        if r == '(' {\n            curr_depth++\n\
    \            if curr_depth > max_depth {\n                max_depth = curr_depth\n\
    \            }\n            isLastWasRightParen = false\n        } else if r ==\
    \ ')' {\n            curr_depth--\n            isLastWasRightParen = true\n  \
    \      } else if r == ' ' {\n            if isLastWasRightParen {\n          \
    \      curr_result = append(curr_result, max_depth)\n                max_depth\
    \ = 0\n                curr_depth = 0\n            }\n        }\n    }\n    if\
    \ isLastWasRightParen {\n        curr_result = append(curr_result, max_depth)\n\
    \    }\n    return curr_result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp32okdnp0_test.go:18:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074319
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_group := strings.Split(paren_string, \" \")\n   \
    \ paren_depth := make([]int, len(paren_group))\n    for i, paren := range paren_group\
    \ {\n        current_depth := 0\n        max_depth := 0\n        for _, token\
    \ := range paren {\n            if token == '(' {\n                current_depth++\n\
    \            } else if token == ')' {\n                current_depth--\n     \
    \       }\n            if current_depth > max_depth {\n                max_depth\
    \ = current_depth\n            }\n        }\n        paren_depth[i] = max_depth\n\
    \    }\n    return paren_depth\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx8m1l_8p_test.go:14:20: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074319
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var accum []int\n    var paren int\n    for _, v := range\
    \ paren_string {\n        if v == '(' {\n            paren++\n        } else if\
    \ v == ')' {\n            paren--\n        } else if v == ' ' {\n            accum\
    \ = append(accum, paren)\n        }\n    }\n    return accum\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpnrn30v3n_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpnrn30v3n_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpnrn30v3n_test.go:43: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    group_strings := string_to_slice(paren_string)\n    var\
    \ depths []int\n    for _, group_string := range group_strings {\n        depths\
    \ = append(depths, count_level(group_string))\n    }\n    return depths\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6cx2g_8__test.go:14:22: undefined: string_to_slice

    /tmp/tmp6cx2g_8__test.go:17:33: undefined: count_level

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    res := make([]int, 0)\n    max_len := 0\n    open_parens\
    \ := 0\n    for _, c := range paren_string {\n        if c == '(' {\n        \
    \    open_parens += 1\n            if open_parens > max_len {\n              \
    \  max_len = open_parens\n            }\n        } else if c == ')' {\n      \
    \      if open_parens == max_len {\n                res = append(res, max_len)\n\
    \                max_len = 0\n            }\n            open_parens -= 1\n  \
    \      }\n    }\n    return res\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmphu8i26kj_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3) %!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmphu8i26kj_test.go:49: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074322
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_stack := make([]int, 0)\n    max_paren_stack := make([]int,\
    \ 0)\n    for _, paren := range paren_string {\n        if paren == '(' {\n  \
    \          paren_stack = append(paren_stack, 1)\n        } else if paren == ')'\
    \ {\n            if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n\
    \            }\n        } else if paren == ' ' {\n            if len(paren_stack)\
    \ > len(max_paren_stack) {\n                max_paren_stack = paren_stack\n  \
    \          }\n            paren_stack = make([]int, 0)\n        }\n    }\n   \
    \ if len(paren_stack) > len(max_paren_stack) {\n        max_paren_stack = paren_stack\n\
    \    }\n    return max_paren_stack\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpg4gpyhid_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmpg4gpyhid_test.go:51: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmpg4gpyhid_test.go:51: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074321
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var num_nesting []int\n    var current_nesting int\n  \
    \  for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '('\
    \ {\n            current_nesting++\n        } else if paren_string[i] == ')' {\n\
    \            current_nesting--\n        } else if paren_string[i] == ' ' {\n \
    \           num_nesting = append(num_nesting, current_nesting)\n            current_nesting\
    \ = 0\n        }\n    }\n    num_nesting = append(num_nesting, current_nesting)\n\
    \    return num_nesting\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n \
    \ candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpjudcmqds_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpjudcmqds_test.go:45:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmpjudcmqds_test.go:45: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074322
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp1uls3cd__test.go:33: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmp1uls3cd__test.go:33: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmp1uls3cd__test.go:33: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074314
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Parse the input string.\n    paren_groups := parse_input(paren_string)\n\
    \n    results := make([]int, len(paren_groups))\n    for i, group := range paren_groups\
    \ {\n        results[i] = analyze_paren_group(group)\n    }\n\n    return results\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgc03cp_w_test.go:15:21: undefined: parse_input

    /tmp/tmpgc03cp_w_test.go:19:22: undefined: analyze_paren_group

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074322
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n    nested_level := 0\n    curr_paren\
    \ := make([]rune, 0)\n    for _, v := range paren_string {\n        if v == '('\
    \ {\n            nested_level++\n            curr_paren = append(curr_paren, v)\n\
    \        } else if v == ')' {\n            nested_level--\n            curr_paren\
    \ = append(curr_paren, v)\n        } else if v == ' ' {\n            if curr_paren[0]\
    \ == '(' && curr_paren[len(curr_paren)-1] == ')' {\n                result = append(result,\
    \ nested_level)\n            }\n            curr_paren = make([]rune, 0)\n   \
    \     }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpibtb706a_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpibtb706a_test.go:49: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpibtb706a_test.go:49: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074322
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_levels := make([]int, 0)\n    paren_depth := 0\n\
    \    start_paren_idx := 0\n    for i, paren := range paren_string {\n        if\
    \ paren == '(' {\n            if paren_depth == 0 {\n                start_paren_idx\
    \ = i\n            }\n            paren_depth++\n        } else if paren == ')'\
    \ {\n            paren_depth--\n            if paren_depth == 0 {\n          \
    \      paren_levels = append(paren_levels, i - start_paren_idx + 1)\n        \
    \    }\n        }\n    }\n    return paren_levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpzid21y1v_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=6) %!s(int=6) %!s(int=2) %!s(int=10)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpzid21y1v_test.go:48:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=2) %!s(int=4)\
    \ %!s(int=6) %!s(int=8)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmpzid21y1v_test.go:48: expected '[%!s(int=4)]', got '[%!s(int=14)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074323
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    panic(\"Not Implemented\")\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\npanic: Not Implemented [recovered]\n\
    \tpanic: Not Implemented\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x4fcd60,\
    \ 0x548940})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x4fcd60, 0x548940})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_nested_parens(...)\n\t/tmp/tmpm_7up54x_test.go:14\n\
    command-line-arguments_test.TestParse_Nested_Parens(0x0?)\n\t/tmp/tmpm_7up54x_test.go:24\
    \ +0x27\ntesting.tRunner(0xc00013c1a0, 0x527d50)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074323
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    parens := []rune(paren_string)\n    cur_max := 0\n    cur_count\
    \ := 0\n    output := []int{}\n    for _, val := range parens {\n        if val\
    \ == '(' {\n            cur_count += 1\n            if cur_count > cur_max {\n\
    \                cur_max = cur_count\n            }\n        } else if val ==\
    \ ')' {\n            cur_count -= 1\n        } else if val == ' ' {\n        \
    \    output = append(output, cur_max)\n            cur_max = 0\n            cur_count\
    \ = 0\n        }\n    }\n    output = append(output, cur_max)\n    return output\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074323
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n    current_depth := 0\n    max_depth\
    \ := 0\n    for _, r := range paren_string {\n        if r == '(' {\n        \
    \    current_depth += 1\n            if current_depth > max_depth {\n        \
    \        max_depth = current_depth\n            }\n        } else if r == ')'\
    \ {\n            current_depth -= 1\n        } else if r == ' ' {\n          \
    \  result = append(result, max_depth)\n            current_depth = 0\n       \
    \     max_depth = 0\n        }\n    }\n    result = append(result, max_depth)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074323
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    parens := []rune(paren_string)\n    max_depth := 0\n  \
    \  depth := 0\n    result := make([]int, 0)\n    for _, paren := range parens\
    \ {\n        if paren == '(' {\n            depth += 1\n            if depth >\
    \ max_depth {\n                max_depth = depth\n            }\n        } else\
    \ if paren == ')' {\n            depth -= 1\n        } else if paren == ' ' {\n\
    \            result = append(result, max_depth)\n            max_depth = 0\n \
    \           depth = 0\n        }\n    }\n    result = append(result, max_depth)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074323
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var left_paren, right_paren int = 0, 0\n    var max, counter\
    \ int = 0, 0\n    var res []int\n    for _, v := range paren_string {\n      \
    \  if v == '(' {\n            left_paren += 1\n            counter += 1\n    \
    \        if counter > max {\n                max = counter\n            }\n  \
    \      } else if v == ')' {\n            right_paren += 1\n            counter\
    \ -= 1\n        } else if v == ' ' {\n            res = append(res, max)\n   \
    \         left_paren, right_paren, max, counter = 0, 0, 0, 0\n        }\n    }\n\
    \    return res\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp34wb8753_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=3) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp34wb8753_test.go:50: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp34wb8753_test.go:50: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074323
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n    max_level := 0\n    level\
    \ := 0\n    for _, rune := range paren_string {\n        if rune == '(' {\n  \
    \          level += 1\n            if level > max_level {\n                max_level\
    \ = level\n            }\n        } else if rune == ')' {\n            level -=\
    \ 1\n        } else if rune == ' ' {\n            result = append(result, max_level)\n\
    \            max_level = 0\n            level = 0\n        }\n    }\n    result\
    \ = append(result, max_level)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074323
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    ret := make([]int, 0)\n    for _, paren_group := range(paren_string)\
    \ {\n        if paren_group == ' ' {\n            continue\n        }\n      \
    \  if paren_group == '(' {\n            depth := 1\n            if next_paren_group,\
    \ err := paren_string.next(); err == nil {\n                if next_paren_group\
    \ == '(' {\n                    depth += parse_nested_parens(paren_string)\n \
    \               }\n            }\n            ret = append(ret, depth)\n     \
    \   }\n    }\n    return ret\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeo6d3hu6_test.go:21:54: paren_string.next undefined (type string has no
    field or method next)

    /tmp/tmpeo6d3hu6_test.go:23:21: invalid operation: depth += parse_nested_parens(paren_string)
    (mismatched types int and []int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074323
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var levels []int\n    for _, group := range paren_string\
    \ {\n        count := 0\n        for _, paren := range group {\n            if\
    \ paren == \"(\" {\n                count += 1\n            } else if paren ==\
    \ \")\" {\n                count -= 1\n            }\n        }\n        levels\
    \ = append(levels, count)\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzk95jkue_test.go:17:31: cannot range over group (variable of type rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074323
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var nesting_levels []int\n    var current_level int = 0\n\
    \    var max_level int = 0\n    var nested_parens_start int = 0\n    var nested_parens_end\
    \ int = 0\n    // find the start and end locations of the parentheses\n    for\
    \ index, char := range paren_string {\n        if char == '(' {\n            if\
    \ current_level == 0 {\n                nested_parens_start = index\n        \
    \    }\n            current_level += 1\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if char == ')' {\n            current_level -= 1\n            if current_level\
    \ == 0 {\n                nested_parens_end = index\n                nesting_levels\
    \ = append(nesting_levels, max_level)\n                max_level = 0\n       \
    \     }\n        }\n    }\n    return nesting_levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl_wjwd9e_test.go:17:9: nested_parens_start declared but not used

    /tmp/tmpl_wjwd9e_test.go:18:9: nested_parens_end declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074323
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    results := make([]int, 0)\n    paren_string = paren_string\
    \ + \" \"\n    current_max := 0\n    curr_count := 0\n    for _, c := range paren_string\
    \ {\n        switch string(c) {\n        case \"(\":\n            curr_count++\n\
    \            if curr_count > current_max {\n                current_max = curr_count\n\
    \            }\n        case \")\":\n            curr_count--\n        case \"\
    \ \":\n            results = append(results, current_max)\n            current_max\
    \ = 0\n            curr_count = 0\n        }\n    }\n    return results\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074323
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var num_parens = make([]int, 0)\n    var paren_count int\
    \ = 0\n    var new_paren_count int = 0\n    var max_count int = 0\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            paren_count\
    \ += 1\n        } else if char == ')' {\n            paren_count -= 1\n      \
    \  } else if char == ' ' {\n            if paren_count > max_count {\n       \
    \         max_count = paren_count\n            }\n            new_paren_count\
    \ = 0\n        }\n        new_paren_count += 1\n    }\n    if paren_count > max_count\
    \ {\n        max_count = paren_count\n    }\n    num_parens = append(num_parens,\
    \ max_count)\n    paren_string = paren_string[new_paren_count + 1:]\n    return\
    \ append(num_parens, parse_nested_parens(paren_string)...)\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\npanic: runtime error: slice\
    \ bounds out of range [4:3] [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [4:3]\n\ngoroutine 4 [running]:\ntesting.tRunner.func1.2({0x5136a0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5136a0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.parse_nested_parens({0x5233b4, 0x3})\n\t\
    /tmp/tmp91ygl2xg_test.go:35 +0x247\ncommand-line-arguments_test.parse_nested_parens({0x5233a8,\
    \ 0xf})\n\t/tmp/tmp91ygl2xg_test.go:36 +0x193\ncommand-line-arguments_test.parse_nested_parens({0x52339c,\
    \ 0x1b})\n\t/tmp/tmp91ygl2xg_test.go:36 +0x193\ncommand-line-arguments_test.TestParse_Nested_Parens(0x0?)\n\
    \t/tmp/tmp91ygl2xg_test.go:46 +0x4d\ntesting.tRunner(0xc000003d40, 0x529008)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074323
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    if paren_string == \"\" {\n        return nil\n    }\n\
    \    max_level := make([]int, 0)\n    current_level := 0\n    for _, char := range\
    \ paren_string {\n        if char == '(' {\n            current_level += 1\n \
    \       } else if char == ')' {\n            max_level = append(max_level, current_level)\n\
    \            current_level -= 1\n        }\n    }\n    return max_level\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp0yfga2bv_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp0yfga2bv_test.go:45:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp0yfga2bv_test.go:45: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074323
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var nesting_level int\n    var temp_result\
    \ []int\n    for _, c := range paren_string {\n        if c == '(' {\n       \
    \     nesting_level += 1\n        } else if c == ')' {\n            nesting_level\
    \ -= 1\n        } else if c == ' ' {\n            temp_result = append(temp_result,\
    \ nesting_level)\n            nesting_level = 0\n        }\n    }\n    var max_nesting_level\
    \ int\n    for _, nesting_level := range temp_result {\n        if nesting_level\
    \ > max_nesting_level {\n            max_nesting_level = nesting_level\n     \
    \   }\n    }\n    for _, nesting_level := range temp_result {\n        if nesting_level\
    \ == max_nesting_level {\n            result = append(result, nesting_level)\n\
    \        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpdejli3yb_test.go:56: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpdejli3yb_test.go:56: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpdejli3yb_test.go:56: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074323
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    depth := 0\n    result := make([]int, 0)\n    for _, c\
    \ := range paren_string {\n        switch c {\n        case '(':\n           \
    \ depth += 1\n        case ')':\n            depth -= 1\n        case ' ':\n \
    \           result = append(result, depth)\n        }\n    }\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpkiiurw_l_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpkiiurw_l_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpkiiurw_l_test.go:44: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074323
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := make([]int, 0)\n    level := 0\n    for _, c\
    \ := range paren_string {\n        switch c {\n        case '(':\n           \
    \ level++\n        case ')':\n            levels = append(levels, level)\n   \
    \         level--\n        }\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpu17_7m2__test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpu17_7m2__test.go:43:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpu17_7m2__test.go:43: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074323
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_level := 0\n    cur_level := 0\n    var result []int\n\
    \    for _, s := range paren_string {\n        switch string(s) {\n        case\
    \ \"(\":\n            cur_level++\n            if cur_level > max_level {\n  \
    \              max_level = cur_level\n            }\n        case \")\":\n   \
    \         if cur_level == max_level {\n                result = append(result,\
    \ max_level)\n                max_level = 0\n            }\n            cur_level--\n\
    \        case \" \":\n            if cur_level == max_level {\n              \
    \  result = append(result, max_level)\n                max_level = 0\n       \
    \     }\n            cur_level = 0\n        }\n    }\n    return result\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpa9xqe4rz_test.go:56: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=3) %!s(int=2) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpa9xqe4rz_test.go:56: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=2) %!s(int=0) %!s(int=3) %!s(int=0)\
    \ %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpa9xqe4rz_test.go:56: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074324
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_list := []rune(paren_string)\n    paren_indices :=\
    \ []int{}\n    paren_cnt := 0\n    max_cnt := 0\n    for _, paren := range paren_list\
    \ {\n        if paren == '(' {\n            paren_cnt++\n            if paren_cnt\
    \ > max_cnt {\n                max_cnt = paren_cnt\n            }\n        } else\
    \ if paren == ')' {\n            paren_cnt--\n        } else if paren == ' ' {\n\
    \            paren_indices = append(paren_indices, max_cnt)\n            max_cnt\
    \ = 0\n        }\n    }\n    return paren_indices\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpb_lfbrn2_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=3) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpb_lfbrn2_test.go:49: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpb_lfbrn2_test.go:49: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    return []int{}\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpaetmdcix_test.go:32: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmpaetmdcix_test.go:32: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmpaetmdcix_test.go:32: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var stack []int\n    var res []int\n    for _, x := range\
    \ paren_string {\n        if string(x) == \"(\" {\n            stack = append(stack,\
    \ 0)\n        } else if string(x) == \")\" {\n            var level int\n    \
    \        for i:=len(stack)-1; i>=0; i-- {\n                if stack[i] < 0 {\n\
    \                    stack = stack[:i]\n                    break\n          \
    \      }\n                level += stack[i]\n            }\n            stack\
    \ = append(stack, -1)\n            res = append(res, level)\n        } else if\
    \ string(x) == \" \" {\n            for i:=len(stack)-1; i>=0; i-- {\n       \
    \         if stack[i] < 0 {\n                    stack = stack[:i]\n         \
    \           break\n                }\n                stack[i]++\n           \
    \ }\n        }\n    }\n    return res\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpwrsks5ku_test.go:58: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpwrsks5ku_test.go:58:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpwrsks5ku_test.go:58: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var stack []int\n    var deep int\n    var result []int\n\
    \    var parsing bool\n\n    for _, char := range paren_string {\n        if char\
    \ == '(' {\n            parsing = true\n            deep += 1\n            stack\
    \ = append(stack, deep)\n        } else if char == ')' {\n            if parsing\
    \ {\n                result = append(result, stack[len(stack)-1])\n          \
    \      stack = stack[:len(stack)-1]\n                deep -= 1\n            }\n\
    \        } else {\n            if parsing {\n                parsing = false\n\
    \                deep = 0\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpia_y6x3c_test.go:55: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpia_y6x3c_test.go:55:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpia_y6x3c_test.go:55: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074325
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n    for _, str := range(Split(paren_string,\
    \ \" \")) {\n        if len(str) == 0 {\n            continue\n        }\n   \
    \     if str[0] != '(' || str[len(str) - 1] != ')' {\n            panic(\"Malformed\
    \ paren string\")\n        }\n        result = append(result, parse_nested_parens_internal(str,\
    \ 0, 1))\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnpgn4f88_test.go:15:25: undefined: Split

    /tmp/tmpnpgn4f88_test.go:22:33: undefined: parse_nested_parens_internal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_levels := []int{}\n    level := 0\n    current_group\
    \ := \"\"\n    for _, c := range paren_string {\n        current_group += string(c)\n\
    \        if c == '(' {\n            level += 1\n        } else if c == ')' {\n\
    \            level -= 1\n        } else if c == ' ' {\n            max_levels\
    \ = append(max_levels, level)\n            level = 0\n            current_group\
    \ = \"\"\n        }\n    }\n    return max_levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp8tpyte6g_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp8tpyte6g_test.go:47: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp8tpyte6g_test.go:47: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074326
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_level := 0\n    current_level := 0\n    result := make([]int,\
    \ 0)\n    for _, char := range paren_string {\n        if char == '(' {\n    \
    \        current_level += 1\n            if current_level > max_level {\n    \
    \            max_level = current_level\n            }\n        } else if char\
    \ == ')' {\n            if current_level == max_level {\n                result\
    \ = append(result, max_level)\n                max_level = 0\n               \
    \ current_level = 0\n            } else {\n                current_level -= 1\n\
    \            }\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp2qw_1d69_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=0)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2qw_1d69_test.go:51:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp2qw_1d69_test.go:51: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=2)\
    \ %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074326
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    start := 0\n    level := 0\n    for\
    \ i, c := range paren_string {\n        if c == '(' {\n            level++\n \
    \       } else if c == ')' {\n            level--\n        } else if c == ' '\
    \ {\n            if level > 0 {\n                level--\n            } else {\n\
    \                result = append(result, level - start)\n                start\
    \ = level\n            }\n        }\n        if i == len(paren_string) - 1 {\n\
    \            result = append(result, level - start)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp1_d1pxws_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp1_d1pxws_test.go:52:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmp1_d1pxws_test.go:52: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074326
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var current_level int = 0\n    var max_level []int = make([]int,\
    \ 0)\n    var current_group []int = make([]int, 0)\n    for _, c := range paren_string\
    \ {\n        if c == '(' {\n            current_level += 1\n            current_group\
    \ = append(current_group, current_level)\n        } else if c == ')' {\n     \
    \       current_level -= 1\n            current_group = append(current_group,\
    \ current_level)\n        } else if c == ' ' {\n            max_level = append(max_level,\
    \ current_group[len(current_group) - 1])\n            current_group = make([]int,\
    \ 0)\n        }\n    }\n    return max_level\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpy0k9o1oz_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpy0k9o1oz_test.go:47: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpy0k9o1oz_test.go:47: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074326
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var count int\n    var index int\n\
    \    var i int\n    for ; i < len(paren_string); i++ {\n        if paren_string[i]\
    \ == '(' {\n            count++\n        } else if paren_string[i] == ')' {\n\
    \            count--\n        } else if paren_string[i] == ' ' {\n           \
    \ result = append(result, count)\n            count = 0\n            index++\n\
    \        }\n    }\n    result = append(result, count)\n    return result\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp02_mm2xt_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp02_mm2xt_test.go:48:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmp02_mm2xt_test.go:48: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074326
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var stack []int\n    for _, c := range paren_string {\n\
    \        if c == '(' {\n            stack = append(stack, 0)\n        } else if\
    \ c == ')' {\n            depth := 0\n            for i := len(stack) - 1; i >=\
    \ 0; i-- {\n                if stack[i] == 0 {\n                    depth = len(stack)\
    \ - i\n                    break\n                }\n            }\n         \
    \   stack = append(stack, depth)\n        }\n    }\n    return stack\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp61qsp4ce_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0)\
    \ %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=0)\
    \ %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp61qsp4ce_test.go:47: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp61qsp4ce_test.go:47:\
    \ expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=2)\
    \ %!s(int=3) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074326
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_array := []int{}\n    paren_group := \"\"\n    for\
    \ _, char := range paren_string {\n        switch char {\n        case '(':\n\
    \            paren_group += \"(\"\n        case ')':\n            paren_group\
    \ += \")\"\n        case ' ':\n            paren_array = append(paren_array, parse_nested_parens_core(paren_group))\n\
    \            paren_group = \"\"\n        }\n    }\n    return paren_array\n}\n\
    \nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkuibrmc3_test.go:23:47: undefined: parse_nested_parens_core

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074325
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    count_levels := func(input string) int {\n        var level\
    \ int\n        max_level := 0\n        for _, c := range input {\n           \
    \ if c == '(' {\n                level++\n            } else if c == ')' {\n \
    \               level--\n            } else {\n                panic(\"Invalid\
    \ input!\")\n            }\n            if level > max_level {\n             \
    \   max_level = level\n            }\n        }\n        return max_level\n  \
    \  }\n\n    var result []int\n    for _, paren := range paren_string {\n     \
    \   if paren == ' ' {\n            continue\n        }\n        fmt.Println(paren)\n\
    \        level := count_levels(string(paren))\n        result = append(result,\
    \ level)\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "40\n40\n41\n40\n41\n41\n40\n40\n40\n41\n41\n41\n40\n41\n40\n40\n40\n41\n\
    41\n40\n41\n40\n41\n41\n40\n41\n40\n40\n41\n41\n40\n40\n40\n41\n41\n41\n40\n40\n\
    40\n40\n41\n41\n41\n41\n40\n40\n41\n40\n40\n41\n41\n40\n40\n40\n41\n41\n41\n41\n\
    --- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpb1wdvllj_test.go:59: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=1) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpb1wdvllj_test.go:59: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpb1wdvllj_test.go:59:\
    \ expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=1) %!s(int=0) %!s(int=1) %!s(int=1)\
    \ %!s(int=0) %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074326
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var paren_counter int\n    var deepest_nesting\
    \ int\n    for _, char := range paren_string {\n        if string(char) == \"\
    (\" {\n            paren_counter++\n            if paren_counter > deepest_nesting\
    \ {\n                deepest_nesting = paren_counter\n            }\n        }\
    \ else if string(char) == \")\" {\n            paren_counter--\n        } else\
    \ if string(char) == \" \" {\n            result = append(result, deepest_nesting)\n\
    \            deepest_nesting = 0\n        }\n    }\n    result = append(result,\
    \ deepest_nesting)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074326
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    current_level := 0\n    max_level\
    \ := 0\n    for _, char := range paren_string {\n        if char == '(' {\n  \
    \          current_level++\n            if current_level > max_level {\n     \
    \           max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074326
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_count := 0\n    counts := []int{}\n    for _, word\
    \ := range split_words(paren_string) {\n        for _, char := range word {\n\
    \            if char == '(' {\n                max_count += 1\n            } else\
    \ if char == ')' {\n                max_count -= 1\n            }\n        }\n\
    \        counts = append(counts, max_count)\n        max_count = 0\n    }\n  \
    \  return counts\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3pxkvh39_test.go:16:26: undefined: split_words

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074326
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var deepest_nesting = []int{}\n    var cur_paren_group\
    \ = \"\"\n    var cur_deepest_nesting = 0\n    var cur_nesting = 0\n    for _,\
    \ paren := range paren_string {\n        if string(paren) == \" \" {\n       \
    \     deepest_nesting = append(deepest_nesting, cur_deepest_nesting)\n       \
    \     cur_paren_group = \"\"\n            cur_deepest_nesting = 0\n          \
    \  cur_nesting = 0\n        } else {\n            cur_paren_group += string(paren)\n\
    \            if string(paren) == \"(\" {\n                cur_nesting += 1\n \
    \               if cur_nesting > cur_deepest_nesting {\n                    cur_deepest_nesting\
    \ = cur_nesting\n                }\n            } else {\n                cur_nesting\
    \ -= 1\n            }\n        }\n    }\n    deepest_nesting = append(deepest_nesting,\
    \ cur_deepest_nesting)\n    return deepest_nesting\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074326
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := make([]int, 0)\n    paren_level := 0\n    for\
    \ _, c := range paren_string {\n        if c == '(' {\n            paren_level++\n\
    \        } else if c == ')' {\n            levels = append(levels, paren_level)\n\
    \            paren_level--\n        }\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp3cv0eqti_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp3cv0eqti_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp3cv0eqti_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074326
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    depths := make([]int, 0)\n    max_depth := 0\n    depth\
    \ := 0\n    open_paren := '('\n    close_paren := ')'\n    lparen_count := 0\n\
    \    rparen_count := 0\n    for _, char := range paren_string {\n        if char\
    \ == open_paren {\n            lparen_count += 1\n            depth += 1\n   \
    \         if depth > max_depth {\n                max_depth = depth\n        \
    \    }\n        } else if char == close_paren {\n            rparen_count += 1\n\
    \            depth -= 1\n        } else if char == ' ' {\n            if lparen_count\
    \ == rparen_count {\n                depths = append(depths, max_depth)\n    \
    \            max_depth = 0\n                depth = 0\n                lparen_count\
    \ = 0\n                rparen_count = 0\n            }\n        }\n    }\n   \
    \ return depths\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpr2_wt4r7_test.go:59: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=3) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpr2_wt4r7_test.go:59: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpr2_wt4r7_test.go:59: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074326
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var current_level int\n    var result []int\n    for _,\
    \ v := range paren_string {\n        // fmt.Println(v)\n        if v == '(' {\n\
    \            current_level += 1\n        } else if v == ')' {\n            current_level\
    \ -= 1\n        } else if v == ' ' {\n            result = append(result, current_level)\n\
    \            current_level = 0\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpx4qqy3zy_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpx4qqy3zy_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpx4qqy3zy_test.go:45: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074326
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    if paren_string == \"\" {\n        return []int{}\n   \
    \ }\n    stack := make([]int, 0)\n    max := make([]int, 0)\n    for _, ch :=\
    \ range paren_string {\n        if ch == '(' {\n            stack = append(stack,\
    \ 0)\n        } else if ch == ')' {\n            if len(stack) > 0 {\n       \
    \         stack[len(stack)-1]++\n                if len(stack) > len(max) {\n\
    \                    max = stack\n                }\n            }\n        }\
    \ else if ch == ' ' {\n            stack = stack[:0]\n        }\n    }\n    return\
    \ max\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp_zddigir_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=2) %!s(int=1) %!s(int=2)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp_zddigir_test.go:51:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=4)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmp_zddigir_test.go:51: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=1)\
    \ %!s(int=0) %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074326
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var paren_levels []int\n    var current_level int = 0\n\
    \    var max_level int = 0\n    var char string\n    for _, char = range paren_string\
    \ {\n        switch char {\n        case '(':\n            current_level += 1\n\
    \            if current_level > max_level {\n                max_level = current_level\n\
    \            }\n        case ')':\n            current_level -= 1\n        case\
    \ ' ':\n            paren_levels = append(paren_levels, max_level)\n         \
    \   max_level = 0\n            current_level = 0\n        }\n    }\n    paren_levels\
    \ = append(paren_levels, max_level)\n    return paren_levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdu6_mw44_test.go:18:12: cannot use char (value of type rune) as type string
    in assignment

    /tmp/tmpdu6_mw44_test.go:20:14: cannot convert ''('' (untyped rune constant 40)
    to string

    /tmp/tmpdu6_mw44_test.go:25:14: cannot convert '')'' (untyped rune constant 41)
    to string

    /tmp/tmpdu6_mw44_test.go:27:14: cannot convert '' '' (untyped rune constant 32)
    to string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074326
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var results []int\n    return results\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp7d9_i4op_test.go:33: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmp7d9_i4op_test.go:33: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmp7d9_i4op_test.go:33: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074327
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    parens := []rune(paren_string)\n    res := make([]int,\
    \ 0)\n    max := 0\n    for _, c := range parens {\n        if c == '(' {\n  \
    \          max += 1\n        } else if c == ')' {\n            max -= 1\n    \
    \    } else {\n            res = append(res, max)\n            max = 0\n     \
    \   }\n    }\n    res = append(res, max)\n    return res\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpqtv0e_6d_test.go:46: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpqtv0e_6d_test.go:46:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmpqtv0e_6d_test.go:46: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074328
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    depths := make([]int, 0)\n    cur_depth := 0\n    max_depth\
    \ := 0\n    for _, c := range paren_string {\n        if c == '(' {\n        \
    \    cur_depth++\n            if cur_depth > max_depth {\n                max_depth\
    \ = cur_depth\n            }\n        } else if c == ')' {\n            if cur_depth\
    \ > 0 {\n                cur_depth--\n            }\n        } else if c == '\
    \ ' {\n            depths = append(depths, max_depth)\n            max_depth =\
    \ 0\n            cur_depth = 0\n        }\n    }\n    depths = append(depths,\
    \ max_depth)\n    return depths\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074328
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := make([]int, 0)\n    depth := 0\n    max_depth\
    \ := 0\n    for _, c := range paren_string {\n        switch c {\n        case\
    \ '(':\n            depth += 1\n            max_depth = max(max_depth, depth)\n\
    \        case ')':\n            depth -= 1\n        case ' ':\n            if\
    \ depth == 0 {\n                levels = append(levels, max_depth)\n         \
    \       max_depth = 0\n            }\n        }\n    }\n    levels = append(levels,\
    \ max_depth)\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpligk_047_test.go:21:25: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074327
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var current_level int = 0\n    var max_levels []int\n \
    \   for _, current_paren := range paren_string {\n        if current_paren ==\
    \ '(' {\n            current_level++\n        } else if current_paren == ')' {\n\
    \            current_level--\n        } else if current_paren == ' ' {\n     \
    \       max_levels = append(max_levels, current_level)\n            current_level\
    \ = 0\n        }\n    }\n    return max_levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp89hclccr_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmp89hclccr_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmp89hclccr_test.go:44: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074328
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth int = 0\n    var depth_stack []int\n    var\
    \ depth_list []int\n    for _, ch := range paren_string {\n        if ch == '('\
    \ {\n            depth_stack = append(depth_stack, 0)\n        } else if ch ==\
    \ ')' {\n            depth_stack = depth_stack[:len(depth_stack)-1]\n        }\
    \ else if ch == ' ' {\n            if len(depth_stack) > max_depth {\n       \
    \         max_depth = len(depth_stack)\n            }\n            depth_list\
    \ = append(depth_list, max_depth)\n            max_depth = 0\n        }\n    }\n\
    \    return depth_list\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpjovyuxgj_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpjovyuxgj_test.go:48: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpjovyuxgj_test.go:48: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074328
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    parens := []int{}\n    cur := 0\n    for _, r := range\
    \ paren_string {\n        switch r {\n        case '(':\n            cur++\n \
    \       case ')':\n            cur--\n        case ' ':\n            parens =\
    \ append(parens, cur)\n            cur = 0\n        }\n    }\n    return parens\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpnx40dse2_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpnx40dse2_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpnx40dse2_test.go:45: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var ret []int\n    var max_count int = 0\n    var count\
    \ int = 0\n    for _, char := range paren_string {\n        if char == '(' {\n\
    \            count += 1\n        } else if char == ')' {\n            count -=\
    \ 1\n        }\n        max_count = max(max_count, count)\n        if char ==\
    \ ' ' {\n            ret = append(ret, max_count)\n            max_count = 0\n\
    \            count = 0\n        }\n    }\n    return ret\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd1oqr3tt_test.go:23:21: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074328
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    prev_level := 0 // Keep track of current level of nesting\n\
    \    max_level := 0 // Keep track of max level of nesting\n    result := []int{}\
    \ // Store result for each group\n    for _, char := range paren_string {\n  \
    \      if string(char) == \"(\" {\n            prev_level += 1\n            if\
    \ prev_level > max_level {\n                max_level = prev_level\n         \
    \   }\n        } else if string(char) == \")\" {\n            prev_level -= 1\n\
    \        } else if string(char) == \" \" {\n            result = append(result,\
    \ max_level)\n            max_level = 0\n            prev_level = 0\n        }\n\
    \    }\n    result = append(result, max_level)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074329
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n    start_pos := 0\n    cur_level\
    \ := 0\n    max_level := 0\n    for pos, char := range paren_string {\n      \
    \  if char == '(' {\n            cur_level += 1\n            if cur_level > max_level\
    \ {\n                max_level = cur_level\n            }\n        } else if char\
    \ == ')' {\n            cur_level -= 1\n        } else if char == ' ' {\n    \
    \        result = append(result, max_level)\n            start_pos = pos + 1\n\
    \            cur_level = 0\n            max_level = 0\n        }\n    }\n    result\
    \ = append(result, max_level)\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_1sy6bwg_test.go:15:5: start_pos declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074328
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var nested_parens []int\n    var current_level int = 0\n\
    \    var max_level int = 0\n    for _, char := range paren_string {\n        if\
    \ char == '(' {\n            current_level++\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if char == ')' {\n            current_level--\n        } else if char == ' '\
    \ {\n            nested_parens = append(nested_parens, max_level)\n          \
    \  max_level = 0\n            current_level = 0\n        }\n    }\n    return\
    \ nested_parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpdcez0td7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=3) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpdcez0td7_test.go:49: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpdcez0td7_test.go:49: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_array := []int{}\n    paren_count := 0\n    for _,\
    \ char := range paren_string {\n        switch char {\n        case '(':\n   \
    \         paren_count++\n        case ')':\n            paren_count--\n      \
    \  case ' ':\n            paren_array = append(paren_array, paren_count)\n   \
    \         paren_count = 0\n        }\n    }\n    return paren_array\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpre1zhk9g_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpre1zhk9g_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpre1zhk9g_test.go:45: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_levels := make([]int, 0)\n    current_level := 0\n\
    \    current_max := 0\n    // This is to indicate if there is any dangling left\
    \ or right parenthesis, which means the string is not valid.\n    left_dangling\
    \ := false\n    right_dangling := false\n    for _, char := range paren_string\
    \ {\n        switch char {\n        case '(':\n            current_level += 1\n\
    \            if current_level > current_max {\n                current_max = current_level\n\
    \            }\n        case ')':\n            if current_level == 0 {\n     \
    \           right_dangling = true\n            } else {\n                current_level\
    \ -= 1\n            }\n        case ' ':\n            if current_level != 0 {\n\
    \                left_dangling = true\n            }\n            max_levels =\
    \ append(max_levels, current_max)\n            current_max = 0\n            current_level\
    \ = 0\n        }\n    }\n    if current_level != 0 {\n        left_dangling =\
    \ true\n    }\n    max_levels = append(max_levels, current_max)\n    if left_dangling\
    \ || right_dangling {\n        return nil\n    }\n    return max_levels\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074329
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // returns the index of the matched parenthesis.\n    match_paren\
    \ := func(paren_string string, start_index int) int {\n        stack := make([]int,\
    \ 0)\n\n        for i, char := range paren_string {\n            if char == '('\
    \ {\n                stack = append(stack, i)\n            } else if char == ')'\
    \ {\n                if len(stack) == 0 {\n                    return -1\n   \
    \             } else {\n                    stack = stack[:len(stack)-1]\n   \
    \             }\n            }\n        }\n\n        return -1\n    }\n\n    //\
    \ returns the nesting level of the parentheses.\n    get_level := func(paren_string\
    \ string) int {\n        level := 0\n        for _, char := range paren_string\
    \ {\n            if char == '(' {\n                level++\n            } else\
    \ if char == ')' {\n                level--\n            }\n        }\n      \
    \  return level\n    }\n\n    res := make([]int, 0)\n    for i := 0; i < len(paren_string);\
    \ {\n        if paren_string[i] == ' ' {\n            i++\n            continue\n\
    \        }\n        j := match_paren(paren_string[i:], 0)\n        if j != -1\
    \ {\n            res = append(res, get_level(paren_string[i:i+j+1]))\n       \
    \     i += j + 1\n        } else {\n            res = append(res, 0)\n       \
    \     i++\n        }\n    }\n\n    return res\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpxg93f27d_test.go:80: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpxg93f27d_test.go:80: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpxg93f27d_test.go:80:\
    \ expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    parens := make([]int, 0)\n    count := 0\n    for _, c\
    \ := range paren_string {\n        if c == '(' {\n            count += 1\n   \
    \     } else if c == ')' {\n            count -= 1\n        }\n        if c ==\
    \ ' ' {\n            parens = append(parens, count)\n            count = 0\n \
    \       }\n    }\n    parens = append(parens, count)\n    return parens\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpchalry4c_test.go:46: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpchalry4c_test.go:46:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmpchalry4c_test.go:46: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var prev_level int = 0\n    var ans []int = make([]int,\
    \ 0)\n    var level int = 0\n    for _, paren := range paren_string {\n      \
    \  if string(paren) == \"(\" {\n            level += 1\n        } else if string(paren)\
    \ == \")\" {\n            level -= 1\n        } else if string(paren) == \" \"\
    \ {\n            ans = append(ans, level)\n            level = 0\n        }\n\
    \    }\n    return ans\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmrrq7jvh_test.go:14:9: prev_level declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074329
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // TODO\n    return []int{}\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpkip0o2ya_test.go:33: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmpkip0o2ya_test.go:33: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmpkip0o2ya_test.go:33: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_nesting := 0\n    cur_nesting := 0\n    max_nesting_lst\
    \ := []int{}\n    for _, paren := range paren_string {\n        if paren == '('\
    \ {\n            cur_nesting += 1\n        } else if paren == ')' {\n        \
    \    cur_nesting -= 1\n        } else if paren == ' ' {\n            max_nesting_lst\
    \ = append(max_nesting_lst, max_nesting)\n            max_nesting = 0\n      \
    \      cur_nesting = 0\n        }\n        if cur_nesting > max_nesting {\n  \
    \          max_nesting = cur_nesting\n        }\n    }\n    max_nesting_lst =\
    \ append(max_nesting_lst, max_nesting)\n    return max_nesting_lst\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074329
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var stack []int\n\n    // Maximum number of groups are\
    \ 4:\n    parsed_nesting_levels := make([]int, 4)\n    nesting_level := 0\n  \
    \  group_count := 0\n\n    for i := 0; i < len(paren_string); i++ {\n        switch\
    \ paren_string[i] {\n        case '(':\n            stack = append(stack, 0)\n\
    \            nesting_level++\n        case ')':\n            if nesting_level\
    \ == 0 {\n                return nil\n            }\n            stack = stack[:len(stack)-1]\n\
    \            nesting_level--\n        case ' ':\n            if nesting_level\
    \ != 0 {\n                return nil\n            }\n            parsed_nesting_levels[group_count]\
    \ = len(stack)\n            group_count++\n        }\n    }\n\n    if len(stack)\
    \ != 0 {\n        return nil\n    }\n\n    return parsed_nesting_levels\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp5a6zfsfa_test.go:63: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp5a6zfsfa_test.go:63:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmp5a6zfsfa_test.go:63: expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074330
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var output []int\n    var depth int\n    var depth_max\
    \ int\n    var paren_open = rune('(')\n    var paren_close = rune(')')\n    paren_string_runes\
    \ := []rune(paren_string)\n    for _, v := range paren_string_runes {\n      \
    \  if v == paren_open {\n            depth++\n            if depth > depth_max\
    \ {\n                depth_max = depth\n            }\n        } else if v ==\
    \ paren_close {\n            output = append(output, depth_max)\n            depth_max\
    \ = 0\n            depth--\n        }\n    }\n    return output\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpo5qxbkdj_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=3) %!s(int=0) %!s(int=2) %!s(int=2) %!s(int=0)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpo5qxbkdj_test.go:50:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpo5qxbkdj_test.go:50: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074329
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_level_list []int\n    var paren_count, paren_max_count\
    \ int\n\n    for index, char := range paren_string {\n        if char == '(' {\n\
    \            paren_count++\n            paren_max_count = Max(paren_max_count,\
    \ paren_count)\n        } else if char == ')' {\n            paren_count--\n \
    \       } else if char == ' ' {\n            max_level_list = append(max_level_list,\
    \ paren_max_count)\n            paren_count, paren_max_count = 0, 0\n        }\n\
    \        if index == len(paren_string) - 1 {\n            max_level_list = append(max_level_list,\
    \ paren_max_count)\n        }\n    }\n    return max_level_list\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9jupfifg_test.go:20:31: undefined: Max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074329
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var groups []string = make([]string, 0)\n    var empty_string\
    \ string = \"\"\n    for _, char := range paren_string {\n        if char == '\
    \ ' {\n            if empty_string != \"\" {\n                groups = append(groups,\
    \ empty_string)\n                empty_string = \"\"\n            }\n        }\
    \ else {\n            empty_string += string(char)\n        }\n    }\n    if empty_string\
    \ != \"\" {\n        groups = append(groups, empty_string)\n    }\n    var result\
    \ []int = make([]int, len(groups))\n    for i, group := range groups {\n     \
    \   var current_level int = 0\n        var max_level int = 0\n        for _, char\
    \ := range group {\n            if char == '(' {\n                current_level\
    \ += 1\n            } else if char == ')' {\n                current_level -=\
    \ 1\n            }\n            if current_level > max_level {\n             \
    \   max_level = current_level\n            }\n        }\n        result[i] = max_level\n\
    \    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n\
    \  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074330
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    results := make([]int, 0)\n    parens := []rune(paren_string)\n\
    \    result, consumed := get_nested_parens(parens)\n    if consumed < len(parens)\
    \ {\n        fmt.Println(\"Unconsumed Inputs: \", parens[consumed:])\n    }\n\
    \    results = append(results, result)\n    return results\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpax_3nnak_test.go:16:25: undefined: get_nested_parens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074329
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    stack := []int{}\n    results := []int{}\n    for _, paren\
    \ := range paren_string {\n        switch paren {\n        case '(':\n       \
    \     stack = append(stack, 1)\n        case ')':\n            if len(stack) ==\
    \ 0 {\n                // Invalid input\n                stack = append(stack,\
    \ 0)\n            } else {\n                res := 0\n                for _, p\
    \ := range stack {\n                    res += p\n                }\n        \
    \        results = append(results, res)\n                stack = stack[:len(stack)-1]\n\
    \            }\n        case ' ':\n            if len(stack) > 0 {\n         \
    \       res := 0\n                for _, p := range stack {\n                \
    \    res += p\n                }\n                results = append(results, res)\n\
    \            }\n            stack = []int{}\n        }\n    }\n    return results\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp8hz84aze_test.go:61: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp8hz84aze_test.go:61:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp8hz84aze_test.go:61: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074330
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    if len(paren_string) == 0 {\n        return []int{}\n \
    \   }\n    // Use a stack to parse string\n    stack := []int{}\n    max_level\
    \ := []int{}\n    current_level := 0\n    for _, v := range paren_string {\n \
    \       if v == '(' {\n            stack = append(stack, 1)\n            current_level++\n\
    \        } else if v == ')' {\n            stack = stack[:len(stack)-1]\n    \
    \        current_level--\n        } else if v == ' ' {\n            max_level\
    \ = append(max_level, current_level)\n        }\n    }\n    max_level = append(max_level,\
    \ current_level)\n    return max_level\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmplx_rz83s_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmplx_rz83s_test.go:51:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmplx_rz83s_test.go:51: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074330
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    output := make([]int, 0)\n    level := 0\n    for _, c\
    \ := range paren_string {\n        if c == '(' {\n            level += 1\n   \
    \     } else if c == ')' {\n            output = append(output, level)\n     \
    \       level -= 1\n        }\n    }\n    return output\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmptm0wtl43_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmptm0wtl43_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmptm0wtl43_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074331
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // TODO - Add your code here\n    return nil\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpivjwrac1_test.go:33: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmpivjwrac1_test.go:33: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmpivjwrac1_test.go:33: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074331
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var nested_levels []int\n    var current_level int = 0\n\
    \    var max_level int = 0\n    var paren_string_array []rune = []rune(paren_string)\n\
    \    for _, current_rune := range paren_string_array {\n        switch current_rune\
    \ {\n        case '(':\n            current_level += 1\n            if max_level\
    \ < current_level {\n                max_level = current_level\n            }\n\
    \        case ')':\n            if current_level == 0 {\n                // error\n\
    \                panic(\"Invalid input string: extra closing parenthesis.\")\n\
    \            }\n            current_level -= 1\n        case ' ':\n          \
    \  if current_level != 0 {\n                // error\n                panic(\"\
    Invalid input string: unexpected space in the middle of a level.\")\n        \
    \    }\n            nested_levels = append(nested_levels, max_level)\n       \
    \     max_level = 0\n        default:\n            // error\n            panic(\"\
    Invalid input string: unexpected character.\")\n        }\n    }\n    // Add the\
    \ last nested_level\n    nested_levels = append(nested_levels, max_level)\n  \
    \  return nested_levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n \
    \ candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074331
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // Space separated groups of parens\n    paren_groups :=\
    \ []string{}\n    start := 0\n    for i, ch := range paren_string {\n        if\
    \ ch == ' ' {\n            paren_groups = append(paren_groups, paren_string[start:i])\n\
    \            start = i + 1\n        }\n    }\n    if start < len(paren_string)\
    \ {\n        paren_groups = append(paren_groups, paren_string[start:])\n    }\n\
    \n    // For each paren group, calculate the max level of nesting\n    max_level\
    \ := []int{}\n    for _, s := range paren_groups {\n        tmp := 0\n       \
    \ max := 0\n        for _, ch := range s {\n            if ch == '(' {\n     \
    \           tmp += 1\n            } else if ch == ')' {\n                tmp -=\
    \ 1\n            }\n            if tmp > max {\n                max = tmp\n  \
    \          }\n        }\n        max_level = append(max_level, max)\n    }\n \
    \   return max_level\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074331
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    depth := 0\n    depth_list := make([]int, 0)\n    for _,\
    \ c := range paren_string {\n        switch c {\n        case '(':\n         \
    \   depth++\n        case ')':\n            depth_list = append(depth_list, depth)\n\
    \            depth--\n        case ' ':\n            // skip this\n        default:\n\
    \            fmt.Printf(\"Error: unexpected character %v in input string.\\n\"\
    , c)\n        }\n    }\n    return depth_list\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp8uz2bfud_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp8uz2bfud_test.go:47:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp8uz2bfud_test.go:47: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074331
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    levels := make([]int, 0)\n    current_level := 0\n    for\
    \ _, c := range paren_string {\n        switch c {\n        case '(':\n      \
    \      current_level++\n        case ')':\n            current_level--\n     \
    \   default:\n            levels = append(levels, current_level)\n           \
    \ current_level = 0\n        }\n    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpiw4yr0x5_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpiw4yr0x5_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpiw4yr0x5_test.go:45: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074331
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    results := make([]int, 0)\n    nest_level := 0\n    for\
    \ _, char := range paren_string {\n        if char == '(' {\n            nest_level\
    \ += 1\n        } else if char == ')' {\n            nest_level -= 1\n       \
    \ } else if char == ' ' {\n            results = append(results, nest_level)\n\
    \            nest_level = 0\n        }\n    }\n    results = append(results, nest_level)\n\
    \    return results\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpj77vmc4w_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpj77vmc4w_test.go:45:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmpj77vmc4w_test.go:45: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074332
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var nested_levels []int\n    var current_level int\n  \
    \  var max_level int\n    for _, c := range paren_string {\n        if c == '('\
    \ {\n            current_level++\n            if current_level > max_level {\n\
    \                max_level = current_level\n            }\n        } else if c\
    \ == ')' {\n            current_level--\n        } else if c == ' ' {\n      \
    \      nested_levels = append(nested_levels, max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    nested_levels = append(nested_levels,\
    \ max_level)\n    return nested_levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074332
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n    current_level := 0\n    current_group\
    \ := 0\n    var i int\n    for i = 0; i < len(paren_string); i++ {\n        if\
    \ paren_string[i] == '(' {\n            current_level += 1\n        } else if\
    \ paren_string[i] == ')' {\n            current_level -= 1\n        } else if\
    \ paren_string[i] == ' ' {\n            result = append(result, current_level)\n\
    \            current_level = 0\n            current_group += 1\n        }\n  \
    \  }\n    result = append(result, current_level)\n    return result\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmposxeltej_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmposxeltej_test.go:48:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmposxeltej_test.go:48: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074332
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    output := make([]int, 0)\n    token := \"\"\n    for _,\
    \ char := range paren_string {\n        if char == ' ' {\n            if token\
    \ != \"\" {\n                output = append(output, parse_single_group(token))\n\
    \                token = \"\"\n            }\n        } else {\n            token\
    \ += string(char)\n        }\n    }\n    if token != \"\" {\n        output =\
    \ append(output, parse_single_group(token))\n    }\n    return output\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp33ft261_test.go:19:41: undefined: parse_single_group

    /tmp/tmpp33ft261_test.go:27:33: undefined: parse_single_group

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074331
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // The algorithm is to iterate through the string, for\
    \ each character\n    //   if it is '(', increment the level by 1\n    //   if\
    \ it is ')', decrement the level by 1\n    //   if it is ' ', check if it is the\
    \ deepest level of nesting, update the max if it is\n    //\n    // The state\
    \ we keep is the number of levels of nesting we have seen so far.\n    //\n  \
    \  // Another tricky part is that we do not know how many parentheses group we\
    \ have in the input string.\n    // We need to make sure we reset the level to\
    \ 0 whenever we see a space.\n    //\n    // If a parentheses is unmatched, the\
    \ level would go below 0. It is also possible that it never goes back to 0.\n\
    \    //\n    // If we go past the end of the string and level is not 0, it is\
    \ an error.\n\n    max_levels := []int{}\n    level := 0\n    max_level := 0\n\
    \    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '('\
    \ {\n            level += 1\n        } else if paren_string[i] == ')' {\n    \
    \        level -= 1\n        } else if paren_string[i] == ' ' {\n            if\
    \ level > max_level {\n                max_level = level\n            }\n    \
    \        max_levels = append(max_levels, max_level)\n            max_level = 0\n\
    \            level = 0\n        }\n    }\n    if level > max_level {\n       \
    \ max_level = level\n    }\n    max_levels = append(max_levels, max_level)\n \
    \   if level != 0 {\n        fmt.Println(\"Error, string not balanced\")\n   \
    \ }\n    return max_levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n\
    \  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpulmbbdj3_test.go:70: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpulmbbdj3_test.go:70:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmpulmbbdj3_test.go:70: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074332
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    left_paren_counter := 0\n    right_paren_counter := 0\n\
    \    output := []int{}\n    for _, char := range paren_string {\n        // fmt.Println(char)\n\
    \        if char == '(' {\n            left_paren_counter += 1\n        } else\
    \ if char == ')' {\n            right_paren_counter += 1\n        } else if char\
    \ == ' ' {\n            // fmt.Println(\"appending \", left_paren_counter, right_paren_counter)\n\
    \            output = append(output, left_paren_counter)\n            left_paren_counter\
    \ = 0\n            right_paren_counter = 0\n        }\n    }\n    output = append(output,\
    \ left_paren_counter)\n    return output\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpwaecdfw__test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=3) %!s(int=3) %!s(int=1) %!s(int=5)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpwaecdfw__test.go:49:\
    \ expected '[%!s(int=4)]', got '[%!s(int=7)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074332
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_groups := paren_string[1:len(paren_string) - 1]\n\
    \    paren_group_array := make([]string, 0)\n    index := 0\n    for i := 0; i\
    \ < len(paren_groups); i++ {\n        if paren_groups[i] == '(' {\n          \
    \  index = i\n        } else if paren_groups[i] == ')' {\n            paren_group_array\
    \ = append(paren_group_array, paren_groups[index:i + 1])\n        }\n    }\n \
    \   max_nesting_level := make([]int, len(paren_group_array))\n    for i := 0;\
    \ i < len(paren_group_array); i++ {\n        max_nesting_level[i] = parse_max_nesting_level(paren_group_array[i])\n\
    \    }\n    return max_nesting_level\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgz50n258_test.go:26:32: undefined: parse_max_nesting_level

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074331
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var max_depth []int\n    var num_left int\n    for _, char\
    \ := range paren_string {\n        if string(char) == \"(\" {\n            num_left\
    \ += 1\n        } else if string(char) == \")\" {\n            num_left -= 1\n\
    \        } else if string(char) == \" \" {\n            max_depth = append(max_depth,\
    \ num_left)\n            num_left = 0\n        }\n    }\n    return max_depth\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmps4n01qbx_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmps4n01qbx_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmps4n01qbx_test.go:44: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074332
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var res []int\n    num := 0\n    for _, ch := range paren_string\
    \ {\n        if ch == '(' {\n            num++\n        } else if ch == ')' {\n\
    \            res = append(res, num)\n            num--\n        }\n    }\n   \
    \ return res\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate :=\
    \ parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((()))\
    \ () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpb5hlvgoj_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpb5hlvgoj_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpb5hlvgoj_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074332
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_levels := make([]int, 0)\n    level := 0\n    for\
    \ _, c := range paren_string {\n        if c == '(' {\n            level += 1\n\
    \        } else if c == ')' {\n            level -= 1\n        } else if c ==\
    \ ' ' {\n            paren_levels = append(paren_levels, level)\n            level\
    \ = 0\n        }\n    }\n    return paren_levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpbs8njna9_test.go:44: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpbs8njna9_test.go:44: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpbs8njna9_test.go:44: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074332
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_levels := make([]int, 0)\n    max_level := 0\n    level\
    \ := 0\n    for _, paren := range paren_string {\n        if paren == '(' {\n\
    \            level += 1\n            if level > max_level {\n                max_level\
    \ = level\n            }\n        } else if paren == ')' {\n            level\
    \ -= 1\n            if level == 0 {\n                max_levels = append(max_levels,\
    \ max_level)\n                max_level = 0\n            }\n        }\n    }\n\
    \    return max_levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074333
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    results := make([]int, 0)\n    if len(paren_string) ==\
    \ 0 {\n        return results\n    }\n    left_paren_count := 0\n    right_paren_count\
    \ := 0\n    max_depth := 0\n    for _, ch := range paren_string {\n        switch\
    \ ch {\n        case '(':\n            left_paren_count++\n            max_depth\
    \ = max(max_depth, left_paren_count)\n        case ')':\n            right_paren_count++\n\
    \            max_depth = max(max_depth, right_paren_count)\n        case ' ':\n\
    \            // Do nothing\n        default:\n            return []int{}\n   \
    \     }\n        if left_paren_count == right_paren_count {\n            results\
    \ = append(results, max_depth)\n            max_depth = 0\n            left_paren_count\
    \ = 0\n            right_paren_count = 0\n        }\n    }\n    return results\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8wq76stp_test.go:25:25: undefined: max

    /tmp/tmp8wq76stp_test.go:28:25: undefined: max

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074333
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    nest_depth := 0\n    max_nest_depth := 0\n    nest_depth_list\
    \ := []int{}\n    for i := 0; i < len(paren_string); i++ {\n        c := paren_string[i]\n\
    \        if c == '(' {\n            nest_depth++\n            if nest_depth >\
    \ max_nest_depth {\n                max_nest_depth = nest_depth\n            }\n\
    \        } else if c == ')' {\n            nest_depth--\n        } else if c ==\
    \ ' ' {\n            nest_depth_list = append(nest_depth_list, max_nest_depth)\n\
    \            max_nest_depth = 0\n            nest_depth = 0\n        }\n    }\n\
    \    nest_depth_list = append(nest_depth_list, max_nest_depth)\n    return nest_depth_list\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074333
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var results []int\n    var i int\n    var deepest_level\
    \ int\n    var count int\n\n    for i = 0; i < len(paren_string); i++ {\n    \
    \    if paren_string[i] == '(' {\n            count++\n            if count >\
    \ deepest_level {\n                deepest_level = count\n            }\n    \
    \    } else if paren_string[i] == ')' {\n            count--\n        } else if\
    \ paren_string[i] == ' ' {\n            results = append(results, deepest_level)\n\
    \            deepest_level = 0\n            count = 0\n        }\n    }\n    results\
    \ = append(results, deepest_level)\n    return results\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074333
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_level int = 0\n    var\
    \ max_level int = 0\n    for _, paren := range paren_string {\n        if paren\
    \ == '(' {\n            current_level += 1\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if paren == ')' {\n            result = append(result, max_level)\n        \
    \    current_level -= 1\n            max_level = current_level\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n \
    \ candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp87k8hkk1_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp87k8hkk1_test.go:47:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp87k8hkk1_test.go:47: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074333
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    arr := make([]int, len(paren_string))\n    max_l := 0\n\
    \    max_r := 0\n    cnt := 0\n    for i, c := range paren_string {\n        //fmt.Println(i,\
    \ c)\n        if c == '(' {\n            if cnt == 0 {\n                max_l\
    \ = i\n            }\n            cnt++\n        } else if c == ')' {\n      \
    \      if cnt == 1 {\n                max_r = i\n                arr[i] = max_r\
    \ - max_l + 1\n            }\n            cnt--\n        }\n    }\n    //fmt.Println(arr)\n\
    \    return arr\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpo_ui0ntg_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=6)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=6)\
    \ %!s(int=0) %!s(int=0) %!s(int=2) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=10)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpo_ui0ntg_test.go:52:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=2)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=6) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=8)]'\n\
    \    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpo_ui0ntg_test.go:52:\
    \ expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=14)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074334
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    if len(paren_string) == 0 {\n        return []int{}\n \
    \   }\n    var max_nesting_levels []int = make([]int, 0)\n    var paren_stack\
    \ []int = make([]int, 0)\n    for _, c := range paren_string {\n        if c ==\
    \ '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c\
    \ == ')' {\n            if len(paren_stack) > 0 {\n                popped_val\
    \ := paren_stack[len(paren_stack) - 1]\n                paren_stack = paren_stack[:len(paren_stack)\
    \ - 1]\n                if len(paren_stack) > 0 {\n                    paren_stack[len(paren_stack)\
    \ - 1] += popped_val + 1\n                } else {\n                    max_nesting_levels\
    \ = append(max_nesting_levels, popped_val + 1)\n                }\n          \
    \  }\n        } else if c == ' ' {\n            // Do nothing\n        } else\
    \ {\n            panic(fmt.Sprintf(\"Unrecognized character %s\", string(c)))\n\
    \        }\n    }\n    return max_nesting_levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpmeo6dayn_test.go:56: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=3) %!s(int=3) %!s(int=1) %!s(int=5)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpmeo6dayn_test.go:56:\
    \ expected '[%!s(int=4)]', got '[%!s(int=7)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074335
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    group_open_close_levels := make([]int, 0)\n    group_open_close_cnt\
    \ := 0\n    max_open_close_level := 0\n    for _, char := range paren_string {\n\
    \        if char == '(' {\n            group_open_close_cnt++\n            if\
    \ group_open_close_cnt > max_open_close_level {\n                max_open_close_level\
    \ = group_open_close_cnt\n            }\n        } else if char == ')' {\n   \
    \         group_open_close_cnt--\n        } else if char == ' ' {\n          \
    \  group_open_close_levels = append(group_open_close_levels, max_open_close_level)\n\
    \            max_open_close_level = 0\n            group_open_close_cnt = 0\n\
    \        }\n    }\n    group_open_close_levels = append(group_open_close_levels,\
    \ max_open_close_level)\n    return group_open_close_levels\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074336
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // TODO: Implement this\n    return []int{}\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpgvc9wpf6_test.go:33: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmpgvc9wpf6_test.go:33: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmpgvc9wpf6_test.go:33: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074336
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var open_stack []int\n\n    for _,\
    \ c := range paren_string {\n        if c == '(' {\n            open_stack = append(open_stack,\
    \ 0)\n        } else if c == ')' {\n            if len(open_stack) == 0 {\n  \
    \              result = append(result, 0)\n            } else {\n            \
    \    var tmp int\n                for i := 0; i < len(open_stack); i++ {\n   \
    \                 tmp += open_stack[i]\n                }\n                result\
    \ = append(result, tmp)\n                open_stack = open_stack[:len(open_stack)-1]\n\
    \            }\n        } else if c == ' ' {\n            if len(open_stack) ==\
    \ 0 {\n                result = append(result, 0)\n            } else {\n    \
    \            var tmp int\n                for i := 0; i < len(open_stack); i++\
    \ {\n                    tmp += open_stack[i]\n                }\n           \
    \     open_stack = open_stack[:len(open_stack)-1]\n                open_stack\
    \ = append(open_stack, tmp)\n            }\n        }\n    }\n\n    return result\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp15o8qnzv_test.go:63: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmp15o8qnzv_test.go:63: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmp15o8qnzv_test.go:63:\
    \ expected '[%!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074336
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_level := 0\n    cur_level := 0\n    var ret []int\n\
    \    for _, c := range paren_string {\n        switch string(c) {\n        case\
    \ \"(\":\n            cur_level += 1\n            if cur_level > max_level {\n\
    \                max_level = cur_level\n            }\n        case \")\":\n \
    \           if cur_level == max_level {\n                ret = append(ret, max_level)\n\
    \                max_level = 0\n                cur_level = 0\n            } else\
    \ {\n                cur_level -= 1\n            }\n        }\n    }\n    return\
    \ ret\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp2ok3mkto_test.go:52: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=0)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp2ok3mkto_test.go:52:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp2ok3mkto_test.go:52: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=2)\
    \ %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074336
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    depth := 0\n    max_depths := []int{}\n    for _, curr_paren\
    \ := range paren_string {\n        if curr_paren == '(' {\n            depth +=\
    \ 1\n        } else if curr_paren == ')' {\n            depth -= 1\n        }\
    \ else if curr_paren == ' ' {\n            max_depths = append(max_depths, depth)\n\
    \            depth = 0\n        }\n    }\n    max_depths = append(max_depths,\
    \ depth)\n    return max_depths\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpq4s7h46e_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpq4s7h46e_test.go:45:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmpq4s7h46e_test.go:45: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074336
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    all_nesting_levels := make([]int, 0)\n    for _, paren_substring\
    \ := range (paren_string) {\n        max_level := 0\n        current_level :=\
    \ 0\n        for _, paren := range (paren_substring) {\n            switch paren\
    \ {\n            case '(':\n                current_level += 1\n            case\
    \ ')':\n                current_level -= 1\n            }\n            if current_level\
    \ > max_level {\n                max_level = current_level\n            }\n  \
    \      }\n        all_nesting_levels = append(all_nesting_levels, max_level)\n\
    \    }\n    return all_nesting_levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzo0lyl_5_test.go:18:31: cannot range over (paren_substring) (variable
    of type rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074335
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n    n := len(paren_string)\n\
    \    lc := 0\n    rc := 0\n    level := 0\n    for i := 0; i < n; i++ {\n    \
    \    c := string(paren_string[i])\n        if c == \"(\" {\n            lc++\n\
    \            level++\n        } else if c == \")\" {\n            rc++\n     \
    \       level--\n        } else if c == \" \" {\n            result = append(result,\
    \ level)\n            lc = 0\n            rc = 0\n            level = 0\n    \
    \    }\n    }\n    result = append(result, level)\n    return result\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpe9o5mudq_test.go:53: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpe9o5mudq_test.go:53:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmpe9o5mudq_test.go:53: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074336
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var count []int\n    if (paren_string == \"\") {\n    \
    \    return count\n    }\n    for _, paren_group := range paren_string {\n   \
    \     if (paren_group == '(') {\n            count = append(count, 1)\n      \
    \  } else if (paren_group == ')') {\n            count = append(count, -1)\n \
    \       }\n    }\n    return count\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpe0y_4q_n_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=1) %!s(int=1) %!s(int=-1) %!s(int=1) %!s(int=-1)\
    \ %!s(int=-1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=-1) %!s(int=-1) %!s(int=-1)\
    \ %!s(int=1) %!s(int=-1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=-1) %!s(int=-1)\
    \ %!s(int=1) %!s(int=-1) %!s(int=1) %!s(int=-1) %!s(int=-1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpe0y_4q_n_test.go:43: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=-1) %!s(int=1) %!s(int=1) %!s(int=-1)\
    \ %!s(int=-1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=-1) %!s(int=-1) %!s(int=-1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=-1) %!s(int=-1) %!s(int=-1)\
    \ %!s(int=-1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n \
    \       tmpe0y_4q_n_test.go:43: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=-1) %!s(int=1) %!s(int=1) %!s(int=-1) %!s(int=-1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=-1) %!s(int=-1) %!s(int=-1) %!s(int=-1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074336
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var paren_string_split []string = strings.Split(paren_string,\
    \ \" \")\n    var max_level []int\n    for i := 0; i < len(paren_string_split);\
    \ i++ {\n        var max_level_i int = 0\n        var num_left_paren int = 0\n\
    \        var num_right_paren int = 0\n        for j := 0; j < len(paren_string_split[i]);\
    \ j++ {\n            if paren_string_split[i][j] == '(' {\n                num_left_paren\
    \ += 1\n                if num_left_paren > max_level_i {\n                  \
    \  max_level_i = num_left_paren\n                }\n            } else if paren_string_split[i][j]\
    \ == ')' {\n                num_right_paren += 1\n                if num_right_paren\
    \ > num_left_paren {\n                    max_level_i = 0\n                  \
    \  break\n                }\n            }\n        }\n        max_level = append(max_level,\
    \ max_level_i)\n    }\n    return max_level\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2z_oxc0p_test.go:14:39: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074336
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_levels := make([]int, 0)\n    paren_level := 0\n\
    \    for _, r := range paren_string {\n        switch r {\n        case '(':\n\
    \            paren_level += 1\n        case ')':\n            paren_level -= 1\n\
    \        case ' ':\n            paren_levels = append(paren_levels, paren_level)\n\
    \            paren_level = 0\n        }\n    }\n    return paren_levels\n}\n\n\
    func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmppekvfz6y_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmppekvfz6y_test.go:45: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmppekvfz6y_test.go:45: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074336
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    return nil\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpe7fjr9ej_test.go:32: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmpe7fjr9ej_test.go:32: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmpe7fjr9ej_test.go:32: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var nested_parens []int\n    paren_counts := make(map[rune]int)\n\
    \    for _, r := range paren_string {\n        if r == '(' {\n            paren_counts[r]\
    \ += 1\n        } else if r == ')' {\n            paren_counts[r] += 1\n     \
    \   }\n    }\n    return nested_parens\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmprho09puf_test.go:41: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n\
    \        tmprho09puf_test.go:41: expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]',\
    \ got '[]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n      \
    \  tmprho09puf_test.go:41: expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074337
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n    start := 0\n    end := 0\n\
    \    current_level := 0\n    max_level := 0\n    for end < len(paren_string) {\n\
    \        //fmt.Println(start, end, max_level, current_level)\n        if paren_string[end]\
    \ == '(' {\n            current_level += 1\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if paren_string[end] == ')' {\n            current_level -= 1\n        } else\
    \ if paren_string[end] == ' ' {\n            result = append(result, max_level)\n\
    \            current_level = 0\n            max_level = 0\n            start =\
    \ end + 1\n        }\n        end += 1\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6cvaf688_test.go:15:5: start declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074336
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    depth := 0\n    max_depth := 0\n    depth_arr := []int{}\n\
    \    for i := 0; i < len(paren_string); i++ {\n        switch string(paren_string[i])\
    \ {\n        case \"(\":\n            depth += 1\n            if depth > max_depth\
    \ {\n                max_depth = depth\n            }\n        case \")\":\n \
    \           depth -= 1\n        case \" \":\n            if depth == 0 {\n   \
    \             depth_arr = append(depth_arr, max_depth)\n                max_depth\
    \ = 0\n            }\n        }\n    }\n    depth_arr = append(depth_arr, max_depth)\n\
    \    return depth_arr\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var stack []int\n    var max_stack []int\n    var deepest_level\
    \ []int\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i]\
    \ == '(' {\n            stack = append(stack, 1)\n        } else if paren_string[i]\
    \ == ')' {\n            if len(stack) > 0 {\n                stack = stack[0:len(stack)-1]\n\
    \            }\n        } else if paren_string[i] == ' ' {\n            max_stack\
    \ = append(max_stack, len(stack))\n        }\n    }\n    max_stack = append(max_stack,\
    \ len(stack))\n    var max int\n    for i := 0; i < len(max_stack); i++ {\n  \
    \      if max_stack[i] > max {\n            max = max_stack[i]\n        }\n  \
    \  }\n    for i := 0; i < len(max_stack); i++ {\n        if max_stack[i] == max\
    \ {\n            deepest_level = append(deepest_level, max)\n        } else {\n\
    \            deepest_level = append(deepest_level, max_stack[i])\n        }\n\
    \    }\n    return deepest_level\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpmuw2sz9__test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpmuw2sz9__test.go:60:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmpmuw2sz9__test.go:60: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    open_count := 0\n    depths := []int{}\n    for _, c :=\
    \ range paren_string {\n        switch c {\n        case '(':\n            open_count++\n\
    \        case ')':\n            depths = append(depths, open_count)\n        \
    \    open_count--\n        }\n    }\n    return depths\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpaepf2q90_test.go:43: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpaepf2q90_test.go:43:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpaepf2q90_test.go:43: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var paren_stack []rune\n    paren_string\
    \ += \" \"\n    var counter int\n    for _, rune_value := range paren_string {\n\
    \        if rune_value == '(' {\n            paren_stack = append(paren_stack,\
    \ rune_value)\n        } else if rune_value == ')' {\n            paren_stack\
    \ = paren_stack[:len(paren_stack)-1]\n            counter += 1\n        } else\
    \ if rune_value == ' ' {\n            result = append(result, counter)\n     \
    \       counter = 0\n        }\n    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpg3tuuead_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=3) %!s(int=3) %!s(int=1) %!s(int=5)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpg3tuuead_test.go:47:\
    \ expected '[%!s(int=4)]', got '[%!s(int=7)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var paren_count []int = make([]int, 0)\n    var temp_count\
    \ int = 0\n    for _, v := range paren_string {\n        if v == '(' {\n     \
    \       temp_count += 1\n        } else if v == ')' {\n            paren_count\
    \ = append(paren_count, temp_count)\n            temp_count = 0\n        }\n \
    \   }\n    return paren_count\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp50wf8x9a_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=1) %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0)\
    \ %!s(int=1) %!s(int=3) %!s(int=0) %!s(int=1) %!s(int=1) %!s(int=0)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp50wf8x9a_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp50wf8x9a_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=2)\
    \ %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074337
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n    for _, paren := range paren_string\
    \ {\n        max_nesting := -1\n        var last byte\n        nesting := 0\n\
    \        for _, c := range paren {\n            if c == '(' {\n              \
    \  if last == ')' {\n                    nesting = 1\n                } else {\n\
    \                    nesting++\n                }\n            } else if c ==\
    \ ')' {\n                nesting--\n            }\n\n            if nesting >\
    \ max_nesting {\n                max_nesting = nesting\n            }\n      \
    \      last = byte(c)\n        }\n        result = append(result, max_nesting)\n\
    \    }\n    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n\
    \  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4nselb9i_test.go:19:27: cannot range over paren (variable of type rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074337
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    paren_strings := strings.Split(paren_string, \" \")\n \
    \   max_nested_level := make([]int, len(paren_strings))\n    for i, paren_str\
    \ := range paren_strings {\n        depth := 0\n        max_depth := 0\n     \
    \   for _, char := range paren_str {\n            if char == '(' {\n         \
    \       depth += 1\n            } else if char == ')' {\n                depth\
    \ -= 1\n            }\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        }\n        max_nested_level[i] = max_depth\n\
    \    }\n    return max_nested_level\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoln8b56f_test.go:14:22: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_depth := make([]int, 0)\n    stack := make([]int, 0)\n\
    \    for _, character := range paren_string {\n        if character == '(' {\n\
    \            stack = append(stack, 0)\n        } else if character == ')' {\n\
    \            if len(stack) > 0 {\n                temp := stack[len(stack)-1]\n\
    \                stack = stack[:len(stack)-1]\n                if len(stack) >\
    \ 0 {\n                    stack[len(stack)-1] += temp + 1\n                }\
    \ else {\n                    max_depth = append(max_depth, temp + 1)\n      \
    \          }\n            }\n        }\n    }\n    return max_depth\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpeu564xhy_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=3) %!s(int=3) %!s(int=1) %!s(int=5)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpeu564xhy_test.go:49:\
    \ expected '[%!s(int=4)]', got '[%!s(int=7)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074337
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    result := make([]int, 0)\n    depth := 0\n    group_depth\
    \ := 0\n    var c rune\n    for _, c = range paren_string {\n        switch c\
    \ {\n        case '(':\n            depth += 1\n            if depth > group_depth\
    \ {\n                group_depth = depth\n            }\n        case ')':\n \
    \           depth -= 1\n        case ' ':\n            if depth == 0 {\n     \
    \           result = append(result, group_depth)\n                group_depth\
    \ = 0\n            }\n        }\n    }\n    result = append(result, group_depth)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074338
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_levels := make([]int, 0)\n    cur_max := 0\n    cur_level\
    \ := 0\n    for _, ch := range paren_string {\n        if ch == '(' {\n      \
    \      cur_level += 1\n            if cur_level > cur_max {\n                cur_max\
    \ = cur_level\n            }\n        } else if ch == ')' {\n            cur_level\
    \ -= 1\n        } else if ch == ' ' {\n            max_levels = append(max_levels,\
    \ cur_max)\n            cur_max = 0\n            cur_level = 0\n        }\n  \
    \  }\n    max_levels = append(max_levels, cur_max)\n    return max_levels\n}\n\
    \nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_depth := 0\n    current_depth := 0\n    depths := []int{}\n\
    \    for _, paren := range paren_string {\n        switch paren {\n        case\
    \ '(':\n            current_depth += 1\n            if current_depth > max_depth\
    \ {\n                max_depth = current_depth\n            }\n        case ')':\n\
    \            if current_depth == 0 {\n                panic(\"Mismatched parentheses\"\
    )\n            }\n            if current_depth == max_depth {\n              \
    \  depths = append(depths, max_depth)\n                max_depth = 0\n       \
    \     }\n            current_depth -= 1\n        case ' ':\n            continue\n\
    \        default:\n            panic(\"Only parentheses and spaces allowed\")\n\
    \        }\n    }\n    if current_depth != 0 {\n        panic(\"Mismatched parentheses\"\
    )\n    }\n    return depths\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n\
    \  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmphv7zykor_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=3) %!s(int=1) %!s(int=3) %!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmphv7zykor_test.go:60: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=4)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_level_list := make([]int, 0)\n    current_level :=\
    \ 0\n    max_level := 0\n    for _, ch := range paren_string {\n        if ch\
    \ == '(' {\n            current_level++\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if ch == ')' {\n            current_level--\n        } else if ch == ' ' {\n\
    \            max_level_list = append(max_level_list, max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    return max_level_list\n\
    }\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpsgnfdwcv_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=3) %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpsgnfdwcv_test.go:49: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpsgnfdwcv_test.go:49: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var counter int = 0\n    var deepest_level []int = make([]int,\
    \ 0)\n    for i := 0; i < len(paren_string); i++ {\n        if string(paren_string[i])\
    \ == \"(\" {\n            counter++\n        } else if string(paren_string[i])\
    \ == \")\" {\n            counter--\n        } else if string(paren_string[i])\
    \ == \" \" {\n            deepest_level = append(deepest_level, counter)\n   \
    \         counter = 0\n        }\n    }\n    deepest_level = append(deepest_level,\
    \ counter)\n    return deepest_level\n}\n\nfunc TestParse_Nested_Parens(t *testing.T)\
    \ {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpfvxd001b_test.go:45: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpfvxd001b_test.go:45:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=0) %!s(int=0)\
    \ %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n\
    \        tmpfvxd001b_test.go:45: expected '[%!s(int=4)]', got '[%!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var prev_level, level int\n    paren_levels := make([]int,\
    \ 0)\n    for _, v := range paren_string {\n        if v == '(' {\n          \
    \  level++\n        } else if v == ')' {\n            if level == 0 {\n      \
    \          panic(\"Extra parentheses\")\n            }\n            if level ==\
    \ prev_level {\n                paren_levels = append(paren_levels, level)\n \
    \           }\n            prev_level = level\n            level--\n        }\n\
    \    }\n    if level != 0 {\n        panic(\"Extra parentheses\")\n    }\n   \
    \ return paren_levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpv4sxhkvc_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=1) %!s(int=2) %!s(int=2)]'\n    --- FAIL:\
    \ TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpv4sxhkvc_test.go:51:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n        tmpv4sxhkvc_test.go:51:\
    \ expected '[%!s(int=4)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var stack []byte\n    var result []int\n    level := 0\n\
    \    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '('\
    \ {\n            level++\n            stack = append(stack, '(')\n        } else\
    \ if paren_string[i] == ')' {\n            level--\n            stack = stack[:len(stack)-1]\n\
    \        } else if paren_string[i] == ' ' {\n            result = append(result,\
    \ level)\n            level = 0\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpq38ix416_test.go:47: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__1\
    \ (0.00s)\n        tmpq38ix416_test.go:47: expected '[%!s(int=1) %!s(int=2) %!s(int=3)\
    \ %!s(int=4)]', got '[%!s(int=0) %!s(int=0) %!s(int=0)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2\
    \ (0.00s)\n        tmpq38ix416_test.go:47: expected '[%!s(int=4)]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    var current_count int\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            current_count\
    \ += 1\n        } else if char == ')' {\n            result = append(result, current_count)\n\
    \            current_count -= 1\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmpvbl8fsod_test.go:42: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=2) %!s(int=2) %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=2) %!s(int=2) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmpvbl8fsod_test.go:42:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=2)\
    \ %!s(int=1) %!s(int=3) %!s(int=2) %!s(int=1) %!s(int=4) %!s(int=3) %!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmpvbl8fsod_test.go:42: expected '[%!s(int=4)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=2) %!s(int=4) %!s(int=3) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    nest_stack := []int{}\n    nest_max := []int{}\n    for\
    \ _, paren := range paren_string {\n        if paren == '(' {\n            nest_stack\
    \ = append(nest_stack, 0)\n        } else if paren == ')' {\n            if len(nest_stack)\
    \ > 0 {\n                nest_max = append(nest_max, nest_stack[len(nest_stack)-1]+1)\n\
    \                nest_stack = nest_stack[:len(nest_stack)-1]\n            }\n\
    \        } else if paren == ' ' {\n            continue\n        } else {\n  \
    \          fmt.Println(\"Unexpected character:\", paren)\n        }\n    }\n \
    \   return nest_max\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestParse_Nested_Parens (0.00s)\n    --- FAIL: TestParse_Nested_Parens/test_num__0\
    \ (0.00s)\n        tmp_h3wt6fh_test.go:48: expected '[%!s(int=2) %!s(int=3) %!s(int=1)\
    \ %!s(int=3)]', got '[%!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\n    ---\
    \ FAIL: TestParse_Nested_Parens/test_num__1 (0.00s)\n        tmp_h3wt6fh_test.go:48:\
    \ expected '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=4)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)\
    \ %!s(int=1)]'\n    --- FAIL: TestParse_Nested_Parens/test_num__2 (0.00s)\n  \
    \      tmp_h3wt6fh_test.go:48: expected '[%!s(int=4)]', got '[%!s(int=1) %!s(int=1)\
    \ %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074338
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    var result []int\n    current := 0\n    max := 0\n    for\
    \ _, ch := range paren_string {\n        if ch == '(' {\n            current +=\
    \ 1\n            if current > max {\n                max = current\n         \
    \   }\n        } else if ch == ')' {\n            current -= 1\n        } else\
    \ if ch == ' ' {\n            result = append(result, max)\n            max =\
    \ 0\n            current = 0\n        }\n    }\n    result = append(result, max)\n\
    \    return result\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate\
    \ := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074338
- exit_code: 2
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    str_arr := strings.Split(paren_string, \" \")\n    levels\
    \ := make([]int, len(str_arr))\n    for i, str := range str_arr {\n        if\
    \ len(str) == 0 {\n            levels[i] = 0\n            continue\n        }\n\
    \        level := 0\n        max := 0\n        for _, ch := range str {\n    \
    \        if ch == '(' {\n                level++\n            } else if ch ==\
    \ ')' {\n                level--\n            }\n            if level > max {\n\
    \                max = level\n            }\n        }\n        levels[i] = max\n\
    \    }\n    return levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n\
    \  candidate := parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual:\
    \ candidate(\"() (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n   \
    \  { actual: candidate(\"(()(())((())))\"), expected: []int{4} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt4bkqzvb_test.go:14:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    // This stack is used to store the deepest level of nesting\
    \ so far.\n    curr_max_nesting := make([]int, 0)\n    // This stack is used to\
    \ keep track of the current level of nesting.\n    curr_nesting := make([]int,\
    \ 0)\n    // This stack is used to keep track of the number of open parentheses.\n\
    \    open_paren_num := make([]int, 0)\n    for _, c := range paren_string {\n\
    \        if c == '(' {\n            // Push an open paren to the stack.\n    \
    \        open_paren_num = append(open_paren_num, 1)\n            // Update the\
    \ current level of nesting.\n            curr_nesting = append(curr_nesting, open_paren_num[len(open_paren_num)-1])\n\
    \            // Update the deepest level of nesting so far.\n            if len(curr_max_nesting)\
    \ == 0 {\n                curr_max_nesting = append(curr_max_nesting, curr_nesting[len(curr_nesting)-1])\n\
    \            } else {\n                curr_max_nesting = append(curr_max_nesting,\n\
    \                    max(curr_max_nesting[len(curr_max_nesting)-1], curr_nesting[len(curr_nesting)-1]))\n\
    \            }\n        } else if c == ')' {\n            // Pop the stack of\
    \ open parens.\n            open_paren_num = open_paren_num[:len(open_paren_num)-1]\n\
    \            // Pop the stack of current nesting.\n            curr_nesting =\
    \ curr_nesting[:len(curr_nesting)-1]\n            // Pop the stack of deepest\
    \ nesting so far.\n            curr_max_nesting = curr_max_nesting[:len(curr_max_nesting)-1]\n\
    \        } else if c == ' ' {\n            // If we meet a space, we should push\
    \ the deepest level of nesting so far to the final result.\n            curr_nesting\
    \ = make([]int, 0)\n            curr_max_nesting = append(curr\nfunc TestParse_Nested_Parens(t\
    \ *testing.T) {\n  candidate := parse_nested_parens\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []int{2, 3,\
    \ 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected: []int{1,\
    \ 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"), expected: []int{4}\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpksffolbx_test.go:43:43: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074338
- exit_code: 0
  program: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string represented multiple groups\
    \ for nested parentheses separated by spaces.\n// For each of the group, output\
    \ the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two\
    \ levels of nesting while ((())) has three.\n// >>> parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\")\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string\
    \ string) []int {\n    max_levels := []int{}\n    max_level := 0\n    bracket_count\
    \ := 0\n    for i := 0; i < len(paren_string); i++ {\n        ch := paren_string[i]\n\
    \        if ch == '(' {\n            bracket_count++\n            if bracket_count\
    \ > max_level {\n                max_level = bracket_count\n            }\n  \
    \      } else if ch == ')' {\n            bracket_count--\n        } else if ch\
    \ == ' ' {\n            max_levels = append(max_levels, max_level)\n         \
    \   max_level = 0\n            bracket_count = 0\n        }\n    }\n    if max_level\
    \ > 0 {\n        max_levels = append(max_levels, max_level)\n    }\n    return\
    \ max_levels\n}\n\nfunc TestParse_Nested_Parens(t *testing.T) {\n  candidate :=\
    \ parse_nested_parens\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()()) ((()))\
    \ () ((())()())\"), expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074339
