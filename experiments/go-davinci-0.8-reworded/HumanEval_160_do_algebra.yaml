name: HumanEval_160_do_algebra
language: go_test.go
prompt: "package do_algebra_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // Given two lists operator, and operand. The first list has basic algebra operations,\
  \ and \n// the second list is a list of integers. Use the two given lists to build\
  \ the algebric \n// expression and return the evaluation of this expression.\n//\
  \ The basic algebra operations:\n// Addition ( + ) \n// Subtraction ( - ) \n// Multiplication\
  \ ( * ) \n// Floor division ( // ) \n// Exponentiation ( ** ) \n// Example:\n//\
  \ operator['+', '*', '-']\n// list = [2, 3, 4, 5]\n// result = 2 + 3 * 4 - 5\n//\
  \ => result = 9\n// Note:\n// The length of operator list is equal to the length\
  \ of operand list minus one.\n// Operand is a list of of non-negative integers.\n\
  // Operator list has at least one operator, and operand list has at least two operands.\n\
  func do_algebra(operator []string, operand []int) int {\n"
tests: "func TestDo_Algebra(t *testing.T) {\n  candidate := do_algebra\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate([]string{\"**\", \"*\", \"+\"}, []int{2, 3,\
  \ 4, 5}), expected: 37 },\n     { actual: candidate([]string{\"+\", \"*\", \"-\"\
  }, []int{2, 3, 4, 5}), expected: 9 },\n     { actual: candidate([]string{\"//\"\
  , \"*\"}, []int{7, 3, 4}), expected: 8 },\n   }\n\n\tfor i, tc := range tests {\n\
  \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
  %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
  \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    var (\n        result int\n        op string\n    )\n    for index,\
    \ op := range operator {\n        if index == 0 {\n            result = operand[index]\n\
    \        }\n        switch op {\n        case \"+\":\n            result += operand[index\
    \ + 1]\n        case \"-\":\n            result -= operand[index + 1]\n      \
    \  case \"*\":\n            result *= operand[index + 1]\n        case \"//\"\
    :\n            result /= operand[index + 1]\n        case \"**\":\n          \
    \  result = int(math.Pow(float64(result), float64(operand[index + 1])))\n    \
    \    }\n    }\n    return result\n}\n", "    var result int\n    result = operand[0]\n\
    \    for i := 0; i < len(operator); i++ {\n        switch operator[i] {\n    \
    \    case \"+\":\n            result += operand[i+1]\n        case \"-\":\n  \
    \          result -= operand[i+1]\n        case \"*\":\n            result *=\
    \ operand[i+1]\n        case \"//\":\n            result /= operand[i+1]\n   \
    \     case \"**\":\n            result = int(math.Pow(float64(result), float64(operand[i+1])))\n\
    \        }\n    }\n    return result\n}\n", "    var result int\n    var operatorIndex\
    \ = 0\n    var operatorValue string\n\n    var operandIndex = 0\n    var operandValue\
    \ int\n\n    var tempIndex = 0\n    var tempValue int\n\n    var exponetiationOperatorIndex\
    \ int\n    var base int\n    var exponetiation int\n\n    var exponetiationResult\
    \ int\n\n    for _, value := range operator {\n        switch value {\n      \
    \  case \"**\":\n            exponetiationOperatorIndex = operatorIndex\n    \
    \        base = operand[tempIndex]\n            exponetiation = operand[tempIndex\
    \ + 1]\n            if exponetiationOperatorIndex == 0 {\n                result\
    \ = doExponetiation(base, exponetiation)\n            } else {\n             \
    \   if operatorValue == \"**\" {\n                    exponetiationResult = doExponetiation(base,\
    \ exponetiation)\n                    operand[tempIndex] = exponetiationResult\n\
    \                } else {\n                    result = doExponetiation(base,\
    \ exponetiation)\n                }\n            }\n        case \"*\":\n    \
    \        operatorValue = value\n            operandValue = operand[tempIndex]\n\
    \            operandIndex = tempIndex + 1\n            if operatorIndex == 0 {\n\
    \                result = doMultiplication(operandValue, operand[operandIndex])\n\
    \            } else {\n                if operatorValue == \"**\" {\n        \
    \            tempValue = doMultiplication(operandValue, operand[operandIndex])\n\
    \                    operand[tempIndex] = tempValue\n                } else {\n\
    \                    result = doMultiplication(operandValue, operand[operandIndex])\n\
    \                }\n            }\n        case \"//\":\n            operatorValue\
    \ = value\n            operandValue = operand[tempIndex]\n            operandIndex\
    \ = tempIndex + 1\n            if operatorIndex == 0 {\n                result\
    \ = doFloorDivision(operandValue, operand[operandIndex])\n            } else {\n\
    \                if operatorValue == \"**\" {\n                    tempValue =\
    \ doFloorDivision(operandValue, operand[operandIndex])\n                    operand[tempIndex]\
    \ = tempValue\n                } else {\n                    result = doFloorDivision(operandValue,\
    \ operand[operandIndex])\n                }\n", "    result := operand[0]\n  \
    \  for i := 1; i < len(operand); i++ {\n        op := operator[i-1]\n        if\
    \ op == \"+\" {\n            result += operand[i]\n        } else if op == \"\
    -\" {\n            result -= operand[i]\n        } else if op == \"*\" {\n   \
    \         result *= operand[i]\n        } else if op == \"//\" {\n           \
    \ result /= operand[i]\n        } else if op == \"**\" {\n            result =\
    \ result ^ operand[i]\n        }\n    }\n    return result\n}\n", "    //var result\
    \ int\n    //for i := range operator {\n    //    if i == 0 {\n    //        result\
    \ = operand[i]\n    //    }\n    //    result = eval(result, operator[i], operand[i\
    \ + 1])\n    //}\n    //return result\n    var result int\n    for i := range\
    \ operator {\n        // TODO : change to the first operand.\n        if i ==\
    \ 0 {\n            result = operand[i]\n        }\n        result = eval(result,\
    \ operator[i], operand[i + 1])\n    }\n    return result\n}\n", "    r := operand[0]\n\
    \    for i := 0; i < len(operator); i++ {\n        switch operator[i] {\n    \
    \    case \"+\":\n            r += operand[i+1]\n        case \"-\":\n       \
    \     r -= operand[i+1]\n        case \"*\":\n            r *= operand[i+1]\n\
    \        case \"//\":\n            r /= operand[i+1]\n        case \"**\":\n \
    \           r = int(math.Pow(float64(r), float64(operand[i+1])))\n        }\n\
    \    }\n    return r\n}\n", "    // TODO: implement this function\n    //panic(\"\
    please implement this function\")\n    if len(operator) == 1 {\n        return\
    \ operand[0]\n    }\n    var temp int\n    for i := 0; i < len(operator); i++\
    \ {\n        switch operator[i] {\n            case \"+\":\n                temp\
    \ = operand[i] + operand[i+1]\n                operand[i+1] = temp\n         \
    \   case \"-\":\n                temp = operand[i] - operand[i+1]\n          \
    \      operand[i+1] = temp\n            case \"*\":\n                temp = operand[i]\
    \ * operand[i+1]\n                operand[i+1] = temp\n            case \"//\"\
    :\n                temp = operand[i] / operand[i+1]\n                operand[i+1]\
    \ = temp\n            case \"**\":\n                temp = operand[i] ^ operand[i+1]\n\
    \                operand[i+1] = temp\n        }\n    }\n    return operand[len(operand)-1]\n\
    }\n", "    // Write your code here\n    return 0\n}\n", "    result := operand[0]\n\
    \    for i := 1; i < len(operand); i++ {\n        switch operator[i-1] {\n   \
    \     case \"+\":\n            result += operand[i]\n        case \"-\":\n   \
    \         result -= operand[i]\n        case \"*\":\n            result *= operand[i]\n\
    \        case \"//\":\n            result /= operand[i]\n        case \"**\":\n\
    \            result = pow(result, operand[i])\n        }\n    }\n    return result\n\
    }\n", "    result := operand[0]\n    for i := 0; i < len(operator); i++ {\n  \
    \      switch operator[i] {\n        case \"+\":\n            result += operand[i+1]\n\
    \        case \"-\":\n            result -= operand[i+1]\n        case \"*\":\n\
    \            result *= operand[i+1]\n        case \"//\":\n            result\
    \ /= operand[i+1]\n        case \"**\":\n            result = result ^ operand[i+1]\n\
    \        }\n    }\n    return result\n}\n", "    // TODO: implement the function\n\
    \n    return -1\n}\n", "    // write your code here\n    return 0\n}\n", "   \
    \ // TODO: Implement me\n    operand2 := make([]int, len(operand))\n    copy(operand2,\
    \ operand)\n    for _, v := range operator {\n        if v == \"*\" {\n      \
    \      operand2[1] = operand2[0] * operand2[1]\n            operand2 = append(operand2[:0],\
    \ operand2[1:]...)\n        } else if v == \"-\" {\n            operand2[1] =\
    \ operand2[0] - operand2[1]\n            operand2 = append(operand2[:0], operand2[1:]...)\n\
    \        } else if v == \"+\" {\n            operand2[1] = operand2[0] + operand2[1]\n\
    \            operand2 = append(operand2[:0], operand2[1:]...)\n        } else\
    \ if v == \"//\" {\n            operand2[1] = operand2[0] / operand2[1]\n    \
    \        operand2 = append(operand2[:0], operand2[1:]...)\n        } else if v\
    \ == \"**\" {\n            operand2[1] = operand2[0] ^ operand2[1]\n         \
    \   operand2 = append(operand2[:0], operand2[1:]...)\n        }\n    }\n    return\
    \ operand2[0]\n}\n", "    // Write your code here\n    return 0\n}\n", "    n\
    \ := len(operator)\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n\
    \        return operand[1]\n    }\n    m := len(operand)\n    if m == 0 {\n  \
    \      return 0\n    }\n    if m == 1 {\n        return operand[0]\n    }\n  \
    \  expression := \"(\" + fmt.Sprintf(\"%d %s %d\", operand[0], operator[0], operand[1])\n\
    \    for i := 1; i < n; i++ {\n        expression += fmt.Sprintf(\" %s %d\", operator[i],\
    \ operand[i+1])\n    }\n    expression += \")\"\n    fmt.Println(expression)\n\
    \    var result int\n    fmt.Sscanf(expression, \"%d\", &result)\n    return result\n\
    }\n", "    var result int = operand[0]\n    for i := 0; i < len(operator); i++\
    \ {\n        switch operator[i] {\n        case \"+\":\n            result +=\
    \ operand[i+1]\n        case \"-\":\n            result -= operand[i+1]\n    \
    \    case \"*\":\n            result *= operand[i+1]\n        case \"//\":\n \
    \           result /= operand[i+1]\n        case \"**\":\n            result =\
    \ pow(result, operand[i+1])\n        }\n    }\n    return result\n}\n", "\tvar\
    \ result int\n\tswitch operator[0] {\n\tcase \"+\":\n\t\tresult = operand[0] +\
    \ operand[1]\n\tcase \"-\":\n\t\tresult = operand[0] - operand[1]\n\tcase \"*\"\
    :\n\t\tresult = operand[0] * operand[1]\n\tcase \"//\":\n\t\tresult = operand[0]\
    \ / operand[1]\n\tcase \"**\":\n\t\tresult = operand[0] ^ operand[1]\n\t}\n\t\
    if len(operator) > 1 {\n\t\treturn do_algebra(operator[1:], append([]int{result},\
    \ operand[2:]...))\n\t}\n\treturn result\n}\n", "    if len(operator) != len(operand)\
    \ - 1 {\n        return 0\n    }\n    for i := 0; i < len(operator); i++ {\n \
    \       o := operator[i]\n        switch o {\n        case \"+\":\n          \
    \  operand[i+1] = operand[i] + operand[i+1]\n        case \"-\":\n           \
    \ operand[i+1] = operand[i] - operand[i+1]\n        case \"*\":\n            operand[i+1]\
    \ = operand[i] * operand[i+1]\n        case \"//\":\n            operand[i+1]\
    \ = operand[i] / operand[i+1]\n        case \"**\":\n            operand[i+1]\
    \ = operand[i] ^ operand[i+1]\n        }\n    }\n    return operand[len(operand)-1]\n\
    }\n", "    n := len(operator)\n    if n < 1 {\n        return operand[0]\n   \
    \ }\n    if n == 1 {\n        switch operator[0] {\n            case \"+\": return\
    \ operand[0] + operand[1]\n            case \"-\": return operand[0] - operand[1]\n\
    \            case \"*\": return operand[0] * operand[1]\n            case \"//\"\
    : return operand[0] / operand[1]\n            case \"**\": return operand[0] ^\
    \ operand[1]\n        }\n    }\n\n    f := \"\"\n    r := operand[0]\n    for\
    \ i, v := range operator {\n        if v == \"**\" {\n            f = v\n    \
    \        continue\n        }\n        switch v {\n            case \"+\": r +=\
    \ operand[i+1]\n            case \"-\": r -= operand[i+1]\n            case \"\
    *\": r *= operand[i+1]\n            case \"//\": r /= operand[i+1]\n        }\n\
    \    }\n    if f == \"**\" {\n        r = r ^ operand[n+1]\n    }\n    return\
    \ r\n}\n", "    if len(operator) == 0 {\n        return 0\n    }\n    if len(operand)\
    \ == 0 {\n        return 0\n    }\n    if len(operator) >= len(operand) {\n  \
    \      return 0\n    }\n    if len(operand) == 1 {\n        return operand[0]\n\
    \    }\n    // the length of operator is always less than the length of operand.\n\
    \    expr := \"\"\n    expr += fmt.Sprintf(\"%d\", operand[0])\n    for i, op\
    \ := range operator {\n        expr += op\n        expr += fmt.Sprintf(\"%d\"\
    , operand[i+1])\n    }\n    val, _ := GetExprValue(expr)\n    return val\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
