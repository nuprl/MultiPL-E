name: HumanEval_118_get_closest_vowel
language: go_test.go
prompt: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// You are given a word. Your task is to find the closest vowel that stands\
  \ between \n// two consonants from the right side of the word (case sensitive).\n\
  // Vowels in the beginning and ending doesn't count. Return empty string if you\
  \ didn't\n// find any vowel met the above condition. \n// You may assume that the\
  \ given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
  yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
  quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
  \ string) string {\n"
tests: "func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
  \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
  easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n\
  \     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
  bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
  \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
  ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n\
  \     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"\
  Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\"\
  \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
  , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var\
    \ consontants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\"\
    , \"l\", \"m\",\n                               \"n\", \"p\", \"q\", \"r\", \"\
    s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    var cons_vow_index map[int]bool\
    \ = make(map[int]bool)\n    for i, l := range word {\n        for _, v := range\
    \ vowels {\n            if string(l) == v {\n                cons_vow_index[i]\
    \ = true\n            }\n        }\n    }\n    for i, l := range word {\n    \
    \    if !cons_vow_index[i] {\n            continue\n        }\n        for _,\
    \ c := range consontants {\n            if string(l) == c {\n                if\
    \ (i + 1) < len(word) && cons_vow_index[i + 1] {\n                    return string(word[i])\n\
    \                }\n            }\n        }\n    }\n    return \"\"\n}\n", " \
    \   var (\n        res string\n        vowel_map = map[rune]bool{\n          \
    \  'a': true,\n            'e': true,\n            'i': true,\n            'o':\
    \ true,\n            'u': true,\n            'A': true,\n            'E': true,\n\
    \            'I': true,\n            'O': true,\n            'U': true,\n    \
    \    }\n    )\n    if len(word) < 3 {\n        return res\n    }\n    for _, v\
    \ := range word {\n        if !vowel_map[v] {\n            continue\n        }\n\
    \        if !vowel_map[rune(word[len(word)-1])] {\n            res = string(v)\n\
    \            break\n        }\n    }\n    return res\n}\n", "    if len(word)\
    \ < 3 {\n        return \"\"\n    }\n    vowels := \"AEIOUaeiou\"\n    i := len(word)\
    \ - 1\n    prev_consonant := false\n    for ; i >= 0; i-- {\n        if vowels[strings.Index(vowels,\
    \ string(word[i]))] != 0 {\n            if prev_consonant {\n                return\
    \ string(word[i])\n            }\n        } else {\n            prev_consonant\
    \ = true\n        }\n    }\n    return \"\"\n}\n", "    vowels := map[byte]bool{'a':\
    \ true, 'e': true, 'i': true, 'o': true, 'u': true}\n    result := \"\"\n    start\
    \ := len(word) - 1\n    end := len(word) - 1\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if vowels[word[i]] {\n            start = i\n            break\n\
    \        }\n    }\n    for i := start - 1; i >= 0; i-- {\n        if !vowels[word[i]]\
    \ {\n            end = i\n            break\n        }\n    }\n    if start >\
    \ end {\n        result = string(word[start])\n    }\n    return result\n}\n",
  "    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if strInArr(word[i:i+1], vowels) {\n           \
    \ return word[i:i+1]\n        }\n    }\n    return \"\"\n}\n", '    var vowels
    = map[string]', "    vowels := map[rune]int {\n        'a': 1,\n        'e': 1,\n\
    \        'i': 1,\n        'o': 1,\n        'u': 1,\n        'A': 1,\n        'E':\
    \ 1,\n        'I': 1,\n        'O': 1,\n        'U': 1,\n    }\n    result :=\
    \ \"\"\n    count := len(word)\n    for i := len(word) - 1; i >= 0; i-- {\n  \
    \      if _, ok := vowels[rune(word[i])]; ok {\n            if count - i < count\
    \ {\n                result = string(word[i])\n                count = i\n   \
    \         }\n        }\n    }\n    return result\n}\n", "    vowels := \"aeiouAEIOU\"\
    \n    for i := len(word) - 1; i >= 0; i-- {\n        for j := len(vowels) - 1;\
    \ j >= 0; j-- {\n            if word[i] == vowels[j] {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n", " \
    \   vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if findSlice(vowels, string(word[i])) != -1 {\n\
    \            return string(word[i])\n        }\n    }\n    return \"\"\n}\n",
  "    vowels := \"AEIOUaeiou\"\n    distance := len(word)\n    var closestVowel string\n\
    \    for i, c := range word {\n        if strings.Contains(vowels, string(c))\
    \ {\n            currentDistance := len(word) - i\n            if currentDistance\
    \ < distance {\n                distance = currentDistance\n                closestVowel\
    \ = string(c)\n            }\n        }\n    }\n    return closestVowel\n}\n",
  "    if len(word) <= 1 {\n        return \"\"\n    }\n    var vowels = map[string]bool{\"\
    a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    var last string\n\
    \    var first string\n    var last_vowel string\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if _, ok := vowels[string(word[i])]; ok {\n         \
    \   last_vowel = string(word[i])\n            continue\n        }\n        if\
    \ last_vowel != \"\" {\n            last = string(word[i])\n            break\n\
    \        }\n    }\n    for i := 0; i < len(word); i++ {\n        if _, ok := vowels[string(word[i])];\
    \ ok {\n            continue\n        }\n        if last_vowel != \"\" {\n   \
    \         first = string(word[i])\n            break\n        }\n    }\n    if\
    \ last_vowel == \"\" || last == \"\" || first == \"\" {\n        return \"\"\n\
    \    }\n    return last_vowel\n}\n", "\tif len(word) < 3 {\n\t\treturn \"\"\n\t\
    }\n\t// reverse word\n\tvar reversedWord string\n\tfor i := len(word) - 1; i >=\
    \ 0; i-- {\n\t\treversedWord += string(word[i])\n\t}\n\t// find the first consonant\n\
    \tvar firstConsonant string\n\tfor i := 0; i < len(reversedWord); i++ {\n\t\t\
    switch reversedWord[i] {\n\t\tcase 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O',\
    \ 'U':\n\t\t\tfirstConsonant = \"\"\n\t\tdefault:\n\t\t\tfirstConsonant = string(reversedWord[i])\n\
    \t\t\ti++\n\t\t\tbreak\n\t\t}\n\t}\n\t// find the closest vowel\n\tvar closestVowel\
    \ string\n\tfor i := 0; i < len(reversedWord); i++ {\n\t\tswitch reversedWord[i]\
    \ {\n\t\tcase 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U':\n\t\t\tclosestVowel\
    \ = string(reversedWord[i])\n\t\t\tbreak\n\t\t}\n\t}\n\treturn closestVowel\n\
    }\n", "\tvowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\tfor i := len(word)\
    \ - 1; i >= 0; i-- {\n\t\tif j := find_vowel(word[i], vowels); j >= 0 {\n\t\t\t\
    if i+1 < len(word) && find_vowel(word[i+1], vowels) == -1 {\n\t\t\t\treturn vowels[j]\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n", "    vowels := \"aeiouAEIOU\"\n    res\
    \ := \"\"\n    distance := -1\n    is_previous_consonant := false\n    is_next_consonant\
    \ := false\n    for i := len(word) - 1; i >= 0; i-- {\n        if is_next_consonant\
    \ {\n            break\n        }\n        is_previous_consonant = false\n   \
    \     is_next_consonant = false\n        if contains(vowels, string(word[i]))\
    \ {\n            continue\n        }\n        for j := i + 1; j < len(word); j++\
    \ {\n            if contains(vowels, string(word[j])) {\n                is_previous_consonant\
    \ = true\n                if is_next_consonant {\n                    distance\
    \ = j - i\n                    res = string(word[j])\n                    break\n\
    \                }\n            } else {\n                is_next_consonant =\
    \ true\n                if is_previous_consonant {\n                    if distance\
    \ == -1 || j - i < distance {\n                        distance = j - i\n    \
    \                    res = string(word[j-1])\n                    }\n        \
    \            break\n                }\n            }\n        }\n    }\n    return\
    \ res\n}\n", "    vowels := \"aeiou\"\n    var re string\n    for idx := len(word)\
    \ - 1; idx >= 0; idx-- {\n        if len(re) == 0 {\n            idx2 := vowels.IndexRune(rune(word[idx]))\n\
    \            if idx2 >= 0 {\n                re = string(word[idx])\n        \
    \    }\n        } else {\n            idx2 := vowels.IndexRune(rune(word[idx]))\n\
    \            if idx2 < 0 {\n                return re\n            }\n       \
    \ }\n    }\n    return \"\"\n}\n", "    // Your code here\n    return \"\"\n}\n",
  "    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var ans = \"\"\
    \n    for i := len(word) - 1; i >= 0; i-- {\n        for _, vowel := range vowels\
    \ {\n            if word[i] == vowel[0] {\n                ans = string(word[i])\n\
    \                return ans\n            }\n        }\n    }\n    return ans\n\
    }\n", "    l := len(word)\n    if l == 0 {\n        return \"\"\n    }\n    vowels\
    \ := map[byte]bool{\n        'a': true,\n        'e': true,\n        'i': true,\n\
    \        'o': true,\n        'u': true,\n        'A': true,\n        'E': true,\n\
    \        'I': true,\n        'O': true,\n        'U': true,\n    }\n    res :=\
    \ \"\"\n    for i := l - 1; i >= 0; i-- {\n        if !vowels[word[i]] {\n   \
    \         continue\n        }\n        if i + 1 < l && !vowels[word[i + 1]] {\n\
    \            res = string(word[i])\n            break\n        }\n    }\n    return\
    \ res\n}\n", "    r := []rune(word)\n    if len(r) < 2 {\n        return \"\"\n\
    \    }\n    i := len(r) - 1\n    for i > 0 {\n        if !is_vowel(r[i]) {\n \
    \           j := i - 1\n            for j > 0 {\n                if !is_vowel(r[j])\
    \ {\n                    return \"\"\n                }\n                if is_vowel(r[j])\
    \ {\n                    return string(r[j])\n                }\n            \
    \    j--\n            }\n        }\n        i--\n    }\n    return \"\"\n}\n",
  "    var idx int\n    var closest_vowel string\n    var result string\n    var start_idx\
    \ int\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i >= 0; i-- {\n  \
    \      if string(word[i]) == \" \" {\n            start_idx = i - 1\n        \
    \    break\n        }\n    }\n    for i := start_idx; i >= 0; i-- {\n        if\
    \ vowels[0:1] == string(word[i]) || vowels[1:2] == string(word[i]) ||\n      \
    \      vowels[2:3] == string(word[i]) || vowels[3:4] == string(word[i]) ||\n \
    \           vowels[4:5] == string(word[i]) {\n            idx = i\n          \
    \  closest_vowel = string(word[i])\n            break\n        }\n    }\n    if\
    \ idx == 0 {\n        result = \"\"\n    } else {\n        result = closest_vowel\n\
    \    }\n    return result\n}\n", "    var vowels = []string{\"a\", \"e\", \"i\"\
    , \"o\", \"u\"}\n    var length = len(word)\n    for i := length - 1; i > 1; i--\
    \ {\n        for _, v := range vowels {\n            if word[i] == v[0] {\n  \
    \              return string(word[i])\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n", "    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n   \
    \ index := len(word) - 1\n    nextVowel := \"\"\n    for index >= 0 {\n      \
    \  if contains(vowels, string(word[index])) {\n            nextVowel = string(word[index])\n\
    \            index--\n            break\n        }\n        index--\n    }\n \
    \   if nextVowel == \"\" {\n        return \"\"\n    }\n    found := false\n \
    \   for index >= 0 {\n        if contains(vowels, string(word[index])) {\n   \
    \         return nextVowel\n        }\n        if !found {\n            if index\
    \ == 0 {\n                return nextVowel\n            }\n            found =\
    \ true\n        }\n        index--\n    }\n    return \"\"\n}\n", "    var (\n\
    \        vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n        index int\n\
    \    )\n    if len(word) <= 1 {\n        return \"\"\n    }\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if !in(vowels, string(word[i])) {\n            if\
    \ i + 1 < len(word) && in(vowels, string(word[i + 1])) {\n                index\
    \ = i + 1\n                break\n            }\n        }\n    }\n    if index\
    \ > 0 {\n        return string(word[index])\n    }\n    return \"\"\n}\n", " \
    \   vowels := map[rune]int{\n        'a': 1,\n        'e': 1,\n        'i': 1,\n\
    \        'o': 1,\n        'u': 1,\n        'A': 1,\n        'E': 1,\n        'I':\
    \ 1,\n        'O': 1,\n        'U': 1,\n    }\n    word_len := len(word)\n   \
    \ if word_len < 3 {\n        return \"\"\n    }\n    for i := word_len - 2; i\
    \ >= 0; i-- {\n        if _, ok := vowels[rune(word[i])]; ok {\n            if\
    \ _, ok := vowels[rune(word[i + 1])]; !ok {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n", "    var vowel string\n\
    \    var re = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\"\
    , \"O\", \"U\"}\n    for i := len(word) - 1; i >= 0; i-- {\n        // find a\
    \ consonant from the right\n        if !contains(re, string(word[i])) {\n    \
    \        for j := i - 1; j >= 0; j-- {\n                // find a vowel from the\
    \ left of the consonant\n                if contains(re, string(word[j])) {\n\
    \                    return string(word[j])\n                }\n            }\n\
    \        }\n    }\n    return vowel\n}\n", "    vowels := map[string]bool{\n \
    \       \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\"\
    : true,\n        \"u\": true,\n    }\n    var ret string\n    found_consonant\
    \ := false\n    for _, r := range word {\n        if vowels[string(r)] {\n   \
    \         if found_consonant {\n                ret = string(r)\n            \
    \    break\n            }\n        } else {\n            found_consonant = true\n\
    \        }\n    }\n    return ret\n}\n", "    wordLen := len(word)\n    closest\
    \ := \"\"\n    j := 0\n    for i := wordLen - 1; i >= 0; i-- {\n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            closest = string(word[i])\n            j = i\n            break\n\
    \        }\n    }\n    for j > 0 {\n        for i := j - 1; i >= 0; i-- {\n  \
    \          if word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] !=\
    \ 'o' && word[i] != 'u' {\n                j = i\n                break\n    \
    \        }\n        }\n        if j == 0 {\n            break\n        }\n   \
    \     for i := j - 1; i >= 0; i-- {\n            if word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n           \
    \     if len(closest) == 0 || (j - i) < len(closest) {\n                    closest\
    \ = string(word[i])\n                }\n                j = i\n              \
    \  break\n            }\n        }\n    }\n    return closest\n}\n", "    var\
    \ vowel_index = make([]int, 0)\n    for i, letter := range word {\n        switch\
    \ letter {\n        case 'a', 'e', 'i', 'o', 'u':\n            vowel_index = append(vowel_index,\
    \ i)\n        }\n    }\n    if len(vowel_index) == 0 {\n        return \"\"\n\
    \    }\n\n    var first_vowel_index = vowel_index[0]\n    var last_vowel_index\
    \ = vowel_index[len(vowel_index) - 1]\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        switch word[i] {\n        case 'a', 'e', 'i', 'o', 'u':\n       \
    \     continue\n        }\n        // current letter is consonant\n        if\
    \ i < last_vowel_index {\n            return string(word[last_vowel_index])\n\
    \        }\n        return string(word[first_vowel_index])\n    }\n    return\
    \ \"\"\n}\n", "    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n   \
    \ prev_is_vowel := false\n    curr_is_vowel := false\n    s := \"\"\n    for i\
    \ := len(word) - 1; i >= 0; i-- {\n        r := string(word[i])\n        curr_is_vowel\
    \ = false\n        for _, v := range vowels {\n            if r == v {\n     \
    \           curr_is_vowel = true\n                break\n            }\n     \
    \   }\n        if !prev_is_vowel && curr_is_vowel {\n            s = r\n     \
    \       break\n        }\n        prev_is_vowel = curr_is_vowel\n    }\n    return\
    \ s\n}\n", "    vowels := map[rune]bool{\n        'a': true,\n        'e': true,\n\
    \        'i': true,\n        'o': true,\n        'u': true,\n        'A': true,\n\
    \        'E': true,\n        'I': true,\n        'O': true,\n        'U': true,\n\
    \    }\n    prev_vowel := \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n  \
    \      ch := rune(word[i])\n        if _, ok := vowels[ch]; ok {\n           \
    \ prev_vowel = string(ch)\n        } else if prev_vowel != \"\" {\n          \
    \  return prev_vowel\n        }\n    }\n    return \"\"\n}\n", "    vowels :=\
    \ \"aeiou\"\n    var vowel_list []string\n    var offset int\n    var closest_vowel\
    \ string\n    closest_offset := len(word)\n\n    for i := 0; i < len(word); i++\
    \ {\n        if vowels_index := strings.IndexAny(vowels, word[i:i+1]); vowels_index\
    \ != -1 {\n            vowel_list = append(vowel_list, word[i:i+1])\n        }\n\
    \    }\n\n    if len(vowel_list) == 0 {\n        return \"\"\n    }\n\n    for\
    \ _, v := range vowel_list {\n        if offset = strings.LastIndex(word, v);\
    \ offset != -1 {\n            if closest_offset > offset {\n                closest_offset\
    \ = offset\n                closest_vowel = v\n            }\n        }\n    }\n\
    \n    return closest_vowel\n}\n", "    vowels := []string{\"a\", \"e\", \"i\"\
    , \"o\", \"u\"}\n    for i := len(word) - 1; i >= 0; i-- {\n        if is_consonant(word[i])\
    \ {\n            for j := i - 1; j >= 0; j-- {\n                if is_vowel(word[j])\
    \ {\n                    return string(word[j])\n                }\n         \
    \   }\n        }\n    }\n    return \"\"\n}\n", "    vowels := map[string]bool{\"\
    a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    i := len(word)\
    \ - 1\n    before := \"\"\n    after := \"\"\n    for ; i >= 0; i-- {\n      \
    \  if vowels[string(word[i])] {\n            after = string(word[i])\n       \
    \     break\n        }\n    }\n    for ; i >= 0; i-- {\n        if !vowels[string(word[i])]\
    \ {\n            before = string(word[i])\n            break\n        }\n    }\n\
    \    if before == \"\" || after == \"\" {\n        return \"\"\n    }\n    return\
    \ after\n}\n", "\t// Write your code here!\n    return \"\"\n}\n", "    if len(word)\
    \ < 3 {\n        return \"\"\n    }\n    reverseWord := []rune(word)\n    result\
    \ := \"\"\n    for i := len(reverseWord) - 1; i > 0; i-- {\n        if isVowel(reverseWord[i])\
    \ {\n            if !isVowel(reverseWord[i - 1]) {\n                result = string(reverseWord[i])\n\
    \                break\n            }\n        }\n    }\n    return result\n}\n",
  "    if len(word) < 3 {\n        return \"\"\n    }\n    vowels := map[string]string{\"\
    a\": \"\", \"e\": \"\", \"i\": \"\", \"o\": \"\", \"u\": \"\"}\n    for i := len(word)\
    \ - 1; i > 0; i-- {\n        if _, exists := vowels[string(word[i])]; exists {\n\
    \            if _, exists := vowels[string(word[i-1])]; !exists {\n          \
    \      return string(word[i])\n            }\n        }\n    }\n    return \"\"\
    \n}\n", "    vowels := \"aeiou\"\n    wordLen := len(word)\n    for i := wordLen\
    \ - 1; i > 0; i-- {\n        for j := len(vowels) - 1; j >= 0; j-- {\n       \
    \     if word[i] == vowels[j] {\n                return string(word[i])\n    \
    \        }\n        }\n    }\n    return \"\"\n}\n", "\tvowels := []string{\"\
    a\", \"e\", \"i\", \"o\", \"u\"}\n\tisConsonant := func(c string) bool {\n\t\t\
    for _, v := range vowels {\n\t\t\tif c == v {\n\t\t\t\treturn false\n\t\t\t}\n\
    \t\t}\n\t\treturn true\n\t}\n\ti := len(word) - 1\n\tfor ; i >= 0; i-- {\n\t\t\
    if isConsonant(word[i:i+1]) {\n\t\t\tfor j := i - 1; j >= 0; j-- {\n\t\t\t\tif\
    \ !isConsonant(word[j:j+1]) {\n\t\t\t\t\treturn word[j:j+1]\n\t\t\t\t}\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn \"\"\n}\n", "    l := len(word)\n    if l < 2 {\n    \
    \    return \"\"\n    }\n    vowels := \"AEIOUaeiou\"\n    for i := l - 1; i >\
    \ 0; i-- {\n        if strings.Contains(vowels, string(word[i])) {\n         \
    \   return string(word[i])\n        }\n    }\n    return \"\"\n}\n", "    word_len\
    \ := len(word)\n    if word_len == 0 {\n        return \"\"\n    }\n    if word_len\
    \ == 1 {\n        if IsVowel(string(word[0])) {\n            return string(word[0])\n\
    \        } else {\n            return \"\"\n        }\n    }\n    for i := word_len\
    \ - 1; i > 0; i-- {\n        if IsVowel(string(word[i])) {\n            if IsVowel(string(word[i-1]))\
    \ {\n                continue\n            } else {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n", "    dist := len(word)\n\
    \    r := len(word) - 1\n    d := 0\n    w := \"\"\n    for i := r; i >= 0; i--\
    \ {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            d = r - i\n            if d < dist {\n\
    \                dist = d\n                w = string(word[i])\n            }\n\
    \        }\n    }\n    return w\n}\n", "    vowels := []string{\"a\", \"e\", \"\
    i\", \"o\", \"u\"}\n    last_vowel := \"\"\n    var index_last_vowel int = -1\n\
    \    var index_last_consonant int = -1\n    for i, c := range word {\n       \
    \ str := string(c)\n        if stringInSlice(str, vowels) {\n            last_vowel\
    \ = str\n            index_last_vowel = i\n        } else {\n            if index_last_vowel\
    \ > index_last_consonant {\n                return last_vowel\n            }\n\
    \            index_last_consonant = i\n        }\n    }\n    return \"\"\n}\n",
  "    if len(word) < 3 {\n        return \"\"\n    }\n    vowels := \"AEIOU\"\n \
    \   pos := len(word) - 2\n    for ; pos >= 0; pos-- {\n        if vowels[vowels_index(word[pos])]\
    \ == word[pos] {\n            // Is vowel\n            if vowels[vowels_index(word[pos+1])]\
    \ != word[pos+1] {\n                // Is consonant\n                return string(word[pos])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n", "    // your code goes\
    \ here\n    return \"\"\n}\n", "    vowels := []string{\"a\", \"e\", \"i\", \"\
    o\", \"u\"}\n    last_pos := -1\n    for i := len(word) - 1; i >= 0; i-- {\n \
    \       for _, v := range vowels {\n            if v == string(word[i]) {\n  \
    \              last_pos = i\n                break\n            }\n        }\n\
    \        if last_pos != -1 {\n            break\n        }\n    }\n    return\
    \ string(word[last_pos])\n}\n", "    if len(word) < 3 {\n        return \"\"\n\
    \    }\n    for i := len(word) - 2; i > 0; i-- {\n        if is_consonant(word[i])\
    \ && is_consonant(word[i-1]) {\n            return string(word[i+1])\n       \
    \ }\n    }\n    return \"\"\n}\n", "    if len(word) <= 2 {\n        return \"\
    \"\n    }\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var\
    \ is_vowel = func(c string) bool {\n        for _, v := range vowels {\n     \
    \       if c == v {\n                return true\n            }\n        }\n \
    \       return false\n    }\n    var is_consonant = func(c string) bool {\n  \
    \      return !is_vowel(c)\n    }\n    var index int\n    for i := len(word) -\
    \ 1; i >= 0; i-- {\n        if is_consonant(string(word[i])) {\n            index\
    \ = i\n            break\n        }\n    }\n    if index <= 0 {\n        return\
    \ \"\"\n    }\n    for i := index - 1; i >= 0; i-- {\n        if is_vowel(string(word[i]))\
    \ {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n",
  "    for i:=len(word)-1; i>0; i-- {\n        if isVowel(word[i]) && !isVowel(word[i-1])\
    \ {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n",
  "    // TODO your code here\n    return \"\";\n}\n", "    // see the comment in\
    \ the reverse version\n    // I don't really like this version. The reverse version\
    \ is much clearer\n    consonants := map[rune]bool{\n        'B': true, 'C': true,\
    \ 'D': true, 'F': true, 'G': true, 'H': true,\n        'J': true, 'K': true, 'L':\
    \ true, 'M': true, 'N': true, 'P': true,\n        'Q': true, 'R': true, 'S': true,\
    \ 'T': true, 'V': true, 'W': true,\n        'X': true, 'Y': true, 'Z': true,\n\
    \    }\n    vowels := map[rune]bool{\n        'A': true, 'E': true, 'I': true,\
    \ 'O': true, 'U': true,\n    }\n    var prev_consonant, cur_consonant, cur_vowel\
    \ rune\n    for i, char := range word {\n        if consonants[char] {\n     \
    \       if vowels[cur_vowel] {\n                return string(cur_vowel)\n   \
    \         }\n            prev_consonant = cur_consonant\n            cur_consonant\
    \ = char\n        } else if vowels[char] {\n            if i == 0 || consonants[prev_consonant]\
    \ {\n                return string(char)\n            }\n            cur_vowel\
    \ = char\n        }\n    }\n    return \"\"\n}\n", "    vowels := map[rune]bool{'a':\
    \ true, 'e': true, 'i': true, 'o': true, 'u': true, 'A': true, 'E': true, 'I':\
    \ true, 'O': true, 'U': true}\n    consonants := map[rune]bool{'q': true, 'w':\
    \ true, 'r': true, 't': true, 'p': true, 's': true, 'd': true, 'f': true, 'g':\
    \ true, 'h': true, 'j': true, 'k': true, 'l': true, 'z': true, 'x': true, 'c':\
    \ true, 'v': true, 'b': true, 'n': true, 'm': true, 'Q': true, 'W': true, 'R':\
    \ true, 'T': true, 'P': true, 'S': true, 'D': true, 'F': true, 'G': true, 'H':\
    \ true, 'J': true, 'K': true, 'L': true, 'Z': true, 'X': true, 'C': true, 'V':\
    \ true, 'B': true, 'N': true, 'M': true}\n    word_runes := []rune(word)\n   \
    \ for i, ch := range word_runes {\n        if vowels[ch] {\n            if (i\
    \ > 0 && consonants[word_runes[i-1]]) && (i < len(word_runes)-1 && consonants[word_runes[i+1]])\
    \ {\n                return string(ch)\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n", "\tif len(word) <= 1 {\n\t\treturn \"\"\n\t}\n\tfor i := len(word)\
    \ - 1; i > 0; i-- {\n\t\tif word[i] == 'a' || word[i] == 'e' || word[i] == 'i'\
    \ || word[i] == 'o' || word[i] == 'u' {\n\t\t\tif word[i-1] != 'a' && word[i-1]\
    \ != 'e' && word[i-1] != 'i' && word[i-1] != 'o' && word[i-1] != 'u' {\n\t\t\t\
    \treturn string(word[i])\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n", "    vowels\
    \ := \"aeiou\"\n    cons := \"bcdfghjklmnpqrstvwxyz\"\n    for i := len(word)\
    \ - 2; i >= 0; i-- {\n        if strings.Contains(cons, string(word[i])) {\n \
    \           for j := i + 1; j < len(word); j++ {\n                if strings.Contains(vowels,\
    \ string(word[j])) {\n                    return string(word[j])\n           \
    \     }\n            }\n        }\n    }\n    return \"\"\n}\n", "    return \"\
    \"\n}\n", "    v := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    lastC :=\
    \ -1\n    lastV := -1\n    best := 1000\n    for i, c := range word {\n      \
    \  if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n           \
    \ if lastC != -1 {\n                if i - lastC < best {\n                  \
    \  best = i - lastC\n                    lastV = i\n                }\n      \
    \      }\n        } else {\n            lastC = i\n        }\n    }\n    if lastV\
    \ != -1 {\n        return v[(word[lastV] - 'a') % len(v)]\n    }\n    return \"\
    \"\n}\n", "    distance := -1\n    result := \"\"\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        char := string(word[i])\n        if char == \"a\" ||\
    \ char == \"e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n       \
    \     // get distance from the end\n            current_distance := len(word)\
    \ - i\n            if distance == -1 || current_distance < distance {\n      \
    \          distance = current_distance\n                result = char\n      \
    \      }\n        }\n    }\n    return result\n}\n", "    var vowels = []string{\"\
    a\", \"e\", \"i\", \"o\", \"u\"}\n    var prev, next rune\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if i != len(word) - 1 {\n            next = rune(word[i\
    \ + 1])\n        } else {\n            next = 0\n        }\n        prev = rune(word[i])\n\
    \        for _, v := range vowels {\n            if rune(v[0]) == prev {\n   \
    \             if next != 0 {\n                    if rune(v[0]) != next {\n  \
    \                      return v\n                    }\n                } else\
    \ {\n                    return v\n                }\n            }\n        }\n\
    \    }\n    return \"\"\n}\n", "    vowels := []string{\"a\", \"e\", \"i\", \"\
    o\", \"u\"}\n    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range\
    \ vowels {\n            if word[i] == v[0] {\n                return v\n     \
    \       }\n        }\n    }\n    return \"\"\n}\n", "    // TODO\n    return \"\
    \"\n}\n", "    return \"\"\n}\n", "    vowels := []rune(\"aeiou\")\n    prev :=\
    \ ' '\n    for i := len(word) - 1; i >= 0; i-- {\n        char := rune(word[i])\n\
    \        if isVowel(char, vowels) {\n            if isConsonant(prev, vowels)\
    \ {\n                return string(char)\n            }\n        } else {\n  \
    \          prev = char\n        }\n    }\n    return \"\"\n}\n", "    is_vowel\
    \ := func(c byte) bool {\n        return c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u' ||\n               c == 'A' || c == 'E' || c == 'I' || c\
    \ == 'O' || c == 'U'\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n     \
    \   if !is_vowel(word[i]) {\n            if i == len(word) - 1 {\n           \
    \     return \"\"\n            }\n            if is_vowel(word[i+1]) {\n     \
    \           return string(word[i+1])\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n", "    // Your code here\n    for i := len(word) - 1; i > 0; i-- {\n\
    \        if !is_vowel(word[i]) && is_vowel(word[i-1]) {\n            return string(word[i-1])\n\
    \        }\n    }\n    return \"\"\n}\n", "    return \"\"\n}\n", "    vowels\
    \ := map[string]int{\"a\":1, \"e\":1, \"i\":1, \"o\":1, \"u\":1, \"A\":1, \"E\"\
    :1, \"I\":1, \"O\":1, \"U\":1}\n    if len(word) < 3 {\n        return \"\"\n\
    \    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ ok {\n            if _, ok := vowels[string(word[i-1])]; !ok {\n           \
    \     if _, ok := vowels[string(word[i-2])]; !ok {\n                    return\
    \ string(word[i])\n                }\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n", "    vowels := map[string]int{\"a\":1, \"e\":1, \"i\":1, \"o\":1,\
    \ \"u\":1, \"A\":1, \"E\":1, \"I\":1, \"O\":1, \"U\":1}\n    previous_vowel :=\
    \ \"\"\n    previous_consonant := \"\"\n    previous_found := false\n    i :=\
    \ len(word) - 1\n    for ; i > 0; i-- {\n        if _, ok := vowels[string(word[i])];\
    \ ok {\n            if previous_found {\n                break\n            }\n\
    \            previous_vowel = string(word[i])\n        } else {\n            if\
    \ previous_vowel != \"\" {\n                previous_found = true\n          \
    \  }\n            previous_consonant = string(word[i])\n        }\n    }\n   \
    \ if previous_vowel != \"\" && previous_consonant != \"\" {\n        return previous_vowel\n\
    \    }\n    return \"\"\n}\n", "    if word == \"\" {\n        return \"\"\n \
    \   }\n    vowel := \"aeiou\"\n    last_char := word[len(word)-1:]\n    second_last_char\
    \ := word[len(word)-2:len(word)-1]\n    var vowel_index int\n    for index, v\
    \ := range vowel {\n        if string(v) == last_char {\n            vowel_index\
    \ = index\n            break\n        }\n    }\n    if vowel_index != 0 {\n  \
    \      for i := vowel_index; i >= 0; i-- {\n            if string(vowel[i]) ==\
    \ second_last_char {\n                return \"\"\n            }\n        }\n\
    \        return last_char\n    }\n    for i := vowel_index; i < len(vowel); i++\
    \ {\n        if string(vowel[i]) == second_last_char {\n            return \"\"\
    \n        }\n    }\n    return last_char\n}\n", "    for i := len(word) - 1; i\
    \ > 0; i-- {\n        if !is_vowel(word[i]) && is_vowel(word[i-1]) {\n       \
    \     return string(word[i-1])\n        }\n    }\n    return \"\"\n}\n", "   \
    \ vowels := \"AEIOUaeiou\"\n    result := \"\"\n    for i := len(word) - 1; i\
    \ >= 0; i-- {\n        for j := 0; j < len(vowels); j++ {\n            if i >=\
    \ 1 && word[i] == vowels[j] && word[i-1] != vowels[j] {\n                result\
    \ = string(word[i])\n                break\n            }\n        }\n       \
    \ if result != \"\" {\n            break\n        }\n    }\n    return result\n\
    }\n", "    if len(word) < 2 {\n        return \"\"\n    }\n    vowels := map[rune]bool{'a':\
    \ true, 'e': true, 'i': true, 'o': true, 'u': true,\n                        \
    \    'A': true, 'E': true, 'I': true, 'O': true, 'U': true}\n    consonants :=\
    \ map[rune]bool{'b': true, 'c': true, 'd': true, 'f': true, 'g': true, 'h': true,\n\
    \                                'j': true, 'k': true, 'l': true, 'm': true, 'n':\
    \ true, 'p': true,\n                                'q': true, 'r': true, 's':\
    \ true, 't': true, 'v': true, 'w': true,\n                                'x':\
    \ true, 'y': true, 'z': true,\n                                'B': true, 'C':\
    \ true, 'D': true, 'F': true, 'G': true, 'H': true,\n                        \
    \        'J': true, 'K': true, 'L': true, 'M': true, 'N': true, 'P': true,\n \
    \                               'Q': true, 'R': true, 'S': true, 'T': true, 'V':\
    \ true, 'W': true,\n                                'X': true, 'Y': true, 'Z':\
    \ true}\n    for i := len(word) - 1; i > 0; i-- {\n        if _, ok := consonants[rune(word[i])];\
    \ ok {\n            if _, ok := consonants[rune(word[i-1])]; ok {\n          \
    \      if _, ok := vowels[rune(word[i-2])]; ok {\n                    return string(word[i-2])\n\
    \                }\n            }\n        }\n    }\n    return \"\"\n}\n", " \
    \   // TODO: implement\n    return \"\"\n}\n", "    const vowels = \"aeiouAEIOU\"\
    \n    for i := len(word) - 1; i >= 0; i-- {\n        if strings.Contains(vowels,\
    \ string(word[i])) {\n            for j := i; j >= 0; j-- {\n                if\
    \ strings.Contains(vowels, string(word[j])) {\n                    return \"\"\
    \n                }\n                if j == 0 {\n                    return string(word[i])\n\
    \                }\n            }\n        }\n    }\n    return \"\"\n}\n", " \
    \   vowels := map[string]int {\n        \"a\": 1,\n        \"e\": 1,\n       \
    \ \"i\": 1,\n        \"o\": 1,\n        \"u\": 1,\n        \"A\": 1,\n       \
    \ \"E\": 1,\n        \"I\": 1,\n        \"O\": 1,\n        \"U\": 1,\n    }\n\
    \    closest := \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if _,\
    \ ok := vowels[string(word[i])]; ok {\n            closest = string(word[i])\n\
    \            continue\n        }\n        if closest != \"\" {\n            break\n\
    \        }\n    }\n    return closest\n}\n", "    // TODO: rewrite this function\n\
    \    return \"\"\n}\n", "    vowel_map := map[string]int{\"a\": 1, \"e\": 1, \"\
    i\": 1, \"o\": 1, \"u\": 1, \"A\": 1, \"E\": 1, \"I\": 1, \"O\": 1, \"U\": 1}\n\
    \    chars := []rune(word)\n    target_vowel := \"\"\n    vowels := \"\"\n   \
    \ for i:=len(chars)-1; i>=0; i-- {\n        if v, ok := vowel_map[string(chars[i])];\
    \ ok {\n            vowels = string(chars[i]) + vowels\n        } else {\n   \
    \         if len(vowels) > 0 {\n                target_vowel = vowels[0:1]\n \
    \               break\n            }\n        }\n    }\n    return target_vowel\n\
    }\n", "    return \"\"\n}\n", "    var map_vowel = map[string]int{\"a\": 0, \"\
    e\": 0, \"i\": 0, \"o\": 0, \"u\": 0}\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        if _, ok := map_vowel[string(word[i])]; ok {\n            return\
    \ string(word[i])\n        }\n    }\n    return \"\"\n}\n", "    last_index :=\
    \ len(word) - 1\n    for index, char := range word {\n        if index == 0 {\n\
    \            continue\n        }\n        if char == 'A' || char == 'E' || char\
    \ == 'I' || char == 'O' || char == 'U' {\n            if word[index-1] == ' '\
    \ || word[index-1] == 'A' || word[index-1] == 'E' || word[index-1] == 'I' || word[index-1]\
    \ == 'O' || word[index-1] == 'U' {\n                continue\n            }\n\
    \            if index != last_index {\n                if word[index+1] == ' '\
    \ || word[index+1] == 'A' || word[index+1] == 'E' || word[index+1] == 'I' || word[index+1]\
    \ == 'O' || word[index+1] == 'U' {\n                    continue\n           \
    \     }\n            }\n            return string(char)\n        }\n    }\n  \
    \  return \"\"\n}\n", "    vowels := map[byte]bool{'a': true, 'e': true, 'i':\
    \ true, 'o': true, 'u': true}\n    new_word := []byte(word)\n    l := len(new_word)\n\
    \    index := l - 1\n    for {\n        if index < 0 {\n            break\n  \
    \      }\n        if !vowels[new_word[index]] {\n            break\n        }\n\
    \        index--\n    }\n    index--\n    for {\n        if index < 0 {\n    \
    \        break\n        }\n        if vowels[new_word[index]] {\n            return\
    \ string(new_word[index])\n        }\n        index--\n    }\n    return \"\"\n\
    }\n", "    // your code here\n    return \"\"\n}\n", "    if len(word) < 3 {\n\
    \        return \"\"\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n     \
    \   if is_vowel(word[i]) {\n            if i + 1 < len(word) && !is_vowel(word[i\
    \ + 1]) {\n                return string(word[i])\n            }\n        } else\
    \ {\n            if i + 1 < len(word) && is_vowel(word[i + 1]) {\n           \
    \     return string(word[i + 1])\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n", "    word = word[::-1] // reverse word\n\n    first := -1\n    found\
    \ := -1\n    for index, value := range word {\n        if value == 'a' || value\
    \ == 'e' || value == 'i' || value == 'o' || value == 'u' {\n            found\
    \ = index\n            if first != -1 {\n                break\n            }\n\
    \        } else {\n            if first == -1 {\n                first = index\n\
    \            }\n        }\n    }\n\n    if first == -1 || found == -1 {\n    \
    \    return \"\"\n    } else {\n        return string(word[found])\n    }\n}\n",
  "    var vowels = \"aeiouAEIOU\"\n    var rv string = \"\"\n    var vowel_idx int\
    \ = -1\n    var vowel_pos int = len(word)\n    for i, l := range word {\n    \
    \    if vowels[0:5].IndexRune(l) >= 0 {\n            if vowel_idx == -1 {\n  \
    \              vowel_idx = vowels[0:5].IndexRune(l)\n                vowel_pos\
    \ = i\n            } else {\n                if i - vowel_pos > vowel_pos {\n\
    \                    break\n                }\n                if vowels[0:5].IndexRune(l)\
    \ > vowel_idx {\n                    vowel_idx = vowels[0:5].IndexRune(l)\n  \
    \                  vowel_pos = i\n                }\n            }\n        }\n\
    \    }\n    if vowel_idx == -1 {\n        return rv\n    }\n    return vowels[vowel_idx:vowel_idx+1]\n\
    }\n", "    vowels := map[rune]bool{'a': true, 'e': true, 'i': true, 'o': true,\
    \ 'u': true, 'A': true, 'E': true, 'I': true, 'O': true, 'U': true}\n    rs :=\
    \ []rune(word)\n    for i := len(rs) - 1; i >= 0; i-- {\n        if vowels[rs[i]]\
    \ {\n            if i > 0 && vowels[rs[i - 1]] {\n                continue\n \
    \           }\n            if i < len(rs) - 1 && vowels[rs[i + 1]] {\n       \
    \         continue\n            }\n            return string(rs[i])\n        }\n\
    \    }\n    return \"\"\n}\n", "    vowels := map[string]bool{\n        \"a\"\
    : true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n  \
    \      \"u\": true,\n    }\n    var result string\n    previous_was_vowel := false\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        if _, is_vowel := vowels[string(word[i])];\
    \ is_vowel {\n            if !previous_was_vowel {\n                result = string(word[i])\n\
    \                break\n            }\n            previous_was_vowel = true\n\
    \        } else {\n            previous_was_vowel = false\n        }\n    }\n\
    \    return result\n}\n", "    consonants := \"bcdfghjklmnpqrstvwxyz\"\n    vowels\
    \ := \"aeiou\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if strings.Contains(consonants,\
    \ word[i:i+1]) {\n            for j := i - 1; j >= 0; j-- {\n                if\
    \ strings.Contains(vowels, word[j:j+1]) {\n                    return word[j:j+1]\n\
    \                }\n            }\n        }\n    }\n    return \"\"\n}\n", " \
    \   vowels := map[rune]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true,\n\
    \        'A': true, 'E': true, 'I': true, 'O': true, 'U': true}\n    var preConsonant,\
    \ foundVowel rune\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[rune(word[i])]\
    \ {\n            foundVowel = rune(word[i])\n            if preConsonant != 0\
    \ {\n                return string(foundVowel)\n            }\n        } else\
    \ {\n            preConsonant = rune(word[i])\n        }\n    }\n    return \"\
    \"\n}\n", "    chars := []rune(word)\n    numChars := len(chars)\n    for i :=\
    \ numChars - 1; i > 0; i-- {\n        if isVowel(chars[i]) && !isVowel(chars[i-1])\
    \ {\n            return string(chars[i])\n        }\n    }\n    return \"\"\n\
    }\n", "    fmt.Println(\"Input: \", word)\n    if len(word) < 3 {\n        return\
    \ \"\"\n    }\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n   \
    \ for i := 0; i < len(word) - 1; i++ {\n        if is_consonant(word[i]) && is_consonant(word[i\
    \ + 1]) {\n            // word has 2 consonants, check if there is vowel\n   \
    \         // in between.\n            for j := i + 1; j < len(word); j++ {\n \
    \               for _,v := range vowels {\n                    if string(word[j])\
    \ == v {\n                        return string(word[j])\n                   \
    \ }\n                }\n            }\n        }\n    }\n    return \"\"\n}\n",
  "    var closest_vowel string = \"\"\n    var consonant_count int = 0\n    var closest_pos\
    \ int = -1\n    for _, c := range word {\n        if !is_vowel(c) {\n        \
    \    consonant_count++\n        } else {\n            if consonant_count >= 2\
    \ {\n                closest_vowel = string(c)\n                break\n      \
    \      } else {\n                closest_pos = -1\n            }\n        }\n\
    \        closest_pos++\n    }\n    return closest_vowel\n}\n", "    vowels :=\
    \ []string {\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word) - 1; i\
    \ >= 0; i-- {\n        for _, v := range vowels {\n            if string(word[i])\
    \ == v {\n                if i == len(word) - 1 {\n                    break\n\
    \                }\n                for j := i - 1; j >= 0; j-- {\n          \
    \          for _, v := range vowels {\n                        if string(word[j])\
    \ == v {\n                            break\n                        }\n     \
    \                   if j == 0 {\n                            return string(word[i])\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    return \"\"\n}\n", "    var vowels string = \"\
    AEIOUaeiou\"\n    var i int\n    var vowel_index int = -1\n    var consonant_index\
    \ int = -1\n    var result string = \"\"\n    for i = len(word) - 1; i >= 0; i--\
    \ {\n        if -1 == consonant_index && -1 == vowel_index {\n            if strings.Contains(vowels,\
    \ string(word[i])) {\n                vowel_index = i\n            } else {\n\
    \                consonant_index = i\n            }\n        } else if -1 == consonant_index\
    \ {\n            if strings.Contains(vowels, string(word[i])) {\n            \
    \    vowel_index = i\n            } else {\n                consonant_index =\
    \ i\n                result = string(word[vowel_index])\n                break\n\
    \            }\n        } else if -1 == vowel_index {\n            if strings.Contains(vowels,\
    \ string(word[i])) {\n                vowel_index = i\n                result\
    \ = string(word[vowel_index])\n                break\n            } else {\n \
    \               consonant_index = i\n            }\n        }\n    }\n    return\
    \ result\n}\n", "    vowels := \"AEIOUaeiou\"\n    cons := \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\
    \n    var found string\n    var pos int\n\n    for i := len(word) - 1; i >= 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            continue\n\
    \        }\n        if strings.Contains(cons, string(word[i])) {\n           \
    \ found = string(word[i])\n            pos = i\n            break\n        }\n\
    \    }\n\n    if found == \"\" {\n        return \"\"\n    }\n\n    for i := pos\
    \ + 1; i < len(word); i++ {\n        if strings.Contains(vowels, string(word[i]))\
    \ {\n            return string(word[i])\n        }\n    }\n\n    return \"\"\n\
    }\n", "    for i := len(word) - 1; i > 0; i-- {\n        if !is_vowel(word[i])\
    \ && is_vowel(word[i-1]) {\n            return string(word[i-1])\n        }\n\
    \    }\n    return \"\"\n}\n", "    ret := \"\"\n    first_consonant := true\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        ch := string(word[i])\n  \
    \      if ch == \"a\" || ch == \"e\" || ch == \"i\" || ch == \"o\" || ch == \"\
    u\" {\n            if !first_consonant {\n                ret = ch\n         \
    \       break\n            }\n        } else {\n            first_consonant =\
    \ false\n        }\n    }\n    return ret\n}\n", "    i := len(word) - 1\n   \
    \ var prev, prevPrev rune\n    for ; i >= 0; i-- {\n        if i == len(word)\
    \ - 1 {\n            prev = rune(word[i])\n        } else if i == len(word) -\
    \ 2 {\n            prevPrev = rune(word[i])\n        } else {\n            prevPrev\
    \ = prev\n            prev = rune(word[i])\n        }\n        if prevPrev ==\
    \ 'a' || prevPrev == 'e' || prevPrev == 'i' || prevPrev == 'o' || prevPrev ==\
    \ 'u' ||\n           prevPrev == 'A' || prevPrev == 'E' || prevPrev == 'I' ||\
    \ prevPrev == 'O' || prevPrev == 'U' {\n            return \"\"\n        }\n \
    \       if prev == 'a' || prev == 'e' || prev == 'i' || prev == 'o' || prev ==\
    \ 'u' ||\n           prev == 'A' || prev == 'E' || prev == 'I' || prev == 'O'\
    \ || prev == 'U' {\n            if i == 0 {\n                return \"\"\n   \
    \         }\n            current := rune(word[i - 1])\n            if current\
    \ == 'a' || current == 'e' || current == 'i' || current == 'o' || current == 'u'\
    \ ||\n               current == 'A' || current == 'E' || current == 'I' || current\
    \ == 'O' || current == 'U' {\n                return \"\"\n            }\n   \
    \         return string(prev)\n        }\n    }\n    return \"\"\n}\n", "    consonants\
    \ := []rune{'B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R',\
    \ 'S', 'T', 'V', 'W', 'X', 'Y', 'Z'}\n    vowels := []rune{'A', 'E', 'I', 'O',\
    \ 'U'}\n    all_letters := append(consonants, vowels...)\n    l := len(word)\n\
    \    for i := range word {\n        for _, c := range consonants {\n         \
    \   if word[i] == c {\n                for j := i + 1; j < l; j++ {\n        \
    \            for _, v := range vowels {\n                        if word[j] ==\
    \ v {\n                            return string(word[j])\n                  \
    \      }\n                    }\n                    for _, v := range consonants\
    \ {\n                        if word[j] == v {\n                            break\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    return \"\"\n}\n", "    vowels := map[string]int{\"\
    a\": 1, \"e\": 1, \"i\": 1, \"o\": 1, \"u\": 1,\n        \"A\": 1, \"E\": 1, \"\
    I\": 1, \"O\": 1, \"U\": 1}\n    var lastVowelPos int\n    var lastConsonantPos\
    \ int\n    for i, v := range word {\n        if _, ok := vowels[string(v)]; ok\
    \ {\n            lastVowelPos = i\n        } else {\n            lastConsonantPos\
    \ = i\n        }\n        if lastVowelPos > lastConsonantPos {\n            return\
    \ string(word[lastVowelPos])\n        }\n    }\n    return \"\"\n}\n", "    var\
    \ vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var closest string\n\
    \    closest = \"\"\n    var closestPos int\n    closestPos = -1\n    for i :=\
    \ len(word) - 1; i >= 0; i-- {\n        for j := 0; j < len(vowels); j++ {\n \
    \           if word[i] == vowels[j][0] {\n                if closestPos == -1\
    \ {\n                    closestPos = i\n                    closest = vowels[j]\n\
    \                } else if i > closestPos {\n                    closestPos =\
    \ i\n                    closest = vowels[j]\n                }\n            }\n\
    \        }\n    }\n    return closest\n}\n\ntype TestData ", "    // Your code\
    \ here\n}\n", "    // check the word len\n    // if the len is less than 3, return\
    \ \"\"\n    if len(word) < 3 {\n        return \"\"\n    }\n    // slice the string\
    \ from the end to first vowel\n    // which is the closest vowel from the end\
    \ of the string\n    // loop it\n    for i := len(word) - 1; i >= 0; i-- {\n \
    \       // check if it is a vowel\n        if is_vowel(word[i]) {\n          \
    \  // if it is a vowel, return it\n            return string(word[i])\n      \
    \  }\n    }\n    // otherwise return \"\"\n    return \"\"\n}\n", "    if len(word)\
    \ < 3 {\n        return \"\"\n    }\n    vowelDict := map[rune]int{'a':0, 'e':0,\
    \ 'i':0, 'o':0, 'u':0, 'A':0, 'E':0, 'I':0, 'O':0, 'U':0}\n    vowelRune := []rune{'a',\
    \ 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    lastConsonant, lastVowel :=\
    \ -1, -1\n    for i := len(word) - 1; i >= 0; i-- {\n        if _, ok := vowelDict[rune(word[i])];\
    \ ok {\n            lastVowel = i\n        } else {\n            if lastVowel\
    \ != -1 {\n                lastConsonant = i\n                break\n        \
    \    }\n        }\n    }\n    if lastConsonant == -1 || lastVowel == -1 {\n  \
    \      return \"\"\n    }\n    curVowel := rune(word[lastVowel])\n    for _, v\
    \ := range vowelRune {\n        if v == curVowel {\n            return string(v)\n\
    \        }\n    }\n    return \"\"\n}\n", "    vowels := \"AEIOUaeiou\"\n    var\
    \ positions []int\n    for _, i := range vowels {\n        for j, v := range word\
    \ {\n            if v == i {\n                positions = append(positions, j)\n\
    \            }\n        }\n    }\n    if len(positions) == 0 {\n        return\
    \ \"\"\n    }\n    last := len(word) - 1\n    if last - positions[len(positions)\
    \ - 1] == 1 {\n        return string(word[positions[len(positions) - 1]])\n  \
    \  }\n    if positions[0] == 0 {\n        return string(word[positions[0]])\n\
    \    }\n    return string(word[positions[0]])\n}\n", "    var vowels = map[rune]bool{'a':\
    \ true, 'e': true, 'i': true, 'o': true, 'u': true,\n        'A': true, 'E': true,\
    \ 'I': true, 'O': true, 'U': true}\n    last_is_vowel := false\n    closest_vowel\
    \ := \"\"\n    for i:=len(word)-1; i>=0; i-- {\n        current_rune := rune(word[i])\n\
    \        if vowels[current_rune] {\n            if last_is_vowel {\n         \
    \       continue\n            } else {\n                closest_vowel = string(current_rune)\n\
    \                last_is_vowel = true\n            }\n        } else {\n     \
    \       if last_is_vowel {\n                break\n            }\n        }\n\
    \    }\n    return closest_vowel\n}\n", "    return \"\"\n}\n", "    vowelIndex\
    \ := 0\n    var result string\n    fmt.Println(word)\n    for index, letter :=\
    \ range word {\n        if letter == 'a' || letter == 'e' || letter == 'i' ||\
    \ letter == 'o' || letter == 'u' {\n            vowelIndex = index\n         \
    \   if index == 0 {\n                continue\n            } else if index ==\
    \ len(word) - 1 {\n                if word[index - 1] == 'a' || word[index - 1]\
    \ == 'e' || word[index - 1] == 'i' || word[index - 1] == 'o' || word[index - 1]\
    \ == 'u' {\n                    continue\n                } else {\n         \
    \           result = string(letter)\n                    break\n             \
    \   }\n            } else {\n                if word[index - 1] == 'a' || word[index\
    \ - 1] == 'e' || word[index - 1] == 'i' || word[index - 1] == 'o' || word[index\
    \ - 1] == 'u' {\n                    continue\n                } else {\n    \
    \                result = string(letter)\n                    break\n        \
    \        }\n            }\n        }\n    }\n    return result\n}\n", "\t// find\
    \ the first vowel from the end of the string\n\tindex := len(word) - 1\n\tvowels\
    \ := map[string]bool{\n\t\t\"a\": true,\n\t\t\"e\": true,\n\t\t\"i\": true,\n\t\
    \t\"o\": true,\n\t\t\"u\": true,\n\t}\n\tfor ; index >= 0; index -- {\n\t\tif\
    \ _, is_vowel := vowels[string(word[index])]; is_vowel {\n\t\t\tbreak\n\t\t}\n\
    \t}\n\t// if index <= 0, we don't find any vowel\n\tif index <= 0 {\n\t\treturn\
    \ \"\"\n\t}\n\t// search back and find a consonant\n\tfor i := index - 1; i >=\
    \ 0; i -- {\n\t\tif _, is_vowel := vowels[string(word[i])]; !is_vowel {\n\t\t\t\
    return string(word[index])\n\t\t}\n\t}\n\treturn \"\"\n}\n", "    var vowel rune\n\
    \    var consonant rune\n    for idx, l := range word {\n        if l == 'a' ||\
    \ l == 'e' || l == 'i' || l == 'o' || l == 'u' {\n            vowel = l\n    \
    \    } else {\n            consonant = l\n        }\n        if idx == len(word)\
    \ - 1 {\n            return \"\"\n        }\n        if vowel != 0 && consonant\
    \ != 0 {\n            if idx == 0 {\n                if word[idx + 1] == 'a' ||\
    \ word[idx + 1] == 'e' || word[idx + 1] == 'i' || word[idx + 1] == 'o' || word[idx\
    \ + 1] == 'u' {\n                    return \"\"\n                }\n        \
    \    } else {\n                return string(vowel)\n            }\n        }\n\
    \    }\n    return \"\"\n}\n", "    var (\n        vowels = []string{\"a\", \"\
    e\", \"i\", \"o\", \"u\"}\n        distances = make([]int, len(vowels))\n    \
    \    min_distance int\n        closest_vowel string\n    )\n    for i, v := range\
    \ vowels {\n        distances[i] = get_distance(word, v)\n    }\n    min_distance\
    \ = min(distances)\n    if min_distance == -1 {\n        return \"\"\n    }\n\
    \    for i, d := range distances {\n        if d == min_distance {\n         \
    \   closest_vowel = vowels[i]\n            break\n        }\n    }\n    return\
    \ closest_vowel\n}\n", "\tvar i, j int\n\n\t// try to find the first vowel from\
    \ the end\n\tfor i = len(word) - 1; i >= 0; i-- {\n\t\tif is_vowel(word[i]) {\n\
    \t\t\t// try to find the first consonant before the vowel\n\t\t\tfor j = i-1;\
    \ j >= 0; j-- {\n\t\t\t\tif !is_vowel(word[j]) {\n\t\t\t\t\t// it's OK, return\
    \ the vowel\n\t\t\t\t\treturn string(word[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\t// no\
    \ consonant found before, try to find consonant after this vowel\n\t\t\tfor j\
    \ = i+1; j < len(word); j++ {\n\t\t\t\tif !is_vowel(word[j]) {\n\t\t\t\t\t// it's\
    \ OK, return the vowel\n\t\t\t\t\treturn string(word[i])\n\t\t\t\t}\n\t\t\t}\n\
    \t\t\t// no consonant found after, try to find another vowel\n\t\t}\n\t}\n\treturn\
    \ \"\"\n}\n", "    vowelSet := []rune{'a', 'e', 'i', 'o', 'u'}\n    consonantSet\
    \ := []rune{'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r',\
    \ 's', 't', 'v', 'w', 'x', 'y', 'z'}\n    var res rune\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] ==\
    \ 'i' || word[i] == 'o' || word[i] == 'u' {\n            res = rune(word[i])\n\
    \            if i < len(word) - 1 && word[i+1] == 'b' || word[i+1] == 'c' || word[i+1]\
    \ == 'd' || word[i+1] == 'f' || word[i+1] == 'g' || word[i+1] == 'h' || word[i+1]\
    \ == 'j' || word[i+1] == 'k' || word[i+1] == 'l' || word[i+1] == 'm' || word[i+1]\
    \ == 'n' || word[i+1] == 'p' || word[i+1] == 'q' || word[i+1] == 'r' || word[i+1]\
    \ == 's' || word[i+1] == 't' || word[i+1] == 'v' || word[i+1] == 'w' || word[i+1]\
    \ == 'x' || word[i+1] == 'y' || word[i+1] == 'z' {\n                if i > 0 &&\
    \ word[i-1] == 'b' || word[i-1] == 'c' || word[i-1] == 'd' || word[i-1] == 'f'\
    \ || word[i-1] == 'g' || word[i-1] == 'h' || word[i-1] == 'j' || word[i-", " \
    \   vowels := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true,\
    \ \"u\": true}\n    for i := len(word) - 1; i >= 0; i-- {\n        cur := string(word[i])\n\
    \        if vowels[cur] {\n            return cur\n        }\n    }\n    return\
    \ \"\"\n}\n", "    var closest_vowel string = \"\"\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if len(closest_vowel) > 0 {\n            if len(word)\
    \ - 1 == i {\n                return closest_vowel\n            }\n          \
    \  if word[i+1] == 'a' ||\n                word[i+1] == 'e' ||\n             \
    \   word[i+1] == 'i' ||\n                word[i+1] == 'o' ||\n               \
    \ word[i+1] == 'u' {\n                return closest_vowel\n            }\n  \
    \      }\n\n        if word[i] == 'a' ||\n            word[i] == 'e' ||\n    \
    \        word[i] == 'i' ||\n            word[i] == 'o' ||\n            word[i]\
    \ == 'u' {\n            closest_vowel = string(word[i])\n        }\n    }\n  \
    \  return closest_vowel\n}\n", "\t// TODO: implement here\n    return \"\"\n}\n",
  "    var is_consonant = func(ch byte) bool {\n        return ch != 'a' && ch !=\
    \ 'e' && ch != 'i' && ch != 'o' && ch != 'u'\n    }\n    var first_vowel int =\
    \ -1\n    for i := len(word) - 1; i >= 0; i-- {\n        ch := word[i]\n     \
    \   if is_consonant(ch) {\n            if first_vowel != -1 {\n              \
    \  return string(word[first_vowel])\n            }\n        } else {\n       \
    \     if first_vowel == -1 {\n                first_vowel = i\n            }\n\
    \        }\n    }\n    return \"\"\n}\n", "    if len(word) < 2 {\n        return\
    \ \"\"\n    }\n    var is_vowel = func(c rune) bool {\n        return c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n               c == 'A'\
    \ || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n    }\n    i := len(word) -\
    \ 1\n    var prev rune\n    for i >= 0 {\n        c := rune(word[i])\n       \
    \ if is_vowel(c) {\n            if is_vowel(prev) {\n                i--\n   \
    \             continue\n            }\n            return string(c)\n        }\n\
    \        prev = c\n        i--\n    }\n    return \"\"\n}\n", "    if word ==\
    \ \"\" {\n        return \"\"\n    }\n    vowels := []string{\"a\", \"e\", \"\
    i\", \"o\", \"u\"}\n    last_consonant := \"\"\n    closest_vowel := \"\"\n  \
    \  for _, v := range word {\n        if string(v) == \"a\" || string(v) == \"\
    e\" || string(v) == \"i\" || string(v) == \"o\" || string(v) == \"u\" {\n    \
    \        // fmt.Println(\"vowel:\", string(v))\n            if last_consonant\
    \ != \"\" {\n                return string(v)\n            }\n        } else {\n\
    \            // fmt.Println(\"consonant:\", string(v))\n            last_consonant\
    \ = string(v)\n        }\n    }\n    return closest_vowel\n}\n", "    vowels :=\
    \ \"aeiou\"\n    for i:=len(word)-1; i>=0; i-- {\n        for j:=0; j<len(vowels);\
    \ j++ {\n            if word[i] == byte(vowels[j]) {\n                if i+1 ==\
    \ len(word) {\n                    return \"\"\n                }\n          \
    \      return string(word[i])\n            }\n        }\n    }\n    return \"\"\
    \n}\n", "    return \"\"\n}\n", "    return \"\"\n}\n", "    consonants := []string{\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\"}\n    vowels := []string{\"\
    a\", \"e\", \"i\", \"o\", \"u\"}\n    closest_vowel := \"\"\n    last_consonant\
    \ := \"\"\n    is_last_consonant := false\n    is_first_vowel := false\n    is_first_consonant\
    \ := false\n    for i := len(word) - 1; i >= 0; i-- {\n        if is_first_vowel\
    \ == false {\n            for _, vowel := range vowels {\n                if string(word[i])\
    \ == vowel {\n                    is_first_vowel = true\n                    break\n\
    \                }\n            }\n        }\n        if is_first_consonant ==\
    \ false {\n            for _, consonant := range consonants {\n              \
    \  if string(word[i]) == consonant {\n                    is_first_consonant =\
    \ true\n                    break\n                }\n            }\n        }\n\
    \        if is_first_vowel == true && is_first_consonant == true {\n         \
    \   if is_last_consonant == false {\n                for _, consonant := range\
    \ consonants {\n                    if string(word[i]) == consonant {\n      \
    \                  is_last_consonant = true\n                        last_consonant\
    \ = string(word[i])\n                        break\n                    }\n  \
    \              }\n            } else {\n                for _, vowel := range\
    \ vowels {\n                    if string(word[i]) == vowel {\n              \
    \          closest_vowel = string(word[i])\n                        break\n  \
    \                  }\n                }\n                break\n            }\n\
    \        }\n    }\n    return closest_vowel\n}\n", "    vowels := []string{\"\
    a\", \"e\", \"i\", \"o\", \"u\"}\n    consonants := []string{\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    for i:= len(word)-1;\
    \ i>=0; i-- {\n        for _, v := range vowels {\n            if word[i] == byte(v[0])\
    \ {\n                if i+1 < len(word) {\n                    for _, c := range\
    \ consonants {\n                        if word[i+1] == byte(c[0]) {\n       \
    \                     return string(word[i])\n                        }\n    \
    \                }\n                }\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n", "    var vowels string = \"AEIOUaeiou\"\n    var (\n        flag,\
    \ found int = 0, 0\n        closest_vowel string = \"\"\n    )\n    // find the\
    \ first vowel, ignore the rest.\n    for i := len(word) - 1; i >= 0; i-- {\n \
    \       for _, ch := range vowels {\n            if string(ch) == string(word[i])\
    \ {\n                if flag == 0 {\n                    closest_vowel = string(word[i])\n\
    \                    flag = 1\n                }\n                found = 1\n\
    \                break\n            }\n        }\n        if found == 1 {\n  \
    \          break\n        }\n    }\n    return closest_vowel\n}\n", "    for i\
    \ := len(word) - 1; i > 0; i-- {\n        c := word[i]\n        switch c {\n \
    \       case 'a', 'e', 'i', 'o', 'u':\n            if word[i-1] == 'a' || word[i-1]\
    \ == 'e' || word[i-1] == 'i' || word[i-1] == 'o' || word[i-1] == 'u' {\n     \
    \           continue\n            }\n            return string(c)\n        }\n\
    \    }\n    return \"\"\n}\n", "    vowels := \"aeiou\"\n    closestVowel := \"\
    \"\n    for i, r := range word {\n        if i == 0 {\n            continue\n\
    \        }\n        if closestVowel != \"\" {\n            return closestVowel\n\
    \        }\n        if vowels[r] == -1 {\n            continue\n        }\n  \
    \      // Found a vowel\n        if i < len(word) - 1 {\n            nextR :=\
    \ word[i+1]\n            if vowels[nextR] == -1 {\n                closestVowel\
    \ = string(r)\n            }\n        }\n    }\n    return closestVowel\n}\n",
  "    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        for _, vowel := range vowels {\n            if i\
    \ > 0 && word[i] == vowel[0] && word[i-1] != vowel[0] {\n                return\
    \ vowel\n            }\n        }\n    }\n    return \"\"\n}\n", "    vowels :=\
    \ []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        for _, v := range vowels {\n            if word[i] == v[0]\
    \ {\n                if i > 0 && i < len(word) - 1 {\n                    if !contains(vowels,\
    \ string(word[i-1])) && !contains(vowels, string(word[i+1])) {\n             \
    \           return string(word[i])\n                    }\n                }\n\
    \            }\n        }\n    }\n    return \"\"\n}\n", "    // TODO: implement\n\
    \    return \"\"\n}\n", "    const vowels = \"aeiou\"\n    var last_consonant\
    \ rune\n    is_first_letter := true\n    for i := len(word) - 1; i >= 0; i-- {\n\
    \        if i == 0 {\n            return \"\"\n        }\n        current_letter\
    \ := rune(word[i])\n        if current_letter == ' ' {\n            continue\n\
    \        }\n        if is_first_letter {\n            if contains_vowel(current_letter,\
    \ vowels) {\n                return \"\"\n            }\n            is_first_letter\
    \ = false\n            last_consonant = current_letter\n            continue\n\
    \        }\n        if contains_vowel(current_letter, vowels) {\n            if\
    \ contains_vowel(last_consonant, vowels) {\n                return \"\"\n    \
    \        }\n            return string(current_letter)\n        }\n        last_consonant\
    \ = current_letter\n    }\n    return \"\"\n}\n", "    var vowels = []string{\"\
    a\", \"e\", \"i\", \"o\", \"u\"}\n    var result = \"\"\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if hasConsonant(word[i-1:i]) && hasConsonant(word[i+1:i+2])\
    \ {\n            for _, v := range vowels {\n                if word[i:i+1] ==\
    \ v {\n                    result = v\n                    break\n           \
    \     }\n            }\n        }\n    }\n    return result\n}\n", "    var vowels\
    \ = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var consonants = []string{\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    var consonantPos\
    \ = make([]int, 0)\n    var vowelPos = make([]int, 0)\n    for i, v := range word\
    \ {\n        if isVowel(string(v), vowels) {\n            vowelPos = append(vowelPos,\
    \ i)\n        }\n        if isConsonant(string(v), consonants) {\n           \
    \ consonantPos = append(consonantPos, i)\n        }\n    }\n    if len(consonantPos)\
    \ < 2 {\n        return \"\"\n    }\n    for i, v := range consonantPos {\n  \
    \      if i != 0 && i != len(consonantPos) - 1 {\n            if vowelPos[0] >\
    \ v && vowelPos[len(vowelPos) - 1] < consonantPos[i + 1] {\n                return\
    \ word[vowelPos[0]:vowelPos[len(vowelPos) - 1] + 1]\n            }\n        }\n\
    \    }\n    return \"\"\n}\n", "    const vowels = \"aeiou\"\n    var has_vowel,\
    \ has_consonant bool\n    for i := len(word) - 1; i >= 0; i-- {\n        c :=\
    \ word[i]\n        if strings.ContainsRune(vowels, c) {\n            has_vowel\
    \ = true\n        } else {\n            has_consonant = true\n        }\n    \
    \    if has_vowel && has_consonant {\n            return string(c)\n        }\n\
    \    }\n    return \"\"\n}\n", "    var i, len int\n    var c1, c2, c_temp string\n\
    \    var vowel_set = map[string]bool{\n        \"a\": true,\n        \"e\": true,\n\
    \        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n        \"\
    A\": true,\n        \"E\": true,\n        \"I\": true,\n        \"O\": true,\n\
    \        \"U\": true,\n    }\n    len = len(word)\n    for i = len - 1; i > 0;\
    \ i-- {\n        c_temp = string(word[i])\n        if vowel_set[c_temp] {\n  \
    \          c2 = c_temp\n            break\n        }\n    }\n    for i = i - 1;\
    \ i >= 0; i-- {\n        c_temp = string(word[i])\n        if vowel_set[c_temp]\
    \ {\n            c1 = c_temp\n            break\n        }\n    }\n    if vowel_set[c1]\
    \ {\n        return c1\n    } else if vowel_set[c2] {\n        return c2\n   \
    \ } else {\n        return \"\"\n    }\n}\n", "    var vowels = []string{\"a\"\
    , \"e\", \"i\", \"o\", \"u\"}\n    var closest = \"\"\n    var distance = 0\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n\
    \            if v == string(word[i]) {\n                if distance == 0 {\n \
    \                   closest = string(word[i])\n                    distance =\
    \ 1\n                } else if closest != \"\" && distance < len(word) - i {\n\
    \                    closest = string(word[i])\n                    distance =\
    \ len(word) - i\n                }\n            }\n        }\n    }\n    return\
    \ closest\n}\n", "    var cons = \"bcdfghjklmnpqrstvwxyz\"\n    var vowels = \"\
    aeiou\"\n    var word_in_cons = true\n    var min_distance = len(word)\n    var\
    \ min_vowel = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        var current_letter\
    \ = string(word[i])\n        var in_cons = false\n        for j := 0; j < len(cons);\
    \ j++ {\n            if cons[j] == current_letter[0] {\n                in_cons\
    \ = true\n                break\n            }\n        }\n        if in_cons\
    \ && !word_in_cons {\n            for j := 0; j < len(vowels); j++ {\n       \
    \         if vowels[j] == current_letter[0] {\n                    if min_distance\
    \ > i {\n                        min_distance = i\n                        min_vowel\
    \ = current_letter\n                    }\n                    break\n       \
    \         }\n            }\n        }\n        word_in_cons = in_cons\n    }\n\
    \    return min_vowel\n}\n", "    vowels := map[string]bool{\n        \"a\": true,\n\
    \        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n        \"\
    u\": true,\n    }\n    var prev_char string\n    var closest_vowel string\n  \
    \  var found_consonant bool\n    for i := len(word) - 1; i >= 0; i-- {\n     \
    \   current_char := string(word[i])\n        if i == len(word) - 1 {\n       \
    \     if !vowels[current_char] {\n                found_consonant = true\n   \
    \         }\n        } else {\n            if found_consonant {\n            \
    \    if vowels[current_char] {\n                    closest_vowel = current_char\n\
    \                    break\n                }\n            } else {\n        \
    \        if !vowels[current_char] {\n                    found_consonant = true\n\
    \                }\n            }\n        }\n        prev_char = current_char\n\
    \    }\n    return closest_vowel\n}\n", "    for i := len(word) - 1; i > 0; i--\
    \ {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i]\
    \ == 'o' || word[i] == 'u' {\n            if word[i-1] != 'a' && word[i-1] !=\
    \ 'e' && word[i-1] != 'i' && word[i-1] != 'o' && word[i-1] != 'u' {\n        \
    \        return string(word[i])\n            }\n        }\n    }\n    return \"\
    \"\n}\n", "    vowels := map[rune]bool{'a': true, 'e': true, 'i': true, 'o': true,\
    \ 'u': true, 'A': true, 'E': true, 'I': true, 'O': true, 'U': true}\n    var offset\
    \ int\n    for i := len(word) - 1; i >= 0; i-- {\n        if !vowels[rune(word[i])]\
    \ {\n            offset = i + 1\n            break\n        }\n    }\n    if offset\
    \ == 0 {\n        return \"\"\n    }\n    var result rune\n    var min int\n \
    \   for i := offset; i < len(word); i++ {\n        if vowels[rune(word[i])] {\n\
    \            temp := i - offset\n            if min == 0 || temp < min {\n   \
    \             min = temp\n                result = rune(word[i])\n           \
    \ }\n        }\n    }\n    return string(result)\n}\n", "    vowels := map[string]bool{\"\
    a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    words := []rune(word)\n\
    \    last_vowel := \"\"\n    for i := len(words) - 1; i >= 0; i-- {\n        char\
    \ := string(words[i])\n        if vowels[char] {\n            if last_vowel ==\
    \ \"\" {\n                last_vowel = char\n            }\n            continue\n\
    \        }\n        return last_vowel\n    }\n    return \"\"\n}\n", "    // your\
    \ code here\n    return \"\"\n}\n", "    vowels := \"aeiou\"\n    word = word[:len(word)-1]\n\
    \    for i := len(word)-1; i >= 0; i-- {\n        if strings.ContainsRune(vowels,\
    \ rune(word[i])) {\n            return string(word[i])\n        }\n    }\n   \
    \ return \"\"\n}\n", "    vowels := \"AEIOU\"\n    word = word[::-1]\n    var\
    \ found_vowel string\n    for i, c := range word {\n        if vowels[0] == c\
    \ || vowels[1] == c || vowels[2] == c || vowels[3] == c || vowels[4] == c {\n\
    \            if i == 0 {\n                break\n            }\n            if\
    \ vowels[0] != word[i-1] && vowels[1] != word[i-1] && vowels[2] != word[i-1] &&\
    \ vowels[3] != word[i-1] && vowels[4] != word[i-1] {\n                found_vowel\
    \ = string(c)\n                break\n            }\n        }\n    }\n    return\
    \ found_vowel\n}\n", "    // Write your code here!\n    vowels := []string {\"\
    a\", \"e\", \"i\", \"o\", \"u\"}\n    vowel_dict := make(map[string]bool)\n  \
    \  for _, vowel := range vowels {\n        vowel_dict[vowel] = true\n    }\n \
    \   for i:= len(word)-1; i>=0; i-- {\n        if vowel_dict[string(word[i])] &&\
    \ i > 0 && !vowel_dict[string(word[i-1])] {\n            return string(word[i])\n\
    \        }\n    }\n    return \"\"\n}\n", "    // Starting the counter at -1 because\
    \ the first letter is not considered\n    counter := -1\n    for i := 0; i < len(word);\
    \ i++ {\n        character := string(word[i])\n        if character == \"a\" ||\
    \ character == \"e\" || character == \"i\" || character == \"o\" || character\
    \ == \"u\" {\n            counter = 0\n        } else {\n            if counter\
    \ >= 0 {\n                counter++\n            }\n        }\n    }\n    return\
    \ string(word[len(word) - counter - 1])\n}\n", "\tvowels := []string{\"a\", \"\
    e\", \"i\", \"o\", \"u\"}\n\tvowel_map := make(map[string]int)\n\tfor _, v :=\
    \ range vowels {\n\t\tvowel_map[v] = 1\n\t}\n\t\n\tvar found_vowel string\n\t\
    for i := len(word) - 1; i >= 0; i-- {\n\t\tc := string(word[i])\n\t\tif _, ok\
    \ := vowel_map[c]; ok {\n\t\t\tfound_vowel = c\n\t\t\tbreak\n\t\t}\n\t}\n\t\n\t\
    if found_vowel == \"\" {\n\t\treturn \"\"\n\t}\n\t\n\tfor i := len(word) - 1;\
    \ i >= 0; i-- {\n\t\tc := string(word[i])\n\t\tif _, ok := vowel_map[c]; !ok {\n\
    \t\t\tif found_vowel == c {\n\t\t\t\tfound_vowel = \"\"\n\t\t\t} else {\n\t\t\t\
    \tbreak\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn found_vowel\n}\n", "    var chars =\
    \ []rune(word)\n    var vowels = map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true}\n    var current = 0\n    var closest = 0\n    var distance\
    \ = len(chars)\n    var i = len(chars) - 1\n    for i >= 0 {\n        if vowels[chars[i]]\
    \ {\n            current = i\n            if current - closest <= distance {\n\
    \                distance = current - closest\n                break\n       \
    \     }\n        } else {\n            closest = i\n        }\n        i--\n \
    \   }\n    if distance == len(chars) {\n        return \"\"\n    }\n    return\
    \ string(chars[current])\n}\n", "\tvar vowels = \"aeiouAEIOU\"\n\tvar consonants\
    \ = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n\tresult := \"\"\n\twordBytes\
    \ := []byte(word)\n\twordLen := len(wordBytes)\n\tif wordLen == 1 {\n\t\treturn\
    \ result\n\t}\n\tfor i := wordLen - 1; i > 0; i-- {\n\t\tif idx := strings.IndexByte(vowels,\
    \ wordBytes[i]); idx > -1 {\n\t\t\tif idx := strings.IndexByte(consonants, wordBytes[i-1]);\
    \ idx > -1 {\n\t\t\t\tresult = string(wordBytes[i])\n\t\t\t\tbreak\n\t\t\t}\n\t\
    \t}\n\t}\n\treturn result\n}\n", "    word_len := len(word)\n    for i := word_len\
    \ - 1; i > 0; i-- {\n        if is_vowel(word[i]) {\n            var left int\n\
    \            for left = i-1; left >= 0; left-- {\n                if is_vowel(word[left])\
    \ {\n                    break\n                }\n            }\n           \
    \ if left < 0 {\n                return string(word[i])\n            }\n     \
    \   }\n    }\n    return \"\"\n}\n", "    vowels := map[string]int{\n        \"\
    a\": 0,\n        \"e\": 0,\n        \"i\": 0,\n        \"o\": 0,\n        \"u\"\
    : 0,\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if _, exists :=\
    \ vowels[string(word[i])]; exists {\n            return string(word[i])\n    \
    \    }\n    }\n    return \"\"\n}\n", "    vowels := \"aeiou\"\n    index := -1\n\
    \    min_distance := len(word)\n    for i, c := range word {\n        if strings.IndexByte(vowels,\
    \ byte(c)) != -1 {\n            if i == 0 || i == len(word) - 1 {\n          \
    \      continue\n            }\n            left := strings.IndexByte(vowels,\
    \ word[i-1])\n            right := strings.IndexByte(vowels, word[i+1])\n    \
    \        if left == -1 && right == -1 {\n                if min_distance > i {\n\
    \                    min_distance = i\n                    index = i\n       \
    \         }\n            }\n        }\n    }\n    if index != -1 {\n        return\
    \ string(word[index])\n    }\n    return \"\"\n}\n", "    l := len(word)\n   \
    \ for i := l - 1; i > 0; i-- {\n        if isVowel(word[i]) && !isVowel(word[i-1])\
    \ {\n            return string(word[i])\n        }\n    }\n    return \"\"\n}\n",
  "    vowels := \"aeiouAEIOU\"\n    var closest_vowel string\n    var closest_vowel_pos\
    \ int\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[i] != 0 {\n\
    \            closest_vowel_pos = i\n            closest_vowel = string(word[i])\n\
    \            break\n        }\n    }\n    for i := closest_vowel_pos - 1; i >=\
    \ 0; i-- {\n        if vowels[i] == 0 {\n            return closest_vowel\n  \
    \      }\n    }\n    return \"\"\n}\n", "    if len(word) < 3 {\n        return\
    \ \"\"\n    }\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true, 'o':\
    \ true, 'u': true, 'A': true, 'E': true, 'I': true, 'O': true, 'U': true}\n  \
    \  var c1, c2 rune\n    var found bool\n    for i := len(word) - 1; i >= 0; i--\
    \ {\n        c1, c2 = rune(word[i]), c1\n        if vowels[c1] && vowels[c2] {\n\
    \            found = true\n            break\n        }\n    }\n    if found {\n\
    \        return string(c1)\n    }\n    return \"\"\n}\n", "    vowels := \"AEIOUaeiou\"\
    \n    prevIsVowel := false\n    var i int\n    for i = len(word) - 1; i >= 0;\
    \ i-- {\n        if strings.Contains(vowels, string(word[i])) {\n            if\
    \ prevIsVowel {\n                break\n            }\n            prevIsVowel\
    \ = true\n        } else {\n            prevIsVowel = false\n        }\n    }\n\
    \    if i >= 0 {\n        return string(word[i])\n    }\n    return \"\"\n}\n",
  "    chars := []rune(word)\n    vowels := []rune(\"aeiouAEIOU\")\n    var vowel\
    \ rune\n    var distance int\n    for i := len(chars) - 1; i >= 0; i-- {\n   \
    \     if chars[i] == 'a' || chars[i] == 'e' || chars[i] == 'i' || chars[i] ==\
    \ 'o' || chars[i] == 'u' ||\n           chars[i] == 'A' || chars[i] == 'E' ||\
    \ chars[i] == 'I' || chars[i] == 'O' || chars[i] == 'U' {\n            if vowel\
    \ == 0 {\n                vowel = chars[i]\n                distance = len(chars)\
    \ - i\n            } else {\n                for j := 0; j < len(vowels); j++\
    \ {\n                    if vowel == vowels[j] {\n                        return\
    \ string(vowel)\n                    }\n                }\n            }\n   \
    \     } else {\n            if vowel != 0 {\n                if len(chars) - i\
    \ < distance {\n                    vowel = chars[i]\n                    distance\
    \ = len(chars) - i\n                }\n            }\n        }\n    }\n    return\
    \ \"\"\n}\n", "\t// TODO: Write your code here\n\treturn \"\"\n}\n", "    return\
    \ \"\";\n}\n", "    // your code here\n    return \"\"\n}\n", "    var vowel,\
    \ pos string\n    l := len(word)\n    for i := l - 1; i >= 0; i-- {\n        if\
    \ i == 0 {\n            return \"\"\n        }\n        v := string(word[i])\n\
    \        if v == \"a\" || v == \"e\" || v == \"i\" || v == \"o\" || v == \"u\"\
    \ {\n            if i - 1 >= 0 {\n                p := string(word[i - 1])\n \
    \               if p != \"a\" && p != \"e\" && p != \"i\" && p != \"o\" && p !=\
    \ \"u\" {\n                    return v\n                }\n            }\n  \
    \      }\n    }\n    return \"\"\n}\n", "    vowels := map[string]bool{\n    \
    \    \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"o\":\
    \ true,\n        \"u\": true,\n    }\n    result := \"\"\n    var first_vowel\
    \ string = \"\"\n    var second_vowel string = \"\"\n    //find the first vowel\n\
    \    for i := len(word) - 1; i >= 0; i-- {\n        cur_char := string(word[i])\n\
    \        if vowels[cur_char] {\n            first_vowel = cur_char\n         \
    \   break\n        }\n    }\n    //find the second vowel\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        cur_char := string(word[i])\n        if vowels[cur_char]\
    \ {\n            if cur_char != first_vowel {\n                second_vowel =\
    \ cur_char\n                break\n            }\n        }\n    }\n    //find\
    \ the closest vowel\n    if first_vowel != \"\" && second_vowel != \"\" {\n  \
    \      first_vowel_idx := len(word) - 1 - strings.LastIndex(word, first_vowel)\n\
    \        second_vowel_idx := len(word) - 1 - strings.LastIndex(word, second_vowel)\n\
    \        if first_vowel_idx > second_vowel_idx {\n            result = second_vowel\n\
    \        } else {\n            result = first_vowel\n        }\n    }\n    return\
    \ result\n}\n", "    cons := map[byte]bool{\n        'b': true, 'c': true, 'd':\
    \ true, 'f': true, 'g': true,\n        'h': true, 'j': true, 'k': true, 'l': true,\
    \ 'm': true,\n        'n': true, 'p': true, 'q': true, 'r': true, 's': true,\n\
    \        't': true, 'v': true, 'w': true, 'x': true, 'y': true, 'z': true,\n \
    \   }\n    vowels := map[byte]bool{\n        'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true,\n    }\n    p := len(word) - 1\n    for ; p >= 0; p--\
    \ {\n        if cons[word[p]] {\n            break\n        }\n    }\n    for\
    \ ; p >= 0; p-- {\n        if vowels[word[p]] {\n            return string(word[p])\n\
    \        }\n    }\n    return \"\"\n}\n", "    // your code here\n    return \"\
    \"\n}\n", "    l := len(word)\n    if l == 0 {\n        return \"\"\n    }\n \
    \   if l == 1 {\n        if word[0] == 'a' || word[0] == 'e' || word[0] == 'i'\
    \ || word[0] == 'o' || word[0] == 'u' {\n            return word\n        }\n\
    \        return \"\"\n    }\n    for i := l - 1; i > 0; i-- {\n        if word[i]\
    \ == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u'\
    \ {\n            if word[i-1] != 'a' && word[i-1] != 'e' && word[i-1] != 'i' &&\
    \ word[i-1] != 'o' && word[i-1] != 'u' {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n", "    word_len := len(word)\n\
    \    if word_len < 3 {\n        return \"\"\n    }\n    for i := word_len - 1;\
    \ i > 0; i-- {\n        left := word[i-1]\n        if left == 'a' || left == 'e'\
    \ || left == 'i' || left == 'o' || left == 'u' {\n            continue\n     \
    \   }\n        right := word[i]\n        if right == 'a' || right == 'e' || right\
    \ == 'i' || right == 'o' || right == 'u' {\n            return string(right)\n\
    \        }\n    }\n    return \"\"\n}\n", "    var vowels string = \"aeiou\"\n\
    \    var consonants string = \"bcdfghjklmnpqrstvwxyz\"\n    var wordLen int =\
    \ len(word)\n    var i int\n    var j int\n\n    for i = wordLen - 1; i >= 0;\
    \ i-- {\n        for j = 0; j < 5; j++ {\n            if word[i] == vowels[j]\
    \ {\n                return string(word[i])\n            }\n        }\n    }\n\
    \n    return \"\"\n}\n", "    var prev, curr rune\n    var vowel string\n    var\
    \ vowelInd int\n    for i,r := range word {\n        curr = prev\n        prev\
    \ = r\n        if i == len(word) - 1 {\n            break\n        }\n       \
    \ if is_vowel(curr) && !is_vowel(prev) {\n            vowel = string(curr)\n \
    \           vowelInd = i\n        }\n    }\n    if is_vowel(curr) && !is_vowel(prev)\
    \ {\n        vowel = string(curr)\n        vowelInd = len(word) - 1\n    }\n \
    \   if vowelInd == 0 {\n        return \"\"\n    }\n    for i, r := range word[vowelInd\
    \ + 1:] {\n        if is_vowel(r) {\n            return \"\"\n        }\n    \
    \    if !is_vowel(r) && i == len(word[vowelInd + 1:]) - 1 {\n            return\
    \ vowel\n        }\n    }\n    return \"\"\n}\n", "    vowels := []string{\"a\"\
    , \"e\", \"i\", \"o\", \"u\"}\n    current := len(word) - 1\n    for {\n     \
    \   if word[current] == 'a' || word[current] == 'e' || word[current] == 'i' ||\
    \ word[current] == 'o' || word[current] == 'u' {\n            return string(word[current])\n\
    \        }\n        current--\n        if current == 0 {\n            return \"\
    \"\n        }\n    }\n}\n", "    var consonants = make(map[string]bool)\n    consonants[\"\
    b\"] = true\n    consonants[\"c\"] = true\n    consonants[\"d\"] = true\n    consonants[\"\
    f\"] = true\n    consonants[\"g\"] = true\n    consonants[\"h\"] = true\n    consonants[\"\
    j\"] = true\n    consonants[\"k\"] = true\n    consonants[\"l\"] = true\n    consonants[\"\
    m\"] = true\n    consonants[\"n\"] = true\n    consonants[\"p\"] = true\n    consonants[\"\
    q\"] = true\n    consonants[\"r\"] = true\n    consonants[\"s\"] = true\n    consonants[\"\
    t\"] = true\n    consonants[\"v\"] = true\n    consonants[\"w\"] = true\n    consonants[\"\
    x\"] = true\n    consonants[\"y\"] = true\n    consonants[\"z\"] = true\n\n  \
    \  var vowels = make(map[string]bool)\n    vowels[\"a\"] = true\n    vowels[\"\
    e\"] = true\n    vowels[\"i\"] = true\n    vowels[\"o\"] = true\n    vowels[\"\
    u\"] = true\n\n    var consonant_index int = -1\n    var vowel_index int = -1\n\
    \    var min_index int = -1\n    var min_distance int = len(word)\n\n    for i,\
    \ c := range word {\n        s := string(c)\n        if consonants[s] == true\
    \ {\n            consonant_index = i\n            for j := i + 1; j < len(word);\
    \ j++ {\n                s = string(word[j])\n                if vowels[s] ==\
    \ true {\n                    vowel_index = j\n                    if vowel_index\
    \ - consonant_index < min_distance {\n                        min_distance = vowel_index\
    \ - consonant_index\n                        min_index = vowel_index\n       \
    \             }\n                }\n            }\n        }\n    }\n\n    if\
    \ min_index >= 0 {\n        return string(word[min_index])\n    } else {\n   \
    \     return \"\"\n    }\n}\n", "    // step 1. scan right to left\n    length\
    \ := len(word)\n    if length < 3 {\n        return \"\"\n    }\n    char := word[length-1]\n\
    \    if char != 'a' && char != 'e' && char != 'i' && char != 'o' && char != 'u'\
    \ {\n        return get_closest_vowel(word[:length-1])\n    } else {\n       \
    \ return char\n    }\n}\n", "    return \"u\"\n}\n", "    if word == \"\" {\n\
    \        return \"\"\n    }\n    current_vowel_pos := -1\n    best_vowel_pos :=\
    \ -1\n    cons_count := 0\n    for pos, char := range word {\n        if char\
    \ == 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n     \
    \       current_vowel_pos = pos\n            cons_count = 0\n        } else {\n\
    \            cons_count++\n            if cons_count == 2 {\n                if\
    \ best_vowel_pos == -1 || (current_vowel_pos > best_vowel_pos && current_vowel_pos\
    \ < pos) {\n                    best_vowel_pos = current_vowel_pos\n         \
    \       }\n            }\n        }\n    }\n    if best_vowel_pos == -1 {\n  \
    \      return \"\"\n    }\n    return string(word[best_vowel_pos])\n}\n", "  \
    \  if len(word) < 2 {\n        return \"\"\n    }\n    vowels := []string{\"a\"\
    , \"e\", \"i\", \"o\", \"u\"}\n    vowels_uppercase := []string{\"A\", \"E\",\
    \ \"I\", \"O\", \"U\"}\n    first_consonant := true\n    for i:= len(word)-1;\
    \ i>=0; i-- {\n        if first_consonant {\n            if not_in_slice(word[i:i+1],\
    \ vowels) && not_in_slice(word[i:i+1], vowels_uppercase) {\n                first_consonant\
    \ = false\n            }\n        } else {\n            if not_in_slice(word[i:i+1],\
    \ vowels) && not_in_slice(word[i:i+1], vowels_uppercase) {\n                return\
    \ \"\"\n            } else {\n                return word[i:i+1]\n           \
    \ }\n        }\n    }\n    return \"\"\n}\n", "    vowels := map[string]int{\n\
    \        \"a\": 1,\n        \"e\": 1,\n        \"i\": 1,\n        \"o\": 1,\n\
    \        \"u\": 1,\n        \"A\": 1,\n        \"E\": 1,\n        \"I\": 1,\n\
    \        \"O\": 1,\n        \"U\": 1,\n    }\n    has_vowel := false\n    for\
    \ _, letter := range word {\n        if _, ok := vowels[string(letter)]; ok {\n\
    \            has_vowel = true\n            break\n        }\n    }\n    if !has_vowel\
    \ {\n        return \"\"\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n \
    \       _, ok := vowels[string(word[i])]\n        if ok {\n            if i ==\
    \ len(word) - 1 {\n                return \"\"\n            }\n            _,\
    \ ok = vowels[string(word[i+1])]\n            if !ok {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n", " \
    \   // Fill this in.\n    vowels := \"aeiou\"\n    lastConsonant := len(word)\
    \ - 1\n    while lastConsonant >= 0 && !isConsonant(word[lastConsonant]) {\n \
    \       lastConsonant--\n    }\n    if lastConsonant < 0 {\n        return \"\"\
    \n    }\n    firstVowel := len(word) - 1\n    while firstVowel >= 0 && !isVowel(word[firstVowel])\
    \ {\n        firstVowel--\n    }\n    if firstVowel <= lastConsonant {\n     \
    \   return \"\"\n    }\n    closestVowel := firstVowel\n    for i := lastConsonant\
    \ + 1; i < firstVowel; i++ {\n        if isVowel(word[i]) && firstVowel - i <\
    \ firstVowel - closestVowel {\n            closestVowel = i\n        }\n    }\n\
    \    return string(word[closestVowel])\n}\n", "    vowels := map[string]int{\"\
    a\": 1, \"e\": 1, \"i\": 1, \"o\": 1, \"u\": 1, \"A\": 1, \"E\": 1, \"I\": 1,\
    \ \"O\": 1, \"U\": 1}\n    found_vowel := \"\"\n    for pos := len(word) - 1;\
    \ pos >= 0; pos-- {\n        if _, ok := vowels[string(word[pos])]; ok {\n   \
    \         found_vowel = string(word[pos])\n            break\n        }\n    }\n\
    \    for pos := len(word) - 1; pos >= 0; pos-- {\n        if _, ok := vowels[string(word[pos])];\
    \ !ok {\n            if found_vowel != \"\" {\n                return found_vowel\n\
    \            }\n        } else {\n            found_vowel = \"\"\n        }\n\
    \    }\n    return found_vowel\n}\n", "    var closestVowel string\n    vowels\
    \ := \"AEIOUaeiou\"\n    const None rune = 0\n\n    var prev rune = None\n   \
    \ var prevPrev rune = None\n    for _, current := range word {\n        if current\
    \ == prev && current == prevPrev {\n            continue\n        }\n\n      \
    \  if vowels[current] {\n            if prev == None || prev == prevPrev {\n \
    \               prevPrev = prev\n                prev = current\n            \
    \    continue\n            }\n            if closestVowel == \"\" || rune(closestVowel[0])\
    \ < current {\n                closestVowel = string(current)\n            }\n\
    \        }\n\n        prevPrev = prev\n        prev = current\n    }\n\n    return\
    \ closestVowel\n}\n", "    vowels := \"aeiou\"\n    var last_vowel string\n  \
    \  var last_consonant bool\n    for _, char := range word {\n        if last_consonant\
    \ && vowels[char] != -1 {\n            return string(char)\n        } else if\
    \ vowels[char] != -1 {\n            last_vowel = string(char)\n            last_consonant\
    \ = false\n        } else {\n            last_consonant = true\n        }\n  \
    \  }\n    return last_vowel\n}\n", "    // ---\n    if len(word) <= 2 {\n    \
    \    return \"\"\n    }\n    for i := len(word) - 2; i >= 0; i-- {\n        if\
    \ isVowel(word[i]) {\n            if isConsonant(word[i + 1]) {\n            \
    \    return string(word[i])\n            }\n        }\n    }\n    return \"\"\n\
    }\n", "    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i :=\
    \ len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n         \
    \   if word[i] == v[0] {\n                if i > 0 && i < len(word) - 1 {\n  \
    \                  if word[i-1] != v[0] && word[i+1] != v[0] {\n             \
    \           return v\n                    }\n                }\n            }\n\
    \        }\n    }\n    return \"\"\n}\n", "    return \"\"\n}\n", "\t// your code\
    \ here\n\tfor i := len(word) - 1; i > 0; i-- {\n\t\tif word[i] == 'a' || word[i]\
    \ == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n\t\t\tif word[i-1]\
    \ != 'a' && word[i-1] != 'e' && word[i-1] != 'i' && word[i-1] != 'o' && word[i-1]\
    \ != 'u' {\n\t\t\t\treturn string(word[i])\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\"\
    \n}\n", "    consonants := \"bcdfghjklmnpqrstvwxyz\"\n    vowels := \"aeiou\"\n\
    \    closest_vowel := \"\"\n    var i, j int\n    for i, j = len(word) - 1, len(word)\
    \ - 1; i >= 0; i-- {\n        for j >= 0 {\n            if strings.Contains(consonants,\
    \ string(word[j])) {\n                break\n            }\n            j--\n\
    \        }\n        if j < 0 {\n            return \"\"\n        }\n        if\
    \ strings.Contains(vowels, string(word[i])) {\n            if len(word) - 1 -\
    \ i > i - j {\n                closest_vowel = string(word[i])\n             \
    \   break\n            }\n        }\n    }\n    return closest_vowel\n}\n", " \
    \   var res string\n    for i := len(word) - 1; i >= 0; i-- {\n        if isVowel(word[i])\
    \ {\n            res = string(word[i])\n            break\n        }\n    }\n\
    \    return res\n}\n", "    // prepend a consonant\n    word = \"a\" + word\n\
    \    if len(word) < 3 {\n        return \"\"\n    }\n    var closest_vowel string\n\
    \    for i := 1; i < len(word) - 1; i++ {\n        // get the letter\n       \
    \ letter := string(word[i])\n        // check if letter is vowel\n        is_vowel\
    \ := letter == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\"\
    \ || letter == \"u\"\n        if is_vowel {\n            // get left and right\
    \ letters\n            left_letter := string(word[i - 1])\n            right_letter\
    \ := string(word[i + 1])\n            // check if left and right letters are consonants\n\
    \            is_left_consonant := left_letter != \"a\" && left_letter != \"e\"\
    \ && left_letter != \"i\" && left_letter != \"o\" && left_letter != \"u\"\n  \
    \          is_right_consonant := right_letter != \"a\" && right_letter != \"e\"\
    \ && right_letter != \"i\" && right_letter != \"o\" && right_letter != \"u\"\n\
    \            if is_left_consonant && is_right_consonant {\n                //\
    \ save letter if left and right letters are consonants\n                closest_vowel\
    \ = letter\n            }\n        }\n    }\n    return closest_vowel\n}\n", " \
    \   if word == \"\" {\n        return \"\"\n    }\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if i == 0 && isVowel(word[i]) {\n            return string(word[i])\n\
    \        }\n        if i == len(word) - 1 && isVowel(word[i]) {\n            return\
    \ string(word[i])\n        }\n        if isVowel(word[i]) && !isVowel(word[i+1])\
    \ && !isVowel(word[i-1]) {\n            return string(word[i])\n        }\n  \
    \  }\n    return \"\"\n}\n", "    for i := len(word) - 1; i > 0; i-- {\n     \
    \   if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' ||\
    \ word[i] == 'u' {\n            if word[i-1] != 'a' && word[i-1] != 'e' && word[i-1]\
    \ != 'i' && word[i-1] != 'o' && word[i-1] != 'u' {\n                return string(word[i])\n\
    \            }\n        }\n    }\n    return \"\"\n}\n", "    for i := len(word)\
    \ - 1; i > 0; i-- {\n        ch := word[i]\n        switch ch {\n        case\
    \ 'a', 'e', 'i', 'o', 'u':\n            if word[i - 1] != 'a' && word[i - 1] !=\
    \ 'e' && word[i - 1] != 'i' &&\n               word[i - 1] != 'o' && word[i -\
    \ 1] != 'u' {\n                return string(ch)\n            }\n        }\n \
    \   }\n    return \"\"\n}\n", "    vowels := \"aeiouAEIOU\"\n    var result string\n\
    \    min_index := len(word)\n    for i := len(word) - 1; i >= 0; i-- {\n     \
    \   c := word[i]\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\
    \ {\n            last_consonant := false\n            if i == len(word) - 1 {\n\
    \                last_consonant = true\n            } else {\n               \
    \ prev_c := word[i + 1]\n                if prev_c != 'a' && prev_c != 'e' &&\
    \ prev_c != 'i' && prev_c != 'o' && prev_c != 'u' &&\n                   prev_c\
    \ != 'A' && prev_c != 'E' && prev_c != 'I' && prev_c != 'O' && prev_c != 'U' {\n\
    \                    last_consonant = true\n                }\n            }\n\
    \            if last_consonant {\n                if i < min_index {\n       \
    \             min_index = i\n                    result = string(c)\n        \
    \        }\n            }\n        }\n    }\n    return result\n}\n", "    var\
    \ vowels, consonants = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}, []string{\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    var lst_consonant,\
    \ lst_vowel = word[len(word)-1], \"\"\n    for i := len(word)-2; i >= 0; i-- {\n\
    \        if is_letter_in_array(string(word[i]), consonants) {\n            lst_consonant\
    \ = string(word[i])\n            if is_letter_in_array(string(word[i+1]), vowels)\
    \ {\n                lst_vowel = string(word[i+1])\n                break\n  \
    \          }\n        }\n    }\n    return lst_vowel\n}\n", "    if len(word)\
    \ <= 2 {\n        return \"\"\n    }\n    vowels := []string{\"a\", \"e\", \"\
    i\", \"o\", \"u\"}\n    for i := len(word) - 2; i >= 0; i-- {\n        if is_consonant(word[i])\
    \ && is_consonant(word[i+1]) {\n            for _, vowel := range vowels {\n \
    \               if string(word[i+1]) == vowel {\n                    return vowel\n\
    \                }\n            }\n        }\n    }\n    return \"\"\n}\n", " \
    \   vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if stringInSlice(word[i:i+1], vowels) {\n      \
    \      return word[i:i+1]\n        }\n    }\n    return \"\"\n}\n", "    vowels\
    \ := []rune{'a', 'e', 'i', 'o', 'u'}\n    offset := 0\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        switch word[i] {\n        case 'a', 'e', 'i', 'o',\
    \ 'u':\n            offset = i\n        case 'b', 'c', 'd', 'f', 'g', 'h', 'j',\
    \ 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z':\n    \
    \        fmt.Println(word[offset:i])\n            return word[offset:i]\n    \
    \    }\n    }\n    return \"\"\n}\n", "    vowels := \"aeiou\"\n    var count\
    \ int\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[count] ==\
    \ word[i] {\n            return string(word[i])\n        }\n        count++\n\
    \    }\n    return \"\"\n}\n", "    vowels := []string{\"a\", \"e\", \"i\", \"\
    o\", \"u\"}\n    len_word := len(word)\n    for i := len_word - 1; i >= 0; i--\
    \ {\n        if string_in_slice(word[i:i+1], vowels) {\n            for j := i\
    \ - 1; j >= 0; j-- {\n                if string_in_slice(word[j:j+1], vowels)\
    \ {\n                    return word[i:i+1]\n                }\n            }\n\
    \        }\n    }\n    return \"\"\n}\n", "    var foundVowel bool\n    var vowels\
    \ []string\n    var result string\n    var index int\n\n    vowels = []string{\"\
    a\", \"e\", \"i\", \"o\", \"u\"}\n\n    for i := len(word) - 1; i >= 0; i-- {\n\
    \        if foundVowel {\n            for _, v := range vowels {\n           \
    \     if word[i] == v[0] {\n                    result = string(word[i])\n   \
    \                 break\n                }\n            }\n            if result\
    \ != \"\" {\n                break\n            }\n        } else {\n        \
    \    for _, v := range vowels {\n                if word[i] == v[0] {\n      \
    \              foundVowel = true\n                    index = i\n            \
    \        break\n                }\n            }\n        }\n    }\n\n    if result\
    \ == \"\" {\n        if index != len(word) - 1 {\n            result = string(word[index\
    \ + 1])\n        }\n    }\n\n    return result\n}\n", "    letters := []string{\"\
    A\", \"E\", \"I\", \"O\", \"U\"}\n    for i := len(word) - 1; i >= 0; i-- {\n\
    \        if stringInSlice(word[i:i+1], letters) {\n            return word[i:i+1]\n\
    \        }\n    }\n    return \"\"\n}\n", "    vowels := \"aeiouAEIOU\"\n    nearestVowel\
    \ := \"\"\n    nearestVowelIdx := -1\n    //fmt.Println(word)\n    wordLen :=\
    \ len(word)\n    //fmt.Println(wordLen)\n    for i := wordLen - 1; i >= 0; i--\
    \ {\n        //fmt.Println(i)\n        if nearestVowelIdx >= 0 {\n           \
    \ //fmt.Println(\"nearestVowelIdx >= 0\")\n            return string(nearestVowel)\n\
    \        }\n        currentLetter := string(word[i])\n        //fmt.Println(currentLetter)\n\
    \        for j := 0; j < len(vowels); j++ {\n            //fmt.Println(vowels[j])\n\
    \            if string(vowels[j]) == currentLetter {\n                //fmt.Println(\"\
    Current letter matches vowel: \" + currentLetter)\n                // If it is\
    \ a vowel, check if it is the first vowel met, or if it is\n                //\
    \ closer to the end of the word than the previous vowel met\n                if\
    \ nearestVowelIdx == -1 || i < nearestVowelIdx {\n                    //fmt.Println(\"\
    Setting vowel \" + currentLetter + \" at idx \" + string(i))\n               \
    \     nearestVowel = currentLetter\n                    nearestVowelIdx = i\n\
    \                }\n            }\n        }\n    }\n    return nearestVowel\n\
    }\n", "    vowels := []rune{'a', 'e', 'i', 'o', 'u'}\n    var prev rune\n    for\
    \ i := len(word) - 1; i >= 0; i-- {\n        r := []rune(word)[i]\n        if\
    \ is_vowel(r, vowels) {\n            if !is_vowel(prev, vowels) {\n          \
    \      return string(r)\n            }\n        }\n        prev = r\n    }\n \
    \   return \"\"\n}\n", "    return \"\"\n}\n", "    // your code here\n    return\
    \ \"\"\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
