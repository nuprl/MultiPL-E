name: HumanEval_118_get_closest_vowel
language: go_test.go
prompt: "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// You are given a word. Your task is to find the closest vowel that stands\
  \ between \n// two consonants from the right side of the word (case sensitive).\n\
  // Vowels in the beginning and ending doesn't count. Return empty string if you\
  \ didn't\n// find any vowel met the above condition. \n// You may assume that the\
  \ given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"\
  yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"\
  quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word\
  \ string) string {\n"
tests: "func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n\
  \     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"\
  easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n\
  \     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"\
  bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\"\
  \ },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"\
  ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n\
  \     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"\
  Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\"\
  \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
  , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var\
    \ consontants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\"\
    , \"l\", \"m\",\n                               \"n\", \"p\", \"q\", \"r\", \"\
    s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    var cons_vow_index map[int]bool\
    \ = make(map[int]bool)\n    for i, l := range word {\n        for _, v := range\
    \ vowels {\n            if string(l) == v {\n                cons_vow_index[i]\
    \ = true\n            }\n        }\n    }\n    for i, l := range word {\n    \
    \    if !cons_vow_index[i] {\n            continue\n        }\n        for _,\
    \ c := range consontants {\n            if string(l) == c {\n                if\
    \ (i + 1) < len(word) && cons_vow_index[i + 1] {\n                    return string(word[i])\n\
    \                }\n            }\n        }\n    }\n    return \"\"\n}\n", " \
    \   var (\n        res string\n        vowel_map = map[rune]bool{\n          \
    \  'a': true,\n            'e': true,\n            'i': true,\n            'o':\
    \ true,\n            'u': true,\n            'A': true,\n            'E': true,\n\
    \            'I': true,\n            'O': true,\n            'U': true,\n    \
    \    }\n    )\n    if len(word) < 3 {\n        return res\n    }\n    for _, v\
    \ := range word {\n        if !vowel_map[v] {\n            continue\n        }\n\
    \        if !vowel_map[rune(word[len(word)-1])] {\n            res = string(v)\n\
    \            break\n        }\n    }\n    return res\n}\n", "    if len(word)\
    \ < 3 {\n        return \"\"\n    }\n    vowels := \"AEIOUaeiou\"\n    i := len(word)\
    \ - 1\n    prev_consonant := false\n    for ; i >= 0; i-- {\n        if vowels[strings.Index(vowels,\
    \ string(word[i]))] != 0 {\n            if prev_consonant {\n                return\
    \ string(word[i])\n            }\n        } else {\n            prev_consonant\
    \ = true\n        }\n    }\n    return \"\"\n}\n", "    vowels := map[byte]bool{'a':\
    \ true, 'e': true, 'i': true, 'o': true, 'u': true}\n    result := \"\"\n    start\
    \ := len(word) - 1\n    end := len(word) - 1\n    for i := len(word) - 1; i >=\
    \ 0; i-- {\n        if vowels[word[i]] {\n            start = i\n            break\n\
    \        }\n    }\n    for i := start - 1; i >= 0; i-- {\n        if !vowels[word[i]]\
    \ {\n            end = i\n            break\n        }\n    }\n    if start >\
    \ end {\n        result = string(word[start])\n    }\n    return result\n}\n",
  "    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if strInArr(word[i:i+1], vowels) {\n           \
    \ return word[i:i+1]\n        }\n    }\n    return \"\"\n}\n", '    var vowels
    = map[string]', "    vowels := map[rune]int {\n        'a': 1,\n        'e': 1,\n\
    \        'i': 1,\n        'o': 1,\n        'u': 1,\n        'A': 1,\n        'E':\
    \ 1,\n        'I': 1,\n        'O': 1,\n        'U': 1,\n    }\n    result :=\
    \ \"\"\n    count := len(word)\n    for i := len(word) - 1; i >= 0; i-- {\n  \
    \      if _, ok := vowels[rune(word[i])]; ok {\n            if count - i < count\
    \ {\n                result = string(word[i])\n                count = i\n   \
    \         }\n        }\n    }\n    return result\n}\n", "    vowels := \"aeiouAEIOU\"\
    \n    for i := len(word) - 1; i >= 0; i-- {\n        for j := len(vowels) - 1;\
    \ j >= 0; j-- {\n            if word[i] == vowels[j] {\n                return\
    \ string(word[i])\n            }\n        }\n    }\n    return \"\"\n}\n", " \
    \   vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    for i := len(word)\
    \ - 1; i >= 0; i-- {\n        if findSlice(vowels, string(word[i])) != -1 {\n\
    \            return string(word[i])\n        }\n    }\n    return \"\"\n}\n",
  "    vowels := \"AEIOUaeiou\"\n    distance := len(word)\n    var closestVowel string\n\
    \    for i, c := range word {\n        if strings.Contains(vowels, string(c))\
    \ {\n            currentDistance := len(word) - i\n            if currentDistance\
    \ < distance {\n                distance = currentDistance\n                closestVowel\
    \ = string(c)\n            }\n        }\n    }\n    return closestVowel\n}\n",
  "    if len(word) <= 1 {\n        return \"\"\n    }\n    var vowels = map[string]bool{\"\
    a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    var last string\n\
    \    var first string\n    var last_vowel string\n    for i := len(word) - 1;\
    \ i >= 0; i-- {\n        if _, ok := vowels[string(word[i])]; ok {\n         \
    \   last_vowel = string(word[i])\n            continue\n        }\n        if\
    \ last_vowel != \"\" {\n            last = string(word[i])\n            break\n\
    \        }\n    }\n    for i := 0; i < len(word); i++ {\n        if _, ok := vowels[string(word[i])];\
    \ ok {\n            continue\n        }\n        if last_vowel != \"\" {\n   \
    \         first = string(word[i])\n            break\n        }\n    }\n    if\
    \ last_vowel == \"\" || last == \"\" || first == \"\" {\n        return \"\"\n\
    \    }\n    return last_vowel\n}\n", "\tif len(word) < 3 {\n\t\treturn \"\"\n\t\
    }\n\t// reverse word\n\tvar reversedWord string\n\tfor i := len(word) - 1; i >=\
    \ 0; i-- {\n\t\treversedWord += string(word[i])\n\t}\n\t// find the first consonant\n\
    \tvar firstConsonant string\n\tfor i := 0; i < len(reversedWord); i++ {\n\t\t\
    switch reversedWord[i] {\n\t\tcase 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O',\
    \ 'U':\n\t\t\tfirstConsonant = \"\"\n\t\tdefault:\n\t\t\tfirstConsonant = string(reversedWord[i])\n\
    \t\t\ti++\n\t\t\tbreak\n\t\t}\n\t}\n\t// find the closest vowel\n\tvar closestVowel\
    \ string\n\tfor i := 0; i < len(reversedWord); i++ {\n\t\tswitch reversedWord[i]\
    \ {\n\t\tcase 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U':\n\t\t\tclosestVowel\
    \ = string(reversedWord[i])\n\t\t\tbreak\n\t\t}\n\t}\n\treturn closestVowel\n\
    }\n", "\tvowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n\tfor i := len(word)\
    \ - 1; i >= 0; i-- {\n\t\tif j := find_vowel(word[i], vowels); j >= 0 {\n\t\t\t\
    if i+1 < len(word) && find_vowel(word[i+1], vowels) == -1 {\n\t\t\t\treturn vowels[j]\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n", "    vowels := \"aeiouAEIOU\"\n    res\
    \ := \"\"\n    distance := -1\n    is_previous_consonant := false\n    is_next_consonant\
    \ := false\n    for i := len(word) - 1; i >= 0; i-- {\n        if is_next_consonant\
    \ {\n            break\n        }\n        is_previous_consonant = false\n   \
    \     is_next_consonant = false\n        if contains(vowels, string(word[i]))\
    \ {\n            continue\n        }\n        for j := i + 1; j < len(word); j++\
    \ {\n            if contains(vowels, string(word[j])) {\n                is_previous_consonant\
    \ = true\n                if is_next_consonant {\n                    distance\
    \ = j - i\n                    res = string(word[j])\n                    break\n\
    \                }\n            } else {\n                is_next_consonant =\
    \ true\n                if is_previous_consonant {\n                    if distance\
    \ == -1 || j - i < distance {\n                        distance = j - i\n    \
    \                    res = string(word[j-1])\n                    }\n        \
    \            break\n                }\n            }\n        }\n    }\n    return\
    \ res\n}\n", "    vowels := \"aeiou\"\n    var re string\n    for idx := len(word)\
    \ - 1; idx >= 0; idx-- {\n        if len(re) == 0 {\n            idx2 := vowels.IndexRune(rune(word[idx]))\n\
    \            if idx2 >= 0 {\n                re = string(word[idx])\n        \
    \    }\n        } else {\n            idx2 := vowels.IndexRune(rune(word[idx]))\n\
    \            if idx2 < 0 {\n                return re\n            }\n       \
    \ }\n    }\n    return \"\"\n}\n", "    // Your code here\n    return \"\"\n}\n",
  "    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var ans = \"\"\
    \n    for i := len(word) - 1; i >= 0; i-- {\n        for _, vowel := range vowels\
    \ {\n            if word[i] == vowel[0] {\n                ans = string(word[i])\n\
    \                return ans\n            }\n        }\n    }\n    return ans\n\
    }\n", "    l := len(word)\n    if l == 0 {\n        return \"\"\n    }\n    vowels\
    \ := map[byte]bool{\n        'a': true,\n        'e': true,\n        'i': true,\n\
    \        'o': true,\n        'u': true,\n        'A': true,\n        'E': true,\n\
    \        'I': true,\n        'O': true,\n        'U': true,\n    }\n    res :=\
    \ \"\"\n    for i := l - 1; i >= 0; i-- {\n        if !vowels[word[i]] {\n   \
    \         continue\n        }\n        if i + 1 < l && !vowels[word[i + 1]] {\n\
    \            res = string(word[i])\n            break\n        }\n    }\n    return\
    \ res\n}\n", "    r := []rune(word)\n    if len(r) < 2 {\n        return \"\"\n\
    \    }\n    i := len(r) - 1\n    for i > 0 {\n        if !is_vowel(r[i]) {\n \
    \           j := i - 1\n            for j > 0 {\n                if !is_vowel(r[j])\
    \ {\n                    return \"\"\n                }\n                if is_vowel(r[j])\
    \ {\n                    return string(r[j])\n                }\n            \
    \    j--\n            }\n        }\n        i--\n    }\n    return \"\"\n}\n",
  "    var idx int\n    var closest_vowel string\n    var result string\n    var start_idx\
    \ int\n    vowels := \"aeiou\"\n    for i := len(word) - 1; i >= 0; i-- {\n  \
    \      if string(word[i]) == \" \" {\n            start_idx = i - 1\n        \
    \    break\n        }\n    }\n    for i := start_idx; i >= 0; i-- {\n        if\
    \ vowels[0:1] == string(word[i]) || vowels[1:2] == string(word[i]) ||\n      \
    \      vowels[2:3] == string(word[i]) || vowels[3:4] == string(word[i]) ||\n \
    \           vowels[4:5] == string(word[i]) {\n            idx = i\n          \
    \  closest_vowel = string(word[i])\n            break\n        }\n    }\n    if\
    \ idx == 0 {\n        result = \"\"\n    } else {\n        result = closest_vowel\n\
    \    }\n    return result\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
