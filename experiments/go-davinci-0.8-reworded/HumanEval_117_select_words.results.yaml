language: go_test.go
name: HumanEval_117_select_words
results:
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    res := []string{}\n    if s == \"\" {\n        return res\n    }\n  \
    \  words := strings.Split(s, \" \")\n    for _,word := range words {\n       \
    \ if is_match(word, n) {\n            res = append(res, word)\n        }\n   \
    \ }\n    return res\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpihwd1bw7_test.go:29:14: undefined: strings

    /tmp/tmpihwd1bw7_test.go:31:12: undefined: is_match

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    sel_words := []string{}\n    words := strings.Split(s, \" \")\n    for\
    \ _, word := range words {\n        n_cons := 0\n        for _, c := range word\
    \ {\n            if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n\
    \                n_cons++\n            }\n        }\n        if n_cons == n {\n\
    \            sel_words = append(sel_words, word)\n        }\n    }\n    return\
    \ sel_words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv1x9llld_test.go:26:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    chars := []rune(s)\n    begin, end := 0, 0\n\
    \    for i, c := range chars {\n        if c == ' ' {\n            if (end - begin)\
    \ == n {\n                words = append(words, string(chars[begin:end]))\n  \
    \          }\n            begin = i + 1\n            end = i + 1\n        } else\
    \ {\n            end = i + 1\n        }\n    }\n    if (end - begin) == n {\n\
    \        words = append(words, string(chars[begin:end]))\n    }\n    return words\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpeg0mda8g_test.go:64: expected '[little]', got '[Mary lamb]'\n\
    \    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpeg0mda8g_test.go:64:\
    \ expected '[Mary lamb]', got '[had]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpeg0mda8g_test.go:64: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpeg0mda8g_test.go:64:\
    \ expected '[Uncle]', got '[sam]'\n    --- FAIL: TestSelect_Words/test_num__6\
    \ (0.00s)\n        tmpeg0mda8g_test.go:64: expected '[b c d f]', got '[a b c d\
    \ e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return []string{}\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmph7ir_cnd_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmph7ir_cnd_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmph7ir_cnd_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmph7ir_cnd_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmph7ir_cnd_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    for _, word := range words_from_string(s) {\n\
    \        consonants := 0\n        for _, r := range word {\n            if is_consonant(r)\
    \ {\n                consonants += 1\n            }\n        }\n        if consonants\
    \ == n {\n            words = append(words, word)\n        }\n    }\n    return\
    \ words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplnovvjdy_test.go:26:26: undefined: words_from_string

    /tmp/tmplnovvjdy_test.go:29:16: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    strArr := strings.Split(s, \" \")\n    var resultArr []string\n    for\
    \ _, word := range strArr {\n        if len(word) == 0 {\n            continue\n\
    \        }\n        fmt.Println(word)\n        count := 0\n        for _, char\
    \ := range word {\n            if char == 'a' || char == 'e' || char == 'i' ||\
    \ char == 'o' || char == 'u' {\n                count += 1\n            }\n  \
    \      }\n        if count == n {\n            resultArr = append(resultArr, word)\n\
    \        }\n    }\n    return resultArr\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpksg216e7_test.go:25:15: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    word := \"\"\n    consonants := 0\n    for _,\
    \ c := range s {\n        if c == ' ' {\n            if consonants == n {\n  \
    \              words = append(words, word)\n            }\n            word =\
    \ \"\"\n            consonants = 0\n        } else {\n            word += string(c)\n\
    \            if isConsonant(c) {\n                consonants++\n            }\n\
    \        }\n    }\n    if consonants == n {\n        words = append(words, word)\n\
    \    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7ncitnvf_test.go:37:16: undefined: isConsonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    res := []string{}\n    words := strings.Split(s, \" \")\n    for _, w\
    \ := range words {\n        if len(select_consonants(w)) == n {\n            res\
    \ = append(res, w)\n        }\n    }\n    return res\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcd_4mta0_test.go:26:14: undefined: strings

    /tmp/tmpcd_4mta0_test.go:28:16: undefined: select_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var matchedWords []string\n\n    words := strings.Split(s, \" \")\n \
    \   for _, word := range words {\n        if consonantsCount(word) == n {\n  \
    \          matchedWords = append(matchedWords, word)\n        }\n    }\n\n   \
    \ return matchedWords\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprgcq3hhy_test.go:27:14: undefined: strings

    /tmp/tmprgcq3hhy_test.go:29:12: undefined: consonantsCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    is_consonant := func(r byte) bool {\n       \
    \ return r != 'a' && r != 'e' && r != 'i' && r != 'o' && r != 'u'\n    }\n   \
    \ is_vowel := func(r byte) bool {\n        return !is_consonant(r)\n    }\n  \
    \  var last_char byte\n    var current_word string\n    for _, char := range s\
    \ {\n        c := byte(char)\n        if char == ' ' || char == '\\t' || char\
    \ == '\\n' {\n            if current_word != \"\" {\n                if is_consonant(last_char)\
    \ {\n                    if n == 1 {\n                        words = append(words,\
    \ current_word)\n                    }\n                } else {\n           \
    \         if n > 1 {\n                        words = append(words, current_word)\n\
    \                    }\n                }\n            }\n            current_word\
    \ = \"\"\n        } else {\n            current_word += string(c)\n          \
    \  if is_consonant(c) {\n                if !is_consonant(last_char) {\n     \
    \               if n == 1 {\n                        words = append(words, current_word)\n\
    \                    }\n                }\n            } else {\n            \
    \    if is_consonant(last_char) {\n                    if n > 1 {\n          \
    \              words = append(words, current_word)\n                    }\n  \
    \              }\n            }\n        }\n        last_char = c\n    }\n   \
    \ if current_word != \"\" {\n        if is_consonant(last_char) {\n          \
    \  if n == 1 {\n                words = append(words, current_word)\n        \
    \    }\n        } else {\n            if n > 1 {\n                words = append(words,\
    \ current_word)\n            }\n        }\n    }\n    return words\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkd12xq9o_test.go:29:5: is_vowel declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    word := \"\"\n    if len(s) == 0 {\n       \
    \ return words\n    }\n    for _, w := range s {\n        if string(w) == \" \"\
    \ || string(w) == \"\\n\" {\n            if is_valid(word, n) {\n            \
    \    words = append(words, word)\n            }\n            word = \"\"\n   \
    \     } else {\n            word += string(w)\n        }\n    }\n    if is_valid(word,\
    \ n) {\n        words = append(words, word)\n    }\n    return words\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphcfpotiy_test.go:32:16: undefined: is_valid

    /tmp/tmphcfpotiy_test.go:40:8: undefined: is_valid

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        if count_consonants(word) == n {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0qmvn8eu_test.go:26:26: undefined: strings

    /tmp/tmp0qmvn8eu_test.go:27:12: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    result := []string{}\n    word := \"\"\n    isConsonant := func(char\
    \ string) bool {\n        consonants := \"qwrtypsdfghjklzxcvbnm\"\n        for\
    \ _, v := range consonants {\n            if v == rune(char[0]) {\n          \
    \      return true\n            }\n        }\n        return false\n    }\n  \
    \  count := 0\n    for _, char := range s {\n        if char == ' ' {\n      \
    \      if count == n {\n                result = append(result, word)\n      \
    \      }\n            word = \"\"\n            count = 0\n        } else {\n \
    \           word += string(char)\n            if isConsonant(string(char)) {\n\
    \                count += 1\n            }\n        }\n    }\n    if count ==\
    \ n {\n        result = append(result, word)\n    }\n    return result\n}\n\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__1\
    \ (0.00s)\n        tmpk89hg4to_test.go:76: expected '[Mary lamb]', got '[lamb]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n\n    for _, word := range words(s) {\n        if\
    \ count_consonants(word) == n {\n            result = append(result, word)\n \
    \       }\n    }\n\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpamyew3oz_test.go:27:26: undefined: words

    /tmp/tmpamyew3oz_test.go:28:12: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, w := range(strings.Split(s, \" \")) {\n\
    \        if num_of_const(w) == n {\n            words = append(words, w)\n   \
    \     }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps940piyj_test.go:26:23: undefined: strings

    /tmp/tmps940piyj_test.go:27:12: undefined: num_of_const

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var res []string\n    if n < 0 {\n        return res\n    }\n    word\
    \ := \"\"\n    for _, c := range s {\n        if c == ' ' {\n            if num_consonants(word)\
    \ == n {\n                res = append(res, word)\n            }\n           \
    \ word = \"\"\n        } else {\n            word += string(c)\n        }\n  \
    \  }\n    if num_consonants(word) == n {\n        res = append(res, word)\n  \
    \  }\n    return res\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfpywi_q4_test.go:32:16: undefined: num_consonants

    /tmp/tmpfpywi_q4_test.go:40:8: undefined: num_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range splitString(s) {\n    \
    \    if countConsonants(word) == n {\n            words = append(words, word)\n\
    \        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpro3tusk2_test.go:26:26: undefined: splitString

    /tmp/tmpro3tusk2_test.go:27:12: undefined: countConsonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return []string{}\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmph7ir_cnd_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmph7ir_cnd_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmph7ir_cnd_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmph7ir_cnd_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmph7ir_cnd_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if len(s) == 0 {\n        return []string{}\n    }\n    var words []string\n\
    \    for _, word := range words_from_string(s) {\n        if consonants_count(word)\
    \ == n {\n            words = append(words, word)\n        }\n    }\n    return\
    \ words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprm8xaaj1_test.go:29:26: undefined: words_from_string

    /tmp/tmprm8xaaj1_test.go:30:12: undefined: consonants_count

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    s = \"Mary had a little lamb\"\n    n = 4\n    fmt.Println(s)\n    fmt.Println(n)\n\
    \    return []string{\"little\"}\n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Mary had a little lamb\n4\nMary had a little lamb\n4\nMary had a little\
    \ lamb\n4\nMary had a little lamb\n4\nMary had a little lamb\n4\nMary had a little\
    \ lamb\n4\nMary had a little lamb\n4\n--- FAIL: TestSelect_Words (0.00s)\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpulmea6mk_test.go:51:\
    \ expected '[Mary lamb]', got '[little]'\n    --- FAIL: TestSelect_Words/test_num__2\
    \ (0.00s)\n        tmpulmea6mk_test.go:51: expected '[]', got '[little]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpulmea6mk_test.go:51:\
    \ expected '[world]', got '[little]'\n    --- FAIL: TestSelect_Words/test_num__4\
    \ (0.00s)\n        tmpulmea6mk_test.go:51: expected '[Uncle]', got '[little]'\n\
    \    --- FAIL: TestSelect_Words/test_num__5 (0.00s)\n        tmpulmea6mk_test.go:51:\
    \ expected '[]', got '[little]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpulmea6mk_test.go:51: expected '[b c d f]', got '[little]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return []string{}\n}\n\nvar testCases = []\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv9ox78db_test.go:28:19: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := make([]string, 0)\n    current_word := \"\"\n    for _, r :=\
    \ range s {\n        if r == ' ' {\n            if num_consonants(current_word)\
    \ == n {\n                words = append(words, current_word)\n            }\n\
    \            current_word = \"\"\n        } else {\n            current_word +=\
    \ string(r)\n        }\n    }\n    if num_consonants(current_word) == n {\n  \
    \      words = append(words, current_word)\n    }\n    return words\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpci6uutoi_test.go:29:16: undefined: num_consonants

    /tmp/tmpci6uutoi_test.go:37:8: undefined: num_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    vowel := map[string]bool{\n        \"a\": true,\n        \"e\": true,\n\
    \        \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n   \
    \ words := strings.Split(s, \" \")\n    words_matching := []string{}\n    for\
    \ _, word := range words {\n        total_matching := 0\n        for _, char :=\
    \ range word {\n            if vowel[strings.ToLower(string(char))] {\n      \
    \          total_matching++\n            }\n        }\n        if total_matching\
    \ == n {\n            words_matching = append(words_matching, word)\n        }\n\
    \    }\n    return words_matching\n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsw4czig3_test.go:32:14: undefined: strings

    /tmp/tmpsw4czig3_test.go:37:22: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    word := \"\"\n    for _,char := range s {\n\
    \        if char == 32 {\n            if len(word) == n {\n                result\
    \ = append(result, word)\n            }\n            word = \"\"\n        } else\
    \ {\n            if char != 'a' && char != 'A' && char != 'e' && char != 'E' &&\
    \ char != 'i' && char != 'I' && char != 'o' && char != 'O' && char != 'u' && char\
    \ != 'U' {\n                word += string(char)\n            }\n        }\n \
    \   }\n    if len(word) == n {\n        result = append(result, word)\n    }\n\
    \    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpwp_8r1i2_test.go:64: expected '[little]', got '[lttl]'\n\
    \    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpwp_8r1i2_test.go:64:\
    \ expected '[Mary lamb]', got '[Mry lmb]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpwp_8r1i2_test.go:64: expected '[world]', got '[wrld]'\n\
    \    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpwp_8r1i2_test.go:64:\
    \ expected '[Uncle]', got '[ncl]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    for _, word := range split(s) {\n        if\
    \ len(word) == n {\n            result = append(result, word)\n        }\n   \
    \ }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz_ype0l__test.go:26:26: undefined: split

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range SplitIntoWords(s) {\n \
    \       if CountConsonants(word) == n {\n            words = append(words, word)\n\
    \        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfchggm8__test.go:26:26: undefined: SplitIntoWords

    /tmp/tmpfchggm8__test.go:27:12: undefined: CountConsonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075289
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := strings.Split(s, \" \")\n    selWords := []string{}\n    for\
    \ _, word := range words {\n        count := 0\n        for _, char := range word\
    \ {\n            if unicode.IsLetter(char) && unicode.IsUpper(char) {\n      \
    \          count += 1\n            }\n        }\n        if count == n {\n   \
    \         selWords = append(selWords, word)\n        }\n    }\n    return selWords\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwuu3chgr_test.go:25:14: undefined: strings

    /tmp/tmpwuu3chgr_test.go:30:16: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075290
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    str_words := make([]string, 0)\n    words := make([]string, 0)\n    len_s\
    \ := len(s)\n    if len_s > 0 {\n        i := 0\n        for i < len_s {\n   \
    \         if s[i] != ' ' {\n                start := i\n                for i\
    \ < len_s && s[i] != ' ' {\n                    i++\n                }\n     \
    \           end := i\n                str_words = append(str_words, s[start:end])\n\
    \            }\n            i++\n        }\n    }\n    for _, str_word := range\
    \ str_words {\n        if countConsonants(str_word) == n {\n            words\
    \ = append(words, str_word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8va2cf74_test.go:43:12: undefined: countConsonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075290
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var ret []string\n    words := strings.Split(s, \" \")\n    for _, w\
    \ := range words {\n        if count_consonants(w) == n {\n            ret = append(ret,\
    \ w)\n        }\n    }\n    return ret\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp72nalz7z_test.go:26:14: undefined: strings

    /tmp/tmp72nalz7z_test.go:28:12: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075290
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    for _, w := range strings.Fields(s) {\n     \
    \   if n == 0 {\n            return words\n        }\n        if n == nc(w) {\n\
    \            words = append(words, w)\n        }\n    }\n    return words\n}\n\
    \nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0kj98ksx_test.go:26:23: undefined: strings

    /tmp/tmp0kj98ksx_test.go:30:17: undefined: nc

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075290
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var (\n        ret []string\n        word string\n        count int\n\
    \    )\n    for _, c := range s {\n        if c == ' ' {\n            if count\
    \ == n {\n                ret = append(ret, word)\n            }\n           \
    \ word = \"\"\n            count = 0\n        } else {\n            word += string(c)\n\
    \            if is_consonant(c) {\n                count += 1\n            }\n\
    \        }\n    }\n    if count == n {\n        ret = append(ret, word)\n    }\n\
    \    return ret\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9zosuug2_test.go:39:16: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075290
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    var word []rune\n    var consonants int\n\n \
    \   for _, c := range s {\n        switch c {\n        case ' ', '\\t', '\\n':\n\
    \            if len(word) > 0 {\n                if consonants == n {\n      \
    \              words = append(words, string(word))\n                }\n      \
    \          word = []rune{}\n                consonants = 0\n            }\n  \
    \      default:\n            if isConsonant(c) {\n                consonants++\n\
    \            }\n            word = append(word, c)\n        }\n    }\n    if len(word)\
    \ > 0 {\n        if consonants == n {\n            words = append(words, string(word))\n\
    \        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2w4ma6gr_test.go:40:16: undefined: isConsonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075290
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    for _, word := range(words(s)) {\n        if\
    \ consonants(word) == n {\n            result = append(result, word)\n       \
    \ }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp91mgwhi0_test.go:26:26: undefined: words

    /tmp/tmp91mgwhi0_test.go:27:12: undefined: consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075290
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    word := \"\"\n    for _, char := range s {\n\
    \        if char == ' ' {\n            if len(word) > 0 {\n                if\
    \ count_consonants(word) == n {\n                    words = append(words, word)\n\
    \                }\n                word = \"\"\n            }\n        } else\
    \ {\n            word += string(char)\n        }\n    }\n    if len(word) > 0\
    \ {\n        if count_consonants(word) == n {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbi8sn7r0_test.go:30:20: undefined: count_consonants

    /tmp/tmpbi8sn7r0_test.go:40:12: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075290
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // code\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpql4d0mod_test.go:26:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075290
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n\n    for _, word := range split_words(s) {\n  \
    \      if count_consonants(word) == n {\n            result = append(result, word)\n\
    \        }\n    }\n\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp74f6umhz_test.go:27:26: undefined: split_words

    /tmp/tmp74f6umhz_test.go:28:12: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075290
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n\tif s == \"\" {\n\t\treturn []string{}\n\t}\n\tvar strs []string\n\tvar\
    \ str string\n\tword := false\n\tfor _, r := range s {\n\t\tif r == ' ' {\n\t\t\
    \tif word {\n\t\t\t\tstrs = append(strs, str)\n\t\t\t\tstr = \"\"\n\t\t\t\tword\
    \ = false\n\t\t\t}\n\t\t} else {\n\t\t\tif r == 'a' || r == 'e' || r == 'i' ||\
    \ r == 'o' || r == 'u' {\n\t\t\t\tword = true\n\t\t\t}\n\t\t\tstr += string(r)\n\
    \t\t}\n\t}\n\tif word {\n\t\tstrs = append(strs, str)\n\t}\n\tvar res []string\n\
    \tfor _, s := range strs {\n\t\tif count(s) == n {\n\t\t\tres = append(res, s)\n\
    \t\t}\n\t}\n\treturn res\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg8_ygy5n_test.go:50:6: undefined: count

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075290
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n\n    var prev rune\n    var cnt int\n    var word\
    \ string\n    for _,r := range s {\n        if r == ' ' {\n            if cnt\
    \ == n {\n                words = append(words, word)\n            }\n       \
    \     cnt = 0\n            word = \"\"\n        } else {\n            switch r\
    \ {\n            case 'a', 'e', 'i', 'o', 'u':\n                cnt = 0\n    \
    \        default:\n                cnt++\n            }\n            word += string(r)\n\
    \        }\n        prev = r\n    }\n    if cnt == n {\n        words = append(words,\
    \ word)\n    }\n\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc87f4oc0_test.go:27:9: prev declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075290
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := make([]string, 0)\n    start := 0\n    for i, c := range s {\n\
    \        if string(c) == \" \" {\n            word := s[start:i]\n           \
    \ if len(word) > 0 && count_consonants(word) == n {\n                words = append(words,\
    \ word)\n            }\n            start = i + 1\n        }\n    }\n    if start\
    \ < len(s) && count_consonants(s[start:]) == n {\n        words = append(words,\
    \ s[start:])\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptkx517jx_test.go:30:33: undefined: count_consonants

    /tmp/tmptkx517jx_test.go:36:26: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075290
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: implement this\n    return []string{}\n}\n\nvar tests = []\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkmuiqewx_test.go:29:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075289
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var resp []string\n    words := strings.Split(s, \" \")\n    for _, word\
    \ := range words {\n        has_n_consonants := true\n        consonants := 0\n\
    \        for _, letter := range word {\n            if IsVowel(string(letter))\
    \ {\n                consonants = 0\n            } else {\n                consonants++\n\
    \            }\n            if consonants > n {\n                has_n_consonants\
    \ = false\n                break\n            }\n        }\n        if has_n_consonants\
    \ {\n            resp = append(resp, word)\n        }\n    }\n    return resp\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2atjmw7b_test.go:26:14: undefined: strings

    /tmp/tmp2atjmw7b_test.go:31:16: undefined: IsVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075290
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if s == \"\" {\n        return []string{}\n    }\n    var w []string\n\
    \    i := 0\n    cnt := 0\n    for ; i < len(s); i++ {\n        if s[i] == ' '\
    \ {\n            if cnt == n {\n                w = append(w, s[:i])\n       \
    \     }\n            s = s[i+1:]\n            i = 0\n            cnt = 0\n   \
    \     } else if s[i] != 'a' && s[i] != 'e' && s[i] != 'i' && s[i] != 'o' && s[i]\
    \ != 'u' {\n            cnt++\n        }\n    }\n    if cnt == n {\n        w\
    \ = append(w, s)\n    }\n    return w\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpufjhn_lu_test.go:68: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpufjhn_lu_test.go:68:\
    \ expected '[Mary lamb]', got '[Mary little]'\n    --- FAIL: TestSelect_Words/test_num__2\
    \ (0.00s)\n        tmpufjhn_lu_test.go:68: expected '[]', got '[white space]'\n\
    \    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpufjhn_lu_test.go:68:\
    \ expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n\
    \        tmpufjhn_lu_test.go:68: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6\
    \ (0.00s)\n        tmpufjhn_lu_test.go:68: expected '[b c d f]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075290
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    var word string\n    var vowel bool = false\n\
    \    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if CountVowel(word)\
    \ == n {\n                result = append(result, word)\n            }\n     \
    \       word = \"\"\n            vowel = false\n        } else {\n           \
    \ word += string(s[i])\n        }\n    }\n    if CountVowel(word) == n {\n   \
    \     result = append(result, word)\n    }\n    return result\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjxmwkh_c_test.go:27:9: vowel declared but not used

    /tmp/tmpjxmwkh_c_test.go:30:16: undefined: CountVowel

    /tmp/tmpjxmwkh_c_test.go:39:8: undefined: CountVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075290
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    for _, word := range filter(split(s), func(word\
    \ string) bool {\n        return len(filter(word, func(char rune) bool {\n   \
    \         return !isVowel(char)\n        })) == n\n    }) {\n        words = append(words,\
    \ word)\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpomgmw1ly_test.go:26:26: undefined: filter

    /tmp/tmpomgmw1ly_test.go:26:33: undefined: split

    /tmp/tmpomgmw1ly_test.go:27:20: undefined: filter

    /tmp/tmpomgmw1ly_test.go:28:21: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075290
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n\tvar selected []string\n\tvar current string\n\tfor _, v := range s {\n\t\
    \tif v == ' ' {\n\t\t\tif count_consonants(current) == n {\n\t\t\t\tselected =\
    \ append(selected, current)\n\t\t\t}\n\t\t\tcurrent = \"\"\n\t\t} else {\n\t\t\
    \tcurrent += string(v)\n\t\t}\n\t}\n\tif count_consonants(current) == n {\n\t\t\
    selected = append(selected, current)\n\t}\n\treturn selected\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_cdmwp15_test.go:29:7: undefined: count_consonants

    /tmp/tmp_cdmwp15_test.go:37:5: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075290
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    res := []string{}\n    inword := false\n    j := 0\n    count := 0\n\
    \    consonants := []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"\
    x\", \"z\"}\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n   \
    \         if inword && count == n {\n                res = append(res, s[j:i])\n\
    \            }\n            inword = false\n            count = 0\n        } else\
    \ {\n            if !inword {\n                j = i\n                inword =\
    \ true\n            }\n            for _, c := range consonants {\n          \
    \      if string(s[i]) == c {\n                    count++\n                }\n\
    \            }\n        }\n    }\n    if inword && count == n {\n        res =\
    \ append(res, s[j:])\n    }\n    return res\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__1\
    \ (0.00s)\n        tmpxhn3skw4_test.go:74: expected '[Mary lamb]', got '[lamb]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075291
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var all_words []string\n    var result []string\n    all_words = strings.Split(s,\
    \ \" \")\n    for _, word := range all_words {\n        if (count_consonants(word)\
    \ == n) {\n            result = append(result, word)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpio3jhxig_test.go:27:17: undefined: strings

    /tmp/tmpio3jhxig_test.go:29:13: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075290
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n\tvar words []string\n\tif s == \"\" {\n\t\treturn words\n\t}\n\tfor _, word\
    \ := range strings.Split(s, \" \") {\n\t\tif count_consonants(word) == n {\n\t\
    \t\twords = append(words, word)\n\t\t}\n\t}\n\treturn words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg2qmyrvn_test.go:29:23: undefined: strings

    /tmp/tmpg2qmyrvn_test.go:30:6: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075290
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    var start int = 0\n    for i := 0; i < len(s);\
    \ i++ {\n        if i == len(s) - 1 || s[i] == ' ' {\n            if i - start\
    \ == n {\n                result = append(result, s[start:i])\n            }\n\
    \            start = i + 1\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpjk7h8gs2_test.go:57: expected '[little]', got '[Mary]'\n\
    \    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpjk7h8gs2_test.go:57:\
    \ expected '[Mary lamb]', got '[had lam]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpjk7h8gs2_test.go:57: expected '[world]', got '[worl]'\n\
    \    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpjk7h8gs2_test.go:57:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpjk7h8gs2_test.go:57: expected '[b c d f]', got '[a b c d e]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075291
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return select_words_by_count(s, n, true)\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd5e4tsm__test.go:25:12: undefined: select_words_by_count

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075291
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n\treturn []string{}\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp1p78tn5v_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp1p78tn5v_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp1p78tn5v_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp1p78tn5v_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp1p78tn5v_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    vowels := map[string]int{\n        \"a\": 0,\n\
    \        \"e\": 0,\n        \"i\": 0,\n        \"o\": 0,\n        \"u\": 0,\n\
    \    }\n    for _, word := range strings.Split(s, \" \") {\n        for _, char\
    \ := range word {\n            if _, exists := vowels[string(char)]; exists {\n\
    \                vowels[string(char)]++\n            }\n        }\n        consonants\
    \ := len(word) - vowels[\"a\"] - vowels[\"e\"] - vowels[\"i\"] - vowels[\"o\"\
    ] - vowels[\"u\"]\n        if consonants == n {\n            words = append(words,\
    \ word)\n        }\n        vowels[\"a\"] = 0\n        vowels[\"e\"] = 0\n   \
    \     vowels[\"i\"] = 0\n        vowels[\"o\"] = 0\n        vowels[\"u\"] = 0\n\
    \    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjhsbcmse_test.go:33:26: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075292
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    words := []string{}\n\
    \    consonants := 0\n    word := \"\"\n    for _, letter := range s {\n     \
    \   if letter == 32 {\n            if consonants == n {\n                words\
    \ = append(words, word)\n            }\n            consonants = 0\n         \
    \   word = \"\"\n        } else {\n            word += string(letter)\n      \
    \      if !string_in_slice(string(letter), vowels) {\n                consonants++\n\
    \            }\n        }\n    }\n    if consonants == n {\n        words = append(words,\
    \ word)\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc5oal5_2_test.go:38:17: undefined: string_in_slice

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075292
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var vowels = map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"\
    o\": true, \"u\": true}\n    var words []string\n    var word string\n    for\
    \ _, v := range s {\n        word += string(v)\n        if v == ' ' {\n      \
    \      words = append(words, word)\n            word = \"\"\n        }\n    }\n\
    \    if word != \"\" {\n        words = append(words, word)\n    }\n    var nwords\
    \ []string\n    for _, v := range words {\n        if count_consonants(v, vowels)\
    \ == n {\n            nwords = append(nwords, v)\n        }\n    }\n    return\
    \ nwords\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7iy95a8d_test.go:40:12: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    var count int\n    var word string\n    for\
    \ _, v := range s {\n        if v == ' ' {\n            if count == n {\n    \
    \            result = append(result, word)\n            }\n            count =\
    \ 0\n            word = \"\"\n        } else {\n            if v != 'a' && v !=\
    \ 'e' && v != 'i' && v != 'o' && v != 'u' {\n                count++\n       \
    \     }\n            word += string(v)\n        }\n    }\n    if count == n {\n\
    \        result = append(result, word)\n    }\n    return result\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__4\
    \ (0.00s)\n        tmpsl3sj2fs_test.go:67: expected '[Uncle]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if len(s) == 0 {\n        return nil\n    }\n    var words []string\n\
    \    var word []rune\n    var consonants int\n    var vowels int\n    for _, c\
    \ := range s {\n        if c == ' ' {\n            if consonants == n {\n    \
    \            words = append(words, string(word))\n            }\n            word\
    \ = nil\n            consonants = 0\n            vowels = 0\n        } else {\n\
    \            word = append(word, c)\n            if isVowel(c) {\n           \
    \     vowels++\n            } else {\n                consonants++\n         \
    \   }\n        }\n    }\n    if consonants == n {\n        words = append(words,\
    \ string(word))\n    }\n    return words\n}\n\nvar vowels = map[rune]bool{\n \
    \   'a': true,\n    'e': true,\n    'i': true,\n    'o': true,\n    'u': true,\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiztnlh1t_test.go:42:16: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075292
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    if len(s) == 0 {\n        return words\n   \
    \ }\n    word := \"\"\n    vowels := \"aeiouAEIOU\"\n    for _, c := range s {\n\
    \        if c == ' ' {\n            if len(word) > 0 {\n                if count_consonants(word,\
    \ vowels) == n {\n                    words = append(words, word)\n          \
    \      }\n                word = \"\"\n            }\n        } else {\n     \
    \       word += string(c)\n        }\n    }\n    if len(word) > 0 {\n        if\
    \ count_consonants(word, vowels) == n {\n            words = append(words, word)\n\
    \        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9m3eoow0_test.go:34:20: undefined: count_consonants

    /tmp/tmp9m3eoow0_test.go:44:12: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075292
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    res := []string{}\n    s2 := \"\"\n    for _, v := range s {\n      \
    \  if v == ' ' {\n            if consNum(s2) == n {\n                res = append(res,\
    \ s2)\n            }\n            s2 = \"\"\n        } else {\n            s2\
    \ += string(v)\n        }\n    }\n    if consNum(s2) == n {\n        res = append(res,\
    \ s2)\n    }\n    return res\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpntpdrcft_test.go:29:16: undefined: consNum

    /tmp/tmpntpdrcft_test.go:37:8: undefined: consNum

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075292
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    for _, word := range word_break(s) {\n      \
    \  if count_consonants(word) == n {\n            words = append(words, word)\n\
    \        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi9sq4baz_test.go:26:26: undefined: word_break

    /tmp/tmpi9sq4baz_test.go:27:12: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var word string\n    var words []string\n    for _, c := range s {\n\
    \        if c != ' ' {\n            word += string(c)\n        } else {\n    \
    \        if len(word) != 0 {\n                words = append(words, word)\n  \
    \              word = \"\"\n            }\n        }\n    }\n    if len(word)\
    \ != 0 {\n        words = append(words, word)\n    }\n    var result []string\n\
    \    for _, word := range words {\n        var consonants int\n        for _,\
    \ c := range word {\n            switch c {\n            case 'a', 'e', 'i', 'o',\
    \ 'u', 'y':\n                continue\n            default:\n                consonants++\n\
    \            }\n        }\n        if consonants == n {\n            result =\
    \ append(result, word)\n        }\n    }\n    return result\n}\n\ntype TestCase\
    \ \nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfj1uz1b2_test.go:58:15: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075291
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    var word string\n    var vowel, consonant int\n\
    \    for _, c := range s {\n        if c == ' ' {\n            if consonant ==\
    \ n {\n                words = append(words, word)\n            }\n          \
    \  word = \"\"\n            vowel = 0\n            consonant = 0\n        } else\
    \ {\n            word += string(c)\n            switch c {\n            case 'a',\
    \ 'e', 'i', 'o', 'u':\n                vowel++\n            default:\n       \
    \         consonant++\n            }\n        }\n    }\n    if consonant == n\
    \ {\n        words = append(words, word)\n    }\n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__4\
    \ (0.00s)\n        tmpotj76f1m_test.go:71: expected '[Uncle]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := make([]string, 0)\n    // @TODO: write code here\n    return\
    \ words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp27_63ic__test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp27_63ic__test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp27_63ic__test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp27_63ic__test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp27_63ic__test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if len(s) == 0 {\n        return []string{}\n    }\n    var words []string\n\
    \    var word string\n    var consonants_in_word int\n    for _, c := range s\
    \ {\n        if c == ' ' {\n            if consonants_in_word == n {\n       \
    \         words = append(words, word)\n            }\n            word = \"\"\n\
    \            consonants_in_word = 0\n        } else {\n            is_consonant\
    \ := false\n            switch c {\n            case 'a', 'e', 'i', 'o', 'u':\n\
    \                is_consonant = false\n            default:\n                is_consonant\
    \ = true\n            }\n            if is_consonant {\n                consonants_in_word++\n\
    \            }\n            word += string(c)\n        }\n    }\n    if consonants_in_word\
    \ == n {\n        words = append(words, word)\n    }\n    return words\n}\n\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__4\
    \ (0.00s)\n        tmp1_n32w4q_test.go:77: expected '[Uncle]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return []string{}\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmph7ir_cnd_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmph7ir_cnd_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmph7ir_cnd_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmph7ir_cnd_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmph7ir_cnd_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if len(s) == 0 {\n        return []string{}\n    }\n    words := []string{}\n\
    \    current_word := \"\"\n    for _, v := range s {\n        if v == ' ' {\n\
    \            if len(current_word) > 0 {\n                word_consonants := 0\n\
    \                for _, w := range current_word {\n                    if w !=\
    \ 'a' && w != 'e' && w != 'i' && w != 'o' && w != 'u' {\n                    \
    \    word_consonants++\n                    }\n                }\n           \
    \     if word_consonants == n {\n                    words = append(words, current_word)\n\
    \                }\n                current_word = \"\"\n            }\n     \
    \   } else {\n            current_word += string(v)\n        }\n    }\n    if\
    \ len(current_word) > 0 {\n        word_consonants := 0\n        for _, w := range\
    \ current_word {\n            if w != 'a' && w != 'e' && w != 'i' && w != 'o'\
    \ && w != 'u' {\n                word_consonants++\n            }\n        }\n\
    \        if word_consonants == n {\n            words = append(words, current_word)\n\
    \        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__4\
    \ (0.00s)\n        tmpho288nhq_test.go:81: expected '[Uncle]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    for _, word := range s.Split(\" \") {\n     \
    \   wordCons := 0\n        for _, char := range word {\n            if char ==\
    \ 'a' || char == 'e' || char == 'i' || char == 'o' || char == 'u' {\n        \
    \        wordCons += 1\n            }\n        }\n        if wordCons == n {\n\
    \            words = append(words, word)\n        }\n    }\n    return words\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu9l8h8ap_test.go:26:28: s.Split undefined (type string has no field or
    method Split)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075292
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    currentWord := \"\"\n    // Scan string\n  \
    \  for _, c := range s {\n        // If we hit a space\n        if c == ' ' {\n\
    \            // Check if the word has n consonants\n            if hasXConsonants(currentWord,\
    \ n) {\n                words = append(words, currentWord)\n            }\n  \
    \          // Empty current word\n            currentWord = \"\"\n        } else\
    \ {\n            // Add character to current word\n            currentWord +=\
    \ string(c)\n        }\n    }\n    // Check if the word has n consonants\n   \
    \ if hasXConsonants(currentWord, n) {\n        words = append(words, currentWord)\n\
    \    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprurp3o7w_test.go:32:16: undefined: hasXConsonants

    /tmp/tmprurp3o7w_test.go:43:8: undefined: hasXConsonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075292
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if len(s) == 0 {\n        return []string{}\n    }\n    var words []string\n\
    \    var ch rune\n    for i, v := range s {\n        if v == ' ' || i == len(s)-1\
    \ {\n            if i == len(s)-1 {\n                ch = v\n            }\n \
    \           if consonants(words) == n {\n                return words\n      \
    \      }\n            words = []string{}\n        } else {\n            words\
    \ = append(words, string(v))\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5_rqghoj_test.go:29:9: ch declared but not used

    /tmp/tmp5_rqghoj_test.go:35:16: undefined: consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075292
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    j := 0\n    for i := 0; i < len(s); i++ {\n \
    \       if s[i] == ' ' {\n            if isValid(s[j:i], n) {\n              \
    \  words = append(words, s[j:i])\n            }\n            j = i + 1\n     \
    \   }\n    }\n    if isValid(s[j:], n) {\n        words = append(words, s[j:])\n\
    \    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpde29ly8t_test.go:29:16: undefined: isValid

    /tmp/tmpde29ly8t_test.go:35:8: undefined: isValid

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var ret []string\n    words := parse_words(s)\n    for _, w := range\
    \ words {\n        if len(select_consonants(w)) == n {\n            ret = append(ret,\
    \ w)\n        }\n    }\n    return ret\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpixvt2kp4_test.go:26:14: undefined: parse_words

    /tmp/tmpixvt2kp4_test.go:28:16: undefined: select_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075292
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := make([]string, 0)\n    word := \"\"\n    inWord := false\n \
    \   consonants := 0\n    for _, char := range s {\n        if char == ' ' {\n\
    \            if inWord {\n                inWord = false\n                if consonants\
    \ == n {\n                    words = append(words, word)\n                }\n\
    \                word = \"\"\n                consonants = 0\n            }\n\
    \        } else {\n            if !inWord {\n                inWord = true\n \
    \           }\n            word += string(char)\n            if isConsonant(char)\
    \ {\n                consonants++\n            }\n        }\n    }\n    if consonants\
    \ == n {\n        words = append(words, word)\n    }\n    return words\n}\n\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeccf2w8l_test.go:44:16: undefined: isConsonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075292
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    consonants := map[string]bool{\"b\": true, \"c\": true, \"d\": true,\
    \ \"f\": true, \"g\": true,\n                                  \"h\": true, \"\
    j\": true, \"k\": true, \"l\": true, \"m\": true,\n                          \
    \        \"n\": true, \"p\": true, \"q\": true, \"r\": true, \"s\": true,\n  \
    \                                \"t\": true, \"v\": true, \"w\": true, \"x\"\
    : true, \"y\": true,\n                                  \"z\": true}\n    words\
    \ := []string{}\n    buffer := \"\"\n    count := 0\n    for _, c := range s {\n\
    \        char := string(c)\n        if char == \" \" {\n            if count ==\
    \ n {\n                words = append(words, buffer)\n            }\n        \
    \    buffer = \"\"\n            count = 0\n        } else {\n            if consonants[char]\
    \ {\n                count++\n            }\n            buffer += char\n    \
    \    }\n    }\n    if count == n {\n        words = append(words, buffer)\n  \
    \  }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__1\
    \ (0.00s)\n        tmpg9xcthw9_test.go:73: expected '[Mary lamb]', got '[lamb]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075293
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    if len(s) == 0 {\n        return words\n    }\n\
    \    // Check if consonant by checking if the letter falls within the set of \n\
    \    // vowels.\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true}\n    for _, word := range wordsInString(s) {\n       \
    \ consonants := 0\n        for _, letter := range word {\n            if _, ok\
    \ := vowels[letter]; !ok {\n                consonants++\n            }\n    \
    \    }\n        if consonants == n {\n            words = append(words, word)\n\
    \        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp68rfx6xb_test.go:32:26: undefined: wordsInString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075293
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if s == \"\" {\n        return []string{}\n    }\n    selected_words\
    \ := []string{}\n    vowels := map[rune]bool{'a': true, 'e': true, 'i': true,\
    \ 'o': true, 'u': true}\n    words := strings.Split(s, \" \")\n    for _, word\
    \ := range words {\n        num_consonants := 0\n        for _, letter := range\
    \ word {\n            if !vowels[letter] {\n                num_consonants++\n\
    \            }\n        }\n        if num_consonants == n {\n            selected_words\
    \ = append(selected_words, word)\n        }\n    }\n    return selected_words\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2ezsr8nt_test.go:30:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075294
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words = make([]string, 0)\n    var start = 0\n    for i, c := range\
    \ s {\n        if c == ' ' {\n            var consonants = 0\n            for\
    \ j := start; j < i; j++ {\n                if (s[j] == 'a' || s[j] == 'e' ||\
    \ s[j] == 'i' || s[j] == 'o' || s[j] == 'u') {\n                    consonants\
    \ += 1\n                }\n            }\n            if consonants == n {\n \
    \               words = append(words, s[start:i])\n            }\n           \
    \ start = i + 1\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmplpis8epu_test.go:63: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmplpis8epu_test.go:63:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__2\
    \ (0.00s)\n        tmplpis8epu_test.go:63: expected '[]', got '[simple white]'\n\
    \    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmplpis8epu_test.go:63:\
    \ expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n\
    \        tmplpis8epu_test.go:63: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6\
    \ (0.00s)\n        tmplpis8epu_test.go:63: expected '[b c d f]', got '[a e]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075294
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var count int\n    var words []string\n    for _, ch := range s {\n \
    \       switch ch {\n        case 'a', 'e', 'i', 'o', 'u':\n            count\
    \ = 0\n        default:\n            count++\n        }\n        if count == n\
    \ {\n            words = append(words, string(ch))\n        }\n    }\n    return\
    \ words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp606vthtt_test.go:60: expected '[little]', got '[h]'\n  \
    \  --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp606vthtt_test.go:60:\
    \ expected '[Mary lamb]', got '[  l]'\n    --- FAIL: TestSelect_Words/test_num__2\
    \ (0.00s)\n        tmp606vthtt_test.go:60: expected '[]', got '[p w s]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp606vthtt_test.go:60:\
    \ expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n\
    \        tmp606vthtt_test.go:60: expected '[Uncle]', got '[c]'\n    --- FAIL:\
    \ TestSelect_Words/test_num__6 (0.00s)\n        tmp606vthtt_test.go:60: expected\
    \ '[b c d f]', got '[   ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075294
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    for _, word := range(s.Split(\" \")) {\n    \
    \    //check how many consonants in a word\n        var c_cnt int = 0\n      \
    \  for _, c := range(word) {\n            if c != 'a' && c != 'e' && c != 'i'\
    \ && c != 'o' && c != 'u' {\n                c_cnt++\n            }\n        }\n\
    \        if c_cnt == n {\n            words = append(words, word)\n        }\n\
    \    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuhpgml9k_test.go:26:28: s.Split undefined (type string has no field or
    method Split)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075294
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := make([]string, 0)\n    for _, word := range strings.Split(s,\
    \ \" \") {\n        if strings.Count(word, \"aeiou\") == n {\n            words\
    \ = append(words, word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp61c5ov7p_test.go:26:26: undefined: strings

    /tmp/tmp61c5ov7p_test.go:27:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075294
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    fmt.Println(\"s = \", s)\n    if s == \"\" {\n        return []string{}\n\
    \    }\n    result := []string{}\n    words := strings.Split(s, \" \")\n    for\
    \ _, word := range words {\n        num_consonants := get_num_consonants(word)\n\
    \        if num_consonants == n {\n            result = append(result, word)\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7ouie1b4_test.go:30:14: undefined: strings

    /tmp/tmp7ouie1b4_test.go:32:27: undefined: get_num_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075294
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here\n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpc5ciy0yq_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpc5ciy0yq_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpc5ciy0yq_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpc5ciy0yq_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpc5ciy0yq_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range(strings.Split(s, \" \"\
    )) {\n        if len(word) > 0 && count_consonants(word) == n {\n            words\
    \ = append(words, word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp71moiuc3_test.go:26:26: undefined: strings

    /tmp/tmp71moiuc3_test.go:27:29: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075294
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: implement select_words\n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpuf2mgsn8_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpuf2mgsn8_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpuf2mgsn8_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpuf2mgsn8_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpuf2mgsn8_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    count := 0\n    words := make([]string, 0)\n    currentWord := \"\"\n\
    \    for _, c := range s {\n        if c == ' ' {\n            if count == n {\n\
    \                words = append(words, currentWord)\n            }\n         \
    \   count = 0\n            currentWord = \"\"\n        } else {\n            currentWord\
    \ += string(c)\n            if !isVowel(c) {\n                count++\n      \
    \      }\n        }\n    }\n    if count == n {\n        words = append(words,\
    \ currentWord)\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpah9e_mnp_test.go:37:17: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075294
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    slice := make([]string, 0)\n    for _, item := range split_by_whitespace(s)\
    \ {\n        if len(item) == n + 1 {\n            slice = append(slice, item)\n\
    \        }\n    }\n    return slice\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmhy_fwt1_test.go:26:26: undefined: split_by_whitespace

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075295
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    //your code here\n    var words []string\n    var currentword string\n\
    \    for i := 0; i < len(s); i++ {\n        if s[i] != ' ' {\n            currentword\
    \ += string(s[i])\n        } else {\n            if countConsonants(currentword)\
    \ == n {\n                words = append(words, currentword)\n            }\n\
    \            currentword = \"\"\n        }\n    }\n    if countConsonants(currentword)\
    \ == n {\n        words = append(words, currentword)\n    }\n    return words\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptbiivp4x_test.go:32:16: undefined: countConsonants

    /tmp/tmptbiivp4x_test.go:38:8: undefined: countConsonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    word := \"\"\n    words := []string{}\n    n_conc := 0\n    s = string('\
    \ ') + s + string(' ')\n    for _, c := range s {\n        if string(c) == \"\
    \ \" {\n            if len(word) > 0 {\n                words = append(words,\
    \ word)\n                word = \"\"\n            }\n            n_conc = 0\n\
    \        } else {\n            word += string(c)\n            switch c {\n   \
    \         case 'a', 'e', 'i', 'o', 'u', 'y':\n                continue\n     \
    \       default:\n                n_conc++\n            }\n        }\n    }\n\
    \    final_words := []string{}\n    for _, word := range words {\n        if n_conc\
    \ == n {\n            final_words = append(final_words, word)\n        }\n   \
    \ }\n    return final_words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpjzwy4bqm_test.go:74: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpjzwy4bqm_test.go:74:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpjzwy4bqm_test.go:74: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpjzwy4bqm_test.go:74:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpjzwy4bqm_test.go:74: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return select_words_filter(s, n)\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5utmfvws_test.go:25:12: undefined: select_words_filter

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075295
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := make([]string, 0)\n    current_word := \"\"\n    n_consonants\
    \ := 0\n    for _, char := range s {\n        if char == ' ' {\n            if\
    \ n_consonants == n {\n                words = append(words, current_word)\n \
    \           }\n            current_word = \"\"\n            n_consonants = 0\n\
    \        } else {\n            if is_consonant(char) {\n                n_consonants\
    \ += 1\n            }\n            current_word += string(char)\n        }\n \
    \   }\n    if n_consonants == n {\n        words = append(words, current_word)\n\
    \    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf9iaseg5_test.go:36:16: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075295
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    var current_word string\n    var consonants int\n\
    \    for _, c := range s {\n        if c == ' ' {\n            if consonants ==\
    \ n {\n                words = append(words, current_word)\n            }\n  \
    \          current_word = \"\"\n            consonants = 0\n        } else {\n\
    \            current_word += string(c)\n            if is_consonant(c) {\n   \
    \             consonants++\n            }\n        }\n    }\n    if consonants\
    \ == n {\n        words = append(words, current_word)\n    }\n    return words\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpttvzfe31_test.go:37:16: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075295
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var v []string\n\n    for _, w := range words(s) {\n        if n_consonants(w)\
    \ == n {\n            v = append(v, w)\n        }\n    }\n\n    return v\n}\n\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcb2x6iv9_test.go:27:23: undefined: words

    /tmp/tmpcb2x6iv9_test.go:28:12: undefined: n_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return []string{}\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmph7ir_cnd_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmph7ir_cnd_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmph7ir_cnd_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmph7ir_cnd_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmph7ir_cnd_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // # your code here\n    var words []string\n    var count int\n    var\
    \ word string\n    for _, letter := range s {\n        if letter == ' ' {\n  \
    \          if count == n {\n                words = append(words, word)\n    \
    \        }\n            count = 0\n            word = \"\"\n        } else {\n\
    \            word += string(letter)\n            if letter != 'a' && letter !=\
    \ 'e' && letter != 'i' && letter != 'o' && letter != 'u' {\n                count++\n\
    \            }\n        }\n    }\n    if count == n {\n        words = append(words,\
    \ word)\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__4\
    \ (0.00s)\n        tmp5bdjxbox_test.go:68: expected '[Uncle]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    nb_words := 0\n    nb_consonants := 0\n    nb_vowels\
    \ := 0\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n        \
    \    if nb_consonants == n {\n                words = append(words, s[i-nb_words:i])\n\
    \            }\n            nb_words = 0\n            nb_consonants = 0\n    \
    \        nb_vowels = 0\n        } else {\n            nb_words++\n           \
    \ if is_vowel(s[i]) {\n                nb_vowels++\n            } else {\n   \
    \             nb_consonants++\n            }\n        }\n    }\n    if nb_consonants\
    \ == n {\n        words = append(words, s[len(s)-nb_words:])\n    }\n    return\
    \ words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6x1r01rt_test.go:39:16: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return []string{}\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmph7ir_cnd_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmph7ir_cnd_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmph7ir_cnd_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmph7ir_cnd_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmph7ir_cnd_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    res := []string{}\n    // Implement me\n    word := \"\"\n    for _,\
    \ c := range s {\n        if c != ' ' {\n            word += string(c)\n     \
    \   } else {\n            if len(word) != 0 {\n                if isValid(word,\
    \ n) {\n                    res = append(res, word)\n                }\n     \
    \           word = \"\"\n            }\n        }\n    }\n    if len(word) !=\
    \ 0 {\n        if isValid(word, n) {\n            res = append(res, word)\n  \
    \      }\n    }\n    return res\n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_4w38lu0_test.go:33:20: undefined: isValid

    /tmp/tmp_4w38lu0_test.go:41:12: undefined: isValid

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075295
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    b := []byte(s)\n    var result []string\n    var word []byte\n    for\
    \ i := 0; i < len(b); i++ {\n        if b[i] == ' ' {\n            if len(word)\
    \ == n {\n                result = append(result, string(word))\n            }\n\
    \            word = nil\n        } else {\n            if isConsonant(b[i]) {\n\
    \                word = append(word, b[i])\n            }\n        }\n    }\n\
    \    if len(word) == n {\n        result = append(result, string(word))\n    }\n\
    \    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnvf974xl_test.go:35:16: undefined: isConsonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075295
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return []string{}\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmph7ir_cnd_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmph7ir_cnd_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmph7ir_cnd_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmph7ir_cnd_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmph7ir_cnd_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: implement me\n    var selectedWords []string\n    return selectedWords\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpm3m3fc7q_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpm3m3fc7q_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpm3m3fc7q_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpm3m3fc7q_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpm3m3fc7q_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075296
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // YOUR CODE GOES HERE\n    res := []string{}\n    for _, i := range\
    \ strings.Split(s, \" \") {\n        if countVowels(i) == n {\n            res\
    \ = append(res, i)\n        }\n    }\n    return res\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpri3iyyng_test.go:27:23: undefined: strings

    /tmp/tmpri3iyyng_test.go:28:12: undefined: countVowels

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    for _, word := range string_to_words(s) {\n \
    \       if count_consonants(word) == n {\n            words = append(words, word)\n\
    \        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpubuzq77j_test.go:26:26: undefined: string_to_words

    /tmp/tmpubuzq77j_test.go:27:12: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075296
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    var word string\n    words := strings.Split(s,\
    \ \" \")\n    for _, word = range words {\n        if len(word) == 0 {\n     \
    \       continue\n        }\n        if countConsonants(word) == n {\n       \
    \     result = append(result, word)\n        }\n    }\n    return result\n}\n\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5u3be3k1_test.go:27:14: undefined: strings

    /tmp/tmp5u3be3k1_test.go:32:12: undefined: countConsonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075297
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    result := []string{}\n    word := \"\"\n    consonants := 0\n    for\
    \ _, v := range s {\n        if string(v) == \" \" {\n            if consonants\
    \ == n {\n                result = append(result, word)\n            }\n     \
    \       word = \"\"\n            consonants = 0\n        } else {\n          \
    \  word += string(v)\n            if v != 'a' && v != 'e' && v != 'i' && v !=\
    \ 'o' && v != 'u' {\n                consonants++\n            }\n        }\n\
    \    }\n    if consonants == n {\n        result = append(result, word)\n    }\n\
    \    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__4\
    \ (0.00s)\n        tmptbbyh_73_test.go:67: expected '[Uncle]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075297
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: should implement your code here.\n    return []string{}\n}\n\
    \nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp9u4zn_9__test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp9u4zn_9__test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp9u4zn_9__test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp9u4zn_9__test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp9u4zn_9__test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075297
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var selected []string\n    var words []string\n    words = split(s)\n\
    \    for _, word := range words {\n        if count_consonants(word) == n {\n\
    \            selected = append(selected, word)\n        }\n    }\n    return selected\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx9vsgp50_test.go:27:13: undefined: split

    /tmp/tmpx9vsgp50_test.go:29:12: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075297
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var consonants []string\n    var words []string\n    // insert consonants\n\
    \    for i := range s {\n        letter := string(s[i])\n        if letter ==\
    \ \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\" || letter ==\
    \ \"u\" {\n            consonants = append(consonants, letter)\n        }\n  \
    \  }\n    // insert words\n    for i := range s {\n        letter := string(s[i])\n\
    \        if letter == \" \" {\n            words = append(words, \"\")\n     \
    \   } else {\n            words[len(words)-1] += letter\n        }\n    }\n  \
    \  // select words\n    var sWords []string\n    for i := range words {\n    \
    \    count := 0\n        for j := range words[i] {\n            letter := string(words[i][j])\n\
    \            for k := range consonants {\n                if letter == consonants[k]\
    \ {\n                    count++\n                }\n            }\n        }\n\
    \        if count == n {\n            sWords = append(sWords, words[i])\n    \
    \    }\n    }\n    return sWords\n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\npanic: runtime error: index out of\
    \ range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\n\
    goroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.select_words({0x52221b, 0x16}, 0x4)\n\t\
    /tmp/tmpnyv2uaa8_test.go:40 +0x7a7\ncommand-line-arguments_test.TestSelect_Words(0x0?)\n\
    \t/tmp/tmpnyv2uaa8_test.go:69 +0x52\ntesting.tRunner(0xc0001a0340, 0x529088)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075297
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := strings.Split(s, \" \")\n    result := []string{}\n    for _,\
    \ word := range words {\n        if countConsonants(word) == n {\n           \
    \ result = append(result, word)\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv9btxkle_test.go:25:14: undefined: strings

    /tmp/tmpv9btxkle_test.go:28:12: undefined: countConsonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075297
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := strings.Split(s, \" \")\n    result := []string{}\n    for _,\
    \ word := range words {\n        if count_consonants(word) == n {\n          \
    \  result = append(result, word)\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnh86ebf2_test.go:25:14: undefined: strings

    /tmp/tmpnh86ebf2_test.go:28:12: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075297
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // TODO: Implement me\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp40vgqpss_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp40vgqpss_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp40vgqpss_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp40vgqpss_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp40vgqpss_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Words in the result list\n    var words []string\n    // Current word\n\
    \    var word string\n    // Current word consonants count\n    var count int\n\
    \    // Is the last char a consonant\n    var prev_is_con int\n    // Consonants\n\
    \    cons := \"bcdfghjklmnpqrstvwxyz\"\n    // Loop over all chars\n    for _,\
    \ c := range s {\n        // If we're at a space and we're in a word\n       \
    \ if c == ' ' && prev_is_con == 1 {\n            // Add current word to result\
    \ list if it has exactly n consonants\n            if count == n {\n         \
    \       words = append(words, word)\n            }\n            // Reset current\
    \ word, count and is_con\n            word = \"\"\n            count = 0\n   \
    \         prev_is_con = 0\n        } else {\n            // Add char to word\n\
    \            word += string(c)\n            // If the last char was a consonant,\
    \ increase counter\n            if prev_is_con == 1 {\n                count++\n\
    \            }\n            // Check if char is a consonant\n            if cons[c\
    \ - 'a'] == c {\n                prev_is_con = 1\n            } else {\n     \
    \           prev_is_con = 0\n            }\n        }\n    }\n    // Add last\
    \ word if we're in a word and we're at the end of the string\n    if prev_is_con\
    \ == 1 {\n        // Add current word to result list if it has exactly n consonants\n\
    \        if count == n {\n            words = append(words, word)\n        }\n\
    \    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphb4448d0_test.go:55:33: invalid operation: cons[c - ''a''] == c (mismatched
    types byte and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075298
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var list []string\n    words := Words(s)\n    for _, word := range words\
    \ {\n        count := 0\n        for _, r := range word {\n            if !isVowel(r)\
    \ {\n                count++\n            }\n        }\n        if count == n\
    \ {\n            list = append(list, word)\n        }\n    }\n    return list\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprukky59x_test.go:26:14: undefined: Words

    /tmp/tmprukky59x_test.go:30:17: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return []string{}\n}\n\nvar test_cases = []\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3yehdhfn_test.go:28:20: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075297
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    word := \"\"\n    for _, r := range s {\n   \
    \     if r != ' ' {\n            word += string(r)\n        } else {\n       \
    \     if count_consonants(word) == n {\n                words = append(words,\
    \ word)\n            }\n            word = \"\"\n        }\n    }\n    if count_consonants(word)\
    \ == n {\n        words = append(words, word)\n    }\n    return words\n}\n\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2v93m4sc_test.go:31:16: undefined: count_consonants

    /tmp/tmp2v93m4sc_test.go:37:8: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075298
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := make([]string, 0)\n    // To avoid out of index error when s\
    \ is \"\", use function len\n    length := len(s)\n    i := 0\n    for i < length\
    \ {\n        // the words should start with a letter\n        if (s[i] > 64 &&\
    \ s[i] < 91) || (s[i] > 96 && s[i] < 123) {\n            j := i\n            for\
    \ ; j < length && (s[j] > 64 && s[j] < 91) || (s[j] > 96 && s[j] < 123); j++ {\n\
    \            }\n            if is_n_consonants(s[i:j], n) {\n                words\
    \ = append(words, s[i:j])\n            }\n            i = j\n        } else {\n\
    \            i++\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxryns8tz_test.go:35:16: undefined: is_n_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075298
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        if num_consonants(word) == n {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgnhx1xfo_test.go:26:26: undefined: strings

    /tmp/tmpgnhx1xfo_test.go:27:12: undefined: num_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075298
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n\n    word := \"\"\n    ncons := 0\n    for _, r\
    \ := range s {\n        switch r {\n        case ' ':\n            if ncons ==\
    \ n {\n                words = append(words, word)\n            }\n          \
    \  word = \"\"\n            ncons = 0\n        default:\n            if ! is_vowel(r)\
    \ {\n                ncons++\n            }\n            word += string(r)\n \
    \       }\n    }\n    if ncons == n {\n        words = append(words, word)\n \
    \   }\n\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbxdqk7hx_test.go:38:18: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075298
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n\tvar result []string\n\tvar word string\n\tfor _, c := range s {\n\t\tif\
    \ c == ' ' {\n\t\t\tif n == count_consonants(word) {\n\t\t\t\tresult = append(result,\
    \ word)\n\t\t\t}\n\t\t\tword = \"\"\n\t\t} else {\n\t\t\tword += string(c)\n\t\
    \t}\n\t}\n\treturn result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8gywsqj1_test.go:29:12: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075298
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := strings.Split(s, \" \")\n    result := []string{}\n    for _,\
    \ v := range words {\n        if len(v) == n {\n            result = append(result,\
    \ v)\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdor3lhwa_test.go:25:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if len(s) == 0 {\n        return []string{}\n    }\n    words := []string{}\n\
    \    count := 0\n    word := \"\"\n    for _, c := range s {\n        if string(c)\
    \ == \" \" {\n            if count == n {\n                words = append(words,\
    \ word)\n            }\n            count = 0\n            word = \"\"\n     \
    \   } else {\n            isConsonant := false\n            switch string(c) {\n\
    \            case \"a\", \"e\", \"i\", \"o\", \"u\", \"y\":\n                isConsonant\
    \ = false\n            default:\n                isConsonant = true\n        \
    \    }\n            if isConsonant {\n                count++\n            }\n\
    \            word += string(c)\n        }\n    }\n    if count == n {\n      \
    \  words = append(words, word)\n    }\n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__1\
    \ (0.00s)\n        tmpeg9330q9_test.go:77: expected '[Mary lamb]', got '[lamb]'\n\
    \    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpeg9330q9_test.go:77:\
    \ expected '[Uncle]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075298
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _,v := range s {\n        if v == ' ' {\n\
    \            fmt.Println(\"space\")\n        } else {\n            fmt.Println(v)\n\
    \        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "77\n97\n114\n121\nspace\n104\n97\n100\nspace\n97\nspace\n108\n105\n116\n\
    116\n108\n101\nspace\n108\n97\n109\n98\n77\n97\n114\n121\nspace\n104\n97\n100\n\
    space\n97\nspace\n108\n105\n116\n116\n108\n101\nspace\n108\n97\n109\n98\n115\n\
    105\n109\n112\n108\n101\nspace\n119\n104\n105\n116\n101\nspace\n115\n112\n97\n\
    99\n101\n72\n101\n108\n108\n111\nspace\n119\n111\n114\n108\n100\n85\n110\n99\n\
    108\n101\nspace\n115\n97\n109\n97\nspace\n98\nspace\n99\nspace\n100\nspace\n101\n\
    space\n102\n--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpwe4bd0bz_test.go:55: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpwe4bd0bz_test.go:55:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpwe4bd0bz_test.go:55: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpwe4bd0bz_test.go:55:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpwe4bd0bz_test.go:55: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075299
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    fmt.Println(\"s:\", s)\n    fmt.Println(\"n:\", n)\n    return nil\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "s: Mary had a little lamb\nn: 4\ns: Mary had a little lamb\nn: 3\ns: simple\
    \ white space\nn: 2\ns: Hello world\nn: 4\ns: Uncle sam\nn: 3\ns: \nn: 4\ns: a\
    \ b c d e f\nn: 1\n--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpd4x88cev_test.go:49: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpd4x88cev_test.go:49:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpd4x88cev_test.go:49: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpd4x88cev_test.go:49:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpd4x88cev_test.go:49: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075299
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := make([]string, 0)\n    var word string\n    var vowels int\n\
    \n    for _, c := range s {\n        if c != ' ' {\n            word += string(c)\n\
    \            if is_vowel(string(c)) {\n                vowels++\n            }\n\
    \        } else {\n            if vowels <= len(word) - n {\n                words\
    \ = append(words, word)\n            }\n            word = \"\"\n            vowels\
    \ = 0\n        }\n    }\n\n    if vowels <= len(word) - n {\n        words = append(words,\
    \ word)\n    }\n\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl4m4gtjc_test.go:32:16: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075299
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    var word string\n    var r []rune\n    var word_start\
    \ bool\n    for _, c := range s {\n        if c == ' ' {\n            word_start\
    \ = false\n            if len(r) == n {\n                words = append(words,\
    \ word)\n            }\n            word = \"\"\n            r = nil\n       \
    \ } else {\n            if word_start == false {\n                word_start =\
    \ true\n            }\n            word += string(c)\n            r = append(r,\
    \ c)\n        }\n    }\n    if len(r) == n {\n        words = append(words, word)\n\
    \    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpv29_d0xl_test.go:70: expected '[little]', got '[Mary lamb]'\n\
    \    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpv29_d0xl_test.go:70:\
    \ expected '[Mary lamb]', got '[had]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpv29_d0xl_test.go:70: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpv29_d0xl_test.go:70:\
    \ expected '[Uncle]', got '[sam]'\n    --- FAIL: TestSelect_Words/test_num__6\
    \ (0.00s)\n        tmpv29_d0xl_test.go:70: expected '[b c d f]', got '[a b c d\
    \ e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075300
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    word := \"\"\n    consonants := 0\n    for _,\
    \ c := range s {\n        if c == ' ' {\n            if consonants == n {\n  \
    \              result = append(result, word)\n            }\n            word\
    \ = \"\"\n            consonants = 0\n        } else {\n            word += string(c)\n\
    \            if is_consonant(c) {\n                consonants++\n            }\n\
    \        }\n    }\n    if consonants == n {\n        result = append(result, word)\n\
    \    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu02ea7uh_test.go:37:16: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075299
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        if count_consonants(word) == n {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0qmvn8eu_test.go:26:26: undefined: strings

    /tmp/tmp0qmvn8eu_test.go:27:12: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075116
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // your code here\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp6fi75cb4_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp6fi75cb4_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp6fi75cb4_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp6fi75cb4_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp6fi75cb4_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    var word string\n    var wordCount int\n\n  \
    \  for _, char := range s {\n        if char == ' ' {\n            if wordCount\
    \ == n {\n                words = append(words, word)\n            }\n       \
    \     word = \"\"\n            wordCount = 0\n        } else {\n            if\
    \ isConsonant(char) {\n                wordCount += 1\n            }\n       \
    \     word += string(char)\n        }\n    }\n\n    if wordCount == n {\n    \
    \    words = append(words, word)\n    }\n\n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw9_nprbk_test.go:37:16: undefined: isConsonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075299
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n\treturn []string{}\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp1p78tn5v_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp1p78tn5v_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp1p78tn5v_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp1p78tn5v_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp1p78tn5v_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075292
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    consonants := []rune{'b', 'c', 'd', 'f', 'g',\
    \ 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'z'}\n\
    \    // get words from string\n    for _, word := range strings.Fields(s) {\n\
    \        // count the consonants in the word\n        consCount := 0\n       \
    \ for _, char := range word {\n            for _, cons := range consonants {\n\
    \                if char == cons {\n                    consCount++\n        \
    \        }\n            }\n        }\n        // if the word has n consonants\
    \ add it to the list\n        if consCount == n {\n            words = append(words,\
    \ word)\n        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_57e51qx_test.go:28:26: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075300
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if len(s) == 0 {\n        return []string{}\n    }\n    words := []string{}\n\
    \    word := \"\"\n    word_length := 0\n    consonants := 0\n    for _, char\
    \ := range s {\n        if char == ' ' {\n            if word_length == n {\n\
    \                words = append(words, word)\n            }\n            word\
    \ = \"\"\n            word_length = 0\n            consonants = 0\n        } else\
    \ {\n            word += string(char)\n            word_length++\n           \
    \ if !is_vowel(char) {\n                consonants++\n            }\n        }\n\
    \    }\n    if word_length == n {\n        words = append(words, word)\n    }\n\
    \    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpju7kq682_test.go:43:17: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var vowels = map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"\
    o\": true, \"u\": true}\n    var output []string\n    var currentWord string\n\
    \    for _, c := range s {\n        currentChar := string(c)\n        if currentChar\
    \ == \" \" {\n            output = append(output, currentWord)\n            currentWord\
    \ = \"\"\n        } else {\n            currentWord += currentChar\n        }\n\
    \    }\n    output = append(output, currentWord)\n    var output2 []string\n \
    \   for _, v := range output {\n        var numberOfConsonants = 0\n        for\
    \ _, l := range v {\n            if _, ok := vowels[string(l)]; !ok {\n      \
    \          numberOfConsonants++\n            }\n        }\n        if numberOfConsonants\
    \ == n {\n            output2 = append(output2, v)\n        }\n    }\n    return\
    \ output2\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__4\
    \ (0.00s)\n        tmpotijr3gu_test.go:72: expected '[Uncle]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var res []string\n    var word string\n    var prevIsSpace bool\n   \
    \ for _, c := range s {\n        if c == ' ' {\n            if !prevIsSpace {\n\
    \                if len(word) == n {\n                    res = append(res, word)\n\
    \                }\n                word = \"\"\n            }\n            prevIsSpace\
    \ = true\n        } else {\n            prevIsSpace = false\n            if (c\
    \ != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n                word\
    \ += string(c)\n            }\n        }\n    }\n    if len(word) == n {\n   \
    \     res = append(res, word)\n    }\n    return res\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmptxvm2tig_test.go:69: expected '[little]', got '[lttl]'\n\
    \    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmptxvm2tig_test.go:69:\
    \ expected '[Mary lamb]', got '[Mry lmb]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmptxvm2tig_test.go:69: expected '[world]', got '[wrld]'\n\
    \    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmptxvm2tig_test.go:69:\
    \ expected '[Uncle]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return []string{}\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmph7ir_cnd_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmph7ir_cnd_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmph7ir_cnd_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmph7ir_cnd_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmph7ir_cnd_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    var count int\n    var prev_is_space bool =\
    \ true\n    var word []rune\n    for _, c := range s {\n        if c == ' ' {\n\
    \            prev_is_space = true\n            if count == n {\n             \
    \   result = append(result, string(word))\n            }\n            count =\
    \ 0\n            word = []rune{}\n        } else {\n            if prev_is_space\
    \ {\n                prev_is_space = false\n                word = append(word,\
    \ c)\n            } else {\n                word = append(word, c)\n         \
    \   }\n            if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u'\
    \ {\n                count++\n            }\n        }\n    }\n    if count ==\
    \ n {\n        result = append(result, string(word))\n    }\n    return result\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__4\
    \ (0.00s)\n        tmp2kyu3q6b_test.go:74: expected '[Uncle]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    consonants := \"bcdfghjklmnpqrstvwxz\"\n   \
    \ word := \"\"\n    vowel := false\n    count := 0\n    for _, v := range s {\n\
    \        if v == ' ' {\n            if count == n {\n                words = append(words,\
    \ word)\n            }\n            word = \"\"\n            count = 0\n     \
    \       vowel = false\n        } else {\n            word += string(v)\n     \
    \       if vowel == false {\n                if consonants[v] == 0 {\n       \
    \             count += 1\n                } else {\n                    vowel\
    \ = true\n                }\n            }\n        }\n    }\n    if count ==\
    \ n {\n        words = append(words, word)\n    }\n    return words\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\npanic: runtime error: index out of\
    \ range [77] with length 20 [recovered]\n\tpanic: runtime error: index out of\
    \ range [77] with length 20\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.select_words({0x52222f, 0x16}, 0x4)\n\t\
    /tmp/tmparq2poe0_test.go:41 +0x2d6\ncommand-line-arguments_test.TestSelect_Words(0x0?)\n\
    \t/tmp/tmparq2poe0_test.go:62 +0x52\ntesting.tRunner(0xc0001a01a0, 0x529098)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var vowels = map[rune]bool{'a': true, 'e': true, 'i': true, 'o': true,\
    \ 'u': true}\n    var tokens []string\n    var token string\n    var consonants\
    \ int\n    for _, r := range s {\n        if r == ' ' {\n            if consonants\
    \ == n {\n                tokens = append(tokens, token)\n            }\n    \
    \        token = \"\"\n            consonants = 0\n        } else {\n        \
    \    token += string(r)\n            if !vowels[r] {\n                consonants++\n\
    \            }\n        }\n    }\n    if consonants == n {\n        tokens = append(tokens,\
    \ token)\n    }\n    return tokens\n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__4\
    \ (0.00s)\n        tmpv51pxp37_test.go:68: expected '[Uncle]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 0
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n\tvar result []string\n\tvar str string\n\tvar consonants int\n\tfor i :=\
    \ 0; i < len(s); i++ {\n\t\tif s[i] != ' ' {\n\t\t\tstr += string(s[i])\n\t\t\t\
    //fmt.Println(str)\n\t\t\tif s[i] != 'a' && s[i] != 'A' && s[i] != 'e' && s[i]\
    \ != 'E' && s[i] != 'i' && s[i] != 'I' && s[i] != 'o' && s[i] != 'O' && s[i] !=\
    \ 'u' && s[i] != 'U' {\n\t\t\t\tconsonants++\n\t\t\t}\n\t\t} else {\n\t\t\tif\
    \ consonants == n {\n\t\t\t\tresult = append(result, str)\n\t\t\t}\n\t\t\tconsonants\
    \ = 0\n\t\t\tstr = \"\"\n\t\t}\n\t}\n\tif consonants == n {\n\t\tresult = append(result,\
    \ str)\n\t}\n\treturn result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075301
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n\tl := []string{}\n\tfor _, w := range s.Split(' ') {\n\t\tif len(filter_consonants(w))\
    \ == n {\n\t\t\tl = append(l, w)\n\t\t}\n\t}\n\treturn l\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx_sf33gh_test.go:26:22: s.Split undefined (type string has no field or
    method Split)

    /tmp/tmpx_sf33gh_test.go:27:10: undefined: filter_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n\tvar words []string\n\tvar word string\n\tvar consonants int\n\tfor _, character\
    \ := range s {\n\t\tif character == ' ' {\n\t\t\tif consonants == n {\n\t\t\t\t\
    words = append(words, word)\n\t\t\t}\n\t\t\tword = \"\"\n\t\t\tconsonants = 0\n\
    \t\t} else {\n\t\t\tword += string(character)\n\t\t\tif character != 'a' && character\
    \ != 'e' && character != 'i' && character != 'o' && character != 'u' {\n\t\t\t\
    \tconsonants++\n\t\t\t}\n\t\t}\n\t}\n\tif consonants == n {\n\t\twords = append(words,\
    \ word)\n\t}\n\treturn words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__4\
    \ (0.00s)\n        tmpd7ygzemx_test.go:67: expected '[Uncle]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    words := SplitString(s)\n    for _, word :=\
    \ range words {\n        if n == 0 {\n            result = append(result, word)\n\
    \        } else {\n            consonants := 0\n            for _, c := range\
    \ word {\n                if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c\
    \ != 'u' {\n                    consonants += 1\n                }\n         \
    \   }\n            if consonants == n {\n                result = append(result,\
    \ word)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9nniusr1_test.go:26:14: undefined: SplitString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return []string{}\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmph7ir_cnd_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmph7ir_cnd_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmph7ir_cnd_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmph7ir_cnd_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmph7ir_cnd_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075288
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    return result\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpfqjmoyyw_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpfqjmoyyw_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpfqjmoyyw_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpfqjmoyyw_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpfqjmoyyw_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // write your code in Go 1.4\n    words := []string{}\n    for i, end\
    \ := 0, 0; end < len(s); end++ {\n        if s[end] == ' ' {\n            if numVowels(s[i:end])\
    \ == n {\n                words = append(words, s[i:end])\n            }\n   \
    \         i = end + 1\n        }\n    }\n    if numVowels(s[i:]) == n {\n    \
    \    words = append(words, s[i:])\n    }\n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8y42gecp_test.go:29:16: undefined: numVowels

    /tmp/tmp8y42gecp_test.go:35:8: undefined: numVowels

    /tmp/tmp8y42gecp_test.go:35:20: undefined: i

    /tmp/tmp8y42gecp_test.go:36:33: undefined: i

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075300
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    list_words := make([]string, 0)\n    var list_letters []string\n    for\
    \ _, l := range s {\n        list_letters = append(list_letters, string(l))\n\
    \    }\n    var word string\n    for _, l := range list_letters {\n        if\
    \ l == \" \" {\n            nc := count_consonants(word)\n            if nc ==\
    \ n {\n                list_words = append(list_words, word)\n            }\n\
    \            word = \"\"\n        } else {\n            word += l\n        }\n\
    \    }\n    if word != \"\" {\n        nc := count_consonants(word)\n        if\
    \ nc == n {\n            list_words = append(list_words, word)\n        }\n  \
    \  }\n    return list_words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdncauz76_test.go:33:19: undefined: count_consonants

    /tmp/tmpdncauz76_test.go:43:15: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    w := \"\"\n    flag := false\n    count := 0\n\
    \    for _, c := range s {\n        if c == ' ' {\n            if flag {\n   \
    \             words = append(words, w)\n            }\n            w = \"\"\n\
    \            flag = false\n            count = 0\n        } else {\n         \
    \   if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n          \
    \      count++\n            }\n            if count == n {\n                flag\
    \ = true\n            }\n            w += string(c)\n        }\n    }\n    if\
    \ flag {\n        words = append(words, w)\n    }\n    return words\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp746joo1l_test.go:72: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp746joo1l_test.go:72:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__2\
    \ (0.00s)\n        tmp746joo1l_test.go:72: expected '[]', got '[simple white space]'\n\
    \    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmp746joo1l_test.go:72:\
    \ expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n\
    \        tmp746joo1l_test.go:72: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6\
    \ (0.00s)\n        tmp746joo1l_test.go:72: expected '[b c d f]', got '[a e]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    words := strings.Split(s, \" \")\n    consonants\
    \ := []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"\
    m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"z\"}\n \
    \   for _, w := range words {\n        count := 0\n        for _, l := range w\
    \ {\n            fmt.Println(string(l))\n            if string(l) in consonants\
    \ {\n                count += 1\n            }\n        }\n        if count ==\
    \ n {\n            result = append(result, w)\n        }\n    }\n    return result\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpom2x56o5_test.go:32:26: expected '';'', found in

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075300
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n\treturn nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpku74c6mg_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpku74c6mg_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpku74c6mg_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpku74c6mg_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpku74c6mg_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        if len(strings.Replace(word, \"aeiou\", \"\", -1)) == n {\n     \
    \       words = append(words, word)\n        }\n    }\n\n    return words\n}\n\
    \nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd8_qcvhu_test.go:27:26: undefined: strings

    /tmp/tmpd8_qcvhu_test.go:28:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075302
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    m := make(map[string]int)\n    last := 0\n    for i, b := range s {\n\
    \        if b == ' ' {\n            m[s[last:i]] = countConsonants(s[last:i])\n\
    \            last = i + 1\n        }\n    }\n    m[s[last:]] = countConsonants(s[last:])\n\
    \    fmt.Println(m)\n    ret := make([]string, 0)\n    for k, v := range m {\n\
    \        if v == n {\n            ret = append(ret, k)\n        }\n    }\n   \
    \ return ret\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnoa5a263_test.go:29:28: undefined: countConsonants

    /tmp/tmpnoa5a263_test.go:33:19: undefined: countConsonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075302
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if s == \"\" {\n        return []string{}\n    }\n    wordList := []string{}\n\
    \    word := \"\"\n    consonantCount := 0\n    for i := 0; i < len(s); i++ {\n\
    \        if s[i] == ' ' {\n            if consonantCount == n {\n            \
    \    wordList = append(wordList, word)\n            }\n            word = \"\"\
    \n            consonantCount = 0\n        } else {\n            word += string(s[i])\n\
    \            if isConsonant(s[i]) {\n                consonantCount++\n      \
    \      }\n        }\n    }\n    if consonantCount == n {\n        wordList = append(wordList,\
    \ word)\n    }\n    return wordList\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3gdnboqe_test.go:40:16: undefined: isConsonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075302
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    // First, seperate all the words into an array.\n\
    \    for _, word := range s {\n        if word == 32 {\n            words = append(words,\
    \ \" \")\n        } else {\n            words = append(words, string(word))\n\
    \        }\n    }\n    var result []string\n    for _, word := range words {\n\
    \        if len(word) == 1 {\n            if word == \"a\" || word == \"e\" ||\
    \ word == \"i\" || word == \"o\" || word == \"u\" {\n                continue\n\
    \            } else {\n                result = append(result, word)\n       \
    \     }\n        } else {\n            var count int\n            for _, letter\
    \ := range word {\n                if letter == 97 || letter == 101 || letter\
    \ == 105 || letter == 111 || letter == 117 {\n                    continue\n \
    \               } else {\n                    count++\n                }\n   \
    \         }\n            if count == n {\n                result = append(result,\
    \ word)\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmphsbzx996_test.go:78: expected '[little]', got '[M r y  \
    \ h d     l t t l   l m b]'\n    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n\
    \        tmphsbzx996_test.go:78: expected '[Mary lamb]', got '[M r y   h d   \
    \  l t t l   l m b]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n   \
    \     tmphsbzx996_test.go:78: expected '[]', got '[s m p l   w h t   s p c]'\n\
    \    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmphsbzx996_test.go:78:\
    \ expected '[world]', got '[H l l   w r l d]'\n    --- FAIL: TestSelect_Words/test_num__4\
    \ (0.00s)\n        tmphsbzx996_test.go:78: expected '[Uncle]', got '[U n c l \
    \  s m]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmphsbzx996_test.go:78:\
    \ expected '[b c d f]', got '[  b   c   d     f]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075302
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n\treturn nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpku74c6mg_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpku74c6mg_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpku74c6mg_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpku74c6mg_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpku74c6mg_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075301
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, word := range strings.Split(s, \" \"\
    ) {\n        count := 0\n        for _, letter := range word {\n            if\
    \ !isVowel(letter) {\n                count++\n            }\n        }\n    \
    \    if count == n {\n            words = append(words, word)\n        }\n   \
    \ }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmped3ps_o8_test.go:26:26: undefined: strings

    /tmp/tmped3ps_o8_test.go:29:17: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075302
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var i int\n    var j int\n    var consonants int\n    var words []string\n\
    \    var word string\n    var vowels = map[byte]bool{'a': true, 'e': true, 'i':\
    \ true, 'o': true, 'u': true}\n\n    for i < len(s) {\n        consonants = 0\n\
    \        word = \"\"\n        for j = i; j < len(s); j++ {\n            if s[j]\
    \ == ' ' {\n                break\n            }\n            if _, ok := vowels[s[j]];\
    \ !ok {\n                consonants++\n            }\n            word += string(s[j])\n\
    \        }\n        if consonants == n {\n            words = append(words, word)\n\
    \        }\n        i = j + 1\n    }\n    return words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__4\
    \ (0.00s)\n        tmpt8rsi8dg_test.go:71: expected '[Uncle]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075303
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := strings.Split(s, \" \")\n    result := []string{}\n    for _,\
    \ word := range words {\n        count := 0\n        for _, char := range word\
    \ {\n            if !isVowel(char) {\n                count++\n            }\n\
    \        }\n        if count == n {\n            result = append(result, word)\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2x2os4ks_test.go:25:14: undefined: strings

    /tmp/tmp2x2os4ks_test.go:30:17: undefined: isVowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075302
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    start := 0\n    end := 0\n    // Iterate through\
    \ the string\n    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n  \
    \          end = i\n            if end - start == n {\n                words =\
    \ append(words, s[start:end])\n            }\n            start = i + 1\n    \
    \    }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmprcmk47oe_test.go:60: expected '[little]', got '[Mary]'\n\
    \    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmprcmk47oe_test.go:60:\
    \ expected '[Mary lamb]', got '[had]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmprcmk47oe_test.go:60: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmprcmk47oe_test.go:60:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmprcmk47oe_test.go:60: expected '[b c d f]', got '[a b c d e]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075303
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    res := []string{}\n    for _, w := range words(s) {\n        if len(consonants(w))\
    \ == n {\n            res = append(res, w)\n        }\n    }\n    return res\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuw61tp2v_test.go:26:23: undefined: words

    /tmp/tmpuw61tp2v_test.go:27:16: undefined: consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075302
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    var word []rune\n    word_count := 0\n    consonant_count\
    \ := 0\n    last_space := false\n    for _, char := range s {\n        if last_space\
    \ {\n            if char == ' ' {\n                continue\n            }\n \
    \           last_space = false\n        }\n        if char == ' ' {\n        \
    \    if consonant_count == n {\n                words = append(words, string(word))\n\
    \            }\n            word = nil\n            word_count = 0\n         \
    \   consonant_count = 0\n            last_space = true\n            continue\n\
    \        }\n        word = append(word, char)\n        word_count += 1\n     \
    \   if is_consonant(char) {\n            consonant_count += 1\n        }\n   \
    \     if word_count == len(s) {\n            if consonant_count == n {\n     \
    \           words = append(words, string(word))\n            }\n        }\n  \
    \  }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8xwxlz_d_test.go:49:12: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075303
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    s = \" \" + s\n    words := make([]string, 0)\n    current := \"\"\n\
    \    for i := 0; i < len(s); i++ {\n        if s[i] == ' ' {\n            if len(current)\
    \ == n {\n                words = append(words, current)\n            }\n    \
    \        current = \"\"\n        } else {\n            current += string(s[i])\n\
    \        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpj7mvhkmx_test.go:60: expected '[little]', got '[Mary]'\n\
    \    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpj7mvhkmx_test.go:60:\
    \ expected '[Mary lamb]', got '[had]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpj7mvhkmx_test.go:60: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpj7mvhkmx_test.go:60:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpj7mvhkmx_test.go:60: expected '[b c d f]', got '[a b c d e]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075303
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // Write your code here\n    return nil\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpc5ciy0yq_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpc5ciy0yq_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpc5ciy0yq_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpc5ciy0yq_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpc5ciy0yq_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075295
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var res []string\n    var cur string\n    var consonants int\n\n    for\
    \ _, c := range s {\n        if c == ' ' {\n            if consonants == n {\n\
    \                res = append(res, cur)\n            }\n            cur = \"\"\
    \n            consonants = 0\n        } else {\n            cur += string(c)\n\
    \            if is_consonant(c) {\n                consonants++\n            }\n\
    \        }\n    }\n    if consonants == n {\n        res = append(res, cur)\n\
    \    }\n    return res\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp91fwx5lc_test.go:38:16: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075303
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    count_consonants := func(w string) int {\n        count := 0\n      \
    \  for _, c := range w {\n            if c != 'a' && c != 'e' && c != 'i' && c\
    \ != 'o' && c != 'u' {\n                count += 1\n            }\n        }\n\
    \        return count\n    }\n\n    result := []string{}\n    sb := []byte(s)\n\
    \    wb := []byte{}\n    for _, b := range sb {\n        if b == ' ' {\n     \
    \       if count_consonants(string(wb)) == n {\n                result = append(result,\
    \ string(wb))\n            }\n            wb = []byte{}\n        } else {\n  \
    \          wb = append(wb, b)\n        }\n    }\n    if count_consonants(string(wb))\
    \ == n {\n        result = append(result, string(wb))\n    }\n    return result\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__4\
    \ (0.00s)\n        tmp3lw6frh1_test.go:73: expected '[Uncle]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075303
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n\twords := []string{}\n\tword := \"\"\n\tcurrent_n := 0\n\tfor _, c := range\
    \ s {\n\t\tif current_n == n {\n\t\t\tif c == ' ' {\n\t\t\t\twords = append(words,\
    \ word)\n\t\t\t\tword = \"\"\n\t\t\t\tcurrent_n = 0\n\t\t\t} else {\n\t\t\t\t\
    word += string(c)\n\t\t\t}\n\t\t} else {\n\t\t\tif c == ' ' {\n\t\t\t\tword =\
    \ \"\"\n\t\t\t\tcurrent_n = 0\n\t\t\t} else {\n\t\t\t\tswitch c {\n\t\t\t\tcase\
    \ 'a', 'e', 'i', 'o', 'u':\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tcurrent_n++\n\
    \t\t\t\t}\n\t\t\t\tword += string(c)\n\t\t\t}\n\t\t}\n\t}\n\tif current_n == n\
    \ {\n\t\twords = append(words, word)\n\t}\n\treturn words\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__1\
    \ (0.00s)\n        tmpi0agou1x_test.go:77: expected '[Mary lamb]', got '[Mary\
    \ little lamb]'\n    --- FAIL: TestSelect_Words/test_num__2 (0.00s)\n        tmpi0agou1x_test.go:77:\
    \ expected '[]', got '[simple white space]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075303
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var rs []string\n    var nconsonants int\n\n    for i, _ := range s {\n\
    \        switch s[i] {\n        case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O',\
    \ 'U':\n            nconsonants = 0\n        default:\n            nconsonants++\n\
    \        }\n        if nconsonants == n {\n            var j, k int\n        \
    \    for j = i; j >= 0; j-- {\n                if s[j] == ' ' {\n            \
    \        break\n                }\n            }\n            for k = i; k < len(s);\
    \ k++ {\n                if s[k] == ' ' {\n                    break\n       \
    \         }\n            }\n            rs = append(rs, s[j+1:k])\n          \
    \  nconsonants = 0\n        }\n    }\n    return rs\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [5:4] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [5:4]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.select_words({0x52221b, 0x16}, 0x3)\n\t\
    /tmp/tmp3tlwtych_test.go:47 +0x273\ncommand-line-arguments_test.TestSelect_Words(0x0?)\n\
    \t/tmp/tmp3tlwtych_test.go:62 +0x8b\ntesting.tRunner(0xc0001a01a0, 0x529088)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    var counter int\n    var current_word string\n\
    \    for _,ch := range s {\n        if ch == ' ' {\n            if counter ==\
    \ n {\n                words = append(words, current_word)\n            }\n  \
    \          counter = 0\n            current_word = \"\"\n        } else {\n  \
    \          if ch != 'a' && ch != 'e' && ch != 'i' && ch != 'o' && ch != 'u' {\n\
    \                counter++\n            }\n            current_word += string(ch)\n\
    \        }\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__1\
    \ (0.00s)\n        tmpbo1ka993_test.go:64: expected '[Mary lamb]', got '[Mary]'\n\
    \    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpbo1ka993_test.go:64:\
    \ expected '[world]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__4 (0.00s)\n\
    \        tmpbo1ka993_test.go:64: expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6\
    \ (0.00s)\n        tmpbo1ka993_test.go:64: expected '[b c d f]', got '[b c d]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // parse the string\n    var words = []string{}\n    var currentWord\
    \ = \"\"\n    var matches = []string{}\n    for _, char := range s {\n       \
    \ if char == ' ' {\n            words = append(words, currentWord)\n         \
    \   currentWord = \"\"\n        } else {\n            currentWord += string(char)\n\
    \        }\n    }\n    if currentWord != \"\" {\n        words = append(words,\
    \ currentWord)\n    }\n    // iterate over the words and find the matches\n  \
    \  for _, word := range words {\n        consonants := 0\n        for _, char\
    \ := range word {\n            switch char {\n            case 'a', 'e', 'i',\
    \ 'o', 'u':\n                break\n            default:\n                consonants++\n\
    \            }\n        }\n        if consonants == n {\n            matches =\
    \ append(matches, word)\n        }\n    }\n    return matches\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__4\
    \ (0.00s)\n        tmp6e0tmd74_test.go:77: expected '[Uncle]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    words := strings.Split(s, \" \")\n    for _,\
    \ word := range words {\n        if ConsonantsCount(word) == n {\n           \
    \ result = append(result, word)\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"Mary had a little lamb\", 4), expected: []string{\"\
    little\"} },\n     { actual: candidate(\"Mary had a little lamb\", 3), expected:\
    \ []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\"\
    , 2), expected: []string{} },\n     { actual: candidate(\"Hello world\", 4), expected:\
    \ []string{\"world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected:\
    \ []string{\"Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{}\
    \ },\n     { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\",\
    \ \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4qxyat9t_test.go:26:14: undefined: strings

    /tmp/tmp4qxyat9t_test.go:28:12: undefined: ConsonantsCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075303
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if len(s) == 0 {\n        return []string{}\n    }\n    result := []string{}\n\
    \    str := \"\"\n    for _, i := range s {\n        if i != ' ' {\n         \
    \   str += string(i)\n        } else {\n            if numConsonants(str) == n\
    \ {\n                result = append(result, str)\n            }\n           \
    \ str = \"\"\n        }\n    }\n    if numConsonants(str) == n {\n        result\
    \ = append(result, str)\n    }\n    return result\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdja7z86w_test.go:34:16: undefined: numConsonants

    /tmp/tmpdja7z86w_test.go:40:8: undefined: numConsonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075303
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // YOUR CODE HERE\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmps144fd5o_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmps144fd5o_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmps144fd5o_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmps144fd5o_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmps144fd5o_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    // let's first build the map of consonants\n    // in English:\n    //\
    \ if we assume that a, e, i, o, u are vowels,\n    // then consonants are all\
    \ the rest of the letters\n    m := make(map[rune]bool)\n    for _, c := range\
    \ s {\n        if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n\
    \            m[c] = true\n        }\n    }\n    // now let's use this map to check\
    \ if the strings\n    // containt the required number of consonants\n    words\
    \ := make([]string, 0)\n    for _, word := range(strings.Split(s, \" \")) {\n\
    \        has := 0\n        for _, letter := range(word) {\n            if _, ok\
    \ := m[letter]; ok {\n                has++\n            }\n        }\n      \
    \  if has == n {\n            words = append(words, word)\n        }\n    }\n\
    \    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf0jvng7t_test.go:38:26: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075303
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var rs []string\n    if s == \"\" {\n        return rs\n    }\n    var\
    \ words []string\n    var buffer []byte\n    for i := 0; i < len(s); i++ {\n \
    \       if s[i] == ' ' {\n            words = append(words, string(buffer))\n\
    \            buffer = []byte{}\n        } else {\n            buffer = append(buffer,\
    \ s[i])\n        }\n    }\n    words = append(words, string(buffer))\n    for\
    \ _, w := range words {\n        if is_n_consonants(w, n) {\n            rs =\
    \ append(rs, w)\n        }\n    }\n    return rs\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptvwzrxvr_test.go:41:12: undefined: is_n_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075303
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    ans := []string{}\n    words := strings.Split(s, \" \")\n    for _, w\
    \ := range words {\n        if len(w) > 0 && countConsonants(w) == n {\n     \
    \       ans = append(ans, w)\n        }\n    }\n    return ans\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpihicqlk6_test.go:26:14: undefined: strings

    /tmp/tmpihicqlk6_test.go:28:26: undefined: countConsonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075304
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    var words []string\n    words = get_words(s)\n\
    \    for _, w := range words {\n        if is_consonant(w, n) {\n            result\
    \ = append(result, w)\n        }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk3v080on_test.go:27:13: undefined: get_words

    /tmp/tmpk3v080on_test.go:29:12: undefined: is_consonant

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075304
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if n <= 0 {\n        return nil\n    }\n    if len(s) == 0 {\n      \
    \  return nil\n    }\n    if n == 1 {\n        return strings.Split(s, \" \")\n\
    \    }\n    words := strings.Split(s, \" \")\n    result := make([]string, 0)\n\
    \    for _, w := range words {\n        if count_consonants(w) == n {\n      \
    \      result = append(result, w)\n        }\n    }\n    return result\n}\n\n\
    func TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpklv6bjvl_test.go:32:16: undefined: strings

    /tmp/tmpklv6bjvl_test.go:34:14: undefined: strings

    /tmp/tmpklv6bjvl_test.go:37:12: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    if len(s) == 0 {\n        return words\n    }\n\
    \    return words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpvz1jv5ln_test.go:51: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpvz1jv5ln_test.go:51:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpvz1jv5ln_test.go:51: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpvz1jv5ln_test.go:51:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpvz1jv5ln_test.go:51: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var r []string\n    if len(s) == 0 {\n        return r\n    }\n    start\
    \ := 0\n    end := 0\n    var word string\n    var consonants int\n    var bConsonant\
    \ = false\n    for ; end < len(s); end++ {\n        bConsonant = true\n      \
    \  switch s[end] {\n        case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O',\
    \ 'U':\n            bConsonant = false\n        }\n        if bConsonant {\n \
    \           consonants++\n        }\n        if s[end] == ' ' || end == len(s)\
    \ - 1 {\n            if consonants == n {\n                if end == len(s) -\
    \ 1 {\n                    end++\n                }\n                word = s[start:end]\n\
    \                fmt.Println(word)\n                r = append(r, word)\n    \
    \        }\n            start = end + 1\n            consonants = 0\n        }\n\
    \    }\n    return r\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Mary\nhad\nlamb\nHello\nworld\na\ne\nf\n--- FAIL: TestSelect_Words (0.00s)\n\
    \    --- FAIL: TestSelect_Words/test_num__0 (0.00s)\n        tmpmenlc8sd_test.go:78:\
    \ expected '[little]', got '[Mary]'\n    --- FAIL: TestSelect_Words/test_num__1\
    \ (0.00s)\n        tmpmenlc8sd_test.go:78: expected '[Mary lamb]', got '[had lamb]'\n\
    \    --- FAIL: TestSelect_Words/test_num__3 (0.00s)\n        tmpmenlc8sd_test.go:78:\
    \ expected '[world]', got '[Hello world]'\n    --- FAIL: TestSelect_Words/test_num__4\
    \ (0.00s)\n        tmpmenlc8sd_test.go:78: expected '[Uncle]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__6 (0.00s)\n        tmpmenlc8sd_test.go:78:\
    \ expected '[b c d f]', got '[a e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    //TODO: Implement this function\n    return []string{}\n}\n\nfunc TestSelect_Words(t\
    \ *testing.T) {\n  candidate := select_words\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 4), expected: []string{\"little\"} },\n\
    \     { actual: candidate(\"Mary had a little lamb\", 3), expected: []string{\"\
    Mary\", \"lamb\"} },\n     { actual: candidate(\"simple white space\", 2), expected:\
    \ []string{} },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"\
    world\"} },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"\
    Uncle\"} },\n     { actual: candidate(\"\", 4), expected: []string{} },\n    \
    \ { actual: candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"\
    d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpxapdi5jj_test.go:48: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpxapdi5jj_test.go:48:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpxapdi5jj_test.go:48: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpxapdi5jj_test.go:48:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpxapdi5jj_test.go:48: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words []string\n    count := 0\n    vowel := map[rune]bool{'a': true,\
    \ 'e': true, 'i': true, 'o': true, 'u': true}\n    for _, letter := range s {\n\
    \        if !vowel[letter] {\n            count++\n        }\n    }\n    return\
    \ words\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4),\
    \ expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a little\
    \ lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"\
    simple white space\", 2), expected: []string{} },\n     { actual: candidate(\"\
    Hello world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"\
    Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\
    \", 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1),\
    \ expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp5nywbym5_test.go:55: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp5nywbym5_test.go:55:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp5nywbym5_test.go:55: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp5nywbym5_test.go:55:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmp5nywbym5_test.go:55: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    return nil\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate :=\
    \ select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"Mary had a little lamb\"\
    , 4), expected: []string{\"little\"} },\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual:\
    \ candidate(\"simple white space\", 2), expected: []string{} },\n     { actual:\
    \ candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n     { actual:\
    \ candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n     { actual:\
    \ candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"a b\
    \ c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpbkmi_f63_test.go:47: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpbkmi_f63_test.go:47:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpbkmi_f63_test.go:47: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075115
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    if len(s) == 0 {\n        return result\n  \
    \  }\n    s = s + \" \"\n    var word string\n    counter := 0\n    for _, c :=\
    \ range s {\n        if c != ' ' {\n            word = word + string(c)\n    \
    \        if is_vowel(c) {\n                counter = 0\n            } else {\n\
    \                counter++\n            }\n        } else {\n            if counter\
    \ == n {\n                result = append(result, word)\n            }\n     \
    \       word = \"\"\n            counter = 0\n        }\n    }\n    return result\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbrke0osd_test.go:35:16: undefined: is_vowel

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075304
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var result []string\n    for _, word := range words(s) {\n        if\
    \ countConsonants(word) == n {\n            result = append(result, word)\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n\
    \  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeyfcr4e3_test.go:26:26: undefined: words

    /tmp/tmpeyfcr4e3_test.go:27:12: undefined: countConsonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    words := []string{}\n    for _, v := range s {\n        if v == ' ' {\n\
    \            words = append(words, \"\")\n        } else {\n            words[len(words)-1]\
    \ += string(v)\n        }\n    }\n    f := func(r rune) bool {\n        switch\
    \ r {\n        case 'a', 'e', 'i', 'o', 'u':\n            return true\n      \
    \  }\n        return false\n    }\n    result := []string{}\n    for _, v := range\
    \ words {\n        count := 0\n        for _, r := range v {\n            if !f(r)\
    \ {\n                count++\n            }\n        }\n        if count == n\
    \ {\n            result = append(result, v)\n        }\n    }\n    return result\n\
    }\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\npanic: runtime error: index out of\
    \ range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\n\
    goroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.select_words({0x52221b, 0x16}, 0x4)\n\t\
    /tmp/tmp2ovkjeb6_test.go:30 +0x41f\ncommand-line-arguments_test.TestSelect_Words(0x0?)\n\
    \t/tmp/tmp2ovkjeb6_test.go:62 +0x52\ntesting.tRunner(0xc0001a0340, 0x529088)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var (\n        result []string\n        word   string\n        count\
    \  int\n    )\n    for _, char := range s {\n        if char != ' ' {\n      \
    \      if 'a' <= char && char <= 'z' || 'A' <= char && char <= 'Z' {\n       \
    \         count++\n            }\n            word += string(char)\n        }\
    \ else {\n            if count == n {\n                result = append(result,\
    \ word)\n            }\n            word = \"\"\n            count = 0\n     \
    \   }\n    }\n    if count == n {\n        result = append(result, word)\n   \
    \ }\n    return result\n}\n\nfunc TestSelect_Words(t *testing.T) {\n  candidate\
    \ := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Mary had a\
    \ little lamb\", 4), expected: []string{\"little\"} },\n     { actual: candidate(\"\
    Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"} },\n    \
    \ { actual: candidate(\"simple white space\", 2), expected: []string{} },\n  \
    \   { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"} },\n\
    \     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"} },\n\
    \     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual: candidate(\"\
    a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmp2i_ls9im_test.go:69: expected '[little]', got '[Mary lamb]'\n\
    \    --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmp2i_ls9im_test.go:69:\
    \ expected '[Mary lamb]', got '[had]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmp2i_ls9im_test.go:69: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmp2i_ls9im_test.go:69:\
    \ expected '[Uncle]', got '[sam]'\n    --- FAIL: TestSelect_Words/test_num__6\
    \ (0.00s)\n        tmp2i_ls9im_test.go:69: expected '[b c d f]', got '[a b c d\
    \ e f]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075304
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var words = make([]string, 0)\n    if len(s) == 0 {\n        return words\n\
    \    }\n    var start, end int\n    for end = 0; end < len(s); end++ {\n     \
    \   if s[end] == ' ' {\n            var count = count_consonants(s[start:end])\n\
    \            if count == n {\n                words = append(words, s[start:end])\n\
    \            }\n            start = end + 1\n        }\n    }\n    var count =\
    \ count_consonants(s[start:end])\n    if count == n {\n        words = append(words,\
    \ s[start:end])\n    }\n    return words\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpueq4g3c9_test.go:32:25: undefined: count_consonants

    /tmp/tmpueq4g3c9_test.go:39:17: undefined: count_consonants

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075304
- exit_code: 2
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    var ret []string\n    var flag bool\n    for _, word := range split(s)\
    \ {\n        if len(word) == 0 {\n            continue\n        }\n        flag\
    \ = true\n        for _, c := range word {\n            if c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' {\n                flag = false\n      \
    \          break\n            }\n        }\n        if flag && n == len(word)\
    \ {\n            ret = append(ret, word)\n        }\n    }\n    return ret\n}\n\
    \nfunc TestSelect_Words(t *testing.T) {\n  candidate := select_words\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"Mary had a little lamb\", 4), expected:\
    \ []string{\"little\"} },\n     { actual: candidate(\"Mary had a little lamb\"\
    , 3), expected: []string{\"Mary\", \"lamb\"} },\n     { actual: candidate(\"simple\
    \ white space\", 2), expected: []string{} },\n     { actual: candidate(\"Hello\
    \ world\", 4), expected: []string{\"world\"} },\n     { actual: candidate(\"Uncle\
    \ sam\", 3), expected: []string{\"Uncle\"} },\n     { actual: candidate(\"\",\
    \ 4), expected: []string{} },\n     { actual: candidate(\"a b c d e f\", 1), expected:\
    \ []string{\"b\", \"c\", \"d\", \"f\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfdton438_test.go:27:26: undefined: split

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075304
- exit_code: 1
  program: "package select_words_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// Given a string s and a natural number n, you have been tasked to implement\
    \ \n// a function that returns a list of all words from string s that contain\
    \ exactly \n// n consonants, in order these words appear in the string s.\n//\
    \ If the string s is empty then the function should return an empty list.\n//\
    \ Note: you may assume the input string contains only letters and spaces.\n//\
    \ Examples:\n// >>> select_words(\"Mary had a little lamb\", 4)\n// []string{\"\
    little\"}\n// >>> select_words(\"Mary had a little lamb\", 3)\n// []string{\"\
    Mary\", \"lamb\"}\n// >>> select_words(\"simple white space\", 2)\n// []string{}\n\
    // >>> select_words(\"Hello world\", 4)\n// []string{\"world\"}\n// >>> select_words(\"\
    Uncle sam\", 3)\n// []string{\"Uncle\"}\nfunc select_words(s string, n int) []string\
    \ {\n    if len(s) == 0 {\n        return []string{}\n    }\n    // write your\
    \ solution here...\n    return []string{}\n}\n\nfunc TestSelect_Words(t *testing.T)\
    \ {\n  candidate := select_words\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    Mary had a little lamb\", 4), expected: []string{\"little\"} },\n     { actual:\
    \ candidate(\"Mary had a little lamb\", 3), expected: []string{\"Mary\", \"lamb\"\
    } },\n     { actual: candidate(\"simple white space\", 2), expected: []string{}\
    \ },\n     { actual: candidate(\"Hello world\", 4), expected: []string{\"world\"\
    } },\n     { actual: candidate(\"Uncle sam\", 3), expected: []string{\"Uncle\"\
    } },\n     { actual: candidate(\"\", 4), expected: []string{} },\n     { actual:\
    \ candidate(\"a b c d e f\", 1), expected: []string{\"b\", \"c\", \"d\", \"f\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSelect_Words (0.00s)\n    --- FAIL: TestSelect_Words/test_num__0\
    \ (0.00s)\n        tmpv26qi837_test.go:51: expected '[little]', got '[]'\n   \
    \ --- FAIL: TestSelect_Words/test_num__1 (0.00s)\n        tmpv26qi837_test.go:51:\
    \ expected '[Mary lamb]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__3\
    \ (0.00s)\n        tmpv26qi837_test.go:51: expected '[world]', got '[]'\n    ---\
    \ FAIL: TestSelect_Words/test_num__4 (0.00s)\n        tmpv26qi837_test.go:51:\
    \ expected '[Uncle]', got '[]'\n    --- FAIL: TestSelect_Words/test_num__6 (0.00s)\n\
    \        tmpv26qi837_test.go:51: expected '[b c d f]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075305
