language: go_test.go
name: HumanEval_96_count_up_to
results:
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var ret []int\n    for i := 2; i < n; i++ {\n        isPrime :=\
    \ true\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n      \
    \          isPrime = false\n                break\n            }\n        }\n\
    \        if isPrime {\n            ret = append(ret, i)\n        }\n    }\n  \
    \  return ret\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075075
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 1 {\n        return []int{}\n    }\n    var ints []int\n\
    \    for i := 1; i < n; i++ {\n        if is_prime(i) {\n            ints = append(ints,\
    \ i)\n        }\n    }\n    return ints\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb5z9m9y0_test.go:29:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075075
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return []int{}\n    }\n\n    primes := []int{2}\n\
    \    for i := 3; i < n; i++ {\n        prime := true\n        for _, v := range\
    \ primes {\n            if i % v == 0 {\n                prime = false\n     \
    \           break\n            }\n        }\n        if prime {\n            primes\
    \ = append(primes, i)\n        }\n    }\n    return primes\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075075
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var list []int\n    for i := 2; i < n; i++ {\n        if is_prime(i)\
    \ {\n            list = append(list, i)\n        }\n    }\n    return list\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpotgc9cya_test.go:26:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075075
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var result []int\n\n    for i := 2; i < n; i++ {\n        is_prime\
    \ := true\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n   \
    \             is_prime = false\n                break\n            }\n       \
    \ }\n        if is_prime {\n            result = append(result, i)\n        }\n\
    \    }\n\n    return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075075
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n\tvar ret []int\n\t//primes := []int{2, 3, 5, 7, 11, 13, 17, 19}\n\t\
    if n < 1 {\n\t\treturn ret\n\t}\n\tfor i := 1; i < n; i++ {\n\t\tif i > 1 {\n\t\
    \t\tif i % 2 == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor j := 3; j < i; j++ {\n\
    \t\t\t\tif i % j == 0 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif j == i - 1 {\n\
    \t\t\t\t\tret = append(ret, i)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpnfkcb7j6_test.go:69: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpnfkcb7j6_test.go:69:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=5)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__2 (0.00s)\n        tmpnfkcb7j6_test.go:69: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__3\
    \ (0.00s)\n        tmpnfkcb7j6_test.go:69: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7)]', got '[%!s(int=5) %!s(int=7)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmpnfkcb7j6_test.go:69: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__7 (0.00s)\n        tmpnfkcb7j6_test.go:69: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]',\
    \ got '[%!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__8 (0.00s)\n        tmpnfkcb7j6_test.go:69: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]',\
    \ got '[%!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)\
    \ %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpnfkcb7j6_test.go:69:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[%!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31)"
  timestamp: 1660075075
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n\tvar result []int\n\tfor i := 2; i < n; i++ {\n\t\tif isPrime(i) {\n\
    \t\t\tresult = append(result, i)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwdf9nx4__test.go:26:6: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075075
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var prime_list []int\n    if n <= 1 {\n        return prime_list\n\
    \    }\n    for i := 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n     \
    \       if i % j == 0 {\n                break\n            }\n            if\
    \ j == i - 1 {\n                prime_list = append(prime_list, i)\n         \
    \   }\n        }\n    }\n    return prime_list\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpsli63i6q_test.go:63: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n    \
    \    tmpsli63i6q_test.go:63: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got\
    \ '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n\
    \        tmpsli63i6q_test.go:63: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n\
    \        tmpsli63i6q_test.go:63: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]',\
    \ got '[%!s(int=3) %!s(int=5) %!s(int=7)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmpsli63i6q_test.go:63: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]'\n  \
    \  --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpsli63i6q_test.go:63:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]'\n    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpsli63i6q_test.go:63:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpsli63i6q_test.go:63:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int"
  timestamp: 1660075075
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var nums []int\n    if n < 1 {\n        return nums\n    }\n  \
    \  if n == 1 {\n        return nums\n    }\n    if n == 2 {\n        nums = append(nums,\
    \ 2)\n        return nums\n    }\n    for i := 2; i < n; i++ {\n        if isPrime(i)\
    \ {\n            nums = append(nums, i)\n        }\n    }\n    return nums\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprjn7bk6o_test.go:36:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075075
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    return []int{}\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpsdp4m0j1_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpsdp4m0j1_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpsdp4m0j1_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075075
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var result []int\n    for i := 2; i < n; i++ {\n        if is_prime(i)\
    \ {\n            result = append(result, i)\n        }\n    }\n    return result\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvda8ukrf_test.go:26:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074922
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var list []int\n    if n == 0 {\n        return list\n    }\n \
    \   var count = 0\n    var i = 2\n    for count < n {\n        var flag = true\n\
    \        for x := 2; x < i; x++ {\n            if i % x == 0 {\n             \
    \   flag = false\n                break\n            }\n        }\n        if\
    \ flag {\n            list = append(list, i)\n            count++\n        }\n\
    \        i++\n    }\n    return list\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpmu54pjw8_test.go:69: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__1 (0.00s)\n        tmpmu54pjw8_test.go:69: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpmu54pjw8_test.go:69: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpmu54pjw8_test.go:69:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23)\
    \ %!s(int=29)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpmu54pjw8_test.go:69:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31)\
    \ %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61)\
    \ %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpmu54pjw8_test.go:69: expected '[]', got '[%!s(int=2)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpmu54pjw8_test.go:69:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11)\
    \ %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37)\
    \ %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpmu54pjw8_test.go:69:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(i"
  timestamp: 1660075075
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primeNumbers := []int{}\n    for i := 2; i < n; i++ {\n       \
    \ isPrime := true\n        for j := 2; j < i; j++ {\n            if i % j == 0\
    \ {\n                isPrime = false\n                break\n            }\n \
    \       }\n        if isPrime {\n            primeNumbers = append(primeNumbers,\
    \ i)\n        }\n    }\n    return primeNumbers\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075075
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    // YOUR CODE HERE\n    return []int{2, 3}\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__1\
    \ (0.00s)\n        tmp0rkyl421_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=2) %!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n\
    \        tmp0rkyl421_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=2) %!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n\
    \        tmp0rkyl421_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]',\
    \ got '[%!s(int=2) %!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__4 (0.00s)\n\
    \        tmp0rkyl421_test.go:50: expected '[]', got '[%!s(int=2) %!s(int=3)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp0rkyl421_test.go:50:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=2) %!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmp0rkyl421_test.go:50: expected '[]', got '[%!s(int=2) %!s(int=3)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp0rkyl421_test.go:50:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=2) %!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmp0rkyl421_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[%!s(int=2) %!s(int=3)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmp0rkyl421_test.go:50:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[%!s(int=2)\
    \ %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075075
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    return nil\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmphnf9g0f7_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmphnf9g0f7_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmphnf9g0f7_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075075
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    return nil\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmphnf9g0f7_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmphnf9g0f7_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmphnf9g0f7_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075075
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var primes []int\n    if n > 1 {\n        for i := 2; i < n; i++\
    \ {\n            isPrime := true\n            for j := 2; j < i; j++ {\n     \
    \           if i % j == 0 {\n                    isPrime = false\n           \
    \         break\n                }\n            }\n            if isPrime {\n\
    \                primes = append(primes, i)\n            }\n        }\n    }\n\
    \    return primes\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate :=\
    \ count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075075
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    res := []int{}\n    for i := 2; i < n; i++ {\n        is_prime\
    \ := true\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n   \
    \             is_prime = false\n                break\n            }\n       \
    \ }\n        if is_prime {\n            res = append(res, i)\n        }\n    }\n\
    \    return res\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075075
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var res []int\n    for i := 2; i < n; i++ {\n        for j := 2;\
    \ j <= i; j++ {\n            if i == j {\n                res = append(res, i)\n\
    \            }\n            if i % j == 0 {\n                break\n         \
    \   }\n        }\n    }\n    return res\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075075
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    numbers := make([]int,\
    \ 0)\n    for i := 2; i < n; i++ {\n        if is_prime(i) {\n            numbers\
    \ = append(numbers, i)\n        }\n    }\n    return numbers\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpimp6xkwi_test.go:29:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075075
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var arr []int\n    for i := 2; i < n; i++ {\n        for j := 2;\
    \ j <= i; j++ {\n            if i == j {\n                arr = append(arr, i)\n\
    \            }\n            if i % j == 0 {\n                break\n         \
    \   }\n        }\n    }\n    return arr\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075075
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := []int{}\n    for i := 2; i < n; i++ {\n        if IsPrime(i)\
    \ {\n            primes = append(primes, i)\n        }\n    }\n    return primes\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0d2c_vxc_test.go:26:12: undefined: IsPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075075
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var results []int\n    for i := 1; i < n; i++ {\n        if is_prime(i)\
    \ {\n            results = append(results, i)\n        }\n    }\n    return results\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppt5a3dxh_test.go:26:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075075
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        fmt.Println(\"PATCH list\")\n        return\
    \ []int{}\n    }\n    output := []int{}\n    for i := 2; i < n; i++ {\n      \
    \  if is_prime(i) {\n            output = append(output, i)\n        }\n    }\n\
    \    return output\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate :=\
    \ count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5lyidbht_test.go:30:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075075
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    var res []int\n\
    \    for i := 2; i < n; i++ {\n        if is_prime(i) {\n            res = append(res,\
    \ i)\n        }\n    }\n    return res\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzybuyfe1_test.go:29:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074924
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n\tfmt.Println(\"given: \", n)\n\tprimes := []int{}\n\tif n == 0 {\n\
    \t\treturn primes\n\t}\n\tfor i := 2; i < n; i++ {\n\t\tisPrime := true\n\t\t\
    for j := 2; j < i; j++ {\n\t\t\tif i % j == 0 {\n\t\t\t\tisPrime = false\n\t\t\
    \t\tbreak\n\t\t\t}\n\t\t}\n\t\tif isPrime {\n\t\t\tprimes = append(primes, i)\n\
    \t\t}\n\t}\n\treturn primes\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075075
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var primes []int\n    for i := 2; i < n; i++ {\n        if is_prime(i)\
    \ {\n            primes = append(primes, i)\n        }\n    }\n    return primes\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsw1fwi22_test.go:26:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074922
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    result := []int{}\n    if n < 2 {\n        return result\n    }\n\
    \    for i := 2; i < n; i++ {\n        isPrime := true\n        for j := 2; j\
    \ < i; j++ {\n            if i % j == 0 {\n                isPrime = false\n \
    \               break\n            }\n        }\n        if isPrime {\n      \
    \      result = append(result, i)\n        }\n    }\n    return result\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075077
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    // BEGIN\n    list := []int{}\n    for i := 2; i < n; i++ {\n \
    \       if is_prime(i) {\n            list = append(list, i)\n        }\n    }\n\
    \    return list\n    // END\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdeq9qbac_test.go:27:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075077
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var primes []int\n    for i := 2; i < n; i++ {\n        for j :=\
    \ 2; j <= i; j++ {\n            if i == j {\n                primes = append(primes,\
    \ i)\n            }\n            if i % j == 0 {\n                break\n    \
    \        }\n        }\n    }\n    return primes\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075077
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    lst := []int{}\n    for i := 2; i < n; i++ {\n        if is_prime(i)\
    \ {\n            lst = append(lst, i)\n        }\n    }\n    return lst\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj1a8utl6_test.go:26:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075077
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var list []int\n    if n < 2 {\n        return list\n    }\n  \
    \  for i := 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if\
    \ i % j == 0 {\n                break\n            }\n            if j == i -\
    \ 1 {\n                list = append(list, i)\n            }\n        }\n    }\n\
    \    return list\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpkrqnp5be_test.go:63: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n    \
    \    tmpkrqnp5be_test.go:63: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got\
    \ '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n\
    \        tmpkrqnp5be_test.go:63: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n\
    \        tmpkrqnp5be_test.go:63: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]',\
    \ got '[%!s(int=3) %!s(int=5) %!s(int=7)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmpkrqnp5be_test.go:63: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]'\n  \
    \  --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpkrqnp5be_test.go:63:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]'\n    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpkrqnp5be_test.go:63:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpkrqnp5be_test.go:63:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int"
  timestamp: 1660075077
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var ret []int\n    if n < 2 {\n        return ret\n    }\n    var\
    \ count = 1\n    for i := 2; i < n; i++ {\n        var p = true\n        for j\
    \ := 2; j <= count; j++ {\n            if i % j == 0 {\n                p = false\n\
    \                break\n            }\n        }\n        if p {\n           \
    \ ret = append(ret, i)\n            count++\n        }\n    }\n    return ret\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075077
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    return nil\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmphnf9g0f7_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmphnf9g0f7_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmphnf9g0f7_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075075
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime_numbers := []int{}\n    if n < 2 {\n        return prime_numbers\n\
    \    }\n    for i := 2; i < n; i++ {\n        is_prime := true\n        for j\
    \ := 2; j < i; j++ {\n            if i % j == 0 {\n                is_prime =\
    \ false\n                break\n            }\n        }\n        if is_prime\
    \ {\n            prime_numbers = append(prime_numbers, i)\n        }\n    }\n\
    \    return prime_numbers\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075077
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    // good luck!\n    return nil\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpnpibir7r_test.go:50: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpnpibir7r_test.go:50:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpnpibir7r_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpnpibir7r_test.go:50:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpnpibir7r_test.go:50: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpnpibir7r_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpnpibir7r_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpnpibir7r_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075077
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    // Your implementation goes here!\n    // REMOVE the next line\
    \ to get started.\n    return []int{0}\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpskdgbmw7_test.go:51: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n    \
    \    tmpskdgbmw7_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got\
    \ '[%!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmpskdgbmw7_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=0)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__3 (0.00s)\n        tmpskdgbmw7_test.go:51: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=0)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__4 (0.00s)\n        tmpskdgbmw7_test.go:51: expected\
    \ '[]', got '[%!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n\
    \        tmpskdgbmw7_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=0)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__6 (0.00s)\n        tmpskdgbmw7_test.go:51: expected\
    \ '[]', got '[%!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpskdgbmw7_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=0)]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpskdgbmw7_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[%!s(int=0)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpskdgbmw7_test.go:51: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)\
    \ %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73)\
    \ %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[%!s(int=0)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075078
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return []int{}\n    }\n    res := []int{}\n\
    \    for i := 2; i < n; i++ {\n        is_prime := true\n        for j := 2; j\
    \ < i; j++ {\n            if i % j == 0 {\n                is_prime = false\n\
    \                break\n            }\n        }\n        if is_prime {\n    \
    \        res = append(res, i)\n        }\n    }\n    return res\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075078
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var list []int\n    for i := 1; i < n; i++ {\n        if i > 1\
    \ {\n            isPrime := true\n            for j := 2; j <= i/2; j++ {\n  \
    \              if i%j == 0 {\n                    isPrime = false\n          \
    \          break\n                }\n            }\n            if isPrime {\n\
    \                list = append(list, i)\n            }\n        }\n    }\n   \
    \ return list\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075078
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    results := []int{}\n    for i := 2; i < n; i++ {\n        flag\
    \ := true\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n   \
    \             flag = false\n                break\n            }\n        }\n\
    \        if flag {\n            results = append(results, i)\n        }\n    }\n\
    \    return results\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate :=\
    \ count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075078
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var res []int\n    for i := 2; i < n; i++ {\n        if is_prime(i)\
    \ {\n            res = append(res, i)\n        }\n    }\n    return res\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphrj0glwa_test.go:26:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075077
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        panic(\"Patch list\")\n    }\n    var primes\
    \ []int\n    p := 2\n    for p <= n {\n        primes = append(primes, p)\n  \
    \      p = next_prime(p)\n    }\n    return primes\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfgp3uldk_test.go:31:13: undefined: next_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075077
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var primeNumbers []int\n    for n >= 2 {\n        if isPrime(n)\
    \ {\n            primeNumbers = append(primeNumbers, n)\n        }\n        n--\n\
    \    }\n    return primeNumbers\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n \
    \ candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdeqlziyp_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075077
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    nums := []int{}\n    for i := 2; i < n; i++ {\n        is_prime\
    \ := true\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n   \
    \             is_prime = false\n                break\n            }\n       \
    \ }\n        if is_prime {\n            nums = append(nums, i)\n        }\n  \
    \  }\n    return nums\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075078
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    // check to see if n is negative\n    if n < 0 {\n        return\
    \ []int{}\n    }\n    var result []int\n    for i := 2; i < n; i++ {\n       \
    \ var is_prime bool = true\n        // check to see if i is prime, if it is then\
    \ add to result\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n\
    \                is_prime = false\n                break\n            }\n    \
    \    }\n        if is_prime {\n            result = append(result, i)\n      \
    \  }\n    }\n    return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075078
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var primes []int\n    if n <= 1 {\n        return primes\n    }\n\
    \    if n == 2 {\n        primes = append(primes, 2)\n        return primes\n\
    \    }\n    for i := 2; i < n; i++ {\n        prime := true\n        for _, j\
    \ := range primes {\n            if i % j == 0 {\n                prime = false\n\
    \                break\n            }\n        }\n        if prime {\n       \
    \     primes = append(primes, i)\n        }\n    }\n    return primes\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075078
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var result []int\n    for i := 2; i < n; i++ {\n        for j :=\
    \ 2; j < i; j++ {\n            if i % j == 0 {\n                goto NEXT\n  \
    \          }\n        }\n        result = append(result, i)\n        NEXT:\n \
    \   }\n    return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075078
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    res := []int{}\n    for i := 2; i < n; i++ {\n        flag := true\n\
    \        for j := 2; j < i; j++ {\n            if i % j == 0 {\n             \
    \   flag = false\n                break\n            }\n        }\n        if\
    \ flag {\n            res = append(res, i)\n        }\n    }\n    return res\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075078
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var result []int\n    if n < 2 {\n        return result\n    }\n\
    \    result = append(result, 2)\n    for i := 3; i < n; i = i + 2 {\n        if\
    \ is_prime(i) {\n            result = append(result, i)\n        }\n    }\n  \
    \  return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqg8qmgne_test.go:30:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075077
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    // Your code here\n    var result []int\n    for i := 2; i < n;\
    \ i++ {\n        if isPrime(i) {\n            result = append(result, i)\n   \
    \     }\n    }\n    return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfcaxrp95_test.go:27:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075077
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    result := []int{2}\n\
    \    for i := 3; i < n; i++ {\n        j := 0\n        for ; j < len(result);\
    \ j++ {\n            if i % result[j] == 0 {\n                break\n        \
    \    }\n        }\n        if j == len(result) {\n            result = append(result,\
    \ i)\n        }\n    }\n    return result\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075078
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var result []int\n    for i := 2; i < n; i++ {\n        if is_prime(i)\
    \ {\n            result = append(result, i)\n        }\n    }\n    return result\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvda8ukrf_test.go:26:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074922
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return []int{}\n    }\n    arr := []int{}\n\
    \    for i := 2; i < n; i++ {\n        if isPrime(i) {\n            arr = append(arr,\
    \ i)\n        }\n    }\n    return arr\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7kjivk68_test.go:29:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075079
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    count := []int{}\n    for i := 2; i < n; i++ {\n        prime :=\
    \ true\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n      \
    \          prime = false\n                break\n            }\n        }\n  \
    \      if prime {\n            count = append(count, i)\n        }\n    }\n  \
    \  return count\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075079
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return nil\n    }\n    arr := make([]int,\
    \ 0)\n    for i := 2; i < n; i++ {\n        if isPrime(i) {\n            arr =\
    \ append(arr, i)\n        }\n    }\n    return arr\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4n76d3of_test.go:29:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075079
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return nil\n    }\n    result := []int{}\n\
    \    for i := 2; i < n; i++ {\n        isPrime := true\n        for j := 2; j\
    \ < i; j++ {\n            if i % j == 0 {\n                isPrime = false\n \
    \               break\n            }\n        }\n        if isPrime {\n      \
    \      result = append(result, i)\n        }\n    }\n    return result\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075080
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return []int{}\n    }\n\n    var result []int\n\
    \    for i := 2; i < n; i++ {\n        if prime(i) {\n            result = append(result,\
    \ i)\n        }\n    }\n    return result\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzho03uq4_test.go:30:12: undefined: prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075079
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return []int{}\n    }\n    is_prime := func(n\
    \ int) bool {\n        for i := 2; i < n; i++ {\n            if n % i == 0 {\n\
    \                return false\n            }\n        }\n        return true\n\
    \    }\n    // 1. find the length of the list\n    ret_len := 0\n    for i :=\
    \ 1; i < n; i++ {\n        if is_prime(i) {\n            ret_len++\n        }\n\
    \    }\n    ret := make([]int, ret_len)\n    // 2. now find the list\n    index\
    \ := 0\n    for i := 1; i < n; i++ {\n        if is_prime(i) {\n            ret[index]\
    \ = i\n            index++\n        }\n    }\n    return ret\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp63nb2dye_test.go:76: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__1\
    \ (0.00s)\n        tmp63nb2dye_test.go:76: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp63nb2dye_test.go:76: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__3\
    \ (0.00s)\n        tmp63nb2dye_test.go:76: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp63nb2dye_test.go:76:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__7 (0.00s)\n        tmp63nb2dye_test.go:76: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]',\
    \ got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]'\n    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp63nb2dye_test.go:76:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31)\
    \ %!s(int=37) %!s(int=41) %!s(int=43)]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmp63nb2dye_test.go:76: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s("
  timestamp: 1660075080
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 1 {\n        return nil\n    }\n    var result []int\n \
    \   var i int\n    for i = 2; i < n; i++ {\n        if is_prime(i) {\n       \
    \     result = append(result, i)\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpakgw063l_test.go:30:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075079
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primeList := []int{}\n    if n <= 0 {\n        return primeList\n\
    \    }\n    for i := 2; i < n; i++ {\n        flag := true\n        for j := 2;\
    \ j <= i/2; j++ {\n            if i%j == 0 {\n                flag = false\n \
    \               break\n            }\n        }\n        if flag {\n         \
    \   primeList = append(primeList, i)\n        }\n    }\n    return primeList\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075080
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := []int{}\n    for i := 2; i < n; i++ {\n        isPrime\
    \ := true\n        for j := 2; j <= i/2; j++ {\n            if i%j == 0 {\n  \
    \              isPrime = false\n                break\n            }\n       \
    \ }\n        if isPrime {\n            primes = append(primes, i)\n        }\n\
    \    }\n    return primes\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075080
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return nil\n    }\n    var list []int\n   \
    \ for i := 2; i < n; i++ {\n        if is_prime(i) {\n            list = append(list,\
    \ i)\n        }\n    }\n    return list\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqoqifmei_test.go:29:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075079
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var ret []int\n    if n > 1 {\n        for i := 2; i < n; i++ {\n\
    \            for j := 2; j <= i; j++ {\n                if i == j {\n        \
    \            ret = append(ret, i)\n                } else if i % j == 0 {\n  \
    \                  break\n                }\n            }\n        }\n    }\n\
    \    return ret\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075080
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := []int{}\n    if n < 2 {\n        return primes\n    }\n\
    \    for i := 2; i < n; i++ {\n        prime := true\n        for j := 2; j <\
    \ i; j++ {\n            if i % j == 0 {\n                prime = false\n     \
    \           break\n            }\n        }\n        if prime {\n            primes\
    \ = append(primes, i)\n        }\n    }\n    return primes\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075080
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    result := []int{}\n    for i := 2; i < n; i++ {\n        is_prime\
    \ := true\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n   \
    \             is_prime = false\n                break\n            }\n       \
    \ }\n        if is_prime {\n            result = append(result, i)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075080
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var res []int\n    for i := 1; i < n; i++ {\n        if is_prime(i)\
    \ {\n            res = append(res, i)\n        }\n    }\n    return res\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr906q64e_test.go:26:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075080
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var primes []int\n    for i := 2; i < n; i++ {\n        for j :=\
    \ 2; j < i; j++ {\n            if i % j == 0 {\n                break\n      \
    \      } else if j == i - 1 {\n                primes = append(primes, i)\n  \
    \          }\n        }\n    }\n    return primes\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpv763wemf_test.go:59: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n    \
    \    tmpv763wemf_test.go:59: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got\
    \ '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n\
    \        tmpv763wemf_test.go:59: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n\
    \        tmpv763wemf_test.go:59: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]',\
    \ got '[%!s(int=3) %!s(int=5) %!s(int=7)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmpv763wemf_test.go:59: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]'\n  \
    \  --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpv763wemf_test.go:59:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]'\n    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpv763wemf_test.go:59:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpv763wemf_test.go:59:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int"
  timestamp: 1660075080
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var re []int\n    if n <= 0 {\n        re = make([]int, 0)\n  \
    \  } else {\n        re = make([]int, n)\n        for i := 0; i < n; i++ {\n \
    \           if i < 2 {\n                re[i] = 0\n            } else {\n    \
    \            re[i] = 1\n            }\n        }\n        for i := 2; i < n; i++\
    \ {\n            if re[i] == 1 {\n                for j := 2; i * j < n; j++ {\n\
    \                    re[i * j] = 0\n                }\n            }\n       \
    \ }\n        var k int\n        for i := 0; i < n; i++ {\n            if re[i]\
    \ == 1 {\n                re[k] = i\n                k++\n            }\n    \
    \    }\n        re = re[:k]\n    }\n    return re\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075080
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    r:=[]int{}\n    if n==0{\n        return r\n    }\n    if n==1{\n\
    \        return r\n    }\n    r=append(r,2)\n    for i:=3;i<n;i+=2{\n        for\
    \ j:=0;j<len(r);j++{\n            if i%r[j]==0{\n                break\n     \
    \       }\n            if j==len(r)-1{\n                r=append(r,i)\n      \
    \      }\n        }\n    }\n    return r\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075080
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    // check if n is negative\n    if n < 0 {\n        return []int{}\n\
    \    }\n\n    var primes []int\n    // check if n is prime\n    for i := 2; i\
    \ < n; i++ {\n        isPrime := true\n        for j := 2; j < i; j++ {\n    \
    \        if i % j == 0 {\n                isPrime = false\n                break\n\
    \            }\n        }\n        if isPrime {\n            primes = append(primes,\
    \ i)\n        }\n    }\n    return primes\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075080
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var primes []int\n    for i := 1; i < n; i++ {\n        if is_prime(i)\
    \ {\n            primes = append(primes, i)\n        }\n    }\n    return primes\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6l02advo_test.go:26:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075080
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 1 {\n        return []int{}\n    }\n\n    for i := 2; i\
    \ <= n; i++ {\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n\
    \                break\n            }\n        }\n    }\n    return []int{2, 3,\
    \ 5, 7, 11, 13, 17, 19}\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpywa0s80z_test.go:60: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpywa0s80z_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__2 (0.00s)\n        tmpywa0s80z_test.go:60: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__3 (0.00s)\n        tmpywa0s80z_test.go:60: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]'\n  \
    \  --- FAIL: TestCount_Up_To/test_num__6 (0.00s)\n        tmpywa0s80z_test.go:60:\
    \ expected '[]', got '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11)\
    \ %!s(int=13) %!s(int=17) %!s(int=19)]'\n    --- FAIL: TestCount_Up_To/test_num__7\
    \ (0.00s)\n        tmpywa0s80z_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]'\n  \
    \  --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpywa0s80z_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]', got '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11)\
    \ %!s(int=13) %!s(int=17) %!s(int=19)]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpywa0s80z_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int="
  timestamp: 1660075080
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    numbers := make([]int, 0)\n    if n > 0 {\n        for i := 2;\
    \ i < n; i++ {\n            prime := true\n            for j := 2; j < i; j++\
    \ {\n                if i % j == 0 {\n                    prime = false\n    \
    \                break\n                }\n            }\n            if prime\
    \ {\n                numbers = append(numbers, i)\n            }\n        }\n\
    \    }\n    return numbers\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075080
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    res := []int{}\n    for i := 2; i < n; i++ {\n        if is_prime(i)\
    \ {\n            res = append(res, i)\n        }\n    }\n    return res\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpubmbx2ls_test.go:26:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075080
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    return []int{}\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpsdp4m0j1_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpsdp4m0j1_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpsdp4m0j1_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075075
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        panic(\"patch list\")\n    }\n    primes :=\
    \ []int{}\n    for i := 2; i < n; i++ {\n        isPrime := true\n        for\
    \ j := 2; j < i; j++ {\n            if i % j == 0 {\n                isPrime =\
    \ false\n                break\n            }\n        }\n        if isPrime {\n\
    \            primes = append(primes, i)\n        }\n    }\n    return primes\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: patch list [recovered]\n\tpanic:\
    \ patch list\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x4fcd60, 0x548978})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x4fcd60,\
    \ 0x548978})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp9q5xx6wi_test.go:25\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp9q5xx6wi_test.go:54\
    \ +0x21b\ntesting.tRunner(0xc000199040, 0x527d48)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075080
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var PrimeNumbers []int\n    if n == 0 {\n        return PrimeNumbers\n\
    \    } else if n == 1 {\n        return PrimeNumbers\n    } else {\n        isPrime\
    \ := true\n        for i := 2; i < n; i++ {\n            for j := 2; j < i; j++\
    \ {\n                if i % j == 0 {\n                    isPrime = false\n  \
    \                  break\n                }\n            }\n            if isPrime\
    \ {\n                PrimeNumbers = append(PrimeNumbers, i)\n            }\n \
    \           isPrime = true\n        }\n        return PrimeNumbers\n    }\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075081
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return nil\n    }\n    prime_numbers := []int{}\n\
    \    for i := 2; i < n; i++ {\n        k := 0\n        for j := 2; j < i; j++\
    \ {\n            if i % j == 0 {\n                k++\n            }\n       \
    \ }\n        if k == 0 {\n            prime_numbers = append(prime_numbers, i)\n\
    \        }\n    }\n    return prime_numbers\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075082
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var a []int\n    for i := 2; i < n; i++ {\n        for j := 2;\
    \ j < i; j++ {\n            if i % j == 0 {\n                break\n         \
    \   } else if i == j + 1 {\n                a = append(a, i)\n            }\n\
    \        }\n    }\n    return a\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n \
    \ candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp9ax03opa_test.go:59: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n    \
    \    tmp9ax03opa_test.go:59: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got\
    \ '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n\
    \        tmp9ax03opa_test.go:59: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n\
    \        tmp9ax03opa_test.go:59: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]',\
    \ got '[%!s(int=3) %!s(int=5) %!s(int=7)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmp9ax03opa_test.go:59: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]'\n  \
    \  --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp9ax03opa_test.go:59:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]'\n    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp9ax03opa_test.go:59:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmp9ax03opa_test.go:59:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int"
  timestamp: 1660075082
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 1 {\n        return nil\n    }\n    var primes []int\n \
    \   for i := 2; i < n; i++ {\n        is_prime := true\n        for j := 2; j\
    \ < i; j++ {\n            if i % j == 0 {\n                is_prime = false\n\
    \                break\n            }\n        }\n        if is_prime {\n    \
    \        primes = append(primes, i)\n        }\n    }\n    return primes\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075082
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var results []int\n    for i := 2; i < n; i++ {\n        for j\
    \ := 2; j < i; j++ {\n            if i % j == 0 {\n                break\n   \
    \         }\n            if j == i - 1 {\n                results = append(results,\
    \ i)\n            }\n        }\n    }\n    return results\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpwb22m08u_test.go:60: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n    \
    \    tmpwb22m08u_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got\
    \ '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n\
    \        tmpwb22m08u_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n\
    \        tmpwb22m08u_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]',\
    \ got '[%!s(int=3) %!s(int=5) %!s(int=7)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmpwb22m08u_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]'\n  \
    \  --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpwb22m08u_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]'\n    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpwb22m08u_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpwb22m08u_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int"
  timestamp: 1660075082
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    return []int{}\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpsdp4m0j1_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpsdp4m0j1_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpsdp4m0j1_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075075
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var ret = []int{}\n    var i int = 2\n    for ; i <= n; i++ {\n\
    \        j := 2\n        for ; j < i; j++ {\n            if i % j == 0 {\n   \
    \             break\n            }\n        }\n        if j == i {\n         \
    \   ret = append(ret, i)\n        }\n    }\n    return ret\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpy7rdb57u_test.go:62: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=2) %!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpy7rdb57u_test.go:62: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpy7rdb57u_test.go:62: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23)\
    \ %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpy7rdb57u_test.go:62:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[%!s(int=2)\
    \ %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)\
    \ %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47)\
    \ %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79)\
    \ %!s(int=83) %!s(int=89) %!s(int=97) %!s(int=101)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075082
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    return nil\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmphnf9g0f7_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmphnf9g0f7_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmphnf9g0f7_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075075
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    return []int{}\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpsdp4m0j1_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpsdp4m0j1_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpsdp4m0j1_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075075
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    return []int{}\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpsdp4m0j1_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpsdp4m0j1_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpsdp4m0j1_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075075
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var result []int\n    if n < 1 {\n        return result\n    }\n\
    \    var primes []int\n    for i := 2; i < n; i++ {\n        isPrime := true\n\
    \        for _, prime := range primes {\n            if i % prime == 0 {\n   \
    \             isPrime = false\n                break\n            }\n        }\n\
    \        if isPrime {\n            primes = append(primes, i)\n        }\n   \
    \ }\n    return primes\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075082
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primeNumbers := []int{}\n    for i := 2; i < n; i++ {\n       \
    \ if isPrime(i) {\n            primeNumbers = append(primeNumbers, i)\n      \
    \  }\n    }\n    return primeNumbers\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa0dox5d9_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075082
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return nil\n    }\n    limit := n + 1\n   \
    \ primes := make([]int, 0, n)\n    for i := 2; i < limit; i++ {\n        for j\
    \ := 2; j * j <= i; j++ {\n            if i % j == 0 {\n                break\n\
    \            }\n            if j + 1 > int(math.Sqrt(float64(i))) {\n        \
    \        primes = append(primes, i)\n            }\n        }\n    }\n    return\
    \ primes\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4gawnqka_test.go:34:28: undefined: math

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075082
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var result []int\n    if n < 1 {\n        return result\n    }\n\
    \    result = append(result, 2)\n    if n < 3 {\n        return result\n    }\n\
    \    for i := 3; i < n; i++ {\n        isPrime := true\n        for j := 2; j\
    \ < i; j++ {\n            if i % j == 0 {\n                isPrime = false\n \
    \               break\n            }\n        }\n        if isPrime {\n      \
    \      result = append(result, i)\n        }\n    }\n    return result\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpscwbpf66_test.go:69: expected '[]', got '[%!s(int=2)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075082
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var result []int\n    for i := 2; i < n; i++ {\n        if is_prime(i)\
    \ {\n            result = append(result, i)\n        }\n    }\n    return result\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvda8ukrf_test.go:26:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074922
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    res := []int{}\n    if n < 2 {\n        return res\n    }\n   \
    \ for num := 2; num < n; num++ {\n        if is_prime(num) {\n            res\
    \ = append(res, num)\n        }\n    }\n    return res\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxv6m4yfu_test.go:29:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075082
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    list := []int{2}\n\
    \    n += 1\n    for i := 3; i < n; i++ {\n        is_prime := true\n        for\
    \ _, v := range list {\n            if i % v == 0 {\n                is_prime\
    \ = false\n                break\n            }\n        }\n        if is_prime\
    \ {\n            list = append(list, i)\n        }\n    }\n    return list\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpwz1n4kpq_test.go:66: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=2) %!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpwz1n4kpq_test.go:66: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpwz1n4kpq_test.go:66: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23)\
    \ %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpwz1n4kpq_test.go:66:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[%!s(int=2)\
    \ %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)\
    \ %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47)\
    \ %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79)\
    \ %!s(int=83) %!s(int=89) %!s(int=97) %!s(int=101)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075082
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var answer []int\n    if n == 0 {\n        return answer\n    }\n\
    \    for i := 2; i < n; i++ {\n        if is_prime(i) {\n            answer =\
    \ append(answer, i)\n        }\n    }\n    return answer\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppomm384k_test.go:29:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075082
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n\tvar ret []int\n\tfor i := 1; i < n; i++ {\n\t\tif isPrime(i) {\n\t\
    \t\tret = append(ret, i)\n\t\t}\n\t}\n\treturn ret\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp518retxr_test.go:26:6: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075082
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var res []int\n    for i := 1; i < n; i++ {\n        prime := true\n\
    \        for j := 2; j < i; j++ {\n            if i % j == 0 {\n             \
    \   prime = false\n                break\n            }\n        }\n        if\
    \ prime {\n            res = append(res, i)\n        }\n    }\n    return res\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpb75lkq72_test.go:62: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__1\
    \ (0.00s)\n        tmpb75lkq72_test.go:62: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpb75lkq72_test.go:62: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__3\
    \ (0.00s)\n        tmpb75lkq72_test.go:62: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpb75lkq72_test.go:62:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__7 (0.00s)\n        tmpb75lkq72_test.go:62: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]',\
    \ got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]'\n    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpb75lkq72_test.go:62:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]', got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31)\
    \ %!s(int=37) %!s(int=41) %!s(int=43)]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpb75lkq72_test.go:62: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s("
  timestamp: 1660075082
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return nil\n    }\n    primes := []int{}\n\
    \    if n >= 2 {\n        primes = append(primes, 2)\n    }\n    if n >= 3 {\n\
    \        primes = append(primes, 3)\n    }\n    for i := 5; i < n; i += 2 {\n\
    \        isPrime := true\n        for _, num := range primes {\n            if\
    \ i % num == 0 {\n                isPrime = false\n                break\n   \
    \         }\n        }\n        if isPrime {\n            primes = append(primes,\
    \ i)\n        }\n    }\n    return primes\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075082
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := []int{}\n    for i := 2; i < n; i++ {\n        isPrime\
    \ := true\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n   \
    \             isPrime = false\n                break\n            }\n        }\n\
    \        if isPrime {\n            primes = append(primes, i)\n        }\n   \
    \ }\n    return primes\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075083
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 1 {\n        return []int{}\n    }\n\n    var prime_list\
    \ []int\n    prime_list = append(prime_list, 2)\n    if n == 2 {\n        return\
    \ prime_list\n    }\n\n    for i := 3; i < n; i += 2 {\n        is_prime := true\n\
    \        for _, v := range prime_list {\n            if i % v == 0 {\n       \
    \         is_prime = false\n                break\n            }\n        }\n\
    \        if is_prime {\n            prime_list = append(prime_list, i)\n     \
    \   }\n    }\n\n    return prime_list\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpzilcia1y_test.go:72: expected '[]', got '[%!s(int=2)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075083
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return []int{}\n    }\n    primes := []int{2}\n\
    \    for i := 3; i < n; i++ {\n        isPrime := true\n        for _, p := range\
    \ primes {\n            if i % p == 0 {\n                isPrime = false\n   \
    \             break\n            }\n        }\n        if isPrime {\n        \
    \    primes = append(primes, i)\n        }\n    }\n    return primes\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074922
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := []int{}\n    for i := 2; i < n; i++ {\n        for j\
    \ := 2; j < i; j++ {\n            if i % j == 0 {\n                break\n   \
    \         }\n            if j == i - 1 {\n                primes = append(primes,\
    \ i)\n            }\n        }\n    }\n    return primes\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpdoklovbi_test.go:60: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n    \
    \    tmpdoklovbi_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got\
    \ '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n\
    \        tmpdoklovbi_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n\
    \        tmpdoklovbi_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]',\
    \ got '[%!s(int=3) %!s(int=5) %!s(int=7)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmpdoklovbi_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]'\n  \
    \  --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpdoklovbi_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]'\n    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpdoklovbi_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpdoklovbi_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int"
  timestamp: 1660075083
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    ans := []int{}\n    for i := 1; i < n; i++ {\n        if is_prime(i)\
    \ {\n            ans = append(ans, i)\n        }\n    }\n    return ans\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3j8hmzli_test.go:26:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075083
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    // define an array to store the results\n    results := []int{}\n\
    \    // iterate over the numbers\n    for i := 2; i < n; i++ {\n        // check\
    \ if i is prime\n        if check_prime(i) {\n            // add i to the results\n\
    \            results = append(results, i)\n        }\n    }\n    return results\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiwy61rxs_test.go:29:12: undefined: check_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075083
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return []int{}\n    }\n    primes := []int{2}\n\
    \    for i := 3; i < n; i += 2 {\n        isPrime := true\n        for _, prime\
    \ := range primes {\n            if i % prime == 0 {\n                isPrime\
    \ = false\n                break\n            }\n        }\n        if isPrime\
    \ {\n            primes = append(primes, i)\n        }\n    }\n    return primes\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075083
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var result []int\n\n    if n <= 1 {\n        return result\n  \
    \  }\n\n    // count\n    for i := 2; i < n; i++ {\n        prime := true\n  \
    \      for j := 2; j < i; j++ {\n            if i % j == 0 {\n               \
    \ prime = false\n                break\n            }\n        }\n        if prime\
    \ {\n            result = append(result, i)\n        }\n    }\n\n    return result\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075083
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var result []int\n    if n < 2 {\n        return result\n    }\n\
    \    for i := 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if\
    \ i % j == 0 {\n                break\n            }\n            if j == i -\
    \ 1 {\n                result = append(result, i)\n            }\n        }\n\
    \    }\n    return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpd3ptvhh6_test.go:63: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n    \
    \    tmpd3ptvhh6_test.go:63: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got\
    \ '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n\
    \        tmpd3ptvhh6_test.go:63: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n\
    \        tmpd3ptvhh6_test.go:63: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]',\
    \ got '[%!s(int=3) %!s(int=5) %!s(int=7)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmpd3ptvhh6_test.go:63: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]'\n  \
    \  --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpd3ptvhh6_test.go:63:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]'\n    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpd3ptvhh6_test.go:63:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpd3ptvhh6_test.go:63:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int"
  timestamp: 1660075084
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var res []int\n    var flag int\n    for i := 2; i < n; i++ {\n\
    \        flag = 0\n        for j := 2; j < i; j++ {\n            if i % j == 0\
    \ {\n                flag = 1\n                break\n            }\n        }\n\
    \        if flag == 0 {\n            res = append(res, i)\n        }\n    }\n\
    \    return res\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075084
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 1 {\n        return []int{}\n    }\n\n    primes := []int{2}\n\
    \    for i := 3; i < n; i++ {\n        isPrime := true\n        for _, p := range\
    \ primes {\n            if i % p == 0 {\n                isPrime = false\n   \
    \             break\n            }\n        }\n        if isPrime {\n        \
    \    primes = append(primes, i)\n        }\n    }\n    return primes\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpwnxnmjdl_test.go:66: expected '[]', got '[%!s(int=2)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075084
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return nil\n    }\n    list := make([]int,\
    \ 0)\n    for i := 2; i < n; i++ {\n        count := 0\n        for j := 1; j\
    \ <= i; j++ {\n            if i % j == 0 {\n                count++\n        \
    \    }\n        }\n        if count == 2 {\n            list = append(list, i)\n\
    \        }\n    }\n    return list\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075084
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    return []int{}\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpsdp4m0j1_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpsdp4m0j1_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpsdp4m0j1_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075075
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return []int{}\n    }\n    var primes []int\n\
    \    for i := 2; i < n; i++ {\n        prime := true\n        for _, factor :=\
    \ range primes {\n            if i % factor == 0 {\n                prime = false\n\
    \                break\n            }\n        }\n        if prime {\n       \
    \     primes = append(primes, i)\n        }\n    }\n    return primes\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075084
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n\tresult := []int{}\n\tfor i := 2; i < n; i++ {\n\t\tif isPrime(i)\
    \ {\n\t\t\tresult = append(result, i)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptge_gln6_test.go:26:6: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075084
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var list []int\n    for i := 2; i < n; i++ {\n        if is_prime(i)\
    \ {\n            list = append(list, i)\n        }\n    }\n    return list\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpotgc9cya_test.go:26:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075075
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var res []int\n    if n == 0 {\n        return res\n    }\n   \
    \ if n == 1 {\n        return res\n    }\n    res = append(res, 2)\n    for i\
    \ := 3; i < n; i++ {\n        isPrime := true\n        for j := 2; j < i; j++\
    \ {\n            if i % j == 0 {\n                isPrime = false\n          \
    \      break\n            }\n        }\n        if isPrime {\n            res\
    \ = append(res, i)\n        }\n    }\n    return res\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075085
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var i, j int\n    count := 0\n    ans := make([]int, 0)\n    if\
    \ n <= 1 {\n        return ans\n    }\n    for i = 2; i < n; i++ {\n        for\
    \ j = 2; j <= i; j++ {\n            if i % j == 0 {\n                count++\n\
    \            }\n        }\n        if count == 1 {\n            ans = append(ans,\
    \ i)\n        }\n        count = 0\n    }\n    return ans\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075085
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    // Put your code here\n    return []int{}\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp944d8cco_test.go:50: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmp944d8cco_test.go:50:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp944d8cco_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp944d8cco_test.go:50:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp944d8cco_test.go:50: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmp944d8cco_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmp944d8cco_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmp944d8cco_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075085
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var primes []int\n    // TODO: Implement the function.\n    return\
    \ primes\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpu8v0_f7q_test.go:51: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpu8v0_f7q_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpu8v0_f7q_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpu8v0_f7q_test.go:51:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpu8v0_f7q_test.go:51: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpu8v0_f7q_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpu8v0_f7q_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpu8v0_f7q_test.go:51: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075085
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var count []int\n    if n == 0 {\n        return count\n    }\n\
    \    if n == 1 {\n        return count\n    }\n    count = append(count, 2)\n\
    \    for i := 3; i < n; i++ {\n        var flag bool = true\n        for j :=\
    \ 2; j < i; j++ {\n            if i % j == 0 {\n                flag = false\n\
    \                break\n            }\n        }\n        if flag {\n        \
    \    count = append(count, i)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075085
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return []int{}\n    }\n    result := []int{}\n\
    \    for i := 2; i < n; i++ {\n        if is_prime(i) {\n            result =\
    \ append(result, i)\n        }\n    }\n    return result\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa_g_8eim_test.go:29:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074924
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var y []int\n    if n < 1 {\n        y = append(y, -1)\n    } else\
    \ {\n        for i := 2; i < n; i++ {\n            if isPrime(i) {\n         \
    \       y = append(y, i)\n            }\n        }\n    }\n    return y\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnpo6ms1l_test.go:29:16: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075084
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    // YOUR CODE HERE\n    var a []int\n    for i := 0; i < n; i++\
    \ {\n        if judge_prime(i) {\n            a = append(a, i)\n        }\n  \
    \  }\n    return a\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate :=\
    \ count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4nz44shm_test.go:27:12: undefined: judge_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075085
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var prime_list []int\n    if n <= 1 {\n        return prime_list\n\
    \    }\n    var is_prime_flag = true\n    for i := 2; i < n; i++ {\n        for\
    \ j := 2; j < i; j++ {\n            if i % j == 0 {\n                is_prime_flag\
    \ = false\n                break\n            }\n        }\n        if is_prime_flag\
    \ {\n            prime_list = append(prime_list, i)\n        }\n        is_prime_flag\
    \ = true\n    }\n    return prime_list\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075085
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var ret []int\n    if n < 2 {\n        return ret\n    }\n    var\
    \ primes = []int{2}\n    if n < 3 {\n        return primes\n    }\n    var count\
    \ = 3\n    primes = append(primes, count)\n    for count = 5; count < n; count\
    \ += 2 {\n        is_prime := true\n        for _, num := range primes {\n   \
    \         if num * num > count {\n                break\n            }\n     \
    \       if count % num == 0 {\n                is_prime = false\n            \
    \    break\n            }\n        }\n        if is_prime {\n            primes\
    \ = append(primes, count)\n        }\n    }\n    return primes\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075085
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        panic(\"PATCH list\")\n    }\n    var list\
    \ []int\n    for i := 2; i < n; i++ {\n        for _, j := range list {\n    \
    \        if i % j == 0 {\n                continue\n            }\n        }\n\
    \        list = append(list, i)\n    }\n    return list\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: PATCH list [recovered]\n\tpanic:\
    \ PATCH list\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x4fcd60, 0x548978})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x4fcd60,\
    \ 0x548978})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpts28wguu_test.go:25\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpts28wguu_test.go:50\
    \ +0x1cf\ntesting.tRunner(0xc0001924e0, 0x527d48)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075085
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 1 {\n        return []int{}\n    }\n\n    r := []int{}\n\
    \    for i := 2; i < n; i++ {\n        if is_prime(i) {\n            r = append(r,\
    \ i)\n        }\n    }\n    return r\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyn_fu8qz_test.go:30:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075085
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    // paramn is number of primes to return.\n    // return list of\
    \ primes.\n    if n < 2 {\n        return []int{}\n    }\n    if n == 2 {\n  \
    \      return []int{2}\n    }\n    primes := []int{2}\n    for i := 3; i < n;\
    \ i += 2 {\n        for _, prime := range primes {\n            if i % prime ==\
    \ 0 {\n                break\n            }\n            if prime * prime > i\
    \ {\n                primes = append(primes, i)\n                break\n     \
    \       }\n        }\n    }\n    return primes\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075085
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    // Variables needed for the calculation\n    var i, j int\n   \
    \ p := []int{}\n    // We will use an array to keep track of the numbers\n   \
    \ // 0 -> non-prime, 1 -> prime\n    numbers := make([]int, n+1)\n    // We start\
    \ at 2 since 2 is the first prime number\n    for i = 2; i <= n; i++ {\n     \
    \   // If the number is 1, then it is a prime number\n        if numbers[i] ==\
    \ 1 {\n            // Add the prime number to the list\n            p = append(p,\
    \ i)\n            // Start at the next number and mark all of the numbers\n  \
    \          // that are divisible by the prime number as non-prime\n          \
    \  for j = i+i; j <= n; j += i {\n                numbers[j] = 0\n           \
    \ }\n        }\n    }\n    return p\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmptjvt7k1s_test.go:68: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmptjvt7k1s_test.go:68:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmptjvt7k1s_test.go:68: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmptjvt7k1s_test.go:68:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmptjvt7k1s_test.go:68: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmptjvt7k1s_test.go:68: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmptjvt7k1s_test.go:68: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmptjvt7k1s_test.go:68: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075086
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    return nil\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmphnf9g0f7_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmphnf9g0f7_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmphnf9g0f7_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmphnf9g0f7_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075075
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := []int{}\n    // Primes are bigger than 1\n    if n <\
    \ 2 {\n        return primes\n    }\n    // 2 is the only even prime number\n\
    \    if n == 2 {\n        return append(primes, 2)\n    }\n    // Remove all even\
    \ numbers from n\n    for n % 2 == 0 {\n        n /= 2\n    }\n    // n must be\
    \ odd at this point\n    for i := 3; i*i <= n; i += 2 {\n        for n % i ==\
    \ 0 {\n            n /= i\n        }\n    }\n    // n is prime\n    return append(primes,\
    \ n)\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp4mu9d0aj_test.go:69: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n    \
    \    tmp4mu9d0aj_test.go:69: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got\
    \ '[%!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmp4mu9d0aj_test.go:69:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=7)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__3 (0.00s)\n        tmp4mu9d0aj_test.go:69: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=5)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp4mu9d0aj_test.go:69: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[%!s(int=11)]'\n    --- FAIL: TestCount_Up_To/test_num__7\
    \ (0.00s)\n        tmp4mu9d0aj_test.go:69: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=1)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp4mu9d0aj_test.go:69: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]',\
    \ got '[%!s(int=47)]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n   \
    \     tmp4mu9d0aj_test.go:69: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31)\
    \ %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61)\
    \ %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]',\
    \ got '[%!s(int=101)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075086
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var result []int\n    var i int\n    if n <= 0 {\n        return\
    \ result\n    }\n    for i = 1; i < n; i++ {\n        if is_prime(i) {\n     \
    \       result = append(result, i)\n        }\n    }\n    return result\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_3xniduv_test.go:30:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075085
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return nil\n    }\n    intSlice := make([]int,\
    \ 0)\n    for i := 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n       \
    \     if i % j == 0 {\n                break\n            }\n            if j\
    \ == i - 1 {\n                intSlice = append(intSlice, i)\n            }\n\
    \        }\n    }\n    return intSlice\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpr95ehfde_test.go:63: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n    \
    \    tmpr95ehfde_test.go:63: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got\
    \ '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n\
    \        tmpr95ehfde_test.go:63: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n\
    \        tmpr95ehfde_test.go:63: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]',\
    \ got '[%!s(int=3) %!s(int=5) %!s(int=7)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmpr95ehfde_test.go:63: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]'\n  \
    \  --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpr95ehfde_test.go:63:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]'\n    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpr95ehfde_test.go:63:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpr95ehfde_test.go:63:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int"
  timestamp: 1660075086
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    s := make([]int, 0)\n    if n <= 1 {\n        return s\n    }\n\
    \n    s = append(s, 2)\n    for i := 3; i < n; i++ {\n        j := 0\n       \
    \ for j < len(s) && i % s[j] != 0 {\n            j++\n        }\n        if j\
    \ == len(s) {\n            s = append(s, i)\n        }\n    }\n    return s\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075086
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    primes := []int{2}\n\
    \    if n == 2 {\n        return primes\n    }\n    for i := 3; i < n; i++ {\n\
    \        is_prime := true\n        for _, val := range primes {\n            if\
    \ i % val == 0 {\n                is_prime = false\n                break\n  \
    \          }\n        }\n        if is_prime {\n            primes = append(primes,\
    \ i)\n        }\n    }\n    return primes\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075087
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    count_list := []int{}\n    for i := 2; i < n; i++ {\n        if(is_prime(i))\
    \ {\n            count_list = append(count_list, i)\n        }\n    }\n    return\
    \ count_list\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpydiyp3it_test.go:26:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075087
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 1 {\n        return []int{}\n    }\n    prime_list := []int{2}\n\
    \    for i := 3; i < n; i += 2 {\n        is_prime := true\n        for _, prime\
    \ := range prime_list {\n            if i % prime == 0 {\n                is_prime\
    \ = false\n                break\n            }\n        }\n        if is_prime\
    \ {\n            prime_list = append(prime_list, i)\n        }\n    }\n    return\
    \ prime_list\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__6\
    \ (0.00s)\n        tmpk219reza_test.go:65: expected '[]', got '[%!s(int=2)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075087
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return []int{}\n    }\n    l := []int{}\n\
    \    for i := 2; i < n; i++ {\n        j := 2\n        is_prime := true\n    \
    \    for ; j <= i/2; j++ {\n            if i%j == 0 {\n                is_prime\
    \ = false\n                break\n            }\n        }\n        if is_prime\
    \ {\n            l = append(l, i)\n        }\n    }\n    return l\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075087
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var i int\n    var j int\n    var result []int\n    for i = 2;\
    \ i < n; i++ {\n        for j = 2; j <= (i / j); j++ {\n            if i % j ==\
    \ 0 {\n                break\n            }\n        }\n        if j > (i / j)\
    \ {\n            result = append(result, i)\n        }\n    }\n    return result\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.006s\n"
  timestamp: 1660075087
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return []int{}\n    }\n    primes := []int{2}\n\
    \    for i := 3; i < n; i++ {\n        var isPrime bool = true\n        for _,\
    \ e := range primes {\n            if i % e == 0 {\n                isPrime =\
    \ false\n                break\n            }\n        }\n        if isPrime {\n\
    \            primes = append(primes, i)\n        }\n    }\n    return primes\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660075087
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var a []int\n    if n < 2 {\n        return a\n    }\n    isprime\
    \ := true\n    for i := 2; i < n; i++ {\n        isprime = true\n        for j\
    \ := 2; j < i; j++ {\n            if i % j == 0 {\n                isprime = false\n\
    \                break\n            }\n        }\n        if isprime {\n     \
    \       a = append(a, i)\n        }\n    }\n    return a\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075087
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    for i := 2; i < n; i++ {\n       \
    \ for j := 2; j < i; j++ {\n            if i % j == 0 {\n                break\n\
    \            }\n            if j == i - 1 {\n                prime = append(prime,\
    \ i)\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpjfjtc76m_test.go:60: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n    \
    \    tmpjfjtc76m_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got\
    \ '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n\
    \        tmpjfjtc76m_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n\
    \        tmpjfjtc76m_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]',\
    \ got '[%!s(int=3) %!s(int=5) %!s(int=7)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmpjfjtc76m_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]'\n  \
    \  --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpjfjtc76m_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]'\n    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpjfjtc76m_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpjfjtc76m_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int"
  timestamp: 1660075087
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return []int{}\n    }\n\n    l := make([]int,\
    \ 0)\n    for i := 2; i < n; i++ {\n        if is_prime(i) {\n            l =\
    \ append(l, i)\n        }\n    }\n    return l\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi1cavr9m_test.go:30:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075087
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    r := []int{}\n    for i := 2; i < n; i++ {\n        b := true\n\
    \        for j := 2; j < i; j++ {\n            if i % j == 0 {\n             \
    \   b = false\n                break\n            }\n        }\n        if b {\n\
    \            r = append(r, i)\n        }\n    }\n    return r\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075087
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    results := []int{}\n\
    \    for i := 2; i < n; i++ {\n        is_prime := true\n        for j := 2; j\
    \ < i; j++ {\n            if i % j == 0 {\n                is_prime = false\n\
    \                break\n            }\n        }\n        if is_prime {\n    \
    \        results = append(results, i)\n        }\n    }\n    return results\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075087
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    // as prime number is only divisible by itself and 1, we can use\
    \ this\n    // as \"up to n\" value.\n    var nums = make([]int, 0)\n    for i\
    \ := 2; i < n; i++ {\n        ok := true\n        for j := 2; j < i; j++ {\n \
    \           if i % j == 0 {\n                ok = false\n                break\n\
    \            }\n        }\n        if ok {\n            nums = append(nums, i)\n\
    \        }\n    }\n    return nums\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075087
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := []int{}\n    p := 2\n    for p <= n {\n        if n %\
    \ p == 0 {\n            n /= p\n            primes = append(primes, p)\n     \
    \   } else {\n            p += 1\n        }\n    }\n    return primes\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpikz7259a_test.go:59: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n    \
    \    tmpikz7259a_test.go:59: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got\
    \ '[%!s(int=2) %!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n\
    \        tmpikz7259a_test.go:59: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=7)]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n    \
    \    tmpikz7259a_test.go:59: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n\
    \        tmpikz7259a_test.go:59: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=2) %!s(int=11)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpikz7259a_test.go:59:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=2) %!s(int=3) %!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpikz7259a_test.go:59: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[%!s(int=47)]'\n   \
    \ --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpikz7259a_test.go:59:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[%!s(int=101)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075087
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return []int{}\n    }\n\n    result := []int{}\n\
    \    for i := 2; i < n; i++ {\n        isPrime := true\n        for j := 2; j\
    \ < i; j++ {\n            if i % j == 0 {\n                isPrime = false\n \
    \               break\n            }\n        }\n        if isPrime {\n      \
    \      result = append(result, i)\n        }\n    }\n    return result\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075087
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return nil\n    }\n    prime := make([]int,\
    \ n)\n    prime[0] = 2\n    num := 3\n    count := 1\n    for num < n {\n    \
    \    i := 2\n        for i * i <= num {\n            if num % i == 0 {\n     \
    \           break\n            }\n            i += 1\n        }\n        if i\
    \ * i > num {\n            prime[count] = num\n            count += 1\n      \
    \  }\n        num += 2\n    }\n    return prime[:count]\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var count_array []int\n    for i := 2; i < n; i++ {\n        for\
    \ j := 2; j <= (i / j); j++ {\n            if i % j == 0 {\n                break\n\
    \            }\n            if j > (i / j) {\n                count_array = append(count_array,\
    \ i)\n            }\n        }\n    }\n    return count_array\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpax71opt0_test.go:60: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpax71opt0_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpax71opt0_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpax71opt0_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpax71opt0_test.go:60: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpax71opt0_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpax71opt0_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpax71opt0_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var primes []int\n    for i := 2; i < n; i++ {\n        is_prime\
    \ := true\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n   \
    \             is_prime = false\n                break\n            }\n       \
    \ }\n        if is_prime {\n            primes = append(primes, i)\n        }\n\
    \    }\n    return primes\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    patch_list := []int{}\n    if n <= 1 {\n        return patch_list\n\
    \    }\n    prime_numbers := []int{2}\n    is_prime := true\n    for i := 3; i\
    \ < n; i += 2 {\n        for _, number := range prime_numbers {\n            if\
    \ i % number == 0 {\n                is_prime = false\n                break\n\
    \            }\n        }\n        if is_prime {\n            prime_numbers =\
    \ append(prime_numbers, i)\n        }\n        is_prime = true\n    }\n    return\
    \ prime_numbers\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primeList := []int{}\n    if n == 1 {\n        return primeList\n\
    \    }\n    for i := 2; i < n; i++ {\n        isPrime := true\n        for j :=\
    \ 2; j < i; j++ {\n            if i % j == 0 {\n                isPrime = false\n\
    \                break\n            }\n        }\n        if isPrime {\n     \
    \       primeList = append(primeList, i)\n        }\n    }\n    return primeList\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    // Fill in this function\n    var primes []int\n    if n < 2 {\n\
    \        return primes\n    }\n    primes = append(primes, 2)\n    for i := 3;\
    \ i < n; i += 2 {\n        isPrime := true\n        for j := 3; j < i; j += 2\
    \ {\n            if i % j == 0 {\n                isPrime = false\n          \
    \      break\n            }\n        }\n        if isPrime {\n            primes\
    \ = append(primes, i)\n        }\n    }\n    return primes\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var result []int\n    for i := 2; i < n; i++ {\n        for j :=\
    \ 2; j < i; j++ {\n            if i % j == 0 {\n                break\n      \
    \      } else if j == i - 1 {\n                result = append(result, i)\n  \
    \          }\n        }\n    }\n    return result\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp2zuu_mah_test.go:59: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n    \
    \    tmp2zuu_mah_test.go:59: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got\
    \ '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n\
    \        tmp2zuu_mah_test.go:59: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n\
    \        tmp2zuu_mah_test.go:59: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]',\
    \ got '[%!s(int=3) %!s(int=5) %!s(int=7)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmp2zuu_mah_test.go:59: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]'\n  \
    \  --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp2zuu_mah_test.go:59:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]'\n    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp2zuu_mah_test.go:59:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]', got '[%!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmp2zuu_mah_test.go:59:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[%!s(int=3)\
    \ %!s(int=5) %!s(int"
  timestamp: 1660075088
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime_list := []int{}\n    for i := 2; i < n; i++ {\n        is_prime\
    \ := true\n        for j := 2; j < i; j++ {\n            if i % j == 0 {\n   \
    \             is_prime = false\n                break\n            }\n       \
    \ }\n        if is_prime {\n            prime_list = append(prime_list, i)\n \
    \       }\n    }\n    return prime_list\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    // TODO: implement me\n    return nil\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpm1pbxfyo_test.go:50: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpm1pbxfyo_test.go:50:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpm1pbxfyo_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpm1pbxfyo_test.go:50:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpm1pbxfyo_test.go:50: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpm1pbxfyo_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpm1pbxfyo_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpm1pbxfyo_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074922
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return []int{}\n    }\n    var result []int\n\
    \    for i := 2; i < n; i++ {\n        if is_prime(i) {\n            result =\
    \ append(result, i)\n        }\n    }\n    return result\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvzvtympv_test.go:29:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074922
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    res := []int{}\n    for i := 2; i < n; i++ {\n        if is_prime(i)\
    \ {\n            res = append(res, i)\n        }\n    }\n    return res\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpubmbx2ls_test.go:26:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075080
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return nil\n    }\n    var p []int\n    for\
    \ i := 2; i < n; i++ {\n        prime := true\n        for j := 2; j < i; j++\
    \ {\n            if i % j == 0 {\n                prime = false\n            \
    \    break\n            }\n        }\n        if prime {\n            p = append(p,\
    \ i)\n        }\n    }\n    return p\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075088
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n\tif n < 2 {\n\t\treturn []int{}\n\t}\n\tl := []int{}\n\tfor i := 2;\
    \ i < n; i++ {\n\t\tflag := true\n\t\tfor j := 2; j < i; j++ {\n\t\t\tif i%j ==\
    \ 0 {\n\t\t\t\tflag = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif flag {\n\t\t\
    \tl = append(l, i)\n\t\t}\n\t}\n\treturn l\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075089
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    var res []int\n\
    \    for i := 2; i < n; i++ {\n        if is_prime(i) {\n            res = append(res,\
    \ i)\n        }\n    }\n    return res\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzybuyfe1_test.go:29:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074924
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return []int{}\n    }\n    var result []int\n\
    \    for i := 2; i < n; i++ {\n        if is_prime(i) {\n            result =\
    \ append(result, i)\n        }\n    }\n    return result\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvzvtympv_test.go:29:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074922
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    var primeNumbers\
    \ []int\n    for i := 2; i < n; i++ {\n        if isPrime(i) {\n            primeNumbers\
    \ = append(primeNumbers, i)\n        }\n    }\n    return primeNumbers\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgfdq_ngg_test.go:29:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075089
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var res []int\n    if n < 2 {\n        return res\n    }\n    res\
    \ = append(res, 2)\n    if n == 2 {\n        return res\n    }\n    for i := 3;\
    \ i < n; i++ {\n        is_prime := true\n        for j := 2; j < i; j++ {\n \
    \           if i % j == 0 {\n                is_prime = false\n              \
    \  break\n            }\n        }\n        if is_prime {\n            res = append(res,\
    \ i)\n        }\n    }\n    return res\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    var ret = []int{2}\n\
    \    for i := 3; i < n; i++ {\n        var is_prime = true\n        for _, v :=\
    \ range ret {\n            if i % v == 0 {\n                is_prime = false\n\
    \                break\n            }\n        }\n        if is_prime {\n    \
    \        ret = append(ret, i)\n        }\n    }\n    return ret\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n\tvar result []int\n\tcount := 0\n\tfor i := 1; i <= n; i++ {\n\t\t\
    if i <= 1 {\n\t\t\tcontinue\n\t\t} else if i <= 3 {\n\t\t\tcount++\n\t\t\tresult\
    \ = append(result, i)\n\t\t} else if i % 2 == 0 || i % 3 == 0 {\n\t\t\tcontinue\n\
    \t\t} else {\n\t\t\tj := 5\n\t\t\tfor j * j <= i {\n\t\t\t\tif i % j == 0 || i\
    \ % (j + 2) == 0 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tj += 6\n\t\t\t}\n\t\t\t\
    if j * j > i {\n\t\t\t\tcount++\n\t\t\t\tresult = append(result, i)\n\t\t\t}\n\
    \t\t}\n\t}\n\tfmt.Println(count)\n\treturn result\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "3\n3\n4\n4\n0\n8\n0\n7\n15\n26\n--- FAIL: TestCount_Up_To (0.00s)\n   \
    \ --- FAIL: TestCount_Up_To/test_num__0 (0.00s)\n        tmpnc3no0p4_test.go:74:\
    \ expected '[%!s(int=2) %!s(int=3)]', got '[%!s(int=2) %!s(int=3) %!s(int=5)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmpnc3no0p4_test.go:74:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7)]'\n    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpnc3no0p4_test.go:74:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]', got '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11)\
    \ %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37)\
    \ %!s(int=41) %!s(int=43) %!s(int=47)]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpnc3no0p4_test.go:74: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11)\
    \ %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37)\
    \ %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67)\
    \ %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97) %!s(int=101)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var l []int\n    if n <= 1 {\n        return l\n    }\n    for\
    \ i := 2; i < n; i++ {\n        prime := true\n        for j := 2; j < i; j++\
    \ {\n            if i % j == 0 {\n                prime = false\n            \
    \    break\n            }\n        }\n        if prime {\n            l = append(l,\
    \ i)\n        }\n    }\n    return l\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return nil\n    }\n    tmp := make([]int,\
    \ 0)\n    for i := 2; i < n; i++ {\n        flag := 0\n        for j := 2; j <\
    \ i; j++ {\n            if i % j == 0 {\n                flag = 1\n          \
    \      break\n            }\n        }\n        if flag == 0 {\n            tmp\
    \ = append(tmp, i)\n        }\n    }\n    return tmp\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    // write code here\n    return nil\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpo5za3yyr_test.go:50: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpo5za3yyr_test.go:50:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpo5za3yyr_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpo5za3yyr_test.go:50:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpo5za3yyr_test.go:50: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpo5za3yyr_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpo5za3yyr_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpo5za3yyr_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return []int{}\n    }\n    primes := []int{2}\n\
    \    for i := 3; i < n; i++ {\n        isPrime := true\n        for _, prime :=\
    \ range primes {\n            if i % prime == 0 {\n                isPrime = false\n\
    \                break\n            }\n        }\n        if isPrime {\n     \
    \       primes = append(primes, i)\n        }\n    }\n    return primes\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074925
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var list = []int{}\n    for i := 1; i < n; i++ {\n        if is_prime(i)\
    \ {\n            list = append(list, i)\n        }\n    }\n    return list\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_wf_mblm_test.go:26:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075089
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    return []int{}\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpsdp4m0j1_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpsdp4m0j1_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpsdp4m0j1_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075075
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    // Your code here\n    return []int{}\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpg8mjabnm_test.go:50: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpg8mjabnm_test.go:50:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpg8mjabnm_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpg8mjabnm_test.go:50:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpg8mjabnm_test.go:50: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpg8mjabnm_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpg8mjabnm_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpg8mjabnm_test.go:50: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075090
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var x int\n    var y int\n    y = 2\n    result := []int{}\n  \
    \  if n == 0 {\n        return result\n    } else if n < 0 {\n        return result\n\
    \    }\n    for x = 2; x <= n; x++ {\n        for y = 2; y < x; y++ {\n      \
    \      if x % y == 0 {\n                break\n            }\n        }\n    \
    \    if y == x {\n            result = append(result, x)\n        }\n    }\n \
    \   return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpdxzbp_rh_test.go:68: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=2) %!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpdxzbp_rh_test.go:68: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpdxzbp_rh_test.go:68: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23)\
    \ %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpdxzbp_rh_test.go:68:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[%!s(int=2)\
    \ %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)\
    \ %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47)\
    \ %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79)\
    \ %!s(int=83) %!s(int=89) %!s(int=97) %!s(int=101)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var ret []int\n    if n == 0 {\n        return ret\n    }\n   \
    \ var isPrime = func(num int) bool {\n        if num == 2 {\n            return\
    \ true\n        }\n        for i := 2; i < num; i++ {\n            if num % i\
    \ == 0 {\n                return false\n            }\n        }\n        return\
    \ true\n    }\n    for i := 2; i < n; i++ {\n        if isPrime(i) {\n       \
    \     ret = append(ret, i)\n        }\n    }\n    return ret\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var res []int\n    for i := 2; i < n; i++ {\n        if is_prime(i)\
    \ {\n            res = append(res, i)\n        }\n    }\n    return res\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphrj0glwa_test.go:26:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075077
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    // Verify the input\n    if n <= 1 {\n        return nil\n    }\n\
    \n    prime_list := []int{}\n    for i := 2; i < n; i++ {\n        is_prime :=\
    \ true\n        for j := 2; j <= i/2; j++ {\n            if i % j == 0 {\n   \
    \             is_prime = false\n                break\n            }\n       \
    \ }\n        if is_prime {\n            prime_list = append(prime_list, i)\n \
    \       }\n    }\n    return prime_list\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    var ret []int\n\
    \    for i := 2; i < n; i++ {\n        if is_prime(i) {\n            ret = append(ret,\
    \ i)\n        }\n    }\n    return ret\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzhxxsc6r_test.go:29:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := []int{}\n    for i := 2; i < n; i++ {\n        for j\
    \ := 2; j <= i; j++ {\n            if i == j {\n                primes = append(primes,\
    \ i)\n            }\n            if i % j == 0 {\n                break\n    \
    \        }\n        }\n    }\n    return primes\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return []int{}\n    }\n    res := []int{}\n\
    \    for i := 2; i < n; i++ {\n        is_prime := true\n        for j := 2; j\
    \ < i; j++ {\n            if i % j == 0 {\n                is_prime = false\n\
    \                break\n            }\n        }\n        if is_prime {\n    \
    \        res = append(res, i)\n        }\n    }\n    return res\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075078
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    nums := make([]int,\
    \ n - 1)\n    for i := range nums {\n        nums[i] = i + 2\n    }\n    for i\
    \ := 0; i < len(nums); i++ {\n        factor := nums[i]\n        for j := i +\
    \ 1; j < len(nums); j++ {\n            if nums[j] % factor == 0 {\n          \
    \      nums = append(nums[:j], nums[j+1:]...)\n                j--\n         \
    \   }\n        }\n    }\n    return nums\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpysognepq_test.go:65: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=2) %!s(int=3) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpysognepq_test.go:65: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpysognepq_test.go:65: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[%!s(int=2) %!s(int=3)\
    \ %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23)\
    \ %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpysognepq_test.go:65:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[%!s(int=2)\
    \ %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)\
    \ %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47)\
    \ %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79)\
    \ %!s(int=83) %!s(int=89) %!s(int=97) %!s(int=101)]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075090
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var primes []int\n    for i := 2; i < n; i++ {\n        if n %\
    \ i == 0 {\n            primes = append(primes, i)\n        }\n    }\n    return\
    \ primes\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp9x9jw6ob_test.go:55: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmp9x9jw6ob_test.go:55:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=3)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmp9x9jw6ob_test.go:55:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3\
    \ (0.00s)\n        tmp9x9jw6ob_test.go:55: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7)]', got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmp9x9jw6ob_test.go:55: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=2)\
    \ %!s(int=11)]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmp9x9jw6ob_test.go:55:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=2) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmp9x9jw6ob_test.go:55: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmp9x9jw6ob_test.go:55:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    ret := []int{2}\n\
    \    for i := 3; i < n; i += 2 {\n        count := 0\n        for _, j := range\
    \ ret {\n            if i % j == 0 {\n                count += 1\n           \
    \ }\n        }\n        if count == 0 {\n            ret = append(ret, i)\n  \
    \      }\n    }\n    return ret\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n \
    \ candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075090
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    result := []int{2}\n\
    \    for i := 3; i < n; i += 2 {\n        if is_prime(i) {\n            result\
    \ = append(result, i)\n        }\n    }\n    return result\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprloe8ema_test.go:29:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075090
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    // make sure n is non-negative\n    if n < 0 {\n        fmt.Println(\"\
    Please enter a non-negative number\")\n        return nil\n    }\n    // create\
    \ a list for the result\n    var result []int\n    // iterate through all integers\
    \ in the range from 2 to n, if a number is a prime, append it\n    // to the result\
    \ list\n    for i := 2; i < n; i++ {\n        if is_prime(i) {\n            result\
    \ = append(result, i)\n        }\n    }\n    return result\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpny9gnowp_test.go:34:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075090
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    count := []int{}\n\
    \    for i := 2; i < n; i++ {\n        if is_prime(i) {\n            count = append(count,\
    \ i)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprcqwvghh_test.go:29:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075090
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var primes []int\n    if n < 2 {\n        return primes\n    }\n\
    \    is_prime := true\n    for i := 2; i < n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                is_prime = false\n     \
    \           break\n            }\n        }\n        if is_prime {\n         \
    \   primes = append(primes, i)\n        }\n        is_prime = true\n    }\n  \
    \  return primes\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075091
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    panic(\"\")\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic:  [recovered]\n\tpanic: \n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x4fcd60, 0x549010})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x4fcd60, 0x549010})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp8nr_8xro_test.go:24\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp8nr_8xro_test.go:34\
    \ +0x27\ntesting.tRunner(0xc0001a01a0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075091
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var result []int\n    if n <= 1 {\n        return result\n    }\n\
    \n    // Here i <= n is wrong, because n is not included\n    for i := 2; i <\
    \ n; i++ {\n        var j int\n        for j = 2; j < i; j++ {\n            if\
    \ i % j == 0 {\n                break\n            }\n        }\n        if j\
    \ == i {\n            result = append(result, i)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075091
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    return []int{}\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpsdp4m0j1_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpsdp4m0j1_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpsdp4m0j1_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075075
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var result []int\n    for i := 1; i < n; i++ {\n        if is_prime(i)\
    \ {\n            result = append(result, i)\n        }\n    }\n    return result\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7inva5n1_test.go:26:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075091
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var arr []int\n    for i := 1; i < n; i++ {\n        if isPrime(i)\
    \ {\n            arr = append(arr, i)\n        }\n    }\n    return arr\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp09efy3lq_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075091
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    var result []int\n    if n > 1 {\n        for i := 2; i < n; i++\
    \ {\n            if i == 2 || i == 3 || i == 5 || i == 7 {\n                result\
    \ = append(result, i)\n            } else if i%2 != 0 && i%3 != 0 && i%5 != 0\
    \ && i%7 != 0 {\n                result = append(result, i)\n            }\n \
    \       }\n    }\n    return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075091
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 1 {\n        return []int{}\n    }\n    result := []int{}\n\
    \    for i := 2; i < n; i++ {\n        if is_prime(i) {\n            result =\
    \ append(result, i)\n        }\n    }\n    return result\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3tlhijic_test.go:29:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075091
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n <= 1 {\n        return []int{}\n    }\n    var result []int\n\
    \    for i := 2; i < n; i++ {\n        if is_prime(i) {\n            result =\
    \ append(result, i)\n        }\n    }\n    return result\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvzvtympv_test.go:29:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074922
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    return []int{}\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpsdp4m0j1_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpsdp4m0j1_test.go:49:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpsdp4m0j1_test.go:49: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpsdp4m0j1_test.go:49: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075075
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    if n > 1 {\n        prime = append(prime,\
    \ 2)\n    }\n    for i := 3; i < n; i += 2 {\n        is_prime := true\n     \
    \   for _, p := range prime {\n            if i % p == 0 {\n                is_prime\
    \ = false\n                break\n            }\n        }\n        if is_prime\
    \ {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075091
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 1 {\n        return []int{}\n    }\n    res := []int{}\n\
    \    for i := 2; i < n; i++ {\n        if is_prime(i) {\n            res = append(res,\
    \ i)\n        }\n    }\n    return res\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7jabgxsk_test.go:29:12: undefined: is_prime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075091
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n\tif n <= 1 {\n\t\tfmt.Println(\"PATCH list\")\n\t\treturn nil\n\t\
    }\n\tprime := make([]int, 0)\n\tfor i := 2; i < n; i++ {\n\t\tif isPrime(i) {\n\
    \t\t\tprime = append(prime, i)\n\t\t}\n\t}\n\treturn prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgwk90ts5_test.go:30:6: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075091
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    primes := []int{2}\n\
    \    lastPrime := 2\n    for i := 3; i < n; i++ {\n        if isPrime(i, primes)\
    \ {\n            primes = append(primes, i)\n            lastPrime = i\n     \
    \   }\n    }\n    return primes\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n \
    \ candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyac0qf6x_test.go:28:5: lastPrime declared but not used

    /tmp/tmpyac0qf6x_test.go:30:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075091
- exit_code: 0
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    count := make([]int, 0)\n    if n < 1 {\n        return count\n\
    \    }\n    for i := 2; i < n; i++ {\n        isPrime := true\n        for j :=\
    \ 2; j < i; j++ {\n            if i % j == 0 {\n                isPrime = false\n\
    \                break\n            }\n        }\n        if isPrime {\n     \
    \       count = append(count, i)\n        }\n    }\n    return count\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075091
