name: HumanEval_127_intersection
language: go_test.go
prompt: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // You are given two intervals,\n// where each interval is a pair of integers. For\
  \ example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
  \ which means that the interval (start, end)\n// includes both start and end.\n\
  // For each given interval, it is assumed that its start is less or equal its end.\n\
  // Your task is to determine whether the length of intersection of these two \n\
  // intervals is a prime number.\n// Example, the intersection of the intervals (1,\
  \ 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n//\
  \ If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
  \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output]\
  \ samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"\
  NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n\
  // >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc\
  \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n"
tests: "func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
  \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
  \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
  \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
  \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
  \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
  \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
  \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
  \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
  \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
  \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if len(interval1) != 2 || len(interval2) != 2 {\n        return\
    \ \"NO\"\n    }\n    switch interval1[0].(type) {\n    case int:\n        if interval1[0].(int)\
    \ > interval1[1].(int) {\n            return \"NO\"\n        }\n    case float64:\n\
    \        if interval1[0].(float64) > interval1[1].(float64) {\n            return\
    \ \"NO\"\n        }\n    default:\n        return \"NO\"\n    }\n    switch interval2[0].(type)\
    \ {\n    case int:\n        if interval2[0].(int) > interval2[1].(int) {\n   \
    \         return \"NO\"\n        }\n    case float64:\n        if interval2[0].(float64)\
    \ > interval2[1].(float64) {\n            return \"NO\"\n        }\n    default:\n\
    \        return \"NO\"\n    }\n    // fmt.Println(interval1[0], interval1[1],\
    \ interval2[0], interval2[1])\n    left := max(interval1[0], interval2[0])\n \
    \   right := min(interval1[1], interval2[1])\n    if left > right {\n        return\
    \ \"NO\"\n    }\n    if left == right {\n        return \"YES\"\n    }\n    if\
    \ left.(int) < 0 {\n        left = -left.(int)\n    }\n    if right.(int) < 0\
    \ {\n        right = -right.(int)\n    }\n    for i := left.(int); i <= right.(int);\
    \ i++ {\n        if i == 2 || i == 3 || i == 5 || i == 7 {\n            return\
    \ \"YES\"\n        }\n    }\n    return \"NO\"\n}\n", "    if (interval1[0].(int)\
    \ > interval2[1].(int)) || (interval2[0].(int) > interval1[1].(int)) {\n     \
    \   return \"NO\"\n    }\n    var s int\n    var e int\n    if interval1[0].(int)\
    \ > interval2[0].(int) {\n        s = interval1[0].(int)\n    } else {\n     \
    \   s = interval2[0].(int)\n    }\n    if interval1[1].(int) < interval2[1].(int)\
    \ {\n        e = interval1[1].(int)\n    } else {\n        e = interval2[1].(int)\n\
    \    }\n    if (e - s) <= 0 {\n        return \"NO\"\n    }\n    for i := 2; i\
    \ < (e - s); i++ {\n        if (e - s) % i == 0 {\n            return \"NO\"\n\
    \        }\n    }\n    return \"YES\"\n}\n", "    if len(interval1) != 2 || len(interval2)\
    \ != 2 {\n        return \"INVALID\"\n    }\n    if interval1[0] == interval1[1]\
    \ || interval2[0] == interval2[1] {\n        return \"NO\"\n    }\n    var start,\
    \ end int\n    if interval1[0].(int) < interval2[0].(int) {\n        start = interval2[0].(int)\n\
    \    } else {\n        start = interval1[0].(int)\n    }\n    if interval1[1].(int)\
    \ > interval2[1].(int) {\n        end = interval2[1].(int)\n    } else {\n   \
    \     end = interval1[1].(int)\n    }\n    if start >= end {\n        return \"\
    NO\"\n    }\n    if start <= 1 {\n        return \"NO\"\n    }\n    if start ==\
    \ 2 {\n        return \"YES\"\n    }\n    if start & 1 == 0 {\n        start++\n\
    \    }\n    for start <= end {\n        var flag = false\n        for i := 3;\
    \ i * i <= start; i += 2 {\n            if start % i == 0 {\n                flag\
    \ = true\n                break\n            }\n        }\n        if !flag {\n\
    \            return \"YES\"\n        }\n        start += 2\n    }\n    return\
    \ \"NO\"\n}\n", "    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    s := start1\n    if start2 > start1\
    \ {\n        s = start2\n    }\n    e := end1\n    if end2 < end1 {\n        e\
    \ = end2\n    }\n    if isPrime(e - s + 1) {\n        return \"YES\"\n    }\n\
    \    return \"NO\"\n}\n", "    // handle negative values\n    var start1 int =\
    \ -1\n    var end1 int = -1\n    if interval1[0].(int) < 0 {\n        start1 =\
    \ interval1[0].(int) * -1\n    } else {\n        start1 = interval1[0].(int)\n\
    \    }\n    if interval1[1].(int) < 0 {\n        end1 = interval1[1].(int) * -1\n\
    \    } else {\n        end1 = interval1[1].(int)\n    }\n    var start2 int =\
    \ -1\n    var end2 int = -1\n    if interval2[0].(int) < 0 {\n        start2 =\
    \ interval2[0].(int) * -1\n    } else {\n        start2 = interval2[0].(int)\n\
    \    }\n    if interval2[1].(int) < 0 {\n        end2 = interval2[1].(int) * -1\n\
    \    } else {\n        end2 = interval2[1].(int)\n    }\n    // handle when interval1\
    \ is less than interval2\n    if start1 > start2 {\n        start1, start2 = start2,\
    \ start1\n        end1, end2 = end2, end1\n    }\n    var intersectStart int =\
    \ -1\n    var intersectEnd int = -1\n    if end1 < start2 {\n        return \"\
    NO\"\n    } else if end1 > start2 {\n        intersectStart = start2\n       \
    \ if end1 > end2 {\n            intersectEnd = end2\n        } else {\n      \
    \      intersectEnd = end1\n        }\n    } else {\n        intersectStart =\
    \ start2\n        intersectEnd = end2\n    }\n    //fmt.Println(intersectStart,\
    \ intersectEnd)\n    var diff int = intersectEnd - intersectStart\n    if diff\
    \ == 0 {\n        return \"NO\"\n    }\n    if diff < 0 {\n        diff = diff\
    \ * -1\n    }\n    if diff == 1 {\n        return \"YES\"\n    }\n    if diff\
    \ == 2 {\n        return \"NO\"\n    }\n    for i := 2; i < diff; i++ {\n    \
    \    if diff %", "    x1 := interval1[0].(int)\n    x2 := interval1[1].(int)\n\
    \    y1 := interval2[0].(int)\n    y2 := interval2[1].(int)\n    if x1 > x2 {\n\
    \        x1, x2 = x2, x1\n    }\n    if y1 > y2 {\n        y1, y2 = y2, y1\n \
    \   }\n    if x2 < y1 || y2 < x1 {\n        return \"NO\"\n    }\n    x := max(x1,\
    \ y1)\n    y := min(x2, y2)\n    for i := 2; i < y; i++ {\n        if x % i ==\
    \ 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n",
  "    // if interval2[0] < interval1[0] {\n    //     interval1, interval2 = interval2,\
    \ interval1\n    // }\n    start := Max(interval1[0], interval2[0])\n    end :=\
    \ Min(interval1[1], interval2[1])\n    length := end.(int) - start.(int) + 1\n\
    \    if length <= 0 {\n        return \"NO\"\n    }\n    for i := 2; i < length;\
    \ i++ {\n        if length % i == 0 {\n            return \"NO\"\n        }\n\
    \    }\n    return \"YES\"\n}\n", "    fmt.Println(interval1, interval2)\n   \
    \ return \"YES\"\n}\n", "    fmt.Println(interval1, interval2)\n    start1 :=\
    \ interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n\
    \    end2 := interval2[1].(int)\n    var start int\n    var end int\n    if start1\
    \ < start2 {\n        start = start2\n    } else {\n        start = start1\n \
    \   }\n    if end1 < end2 {\n        end = end1\n    } else {\n        end = end2\n\
    \    }\n    if start > end {\n        return \"NO\"\n    }\n    if start == end\
    \ {\n        return \"YES\"\n    }\n    isPrime := true\n    for i := 2; i <=\
    \ end; i++ {\n        if start % i == 0 {\n            isPrime = false\n     \
    \       break\n        }\n    }\n    if isPrime {\n        return \"YES\"\n  \
    \  }\n    return \"NO\"\n}\n\ntype TestCase ", "    if interval1[0].(int) > interval2[1].(int)\
    \ || interval2[0].(int) > interval1[1].(int) {\n        return \"NO\"\n    }\n\
    \n    if interval1[0].(int) <= interval2[0].(int) {\n        start := interval2[0].(int)\n\
    \    } else {\n        start := interval1[0].(int)\n    }\n\n    if interval1[1].(int)\
    \ <= interval2[1].(int) {\n        end := interval1[1].(int)\n    } else {\n \
    \       end := interval2[1].(int)\n    }\n\n    length := end - start + 1\n  \
    \  if isPrime(length) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n",
  "    if len(interval1) < 2 || len(interval2) < 2 {\n        return \"NO\"\n    }\n\
    \    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2\
    \ := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1 > end1\
    \ || start2 > end2 {\n        return \"NO\"\n    }\n    start := start1\n    if\
    \ start2 > start1 {\n        start = start2\n    }\n    end := end1\n    if end2\
    \ < end1 {\n        end = end2\n    }\n    if start > end {\n        return \"\
    NO\"\n    }\n    if start == end {\n        return \"YES\"\n    }\n    diff :=\
    \ end - start + 1\n    for i := 2; i < diff; i++ {\n        if diff % i == 0 {\n\
    \            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n\ntype testData ",
  "    s1 := interval1[0].(int)\n    e1 := interval1[1].(int)\n    s2 := interval2[0].(int)\n\
    \    e2 := interval2[1].(int)\n    s := max(s1, s2)\n    e := min(e1, e2)\n  \
    \  if e < s {\n        return \"NO\"\n    }\n    if isPrime(e - s + 1) {\n   \
    \     return \"YES\"\n    }\n    return \"NO\"\n}\n", "    return \"NO\"\n}\n",
  "    int1Start := interval1[0].(int)\n    int1End := interval1[1].(int)\n    int2Start\
    \ := interval2[0].(int)\n    int2End := interval2[1].(int)\n    var start int\n\
    \    var end int\n    if int1Start <= int2Start {\n        start = int2Start\n\
    \    } else {\n        start = int1Start\n    }\n    if int1End >= int2End {\n\
    \        end = int2End\n    } else {\n        end = int1End\n    }\n    //fmt.Println(start,\
    \ end)\n    if start >= end {\n        return \"NO\"\n    }\n    if isPrime(end\
    \ - start) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n", "    i1\
    \ := interval1[0].(int)\n    i2 := interval1[1].(int)\n    j1 := interval2[0].(int)\n\
    \    j2 := interval2[1].(int)\n    if i1 > i2 {\n        i1, i2 = i2, i1\n   \
    \ }\n    if j1 > j2 {\n        j1, j2 = j2, j1\n    }\n    if i2 < j1 || j2 <\
    \ i1 {\n        return \"NO\"\n    }\n    // i1 <= i2, j1 <= j2\n    s := i2\n\
    \    if j2 < i2 {\n        s = j2\n    }\n    e := i1\n    if j1 > i1 {\n    \
    \    e = j1\n    }\n    for i := s; i > e; i-- {\n        if isPrime(i) {\n  \
    \          return \"YES\"\n        }\n    }\n    return \"NO\"\n}\n", "    _interval1\
    \ := [2]int{interval1[0].(int), interval1[1].(int)}\n    _interval2 := [2]int{interval2[0].(int),\
    \ interval2[1].(int)}\n    fmt.Println(_interval1, _interval2)\n    if _interval1[0]\
    \ > _interval2[1] || _interval2[0] > _interval1[1] {\n        return \"NO\"\n\
    \    }\n    start := max(_interval1[0], _interval2[0])\n    end := min(_interval1[1],\
    \ _interval2[1])\n    length := end - start + 1\n    for i := 2; i < length; i++\
    \ {\n        if length % i == 0 {\n            return \"NO\"\n        }\n    }\n\
    \    return \"YES\"\n}\n", "    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start < start2\
    \ {\n        start = start2\n    }\n    end := end1\n    if end > end2 {\n   \
    \     end = end2\n    }\n    length := end - start\n    if length == 0 {\n   \
    \     return \"NO\"\n    }\n    if length == 1 {\n        return \"YES\"\n   \
    \ }\n    if length == 2 {\n        return \"NO\"\n    }\n    for i := 2; i < length;\
    \ i++ {\n        if length % i == 0 {\n            return \"NO\"\n        }\n\
    \    }\n    return \"YES\"\n}\n", "    // interval1 = [1, 2]\n    // interval2\
    \ = [2, 3]\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    intersect\
    \ := make([]int, 0)\n    if start1 > end2 || start2 > end1 {\n        return \"\
    NO\"\n    }\n    if start1 > start2 {\n        start1 = start2\n    }\n    if\
    \ end1 < end2 {\n        end1 = end2\n    }\n    for i := start1; i <= end1; i++\
    \ {\n        intersect = append(intersect, i)\n    }\n    // fmt.Println(intersect)\n\
    \    for _, i := range intersect {\n        for j := 2; j < i; j++ {\n       \
    \     if i % j == 0 {\n                return \"NO\"\n            }\n        }\n\
    \    }\n    return \"YES\"\n}\n", "    if interval1[0].(int) > interval2[1].(int)\
    \ || interval2[0].(int) > interval1[1].(int) {\n        return \"NO\"\n    }\n\
    \    if isPrime(interval1[1].(int) - interval2[0].(int)) {\n        return \"\
    YES\"\n    }\n    return \"NO\"\n}\n", "    var ival1, ival2 *Interval\n\n   \
    \ ival1 = NewInterval(interval1)\n    ival2 = NewInterval(interval2)\n\n    if\
    \ ival1.Intersects(ival2) {\n        if _, ok := PrimeNumbersMap[ival1.IntersectionLength(ival2)];\
    \ ok {\n            return \"YES\"\n        }\n    }\n\n    return \"NO\"\n}\n",
  "    var start, end int\n    if interval1[0].(int) > interval2[0].(int) {\n    \
    \    start = interval1[0].(int)\n    } else {\n        start = interval2[0].(int)\n\
    \    }\n    if interval1[1].(int) < interval2[1].(int) {\n        end = interval1[1].(int)\n\
    \    } else {\n        end = interval2[1].(int)\n    }\n    if start > end {\n\
    \        return \"NO\"\n    }\n    length := end - start + 1\n    if length ==\
    \ 2 {\n        return \"YES\"\n    }\n    for i := 2; i < length; i++ {\n    \
    \    if length % i == 0 {\n            return \"NO\"\n        }\n    }\n    return\
    \ \"YES\"\n}\n", "\ta, b := interval1[0].(int), interval1[1].(int)\n\tc, d :=\
    \ interval2[0].(int), interval2[1].(int)\n\tintersect := []int{}\n\tif a < c {\n\
    \t\tif b < c {\n\t\t\treturn \"NO\"\n\t\t} else if b > d {\n\t\t\tintersect =\
    \ []int{c, d}\n\t\t} else {\n\t\t\tintersect = []int{c, b}\n\t\t}\n\t} else {\n\
    \t\tif a > d {\n\t\t\treturn \"NO\"\n\t\t} else if b > d {\n\t\t\tintersect =\
    \ []int{a, d}\n\t\t} else {\n\t\t\tintersect = []int{a, b}\n\t\t}\n\t}\n\tif isPrime(intersect[1]\
    \ - intersect[0]) {\n\t\treturn \"YES\"\n\t}\n\treturn \"NO\"\n}\n", "    // Your\
    \ code here\n    return \"\"\n}\n", "    start1 := interval1[0].(int)\n    end1\
    \ := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n\
    \    if start1 > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2\
    \ > end2 {\n        start2, end2 = end2, start2\n    }\n    start := 0\n    end\
    \ := 0\n    if start1 <= start2 {\n        start = start2\n    } else {\n    \
    \    start = start1\n    }\n    if end1 >= end2 {\n        end = end2\n    } else\
    \ {\n        end = end1\n    }\n    if start > end {\n        return \"NO\"\n\
    \    }\n    if start == end {\n        if start <= 1 {\n            return \"\
    NO\"\n        }\n        if start == 2 {\n            return \"YES\"\n       \
    \ }\n        for i := 2; i < start; i++ {\n            if start % i == 0 {\n \
    \               return \"NO\"\n            }\n        }\n        return \"YES\"\
    \n    }\n    //length\n    length := end - start + 1\n    if length <= 1 {\n \
    \       return \"NO\"\n    }\n    if length == 2 {\n        return \"YES\"\n \
    \   }\n    for i := 2; i < length; i++ {\n        if length % i == 0 {\n     \
    \       return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n", "    interval1Start\
    \ := interval1[0].(int)\n    interval1End := interval1[1].(int)\n    interval2Start\
    \ := interval2[0].(int)\n    interval2End := interval2[1].(int)\n    if interval1Start\
    \ <= interval2Start {\n        return isIntersectionPrime(interval1Start, interval1End,\
    \ interval2Start, interval2End)\n    } else {\n        return isIntersectionPrime(interval2Start,\
    \ interval2End, interval1Start, interval1End)\n    }\n}\n", "    i1 := interval1[0].(int)\n\
    \    i2 := interval1[1].(int)\n    j1 := interval2[0].(int)\n    j2 := interval2[1].(int)\n\
    \    if i1 > i2 {\n        i1, i2 = i2, i1\n    }\n    if j1 > j2 {\n        j1,\
    \ j2 = j2, j1\n    }\n    if i2 < j1 || j2 < i1 {\n        return \"NO\"\n   \
    \ }\n    if j1 < i1 {\n        i1 = j1\n    }\n    if j2 < i2 {\n        i2 =\
    \ j2\n    }\n    return isPrime(i2 - i1 + 1)\n}\n", "    // your code here\n \
    \   return \"\"\n}\n", "    var result string = \"NO\"\n    if interval1[0].(int)\
    \ >= interval2[0].(int) && interval1[0].(int) <= interval2[1].(int) {\n      \
    \  if isPrime(interval2[1].(int) - interval1[0].(int)) {\n            result =\
    \ \"YES\"\n        }\n    } else if interval2[0].(int) >= interval1[0].(int) &&\
    \ interval2[0].(int) <= interval1[1].(int) {\n        if isPrime(interval1[1].(int)\
    \ - interval2[0].(int)) {\n            result = \"YES\"\n        }\n    }\n  \
    \  return result\n}\n", "    if len(interval1) != 2 || len(interval2) != 2 {\n\
    \        return \"NO\"\n    }\n    inter1start := interval1[0].(int)\n    inter1end\
    \ := interval1[1].(int)\n    inter2start := interval2[0].(int)\n    inter2end\
    \ := interval2[1].(int)\n    inter1start, inter1end = normInterval(inter1start,\
    \ inter1end)\n    inter2start, inter2end = normInterval(inter2start, inter2end)\n\
    \    if inter1start > inter2end || inter2start > inter1end {\n        return \"\
    NO\"\n    }\n    interStart := inter1start\n    if interStart < inter2start {\n\
    \        interStart = inter2start\n    }\n    interEnd := inter1end\n    if interEnd\
    \ > inter2end {\n        interEnd = inter2end\n    }\n    interLen := interEnd\
    \ - interStart + 1\n    if interLen <= 1 {\n        return \"NO\"\n    }\n   \
    \ return isPrime(interLen)\n}\n", "    if interval1[0].(int) > interval2[1].(int)\
    \ || interval2[0].(int) > interval1[1].(int) {\n        return \"NO\"\n    }\n\
    \    var start, end int\n    if interval1[0].(int) >= interval2[0].(int) {\n \
    \       start = interval1[0].(int)\n    } else {\n        start = interval2[0].(int)\n\
    \    }\n    if interval1[1].(int) <= interval2[1].(int) {\n        end = interval1[1].(int)\n\
    \    } else {\n        end = interval2[1].(int)\n    }\n    if start == end {\n\
    \        return \"YES\"\n    }\n    for i := start; i <= end; i++ {\n        if\
    \ i == 2 || i == 3 || i == 5 || i == 7 {\n            return \"YES\"\n       \
    \ }\n    }\n    return \"NO\"\n}\n", "    var (\n        start1 = int(interval1[0].(float64))\n\
    \        end1 = int(interval1[1].(float64))\n        start2 = int(interval2[0].(float64))\n\
    \        end2 = int(interval2[1].(float64))\n        start, end int\n    )\n \
    \   if start1 < start2 {\n        start = start2\n    } else {\n        start\
    \ = start1\n    }\n    if end1 > end2 {\n        end = end2\n    } else {\n  \
    \      end = end1\n    }\n    if start > end {\n        return \"NO\"\n    }\n\
    \    var arr = make([]int, end - start + 1)\n    for i := 0; i < len(arr); i++\
    \ {\n        arr[i] = start + i\n    }\n    for i := 2; i <= end / 2; i++ {\n\
    \        isPrime := true\n        for j := 0; j < len(arr); j++ {\n          \
    \  if arr[j] % i == 0 {\n                isPrime = false\n                break\n\
    \            }\n        }\n        if isPrime {\n            return \"YES\"\n\
    \        }\n    }\n    return \"NO\"\n}\n", "    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    if start1 > end1 {\n        start1, end1 = end1, start1\n\
    \    }\n    if start2 > end2 {\n        start2, end2 = end2, start2\n    }\n \
    \   if start1 > end2 || start2 > end1 {\n        return \"NO\"\n    }\n    start\
    \ := start1\n    if start < start2 {\n        start = start2\n    }\n    end :=\
    \ end1\n    if end > end2 {\n        end = end2\n    }\n    length := end - start\n\
    \    if length == 0 {\n        return \"NO\"\n    }\n    if length == 1 {\n  \
    \      return \"YES\"\n    }\n    if length == 2 {\n        return \"NO\"\n  \
    \  }\n    if length % 2 == 0 {\n        return \"NO\"\n    }\n    for i := 3;\
    \ i < length; i += 2 {\n        if length % i == 0 {\n            return \"NO\"\
    \n        }\n    }\n    return \"YES\"\n}\n", "    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    if start1 > end1 {\n        start1, end1 = end1, start1\n\
    \    }\n    if start2 > end2 {\n        start2, end2 = end2, start2\n    }\n \
    \   if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    for\
    \ i := start1; i <= end1; i++ {\n        if i >= start2 && i <= end2 {\n     \
    \       if i == 1 {\n                return \"NO\"\n            }\n          \
    \  if i == 2 {\n                return \"YES\"\n            }\n            if\
    \ i%2 == 0 {\n                return \"NO\"\n            }\n            for j\
    \ := 3; j <= i/2; j += 2 {\n                if i%j == 0 {\n                  \
    \  return \"NO\"\n                }\n            }\n            return \"YES\"\
    \n        }\n    }\n    return \"NO\"\n}\n", "    // your code here\n    // check\
    \ is not intersect, return \"NO\"\n    if interval1[1].(int) < interval2[0].(int)\
    \ || interval2[1].(int) < interval1[0].(int) {\n        return \"NO\"\n    }\n\
    \    // convert to prime\n    interval := interval1\n    if interval1[0].(int)\
    \ > interval2[0].(int) {\n        interval = interval2\n    }\n    start, end\
    \ := interval[0].(int), interval[1].(int)\n    if interval1[0].(int) < interval2[0].(int)\
    \ {\n        end = interval2[0].(int)\n    } else {\n        start = interval2[1].(int)\n\
    \    }\n    return prime(start, end)\n}\n", "    isPrime := func(n int) bool {\n\
    \        if n <= 1 {\n            return false\n        }\n        for i := 2;\
    \ i * i <= n; i++ {\n            if n % i == 0 {\n                return false\n\
    \            }\n        }\n        return true\n    }\n    if len(interval1) !=\
    \ 2 || len(interval2) != 2 {\n        return \"NO\"\n    }\n    var start1, end1,\
    \ start2, end2 int\n    switch interval1[0].(type) {\n    case int:\n        start1\
    \ = interval1[0].(int)\n        end1 = interval1[1].(int)\n    case float64:\n\
    \        start1 = int(interval1[0].(float64))\n        end1 = int(interval1[1].(float64))\n\
    \    }\n    switch interval2[0].(type) {\n    case int:\n        start2 = interval2[0].(int)\n\
    \        end2 = interval2[1].(int)\n    case float64:\n        start2 = int(interval2[0].(float64))\n\
    \        end2 = int(interval2[1].(float64))\n    }\n    if start1 > end1 || start2\
    \ > end2 {\n        return \"NO\"\n    }\n    if end1 < start2 || end2 < start1\
    \ {\n        return \"NO\"\n    }\n    if start1 > start2 {\n        start1, start2\
    \ = start2, start1\n    }\n    if end1 < end2 {\n        end1, end2 = end2, end1\n\
    \    }\n    if isPrime(end1 - start2 + 1) {\n        return \"YES\"\n    }\n \
    \   return \"NO\"\n}\n", "    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ <= start2 {\n        if end1 < start2 {\n            return \"NO\"\n       \
    \ }\n        return isPrime(end1 - start2 + 1)\n    }\n    if end2 < start1 {\n\
    \        return \"NO\"\n    }\n    return isPrime(end2 - start1 + 1)\n}\n", " \
    \   start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 :=\
    \ interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1 > end1 {\n\
    \        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n        start2,\
    \ end2 = end2, start2\n    }\n    if start1 == end1 || start2 == end2 {\n    \
    \    return \"NO\"\n    }\n    var is_prime = func(n int) bool {\n        if n\
    \ < 2 {\n            return false\n        }\n        if n == 2 {\n          \
    \  return true\n        }\n        for i := 2; i <= n / 2; i++ {\n           \
    \ if n % i == 0 {\n                return false\n            }\n        }\n  \
    \      return true\n    }\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\"\n    }\n    var min, max int\n    if start1 > start2 {\n        min =\
    \ start1\n    } else {\n        min = start2\n    }\n    if end1 > end2 {\n  \
    \      max = end2\n    } else {\n        max = end1\n    }\n    if is_prime(max\
    \ - min + 1) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n", "    s1\
    \ := interval1[0].(int)\n    e1 := interval1[1].(int)\n    s2 := interval2[0].(int)\n\
    \    e2 := interval2[1].(int)\n    if (s1 <= s2 && s2 <= e1) || (s2 <= s1 && s1\
    \ <= e2) {\n        // Intersects.\n        start := max(s1, s2)\n        end\
    \ := min(e1, e2)\n        n := end - start + 1\n        if n <= 0 {\n        \
    \    return \"NO\"\n        }\n        if n == 1 {\n            return \"YES\"\
    \n        }\n        if n % 2 == 0 {\n            return \"NO\"\n        }\n \
    \       if n % 3 == 0 {\n            return \"NO\"\n        }\n        // Test\
    \ all primes until n.\n        for p := 5; p <= n; p += 2 {\n            if n\
    \ % p == 0 {\n                return \"NO\"\n            }\n        }\n      \
    \  return \"YES\"\n    }\n    return \"NO\"\n}\n", "    int1 := interval1[0].(int)\n\
    \    int2 := interval1[1].(int)\n    int3 := interval2[0].(int)\n    int4 := interval2[1].(int)\n\
    \    start := int1\n    end := int2\n    if int1 > int3 {\n        start = int3\n\
    \    }\n    if int2 < int4 {\n        end = int2\n    }\n    if start > end {\n\
    \        return \"NO\"\n    }\n    flag := true\n    if start <= 2 && end >= 2\
    \ {\n        flag = false\n    }\n    for i := start; i <= end; i++ {\n      \
    \  if i != 2 && i != 3 && i != 5 && i != 7 {\n            flag = false\n     \
    \   }\n    }\n    if flag {\n        return \"YES\"\n    }\n    return \"NO\"\n\
    }\n", "    max := func(a, b int) int {\n        if a > b {\n            return\
    \ a\n        }\n        return b\n    }\n    min := func(a, b int) int {\n   \
    \     if a < b {\n            return a\n        }\n        return b\n    }\n \
    \   isPrime := func(n int) bool {\n        if n < 2 {\n            return false\n\
    \        }\n        for i := 2; i * i <= n; i++ {\n            if n % i == 0 {\n\
    \                return false\n            }\n        }\n        return true\n\
    \    }\n    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n   \
    \ start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    start := max(start1,\
    \ start2)\n    end := min(end1, end2)\n    if start > end {\n        return \"\
    NO\"\n    }\n    return map[bool]string{true: \"YES\", false: \"NO\"}[isPrime(end\
    \ - start + 1)]\n}\n", "    s := []int{interval1[0].(int), interval2[0].(int)}\n\
    \    e := []int{interval1[1].(int), interval2[1].(int)}\n    maxStart := max(s[0],\
    \ s[1])\n    minEnd := min(e[0], e[1])\n    interLen := minEnd - maxStart\n  \
    \  if interLen < 0 {\n        return \"NO\"\n    }\n    if isPrime(interLen) {\n\
    \        return \"YES\"\n    }\n    return \"NO\"\n}\n", "    int1 := toIntSlice(interval1)\n\
    \    int2 := toIntSlice(interval2)\n    if int1[0] <= int2[0] {\n        if int1[1]\
    \ < int2[0] {\n            return \"NO\"\n        }\n        if int1[1] <= int2[1]\
    \ {\n            return isPrime(int2[0] - int1[1])\n        }\n        return\
    \ isPrime(int2[0] - int2[1])\n    }\n    if int2[1] < int1[0] {\n        return\
    \ \"NO\"\n    }\n    if int2[1] <= int1[1] {\n        return isPrime(int1[0] -\
    \ int2[1])\n    }\n    return isPrime(int1[0] - int1[1])\n}\n", "\treturn \"\"\
    \n}\n", "    // Write your code here\n    return \"\"\n}\n", "    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    var s, e int\n    if start1 < start2 {\n        s =\
    \ start2\n    } else {\n        s = start1\n    }\n    if end1 < end2 {\n    \
    \    e = end1\n    } else {\n        e = end2\n    }\n    if s >= e {\n      \
    \  return \"NO\"\n    }\n    l := e - s\n    if l <= 1 {\n        return \"NO\"\
    \n    }\n    if l == 2 {\n        return \"YES\"\n    }\n    for i := 2; i < l;\
    \ i++ {\n        if l % i == 0 {\n            return \"NO\"\n        }\n    }\n\
    \    return \"YES\"\n}\n", "    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if end1\
    \ < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    if start1 <=\
    \ start2 {\n        if end1 <= end2 {\n            return isPrime(end1 - start2\
    \ + 1)\n        } else {\n            return isPrime(end2 - start2 + 1)\n    \
    \    }\n    } else {\n        if end1 <= end2 {\n            return isPrime(end1\
    \ - start1 + 1)\n        } else {\n            return isPrime(end2 - start1 +\
    \ 1)\n        }\n    }\n}\n", "    if isDisjoint(interval1, interval2) {\n   \
    \     return \"NO\"\n    }\n    if !isIntersect(interval1, interval2) {\n    \
    \    return \"NO\"\n    }\n    if isDisjoint(interval1, interval2) {\n       \
    \ return \"NO\"\n    }\n    start := max(interval1[0].(int), interval2[0].(int))\n\
    \    end := min(interval1[1].(int), interval2[1].(int))\n    if start > end {\n\
    \        return \"NO\"\n    }\n    if start == end {\n        return \"YES\"\n\
    \    }\n    if isPrime(end - start) {\n        return \"YES\"\n    }\n    return\
    \ \"NO\"\n}\n", "    start := max(interval1[0].(int), interval2[0].(int))\n  \
    \  end := min(interval1[1].(int), interval2[1].(int))\n    if start > end {\n\
    \        return \"NO\"\n    }\n    return isPrime(end - start + 1)\n}\n", "  \
    \  start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 :=\
    \ interval2[0].(int)\n    end2 := interval2[1].(int)\n    if (start1 < start2)\
    \ {\n        start1, start2 = start2, start1\n        end1, end2 = end2, end1\n\
    \    }\n    if (start1 > end2) {\n        return \"NO\"\n    }\n    start := start1\n\
    \    end := end2\n    if (end > end1) {\n        end = end1\n    }\n    if (start\
    \ <= end) {\n        return fmt.Sprintf(\"%v\", end - start)\n    }\n    return\
    \ \"NO\"\n}\n", "    // your code here\n    return \"\"\n}\n", "    start1 :=\
    \ interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n\
    \    end2 := interval2[1].(int)\n    if start1 > end1 || start2 > end2 {\n   \
    \     return \"NO\"\n    }\n    if end1 < start2 || end2 < start1 {\n        return\
    \ \"NO\"\n    }\n    left := start1\n    if start2 > start1 {\n        left =\
    \ start2\n    }\n    right := end1\n    if end2 < end1 {\n        right = end2\n\
    \    }\n    if left == right {\n        return \"YES\"\n    }\n    if isPrime(right\
    \ - left) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n", "    // your\
    \ code here\n    // lets take the intersection as a slice\n    inter := []int{}\n\
    \    // I really just need to find the first element and last element of the \n\
    \    // intersection\n    // First:\n    // We know the first element cant be\
    \ higher than the interval that starts first\n    // So we find the smaller of\
    \ the two\n    // Second:\n    // We know the last element cant be lower than\
    \ the interval that starts last\n    // So we find the greater of the two\n  \
    \  // With the first and last elements of the intersection, we can determine\n\
    \    // the length of the intersection by taking the difference between the two\n\
    \    first := 0\n    if interval1[0].(int) < interval2[0].(int) {\n        first\
    \ = interval1[0].(int)\n    } else {\n        first = interval2[0].(int)\n   \
    \ }\n    last := 0\n    if interval1[1].(int) > interval2[1].(int) {\n       \
    \ last = interval1[1].(int)\n    } else {\n        last = interval2[1].(int)\n\
    \    }\n    if first > last {\n        return \"NO\"\n    }\n    inter = append(inter,\
    \ first)\n    inter = append(inter, last)\n    // Now we have the intersection,\
    \ we need to determine if the length of the\n    // intersection is a prime number\n\
    \    // To do this, we will have a function that determines if a number is prime\n\
    \    // and we will call that function on the length of the intersection\n   \
    \ if isPrime(last - first) {\n        return \"YES\"\n    }\n    return \"NO\"\
    \n}\n", "    return \"NO\"\n}\n", "\tstart := max(interval1[0].(int), interval2[0].(int))\n\
    \tend := min(interval1[1].(int), interval2[1].(int))\n\tif end < start {\n\t\t\
    return \"NO\"\n\t}\n\treturn isPrime(end - start + 1)\n}\n", "    if (interval1[0].(int)\
    \ > interval2[1].(int)) || (interval2[0].(int) > interval1[1].(int)) {\n     \
    \   return \"NO\"\n    }\n\n    start := interval1[0].(int)\n    if interval2[0].(int)\
    \ > start {\n        start = interval2[0].(int)\n    }\n\n    end := interval1[1].(int)\n\
    \    if interval2[1].(int) < end {\n        end = interval2[1].(int)\n    }\n\n\
    \    if start == end {\n        return \"YES\"\n    }\n\n    n := end - start\n\
    \    count := 0\n    for i := 2; i < n; i++ {\n        if n % i == 0 {\n     \
    \       count++\n        }\n    }\n\n    if count > 0 {\n        return \"NO\"\
    \n    }\n\n    return \"YES\"\n}\n", "    var start, end int\n    // the length\
    \ of intersection\n    var length int\n    if v, ok := interval1[0].(int); ok\
    \ {\n        start = v\n    }\n    if v, ok := interval1[1].(int); ok {\n    \
    \    end = v\n    }\n    // fmt.Println(start, end)\n    if v, ok := interval2[0].(int);\
    \ ok {\n        if v > start {\n            start = v\n        }\n    }\n    if\
    \ v, ok := interval2[1].(int); ok {\n        if v < end {\n            end = v\n\
    \        }\n    }\n    // fmt.Println(start, end)\n    if start > end {\n    \
    \    return \"NO\"\n    }\n    length = end - start\n    if isPrime(length) {\n\
    \        return \"YES\"\n    }\n    return \"NO\"\n}\n", "    start := 0\n   \
    \ end := 0\n    if interval1[0].(int) > interval2[0].(int) {\n        start =\
    \ interval1[0].(int)\n    } else {\n        start = interval2[0].(int)\n    }\n\
    \    if interval1[1].(int) < interval2[1].(int) {\n        end = interval1[1].(int)\n\
    \    } else {\n        end = interval2[1].(int)\n    }\n    if start > end {\n\
    \        return \"NO\"\n    }\n    if start == end {\n        return \"YES\"\n\
    \    }\n    if isPrime(end - start) {\n        return \"YES\"\n    }\n    return\
    \ \"NO\"\n}\n", "    t1 := interval1[0].(int)\n    t2 := interval1[1].(int)\n\
    \    t3 := interval2[0].(int)\n    t4 := interval2[1].(int)\n    // fmt.Println(t1,\
    \ t2, t3, t4)\n    if (t1 > t2) { t1, t2 = t2, t1 }\n    if (t3 > t4) { t3, t4\
    \ = t4, t3 }\n    if (t1 > t4 || t2 < t3) { return \"NO\" }\n    if (t1 <= t3\
    \ && t2 >= t4) {\n        return isPrime(t4 - t3 + 1)\n    }\n    if (t1 >= t3\
    \ && t2 <= t4) {\n        return isPrime(t2 - t1 + 1)\n    }\n    if (t1 >= t3\
    \ && t1 <= t4 && t2 >= t4) {\n        return isPrime(t4 - t1 + 1)\n    }\n   \
    \ if (t1 <= t3 && t2 >= t3 && t2 <= t4) {\n        return isPrime(t2 - t3 + 1)\n\
    \    }\n    return \"NO\"\n}\n", "    start1 := interval1[0].(int)\n    end1 :=\
    \ interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n\
    \    if start1 > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2\
    \ > end2 {\n        start2, end2 = end2, start2\n    }\n    if start1 > end2 ||\
    \ start2 > end1 {\n        return \"NO\"\n    }\n    len1 := end1 - start1\n \
    \   len2 := end2 - start2\n    if len1 < len2 {\n        start1, end1, start2,\
    \ end2 = start2, end2, start1, end1\n    }\n    for {\n        if start1 > end2\
    \ {\n            return \"NO\"\n        }\n        if start1 >= start2 && start1\
    \ <= end2 {\n            return checkPrime(start1 - start2 + 1)\n        }\n \
    \       start1++\n    }\n}\n", "    // your code here\n    return \"\"\n}\n",
  "    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int) > interval1[1].(int)\
    \ {\n        return \"NO\"\n    }\n\n    // fmt.Println(interval1[0].(int))\n\
    \    // fmt.Println(interval1[1].(int))\n    // fmt.Println(interval2[0].(int))\n\
    \    // fmt.Println(interval2[1].(int))\n\n    start := max(interval1[0].(int),\
    \ interval2[0].(int))\n    end := min(interval1[1].(int), interval2[1].(int))\n\
    \n    // fmt.Println(start)\n    // fmt.Println(end)\n\n    if start == end {\n\
    \        return \"YES\"\n    }\n\n    for i := start + 1; i < end; i++ {\n   \
    \     if isPrime(i) {\n            return \"YES\"\n        }\n    }\n\n    return\
    \ \"NO\"\n}\n", "    return \"\"\n}\n", "    var start, end int\n    if interval1[0].(int)\
    \ > interval2[0].(int) {\n        start = interval1[0].(int)\n    } else {\n \
    \       start = interval2[0].(int)\n    }\n    if interval1[1].(int) < interval2[1].(int)\
    \ {\n        end = interval1[1].(int)\n    } else {\n        end = interval2[1].(int)\n\
    \    }\n    if start >= end {\n        return \"NO\"\n    }\n    if isPrime(end\
    \ - start) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n", "    if\
    \ interval1[0].(int) > interval2[1].(int) || interval2[0].(int) > interval1[1].(int)\
    \ {\n        return \"NO\"\n    }\n    var start, end int\n    if interval1[0].(int)\
    \ >= interval2[0].(int) {\n        start = interval1[0].(int)\n    } else {\n\
    \        start = interval2[0].(int)\n    }\n    if interval1[1].(int) <= interval2[1].(int)\
    \ {\n        end = interval1[1].(int)\n    } else {\n        end = interval2[1].(int)\n\
    \    }\n    if end - start == 1 {\n        return \"YES\"\n    }\n    for i :=\
    \ start + 1; i < end; i++ {\n        for j := 2; j < i; j++ {\n            if\
    \ i % j == 0 {\n                return \"NO\"\n            }\n        }\n    }\n\
    \    return \"YES\"\n}\n", "    var result string = \"NO\"\n    var start int\
    \ = 0\n    var end int = 0\n    if interval1[0].(int) < interval2[0].(int) {\n\
    \        start = interval2[0].(int)\n    } else {\n        start = interval1[0].(int)\n\
    \    }\n    if interval1[1].(int) < interval2[1].(int) {\n        end = interval1[1].(int)\n\
    \    } else {\n        end = interval2[1].(int)\n    }\n    if start < end {\n\
    \        result = \"YES\"\n    }\n    return result\n}\n", "    // your code here\n\
    \    return \"\"\n}\n", "    if len(interval1) != 2 || len(interval2) != 2 {\n\
    \        return \"NO\"\n    }\n    start1, ok := interval1[0].(int)\n    if !ok\
    \ {\n        return \"NO\"\n    }\n    end1, ok := interval1[1].(int)\n    if\
    \ !ok {\n        return \"NO\"\n    }\n    start2, ok := interval2[0].(int)\n\
    \    if !ok {\n        return \"NO\"\n    }\n    end2, ok := interval2[1].(int)\n\
    \    if !ok {\n        return \"NO\"\n    }\n    if start1 >= end1 || start2 >=\
    \ end2 {\n        return \"NO\"\n    }\n    if start1 <= start2 && end1 >= start2\
    \ {\n        if end1 < end2 {\n            if end1 - start2 == 1 {\n         \
    \       return \"YES\"\n            }\n            return \"NO\"\n        }\n\
    \        if end1 >= end2 {\n            if end2 - start2 == 1 {\n            \
    \    return \"YES\"\n            }\n            return \"NO\"\n        }\n   \
    \ }\n    if start2 <= start1 && end2 >= start1 {\n        if end2 < end1 {\n \
    \           if end2 - start1 == 1 {\n                return \"YES\"\n        \
    \    }\n            return \"NO\"\n        }\n        if end2 >= end1 {\n    \
    \        if end1 - start1 == 1 {\n                return \"YES\"\n           \
    \ }\n            return \"NO\"\n        }\n    }\n    return \"NO\"\n}\n", " \
    \   return fmt.Sprintf(\"YES\")\n}\n", "    int1 := interval1[0].(int)\n    int2\
    \ := interval1[1].(int)\n    int3 := interval2[0].(int)\n    int4 := interval2[1].(int)\n\
    \    start := 0\n    end := 0\n    isIntersect := false\n    if int1 <= int3 &&\
    \ int3 <= int2 {\n        start = int3\n        isIntersect = true\n    } else\
    \ if int3 <= int1 && int1 <= int4 {\n        start = int1\n        isIntersect\
    \ = true\n    }\n    if int1 <= int4 && int4 <= int2 {\n        end = int4\n \
    \       isIntersect = true\n    } else if int3 <= int2 && int2 <= int4 {\n   \
    \     end = int2\n        isIntersect = true\n    }\n    if !isIntersect {\n \
    \       return \"NO\"\n    }\n    res := end - start\n    if res <= 1 {\n    \
    \    return \"NO\"\n    }\n    if res == 2 {\n        return \"YES\"\n    }\n\
    \    return \"NO\"\n}\n", "    a := interval1[0].(int)\n    b := interval1[1].(int)\n\
    \    c := interval2[0].(int)\n    d := interval2[1].(int)\n    if b < c || a >\
    \ d {\n        return \"NO\"\n    }\n    l := b - c\n    if l < 0 {\n        l\
    \ = -l\n    }\n    return isPrime(l)\n}\n", "    var start, end, a, b int\n\n\
    \    start = interval1[0].(int)\n    end = interval1[1].(int)\n    a = interval2[0].(int)\n\
    \    b = interval2[1].(int)\n\n    if start > end {\n        start, end = end,\
    \ start\n    }\n    if a > b {\n        a, b = b, a\n    }\n\n    if a > end ||\
    \ b < start {\n        return \"NO\"\n    }\n\n    // Found the intersection.\n\
    \    // Now start computation.\n    if b < end {\n        end = b\n    }\n   \
    \ if a > start {\n        start = a\n    }\n\n    for i := start; i <= end; i++\
    \ {\n        if i % 2 == 0 {\n            return \"NO\"\n        }\n    }\n\n\
    \    return \"YES\"\n}\n", "    if interval1[0].(int) > interval2[1].(int) ||\
    \ interval2[0].(int) > interval1[1].(int) {\n        return \"NO\"\n    }\n  \
    \  start := max(interval1[0].(int), interval2[0].(int))\n    end := min(interval1[1].(int),\
    \ interval2[1].(int))\n    length := end - start + 1\n    prime := true\n    for\
    \ i := 2; i < length; i++ {\n        if length % i == 0 {\n            prime =\
    \ false\n            break\n        }\n    }\n    if prime {\n        return \"\
    YES\"\n    }\n    return \"NO\"\n}\n", "    start1 := interval1[0].(int)\n   \
    \ end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n\
    \    if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    if\
    \ start1 <= start2 {\n        if end1 <= end2 {\n            return isPrime(end1\
    \ - start2 + 1)\n        } else {\n            return isPrime(end2 - start2 +\
    \ 1)\n        }\n    } else {\n        if end1 <= end2 {\n            return isPrime(end1\
    \ - start1 + 1)\n        } else {\n            return isPrime(end2 - start1 +\
    \ 1)\n        }\n    }\n}\n", "    // your code here\n    return \"\"\n}\n", " \
    \   // Write your code here\n    // To print results to the standard output you\
    \ can use fmt.Println()\n    // Example: fmt.Println(\"Hello world!\")\n    return\
    \ \"\"\n}\n", "    left := max(interval1[0].(int), interval2[0].(int))\n    right\
    \ := min(interval1[1].(int), interval2[1].(int))\n    if right <= left {\n   \
    \     return \"NO\"\n    }\n    if isPrime(right - left) {\n        return \"\
    YES\"\n    }\n    return \"NO\"\n}\n", "    start1 := interval1[0].(int)\n   \
    \ end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n\
    \    if start1 > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2\
    \ > end2 {\n        start2, end2 = end2, start2\n    }\n    if start1 > end2 ||\
    \ start2 > end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2\
    \ > start1 {\n        start = start2\n    }\n    end := end1\n    if end2 < end1\
    \ {\n        end = end2\n    }\n    length := end - start\n    if length <= 1\
    \ {\n        return \"NO\"\n    }\n    for i := 2; i < length; i++ {\n       \
    \ if length % i == 0 {\n            return \"NO\"\n        }\n    }\n    return\
    \ \"YES\"\n}\n", "    // arr := toIntSlice(interval1)\n    if IsIntersected(interval1,\
    \ interval2) {\n        if isPrime(IntersectionSize(interval1, interval2)) {\n\
    \            return \"YES\"\n        }\n        return \"NO\"\n    }\n    return\
    \ \"NO\"\n}\n", "    i1 := interval1[0].(int)\n    i2 := interval1[1].(int)\n\
    \    i3 := interval2[0].(int)\n    i4 := interval2[1].(int)\n    max := func(a,\
    \ b int) int {\n        if a > b {\n            return a\n        }\n        return\
    \ b\n    }\n    min := func(a, b int) int {\n        if a < b {\n            return\
    \ a\n        }\n        return b\n    }\n    if (i1 < i2 && i3 < i4) && (max(i1,\
    \ i3) <= min(i2, i4)) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n",
  "    fmt.Println(interval1, interval2)\n    return \"wrong answer\"\n}\n", "   \
    \ start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 :=\
    \ interval2[0].(int)\n    end2 := interval2[1].(int)\n    //fmt.Println(start1,\
    \ end1, start2, end2)\n    if end1 < start2 || end2 < start1 {\n        return\
    \ \"NO\"\n    }\n    start := start1\n    if start1 < start2 {\n        start\
    \ = start2\n    }\n    end := end1\n    if end1 > end2 {\n        end = end2\n\
    \    }\n    length := end - start\n    if length <= 1 {\n        return \"NO\"\
    \n    }\n    if length == 2 {\n        return \"YES\"\n    }\n    if length %\
    \ 2 == 0 {\n        return \"NO\"\n    }\n    for i := 3; i < length / 2; i +=\
    \ 2 {\n        if length % i == 0 {\n            return \"NO\"\n        }\n  \
    \  }\n    return \"YES\"\n}\n", "    // NOTE: x and y are assumed to be small\
    \ positive integers.\n    x, y := interval1[0].(int), interval1[1].(int)\n   \
    \ p, q := interval2[0].(int), interval2[1].(int)\n    if y < p || q < x {\n  \
    \      return \"NO\"\n    }\n    start, end := x, y\n    if p > x {\n        start\
    \ = p\n    }\n    if q < y {\n        end = q\n    }\n    for i := start; i <=\
    \ end; i++ {\n        if isPrime(i) {\n            return \"YES\"\n        }\n\
    \    }\n    return \"NO\"\n}\n", "    start1 := interval1[0].(int)\n    end1 :=\
    \ interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n\
    \    if start1 > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2\
    \ > end2 {\n        start2, end2 = end2, start2\n    }\n    if start1 >= end2\
    \ || start2 >= end1 {\n        return \"NO\"\n    }\n    start := start1\n   \
    \ if start2 > start1 {\n        start = start2\n    }\n    end := end1\n    if\
    \ end2 < end1 {\n        end = end2\n    }\n    if end - start == 1 {\n      \
    \  return \"YES\"\n    }\n    if end - start < 1 {\n        return \"NO\"\n  \
    \  }\n    prime := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,\
    \ 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n    for _, p := range prime {\n   \
    \     if p == end - start {\n            return \"YES\"\n        }\n    }\n  \
    \  return \"NO\"\n}\n", "    // your code here\n    return \"\"\n}\n", "    return\
    \ \"\"\n}\n", "    var prime bool = true\n    for i := interval1[0].(int); i <=\
    \ interval1[1].(int); i++ {\n        for j := interval2[0].(int); j <= interval2[1].(int);\
    \ j++ {\n            if i == j {\n                // fmt.Println(i)\n        \
    \        for k := 2; k < i; k++ {\n                    if i % k == 0 {\n     \
    \                   prime = false\n                        break\n           \
    \         }\n                }\n                if prime {\n                 \
    \   return \"YES\"\n                }\n            }\n        }\n    }\n    return\
    \ \"NO\"\n}\n", "    a, b := interval1[0].(int), interval1[1].(int)\n    c, d\
    \ := interval2[0].(int), interval2[1].(int)\n    if a > b {\n        a, b = b,\
    \ a\n    }\n    if c > d {\n        c, d = d, c\n    }\n    e, f := max(a, c),\
    \ min(b, d)\n    if e > f {\n        return \"NO\"\n    }\n    if e == f {\n \
    \       return \"YES\"\n    }\n    return isPrime(f - e + 1)\n}\n", "    if interval1[0].(int)\
    \ > interval2[1].(int) || interval2[0].(int) > interval1[1].(int) {\n        return\
    \ \"NO\"\n    }\n    if interval1[0].(int) < interval2[0].(int) {\n        interval1[0]\
    \ = interval2[0]\n    }\n    if interval1[1].(int) > interval2[1].(int) {\n  \
    \      interval1[1] = interval2[1]\n    }\n    interval1[0] = interval1[0].(int)\
    \ - interval1[1].(int)\n    if interval1[0].(int) < 0 {\n        interval1[0]\
    \ = interval1[0].(int) * -1\n    }\n    interval1[0] = interval1[0].(int) + 1\n\
    \    if interval1[0].(int) <= 1 {\n        return \"NO\"\n    }\n    for i :=\
    \ 2; i < interval1[0].(int); i++ {\n        if interval1[0].(int) % i == 0 {\n\
    \            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n", "    //\
    \ check input\n    if len(interval1) != 2 || len(interval2) != 2 {\n        return\
    \ \"NO\"\n    }\n    // get start and end points\n    start1 := int(interval1[0].(float64))\n\
    \    end1 := int(interval1[1].(float64))\n    start2 := int(interval2[0].(float64))\n\
    \    end2 := int(interval2[1].(float64))\n    // check if the two intervals intersect\n\
    \    if start1 >= end2 || start2 >= end1 {\n        return \"NO\"\n    }\n   \
    \ // calculate the intersection\n    start := start1\n    if start1 < start2 {\n\
    \        start = start2\n    }\n    end := end1\n    if end1 > end2 {\n      \
    \  end = end2\n    }\n    // if the length of the intersection is prime, return\
    \ \"YES\", otherwise return \"NO\"\n    if isPrime(end - start) {\n        return\
    \ \"YES\"\n    }\n    return \"NO\"\n}\n", "    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    if start1 > end1 {\n        start1, end1 = end1, start1\n\
    \    }\n    if start2 > end2 {\n        start2, end2 = end2, start2\n    }\n \
    \   if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    start\
    \ := start1\n    if start2 > start1 {\n        start = start2\n    }\n    end\
    \ := end1\n    if end2 < end1 {\n        end = end2\n    }\n    if end == start\
    \ {\n        return \"YES\"\n    }\n    for i := 2; i < end - start; i++ {\n \
    \       if (end - start) % i == 0 {\n            return \"NO\"\n        }\n  \
    \  }\n    return \"YES\"\n}\n", "    start1 := interval1[0].(int)\n    end1 :=\
    \ interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n\
    \    fmt.Println(start1, end1, start2, end2)\n    var intersectionStart, intersectionEnd\
    \ int\n    if start1 < start2 {\n        intersectionStart = start2\n    } else\
    \ {\n        intersectionStart = start1\n    }\n    if end1 < end2 {\n       \
    \ intersectionEnd = end1\n    } else {\n        intersectionEnd = end2\n    }\n\
    \    length := intersectionEnd - intersectionStart\n    if length == 0 {\n   \
    \     return \"NO\"\n    }\n    for i := 2; i < length; i++ {\n        if length\
    \ % i == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n\
    }\n", "    return \"\"\n}\n", "    //your code here\n    return \"\"\n}\n", " \
    \   if interval1[0].(int) > interval2[1].(int) || interval2[0].(int) > interval1[1].(int)\
    \ {\n        return \"NO\"\n    }\n\n    var intersection_start, intersection_end\
    \ int\n    if interval1[0].(int) < interval2[0].(int) {\n        intersection_start\
    \ = interval2[0].(int)\n    } else {\n        intersection_start = interval1[0].(int)\n\
    \    }\n\n    if interval1[1].(int) < interval2[1].(int) {\n        intersection_end\
    \ = interval1[1].(int)\n    } else {\n        intersection_end = interval2[1].(int)\n\
    \    }\n\n    var length = intersection_end - intersection_start\n    if length\
    \ == 1 {\n        return \"NO\"\n    } else if length == 2 {\n        return \"\
    YES\"\n    }\n\n    for i := 3; i < length; i += 2 {\n        if length % i ==\
    \ 0 {\n            return \"NO\"\n        }\n    }\n\n    return \"YES\"\n}\n",
  "    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 :=\
    \ interval2[0].(int)\n    end2 := interval2[1].(int)\n    start := 0\n    end\
    \ := 0\n    if start1 > start2 {\n        start = start1\n    } else {\n     \
    \   start = start2\n    }\n    if end1 < end2 {\n        end = end1\n    } else\
    \ {\n        end = end2\n    }\n    if start > end {\n        return \"NO\"\n\
    \    }\n    len := end - start + 1\n    for i := 2; i < len; i++ {\n        if\
    \ len % i == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\
    \n}\n", "    // your code here\n    fmt.Println(interval1, interval2)\n    return\
    \ \"YES\"\n}\n", "    if interval1[0].(int) <= interval2[0].(int) {\n        if\
    \ interval1[1].(int) < interval2[0].(int) {\n            return \"NO\"\n     \
    \   }\n        if interval1[1].(int) > interval2[1].(int) {\n            return\
    \ isPrime(interval2[1].(int) - interval2[0].(int) + 1)\n        }\n        return\
    \ isPrime(interval1[1].(int) - interval2[0].(int) + 1)\n    } else {\n       \
    \ if interval2[1].(int) < interval1[0].(int) {\n            return \"NO\"\n  \
    \      }\n        if interval2[1].(int) > interval1[1].(int) {\n            return\
    \ isPrime(interval1[1].(int) - interval1[0].(int) + 1)\n        }\n        return\
    \ isPrime(interval2[1].(int) - interval1[0].(int) + 1)\n    }\n}\n", "    start1\
    \ := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n\
    \    end2 := interval2[1].(int)\n    start := Max(start1, start2)\n    end :=\
    \ Min(end1, end2)\n    if start > end {\n        return \"NO\"\n    }\n    for\
    \ i := start; i <= end; i++ {\n        if IsPrime(i) {\n            return \"\
    YES\"\n        }\n    }\n    return \"NO\"\n}\n", "    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    fmt.Println(start1, end1, start2, end2)\n    if start1\
    \ > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    if start1 <= start2\
    \ && end1 <= end2 {\n        return isPrime(start2 - end1)\n    }\n    if start1\
    \ >= start2 && end1 >= end2 {\n        return isPrime(end2 - start1)\n    }\n\
    \    if start1 >= start2 && end1 <= end2 {\n        return isPrime(end1 - start1)\n\
    \    }\n    if start1 <= start2 && end1 >= end2 {\n        return isPrime(end2\
    \ - start2)\n    }\n    return \"NO\"\n}\n", "    // your code here\n    return\
    \ \"\"\n}\n", "    return \"\"\n}\n", "    if len(interval1) != 2 || len(interval2)\
    \ != 2 {\n        return \"NO\"\n    }\n    var int1, int2 []int\n    for _, num\
    \ := range interval1 {\n        int1 = append(int1, num.(int))\n    }\n    for\
    \ _, num := range interval2 {\n        int2 = append(int2, num.(int))\n    }\n\
    \    if int1[0] > int1[1] || int2[0] > int2[1] {\n        return \"NO\"\n    }\n\
    \    if int1[0] > int2[1] || int2[0] > int1[1] {\n        return \"NO\"\n    }\n\
    \    if int1[0] == int1[1] && int2[0] == int2[1] {\n        if int1[0] == int2[0]\
    \ {\n            return \"YES\"\n        } else {\n            return \"NO\"\n\
    \        }\n    }\n    if int1[0] <= int2[0] {\n        if int1[1] >= int2[1]\
    \ {\n            return checkIntersection(int2[0], int2[1])\n        } else {\n\
    \            return checkIntersection(int2[0], int1[1])\n        }\n    } else\
    \ {\n        if int2[1] >= int1[1] {\n            return checkIntersection(int1[0],\
    \ int1[1])\n        } else {\n            return checkIntersection(int1[0], int2[1])\n\
    \        }\n    }\n}\n", "    a := interval1[0].(int)\n    b := interval1[1].(int)\n\
    \    c := interval2[0].(int)\n    d := interval2[1].(int)\n    if b < c || d <\
    \ a {\n        return \"NO\"\n    }\n    if d < b {\n        b = d\n    }\n  \
    \  if c < a {\n        a = c\n    }\n    length := b - a + 1\n    for i := 2;\
    \ i <= length / 2; i++ {\n        if length % i == 0 {\n            return \"\
    NO\"\n        }\n    }\n    return \"YES\"\n}\n", "    if len(interval1) != 2\
    \ || len(interval2) != 2 {\n        return \"NO\"\n    }\n    x := interval1[0].(int)\n\
    \    y := interval1[1].(int)\n    a := interval2[0].(int)\n    b := interval2[1].(int)\n\
    \    // fmt.Println(x, y, a, b)\n    // fmt.Println(max(x, a), min(y, b))\n  \
    \  if x > y || a > b {\n        return \"NO\"\n    }\n    c := max(x, a)\n   \
    \ d := min(y, b)\n    // fmt.Println(c, d)\n    // c := interval1[0].(int)\n \
    \   // d := interval1[1].(int)\n    if c > d {\n        return \"NO\"\n    }\n\
    \    if d - c < 2 {\n        return \"NO\"\n    }\n    for i := 2; i < d - c;\
    \ i++ {\n        if (d - c) % i == 0 {\n            return \"NO\"\n        }\n\
    \    }\n    return \"YES\"\n}\n", "    if (len(interval1) != 2 || len(interval2)\
    \ != 2) {\n        return \"NO\"\n    }\n    // convert data type\n    start1\
    \ := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n\
    \    end2 := interval2[1].(int)\n    // check intersection\n    if (start1 > end2\
    \ || start2 > end1) {\n        return \"NO\"\n    }\n    // find intersection\n\
    \    var start int\n    var end int\n    if (start1 < start2) {\n        start\
    \ = start2\n    } else {\n        start = start1\n    }\n    if (end1 < end2)\
    \ {\n        end = end1\n    } else {\n        end = end2\n    }\n    // check\
    \ prime\n    if isPrime(end - start) {\n        return \"YES\"\n    }\n    return\
    \ \"NO\"\n}\n", "    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if end1\
    \ < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    start := start1\n\
    \    if start < start2 {\n        start = start2\n    }\n    end := end1\n   \
    \ if end > end2 {\n        end = end2\n    }\n    length := end - start\n    if\
    \ length <= 0 {\n        return \"NO\"\n    }\n    fmt.Println(length)\n    if\
    \ length == 1 {\n        return \"NO\"\n    }\n    for i := 2; i <= length / 2;\
    \ i++ {\n        if length % i == 0 {\n            return \"NO\"\n        }\n\
    \    }\n    return \"YES\"\n}\n", "    if interval1[0].(int) > interval2[1].(int)\
    \ || interval2[0].(int) > interval1[1].(int) {\n        return \"NO\"\n    }\n\
    \n    int1Start := interval1[0].(int)\n    int1End := interval1[1].(int)\n   \
    \ int2Start := interval2[0].(int)\n    int2End := interval2[1].(int)\n\n    if\
    \ int1Start > int2Start {\n        int1Start = int2Start\n    }\n    if int1End\
    \ < int2End {\n        int1End = int2End\n    }\n\n    return intersection([]interface{}{int1Start,\
    \ int1End}, []interface{}{int2Start, int2End})\n}\n", "    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    if start1 <= start2 {\n        if end1 < start2 {\n\
    \            return \"NO\"\n        }\n        if end1 >= end2 {\n           \
    \ return judgeIsPrime(end2 - start2)\n        }\n        return judgeIsPrime(end1\
    \ - start2)\n    }\n    if start1 > end2 {\n        return \"NO\"\n    }\n   \
    \ if end1 >= end2 {\n        return judgeIsPrime(end2 - start1)\n    }\n    return\
    \ judgeIsPrime(end1 - start1)\n}\n", "    // your code goes here\n    a := interval1[0].(int)\n\
    \    b := interval1[1].(int)\n    c := interval2[0].(int)\n    d := interval2[1].(int)\n\
    \    if a > b {\n        a, b = b, a\n    }\n    if c > d {\n        c, d = d,\
    \ c\n    }\n    if a > d || b < c {\n        return \"NO\"\n    }\n    e := max(a,\
    \ c)\n    f := min(b, d)\n    g := f - e + 1\n    if g == 1 {\n        return\
    \ \"NO\"\n    }\n    for i := 2; i < g; i++ {\n        if g % i == 0 {\n     \
    \       return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n", "    return\
    \ \"\"\n}\n", "    t := func(x interface{}) int {\n        return x.(int)\n  \
    \  }\n    start1, end1 := t(interval1[0]), t(interval1[1])\n    start2, end2 :=\
    \ t(interval2[0]), t(interval2[1])\n    if start1 > end1 {\n        start1, end1\
    \ = end1, start1\n    }\n    if start2 > end2 {\n        start2, end2 = end2,\
    \ start2\n    }\n    start := max(start1, start2)\n    end := min(end1, end2)\n\
    \    if start >= end {\n        return \"NO\"\n    }\n    for i := 2; i < start;\
    \ i++ {\n        if end % i == 0 {\n            return \"NO\"\n        }\n   \
    \ }\n    return \"YES\"\n}\n", "    // find length of the intersection\n    //\
    \ check if prime\n    return \"NO\"\n}\n\ntype testingCase ", "    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    if start1 <= start2 {\n        if end1 <= start2 {\n\
    \            return \"NO\"\n        } else if end1 <= end2 {\n            return\
    \ isPrime(end1 - start2)\n        } else {\n            return isPrime(end2 -\
    \ start2)\n        }\n    } else {\n        if end2 <= start1 {\n            return\
    \ \"NO\"\n        } else if end2 <= end1 {\n            return isPrime(end2 -\
    \ start1)\n        } else {\n            return isPrime(end1 - start1)\n     \
    \   }\n    }\n}\n", "    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    length\
    \ := 0\n    // fmt.Println(start1, end1, start2, end2)\n    if start1 > end1 ||\
    \ start2 > end2 {\n        return \"NO\"\n    }\n    if end1 < start2 || end2\
    \ < start1 {\n        return \"NO\"\n    }\n    if start1 > start2 {\n       \
    \ if end1 > end2 {\n            length = end2 - start1 + 1\n        } else {\n\
    \            length = end1 - start1 + 1\n        }\n    } else {\n        if end1\
    \ > end2 {\n            length = end2 - start2 + 1\n        } else {\n       \
    \     length = end1 - start2 + 1\n        }\n    }\n    if length <= 1 {\n   \
    \     return \"NO\"\n    }\n    if length == 2 {\n        return \"YES\"\n   \
    \ }\n    for i := 2; i < length; i++ {\n        if length % i == 0 {\n       \
    \     return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n", "    start1 :=\
    \ interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n\
    \    end2 := interval2[1].(int)\n    // check if the two intervals intersect.\n\
    \    if start1 > end2 || start2 > end1 {\n        return \"NO\"\n    }\n    //\
    \ get the start and end of the intersection interval.\n    left := start1\n  \
    \  if start2 > start1 {\n        left = start2\n    }\n    right := end1\n   \
    \ if end2 < end1 {\n        right = end2\n    }\n    // check if the length of\
    \ the intersection is a prime number.\n    length := right - left + 1\n    var\
    \ isPrime bool = true\n    for i := 2; i < length; i++ {\n        if length %\
    \ i == 0 {\n            isPrime = false\n            break\n        }\n    }\n\
    \    if isPrime {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n", " \
    \   var (\n        start1, end1 = interval1[0].(int), interval1[1].(int)\n   \
    \     start2, end2 = interval2[0].(int), interval2[1].(int)\n        start, end\
    \ int\n    )\n    if start1 <= start2 {\n        start = start2\n    } else {\n\
    \        start = start1\n    }\n    if end1 <= end2 {\n        end = end1\n  \
    \  } else {\n        end = end2\n    }\n    if start > end {\n        return \"\
    NO\"\n    }\n    if start == end {\n        return \"YES\"\n    }\n    if start\
    \ == 1 {\n        return \"NO\"\n    }\n    if start == 2 {\n        return \"\
    YES\"\n    }\n    if start == 3 {\n        return \"YES\"\n    }\n    if start\
    \ % 2 == 0 {\n        return \"NO\"\n    }\n    if start % 3 == 0 {\n        return\
    \ \"NO\"\n    }\n    tmp := 5\n    if start % tmp == 0 {\n        return \"NO\"\
    \n    }\n    for tmp*tmp <= start {\n        if start % tmp == 0 {\n         \
    \   return \"NO\"\n        }\n        tmp += 2\n        if start % tmp == 0 {\n\
    \            return \"NO\"\n        }\n        tmp += 4\n    }\n    return \"\
    YES\"\n}\n", "    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if end1\
    \ < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    if end1 >= start2\
    \ && end1 <= end2 {\n        if end1 - start2 <= 1 {\n            return \"NO\"\
    \n        }\n        for i := 2; i < end1 - start2; i++ {\n            if (end1\
    \ - start2) % i == 0 {\n                return \"NO\"\n            }\n       \
    \ }\n        return \"YES\"\n    }\n    if end2 >= start1 && end2 <= end1 {\n\
    \        if end2 - start1 <= 1 {\n            return \"NO\"\n        }\n     \
    \   for i := 2; i < end2 - start1; i++ {\n            if (end2 - start1) % i ==\
    \ 0 {\n                return \"NO\"\n            }\n        }\n        return\
    \ \"YES\"\n    }\n    return \"NO\"\n}\n", "    return \"NO\"\n}\n", "    isPrime\
    \ := func(x int) bool {\n        if x <= 1 {\n            return false\n     \
    \   }\n        for i := 2; i * i <= x; i++ {\n            if x % i == 0 {\n  \
    \              return false\n            }\n        }\n        return true\n \
    \   }\n    if interval1[0].(int) > interval1[1].(int) {\n        interval1[0],\
    \ interval1[1] = interval1[1], interval1[0]\n    }\n    if interval2[0].(int)\
    \ > interval2[1].(int) {\n        interval2[0], interval2[1] = interval2[1], interval2[0]\n\
    \    }\n    if interval1[1].(int) < interval2[0].(int) || interval2[1].(int) <\
    \ interval1[0].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int)\
    \ <= interval2[0].(int) {\n        if interval1[1].(int) >= interval2[1].(int)\
    \ {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n   \
    \ if interval1[1].(int) >= interval2[1].(int) {\n        return \"YES\"\n    }\n\
    \    return \"NO\"\n}\n", "    var overlap = overlapLength(interval1, interval2)\n\
    \    return isPrime(overlap)\n}\n", "    start1 := interval1[0].(int)\n    end1\
    \ := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n\
    \    fmt.Println(start1, end1, start2, end2)\n    // the end is not included in\
    \ the interval so calculate with end + 1\n    length1 := end1 - start1 + 1\n \
    \   length2 := end2 - start2 + 1\n    max := length1\n    if length2 > length1\
    \ {\n        max = length2\n    }\n    for i := 1; i <= max; i++ {\n        if\
    \ (start1 + i) >= start2 && (start1 + i) <= end2 {\n            if isPrime(i)\
    \ {\n                return \"YES\"\n            }\n        }\n    }\n    return\
    \ \"NO\"\n}\n", "    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    if start == end {\n        return \"YES\"\n    }\n\
    \    for i := 2; i < end; i++ {\n        if (end - start) % i == 0 {\n       \
    \     return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n", "    return \"\
    NO\"\n}\n", "    fmt.Println(interval1, interval2)\n    if (interval1[0].(int)\
    \ >= interval2[1].(int)) ||\n        (interval2[0].(int) >= interval1[1].(int))\
    \ {\n        return \"NO\"\n    }\n    start := interval1[0].(int)\n    if interval2[0].(int)\
    \ > start {\n        start = interval2[0].(int)\n    }\n    end := interval1[1].(int)\n\
    \    if interval2[1].(int) < end {\n        end = interval2[1].(int)\n    }\n\
    \    length := end - start + 1\n    if isPrime(length) {\n        return \"YES\"\
    \n    }\n    return \"NO\"\n}\n", "    var start1 int = interval1[0].(int)\n \
    \   var end1 int = interval1[1].(int)\n    var start2 int = interval2[0].(int)\n\
    \    var end2 int = interval2[1].(int)\n    var start, end int\n    var isIntersecting\
    \ bool\n    if start1 <= start2 {\n        start = start2\n        if end1 < start2\
    \ {\n            isIntersecting = false\n        } else {\n            isIntersecting\
    \ = true\n        }\n    } else {\n        start = start1\n        if end2 < start1\
    \ {\n            isIntersecting = false\n        } else {\n            isIntersecting\
    \ = true\n        }\n    }\n    if isIntersecting {\n        if end1 <= end2 {\n\
    \            end = end1\n        } else {\n            end = end2\n        }\n\
    \        if end - start <= 1 {\n            return \"NO\"\n        }\n       \
    \ if end - start <= 3 {\n            return \"YES\"\n        }\n        if end\
    \ - start % 2 == 0 {\n            return \"NO\"\n        }\n        for i := 3;\
    \ i * i <= end - start; i += 2 {\n            if (end - start) % i == 0 {\n  \
    \              return \"NO\"\n            }\n        }\n        return \"YES\"\
    \n    }\n    return \"NO\"\n}\n", "    // your code here\n    return \"\"\n}\n",
  "    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 :=\
    \ interval2[0].(int)\n    end2 := interval2[1].(int)\n    fmt.Println(start1,\
    \ end1, start2, end2)\n    if end1 < start2 || end2 < start1 {\n        return\
    \ \"NO\"\n    }\n\n    start := start1\n    if start1 < start2 {\n        start\
    \ = start2\n    }\n    end := end1\n    if end1 > end2 {\n        end = end2\n\
    \    }\n    fmt.Println(start, end)\n    length := end - start + 1\n    if length\
    \ <= 1 {\n        return \"NO\"\n    }\n    for i := 2; i < length; i++ {\n  \
    \      if length % i == 0 {\n            return \"NO\"\n        }\n    }\n   \
    \ return \"YES\"\n}\n", "    // in the form [start, end]\n    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    if end1 < start2 || end2 < start1 {\n        return\
    \ \"NO\"\n    }\n    if start1 < start2 {\n        start1 = start2\n    }\n  \
    \  if end1 > end2 {\n        end1 = end2\n    }\n    if end1 - start1 == 1 {\n\
    \        return \"YES\"\n    }\n    for i := 2; i < end1 - start1; i++ {\n   \
    \     if (end1 - start1) % i == 0 {\n            return \"NO\"\n        }\n  \
    \  }\n    return \"YES\"\n}\n", "    a := interval1[0].(int)\n    b := interval1[1].(int)\n\
    \    c := interval2[0].(int)\n    d := interval2[1].(int)\n    if b < c || d <\
    \ a {\n        return \"NO\"\n    }\n    if a < c {\n        a = c\n    }\n  \
    \  if b > d {\n        b = d\n    }\n    r := b - a + 1\n    for i := 2; i * i\
    \ <= r; i++ {\n        if r % i == 0 {\n            return \"NO\"\n        }\n\
    \    }\n    return \"YES\"\n}\n", "    return \"NO\"\n}\n", "    // Code here\n\
    \    return \"\"\n}\n", "    v1 := interval1[0].(int)\n    v2 := interval1[1].(int)\n\
    \    if v1 > v2 {\n        v1, v2 = v2, v1\n    }\n    v3 := interval2[0].(int)\n\
    \    v4 := interval2[1].(int)\n    if v3 > v4 {\n        v3, v4 = v4, v3\n   \
    \ }\n    var v5, v6 int\n    if v1 < v3 {\n        v5 = v3\n    } else {\n   \
    \     v5 = v1\n    }\n    if v2 < v4 {\n        v6 = v2\n    } else {\n      \
    \  v6 = v4\n    }\n    v7 := v6 - v5 + 1\n    if v7 <= 0 {\n        return \"\
    NO\"\n    }\n    var count int\n    for i := 2; i < v7; i++ {\n        if v7 %\
    \ i == 0 {\n            count++\n        }\n    }\n    if count > 0 {\n      \
    \  return \"NO\"\n    }\n    return \"YES\"\n}\n", "    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    if start1 > end1 {\n        start1, end1 = end1, start1\n\
    \    }\n    if start2 > end2 {\n        start2, end2 = end2, start2\n    }\n \
    \   if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    start\
    \ := start1\n    if start2 > start1 {\n        start = start2\n    }\n    end\
    \ := end1\n    if end2 < end1 {\n        end = end2\n    }\n    if start == end\
    \ {\n        return \"YES\"\n    }\n    length := end - start + 1\n    // For\
    \ each given interval, it is assumed that its start is less or equal its end.\n\
    \    if length == 2 {\n        return \"NO\"\n    }\n    for i := 2; i < length;\
    \ i++ {\n        if length % i == 0 {\n            return \"NO\"\n        }\n\
    \    }\n    return \"YES\"\n}\n", "    // TODO\n    return \"\"\n}\n", "    var\
    \ s1 int = interval1[0].(int)\n    var e1 int = interval1[1].(int)\n    var s2\
    \ int = interval2[0].(int)\n    var e2 int = interval2[1].(int)\n    var s, e\
    \ int\n    var d int\n    var n bool\n    // for s1, s2, e1, e2 < 0\n    if (s1\
    \ <= 0 && s2 <= 0 && e1 <= 0 && e2 <= 0) {\n        s = max(s1, s2)\n        e\
    \ = min(e1, e2)\n        d = e - s\n        n = isPrime(d)\n        return fmt.Sprintf(\"\
    %v\", n)\n    }\n    // for s1, s2, e1, e2 > 0\n    if (s1 >= 0 && s2 >= 0 &&\
    \ e1 >= 0 && e2 >= 0) {\n        s = max(s1, s2)\n        e = min(e1, e2)\n  \
    \      d = e - s\n        n = isPrime(d)\n        return fmt.Sprintf(\"%v\", n)\n\
    \    }\n    // for s1, s2 > 0, e1, e2 < 0\n    if (s1 >= 0 && s2 >= 0 && e1 <=\
    \ 0 && e2 <= 0) {\n        s = min(s1, s2)\n        e = max(e1, e2)\n        d\
    \ = e - s\n        n = isPrime(d)\n        return fmt.Sprintf(\"%v\", n)\n   \
    \ }\n    // for s1, s2 < 0, e1, e2 > 0\n    if (s1 <= 0 && s2 <= 0 && e1 >= 0\
    \ && e2 >= 0) {\n        s = min(s1, s2)\n        e = max(e1, e2)\n        d =\
    \ e - s\n        n = isPrime(d)\n        return fmt.Sprintf(\"%v\", n)\n    }\n\
    \    // for s1, s2 > 0, e1, e2 > 0, 0 < s1 <= s2\n    if (s1 >= 0 && s2 >=", " \
    \   if interval1[0].(int) > interval2[1].(int) || interval2[0].(int) > interval1[1].(int)\
    \ {\n        return \"NO\"\n    }\n    if interval1[0].(int) > interval2[0].(int)\
    \ {\n        interval1, interval2 = interval2, interval1\n    }\n    intersec\
    \ := interval2[0].(int) - interval1[1].(int)\n    switch intersec {\n    case\
    \ 0:\n        return \"NO\"\n    case 1:\n        return \"YES\"\n    default:\n\
    \        for i := 2; i < intersec; i++ {\n            if intersec % i == 0 {\n\
    \                return \"NO\"\n            }\n        }\n        return \"YES\"\
    \n    }\n}\n", "    s1 := interval1[0].(int)\n    e1 := interval1[1].(int)\n \
    \   s2 := interval2[0].(int)\n    e2 := interval2[1].(int)\n    if s1 > e1 {\n\
    \        s1, e1 = e1, s1\n    }\n    if s2 > e2 {\n        s2, e2 = e2, s2\n \
    \   }\n    if s1 > e2 || s2 > e1 {\n        return \"NO\"\n    }\n    i1 := s1\n\
    \    i2 := s2\n    if s2 < s1 {\n        i1 = s2\n    }\n    if s1 < s2 {\n  \
    \      i2 = s1\n    }\n    if e1 < e2 {\n        i1 = e1\n    }\n    if e2 < e1\
    \ {\n        i2 = e2\n    }\n    //fmt.Println(i1, i2)\n    for i:=i1; i<=i2;\
    \ i++ {\n        if i == 1 {\n            continue\n        }\n        flag :=\
    \ false\n        for j:=2; j<i; j++ {\n            if i % j == 0 {\n         \
    \       flag = true\n                break\n            }\n        }\n       \
    \ if !flag {\n            return \"YES\"\n        }\n    }\n    return \"NO\"\n\
    }\n", "    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2\
    \ := interval2[0].(int)\n    end2 := interval2[1].(int)\n    minStart := min(start1,\
    \ start2)\n    maxEnd := max(end1, end2)\n    if minStart > maxEnd {\n       \
    \ return \"NO\"\n    }\n    start, end := max(start1, start2), min(end1, end2)\n\
    \    if isPrime(end - start + 1) {\n        return \"YES\"\n    }\n    return\
    \ \"NO\"\n}\n", "    var result string = \"NO\"\n    var start, end int\n    var\
    \ length int\n    if len(interval1) == 2 && len(interval2) == 2 {\n        start\
    \ = max(interval1[0].(int), interval2[0].(int))\n        end = min(interval1[1].(int),\
    \ interval2[1].(int))\n        if end >= start {\n            length = end - start\
    \ + 1\n            if isPrime(length) {\n                result = \"YES\"\n  \
    \          }\n        }\n    }\n    return result\n}\n", "    return \"NO\"\n\
    }\n", "    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2\
    \ := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1 > end1\
    \ {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n    \
    \    start2, end2 = end2, start2\n    }\n    minStart := min(start1, start2)\n\
    \    maxEnd := max(end1, end2)\n    if start1 <= start2 && end1 >= start2 {\n\
    \        if start1 <= end2 && end1 >= end2 {\n            return \"YES\"\n   \
    \     } else {\n            return \"NO\"\n        }\n    } else if start2 <=\
    \ start1 && end2 >= start1 {\n        if start2 <= end1 && end2 >= end1 {\n  \
    \          return \"YES\"\n        } else {\n            return \"NO\"\n     \
    \   }\n    } else {\n        return \"NO\"\n    }\n}\n", "    var start, end int\n\
    \    var i1, i2 = interval1[0].(int), interval2[0].(int)\n    var j1, j2 = interval1[1].(int),\
    \ interval2[1].(int)\n    if i1 > i2 {\n        start = i1\n    } else {\n   \
    \     start = i2\n    }\n    if j1 < j2 {\n        end = j1\n    } else {\n  \
    \      end = j2\n    }\n    if start > end {\n        return \"NO\"\n    }\n \
    \   if isPrime(end - start + 1) {\n        return \"YES\"\n    }\n    return \"\
    NO\"\n}\n", "    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n    if interval1[0].(int)\
    \ < interval2[0].(int) {\n        return isPrime(interval2[0].(int) - interval1[1].(int))\n\
    \    }\n    return isPrime(interval1[0].(int) - interval2[1].(int))\n}\n", " \
    \   if interval1[0].(int) > interval2[1].(int) || interval2[0].(int) > interval1[1].(int)\
    \ {\n        return \"NO\"\n    }\n\n    if isPrime(interval1[1].(int) - interval2[0].(int))\
    \ {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n", "    // your code\
    \ here\n    return \"\"\n}\n", "    fmt.Println(interval1, interval2)\n    int1\
    \ := interval1[0].(int)\n    int2 := interval1[1].(int)\n    int3 := interval2[0].(int)\n\
    \    int4 := interval2[1].(int)\n    if int2 < int3 || int1 > int4 {\n       \
    \ return \"NO\"\n    }\n    start := int1\n    if int3 > int1 {\n        start\
    \ = int3\n    }\n    end := int2\n    if int4 < int2 {\n        end = int4\n \
    \   }\n    length := end - start\n    if length == 0 {\n        return \"NO\"\n\
    \    }\n    for i := 2; i < length; i++ {\n        if length % i == 0 {\n    \
    \        return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n", "    if len(interval1)\
    \ == 0 || len(interval2) == 0 {\n        return \"NO\"\n    }\n    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    l1 := end1 - start1\n    l2 := end2 - start2\n    if\
    \ start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    if start1\
    \ < start2 {\n        start1, start2 = start2, start1\n        end1, end2 = end2,\
    \ end1\n        l1, l2 = l2, l1\n    }\n    if start1 > end2 {\n        return\
    \ \"NO\"\n    }\n    if end1 <= end2 {\n        l1 = end1 - start2\n    }\n  \
    \  if isPrime(l1) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n", " \
    \   return \"\"\n}\n", "    return \"\"\n}\n", "    if interval1[0].(int) > interval2[1].(int)\
    \ || interval2[0].(int) > interval1[1].(int) {\n        return \"NO\"\n    }\n\
    \n    if isPrime(int(interval1[1].(int) - interval2[0].(int))) {\n        return\
    \ \"YES\"\n    }\n\n    return \"NO\"\n}\n", "    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    if end1 < start2 || end2 < start1 {\n        return\
    \ \"NO\"\n    }\n    start := start1\n    if start2 > start1 {\n        start\
    \ = start2\n    }\n    end := end1\n    if end2 < end1 {\n        end = end2\n\
    \    }\n    if isPrime(end - start) {\n        return \"YES\"\n    }\n    return\
    \ \"NO\"\n}\n", "    return \"\"\n}\n", "    a, b := interval1[0].(int), interval1[1].(int)\n\
    \    c, d := interval2[0].(int), interval2[1].(int)\n    // if (b < c) || (d <\
    \ a) {\n    //     return \"NO\"\n    // }\n    start := max(a, c)\n    end :=\
    \ min(b, d)\n    if start > end {\n        return \"NO\"\n    }\n    if end -\
    \ start == 1 {\n        return \"YES\"\n    }\n    for i := 2; i < end; i++ {\n\
    \        if (end - start) % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    return \"YES\"\n}\n", "    primeMap := map[int]bool{\n        2: true,\n\
    \        3: true,\n        5: true,\n        7: true,\n        11: true,\n   \
    \     13: true,\n        17: true,\n        19: true,\n        23: true,\n   \
    \     29: true,\n        31: true,\n        37: true,\n        41: true,\n   \
    \     43: true,\n        47: true,\n        53: true,\n        59: true,\n   \
    \     61: true,\n        67: true,\n        71: true,\n        73: true,\n   \
    \     79: true,\n        83: true,\n        89: true,\n        97: true,\n   \
    \ }\n    var start, end int\n    if interval1[0].(int) <= interval2[0].(int) {\n\
    \        start = interval2[0].(int)\n    } else {\n        start = interval1[0].(int)\n\
    \    }\n    if interval1[1].(int) >= interval2[1].(int) {\n        end = interval2[1].(int)\n\
    \    } else {\n        end = interval1[1].(int)\n    }\n    if _, ok := primeMap[end\
    \ - start + 1]; ok {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n",
  "    if (len(interval1) != 2 || len(interval2) != 2) {\n        return \"NO\"\n\
    \    }\n    a1, a2 := interval1[0].(int), interval1[1].(int)\n    b1, b2 := interval2[0].(int),\
    \ interval2[1].(int)\n    if a1 > a2 || b1 > b2 {\n        return \"NO\"\n   \
    \ }\n    if (a1 <= b1 && b1 <= a2 && a2 <= b2) {\n        return PrimeOrNot(a2\
    \ - b1 + 1)\n    }\n    if (b1 <= a1 && a1 <= b2 && b2 <= a2) {\n        return\
    \ PrimeOrNot(b2 - a1 + 1)\n    }\n    if (a1 <= b1 && b1 <= b2 && b2 <= a2) {\n\
    \        return PrimeOrNot(b2 - b1 + 1)\n    }\n    if (b1 <= a1 && a1 <= a2 &&\
    \ a2 <= b2) {\n        return PrimeOrNot(a2 - a1 + 1)\n    }\n    return \"NO\"\
    \n}\n", "    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int)\
    \ > interval1[1].(int) {\n        return \"NO\"\n    }\n\n    if interval1[0].(int)\
    \ > interval2[0].(int) {\n        return isPrime(interval1[0].(int) - interval2[1].(int))\n\
    \    } else {\n        return isPrime(interval2[0].(int) - interval1[1].(int))\n\
    \    }\n}\n", "    // Happy coding!\n    return \"\"\n}\n", "    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    if start1 >= end2 || start2 >= end1 {\n        return\
    \ \"NO\"\n    }\n\n    start := start1\n    if start2 > start1 {\n        start\
    \ = start2\n    }\n    end := end1\n    if end2 < end1 {\n        end = end2\n\
    \    }\n    if start == end {\n        return \"YES\"\n    }\n    if start+1 ==\
    \ end {\n        return \"NO\"\n    }\n    for i := start+1; i < end; i++ {\n\
    \        for j := 2; j < i; j++ {\n            if i % j == 0 {\n             \
    \   return \"NO\"\n            }\n        }\n    }\n    return \"YES\"\n}\n",
  "    a, b := interval1[0].(int), interval1[1].(int)\n    c, d := interval2[0].(int),\
    \ interval2[1].(int)\n    if b < c || d < a {\n        return \"NO\"\n    }\n\
    \    start, end := max(a, c), min(b, d)\n    length := end - start + 1\n    if\
    \ length <= 1 {\n        return \"NO\"\n    }\n    if length == 2 {\n        return\
    \ \"YES\"\n    }\n    if length % 2 == 0 {\n        return \"NO\"\n    }\n   \
    \ for i := 3; i * i <= length; i += 2 {\n        if length % i == 0 {\n      \
    \      return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n", "    i1 := interval1[0].(int)\n\
    \    i2 := interval1[1].(int)\n    j1 := interval2[0].(int)\n    j2 := interval2[1].(int)\n\
    \    switch {\n    case i1 > j2 || j1 > i2:\n        return \"NO\"\n    case i1\
    \ < j1:\n        return isPrime(j1 - i2)\n    default:\n        return isPrime(j2\
    \ - i1)\n    }\n}\n", "    int1 := []int{interval1[0].(int), interval1[1].(int)}\n\
    \    int2 := []int{interval2[0].(int), interval2[1].(int)}\n    min, max := int1[0],\
    \ int1[1]\n    if min > int2[0] {\n        min = int2[0]\n    }\n    if max <\
    \ int2[1] {\n        max = int2[1]\n    }\n    if min > max {\n        return\
    \ \"NO\"\n    }\n    if max - min < 2 {\n        return \"YES\"\n    }\n    if\
    \ max - min < 4 {\n        return \"NO\"\n    }\n    if max - min < 6 {\n    \
    \    return \"YES\"\n    }\n    if max - min < 9 {\n        return \"NO\"\n  \
    \  }\n    for i := 7; i <= max - min; i += 2 {\n        if (max - min) % i ==\
    \ 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n",
  "    // set interval1 as first interval\n    if interval1[0].(int) > interval2[0].(int)\
    \ {\n        interval1, interval2 = interval2, interval1\n    }\n    if interval1[1].(int)\
    \ < interval2[0].(int) {\n        return \"NO\"\n    }\n    start := interval2[0].(int)\n\
    \    if interval1[0].(int) > start {\n        start = interval1[0].(int)\n   \
    \ }\n    end := interval2[1].(int)\n    if interval1[1].(int) < end {\n      \
    \  end = interval1[1].(int)\n    }\n    if start == end {\n        return \"NO\"\
    \n    }\n    if end - start == 1 {\n        return \"YES\"\n    }\n    for i :=\
    \ 2; i < end - start; i++ {\n        if (end - start) % i == 0 {\n           \
    \ return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n", "    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    if end1 < start2 || end2 < start1 {\n        return\
    \ \"NO\"\n    }\n    intersectionStart := start1\n    if start2 > start1 {\n \
    \       intersectionStart = start2\n    }\n    intersectionEnd := end1\n    if\
    \ end2 < end1 {\n        intersectionEnd = end2\n    }\n    length := intersectionEnd\
    \ - intersectionStart\n    if length == 0 {\n        return \"NO\"\n    }\n  \
    \  if length == 1 {\n        return \"YES\"\n    }\n    if length % 2 == 0 {\n\
    \        return \"NO\"\n    }\n    for i := 3; i * i <= length; i += 2 {\n   \
    \     if length % i == 0 {\n            return \"NO\"\n        }\n    }\n    return\
    \ \"YES\"\n}\n", "    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n\
    \    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    intersects := false\n    if start1\
    \ < start2 {\n        if end1 >= start2 {\n            intersects = true\n   \
    \     }\n    } else {\n        if end2 >= start1 {\n            intersects = true\n\
    \        }\n    }\n    if !intersects {\n        return \"NO\"\n    }\n    if\
    \ end1 < start2 {\n        end1 = start2\n    }\n    if end2 < start1 {\n    \
    \    end2 = start1\n    }\n    l := end1 - start1 + 1\n    if l == 1 {\n     \
    \   return \"NO\"\n    }\n    for i := 2; i <= l / 2; i++ {\n        if l % i\
    \ == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n",
  "    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 :=\
    \ interval2[0].(int)\n    end2 := interval2[1].(int)\n    max := func(a, b int)\
    \ int {\n        if a > b {\n            return a\n        }\n        return b\n\
    \    }\n    min := func(a, b int) int {\n        if a < b {\n            return\
    \ a\n        }\n        return b\n    }\n    if max(start1, start2) > min(end1,\
    \ end2) {\n        return \"NO\"\n    }\n    left := max(start1, start2)\n   \
    \ right := min(end1, end2)\n    length := right - left + 1\n    prime := true\n\
    \    for i := 2; i < length; i++ {\n        if length % i == 0 {\n           \
    \ prime = false\n            break\n        }\n    }\n    if prime {\n       \
    \ return \"YES\"\n    }\n    return \"NO\"\n}\n", "    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    a := min(end1, end2)\n    b := max(start1, start2)\n\
    \    if a < b {\n        return \"NO\"\n    }\n    len := a - b + 1\n    for i\
    \ := 2; i * i <= len; i++ {\n        if len % i == 0 {\n            return \"\
    NO\"\n        }\n    }\n    return \"YES\"\n}\n", "    // your code here\n   \
    \ return \"\"\n}\n", "    length := 0\n    start := interval1[0].(int)\n    end\
    \ := interval1[1].(int)\n    for i := interval2[0].(int); i <= interval2[1].(int);\
    \ i++ {\n        if start <= i && i <= end {\n            length++\n        }\n\
    \    }\n    if length == 0 {\n        return \"NO\"\n    }\n    for i := 2; i\
    \ < length; i++ {\n        if length % i == 0 {\n            return \"NO\"\n \
    \       }\n    }\n    return \"YES\"\n}\n", "    if len(interval1) != 2 || len(interval2)\
    \ != 2 {\n        return \"Invalid input\"\n    }\n    if interval1[0] == interval1[1]\
    \ || interval2[0] == interval2[1] {\n        return \"Invalid input\"\n    }\n\
    \    if interval1[0].(int) > interval1[1].(int) {\n        interval1[0], interval1[1]\
    \ = interval1[1], interval1[0]\n    }\n    if interval2[0].(int) > interval2[1].(int)\
    \ {\n        interval2[0], interval2[1] = interval2[1], interval2[0]\n    }\n\
    \    a := interval1[0].(int)\n    b := interval1[1].(int)\n    c := interval2[0].(int)\n\
    \    d := interval2[1].(int)\n    if a > d || b < c {\n        return \"NO\"\n\
    \    }\n    e := a\n    f := b\n    if c > e {\n        e = c\n    }\n    if d\
    \ < f {\n        f = d\n    }\n    k := f - e\n    if k == 0 {\n        return\
    \ \"NO\"\n    }\n    var i int\n    flag := true\n    for i = 2; i < k; i++ {\n\
    \        if k % i == 0 {\n            flag = false\n            break\n      \
    \  }\n    }\n    if flag {\n        return \"YES\"\n    }\n    return \"NO\"\n\
    }\n", "    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int) >\
    \ interval1[1].(int) {\n        return \"NO\"\n    }\n\n    interval := []int{}\n\
    \    if interval1[0].(int) < interval2[0].(int) {\n        interval = []int{interval2[0].(int),\
    \ interval1[1].(int)}\n    } else {\n        interval = []int{interval1[0].(int),\
    \ interval2[1].(int)}\n    }\n\n    for i := 2; i < interval[1] - interval[0];\
    \ i++ {\n        if (interval[1] - interval[0]) % i == 0 {\n            return\
    \ \"NO\"\n        }\n    }\n\n    return \"YES\"\n}\n", "    if interval1[0].(int)\
    \ > interval2[1].(int) || interval2[0].(int) > interval1[1].(int) {\n        return\
    \ \"NO\"\n    }\n    if isPrime(int(interval1[1].(int) - interval2[0].(int)))\
    \ {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n", "    first := interval1[0].(int)\n\
    \    second := interval1[1].(int)\n    first1 := interval2[0].(int)\n    second1\
    \ := interval2[1].(int)\n    start := 0\n    end := 0\n    if first <= first1\
    \ {\n        start = first1\n    } else {\n        start = first\n    }\n    if\
    \ second <= second1 {\n        end = second\n    } else {\n        end = second1\n\
    \    }\n    for i := start; i <= end; i++ {\n        if start != end {\n     \
    \       return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n", "    fmt.Println(interval1,\
    \ interval2)\n    return \"NO\"\n}\n", "    start1 := interval1[0].(int)\n   \
    \ end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n\
    \    if end1 < start2 || end2 < start1 {\n        return \"NO\"\n    }\n    if\
    \ start1 <= start2 {\n        if end1 >= end2 {\n            start1 = start2\n\
    \            end1 = end2\n        } else {\n            start1 = start2\n    \
    \    }\n    } else {\n        if end1 >= end2 {\n            end1 = end2\n   \
    \     }\n    }\n    return isPrime(end1 - start1 + 1)\n}\n", "    fmt.Println(interval1)\n\
    \    fmt.Println(interval2)\n    return \"NO\"\n}\n", "    return \"NO\"\n}\n",
  "    if interval1[0].(int) > interval2[1].(int) || interval2[0].(int) > interval1[1].(int)\
    \ {\n        return \"NO\"\n    }\n    a := interval1[0].(int)\n    b := interval1[1].(int)\n\
    \    c := interval2[0].(int)\n    d := interval2[1].(int)\n    if c > a {\n  \
    \      a = c\n    }\n    if d < b {\n        b = d\n    }\n    if a == b {\n \
    \       return \"YES\"\n    }\n    if a + 1 == b {\n        return \"NO\"\n  \
    \  }\n    for i := 2; i <= a; i++ {\n        if a % i == 0 && b % i == 0 {\n \
    \           return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n", "    start1\
    \ := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n\
    \    end2 := interval2[1].(int)\n    s, e := max(start1, start2), min(end1, end2)\n\
    \    if s >= e {\n        return \"NO\"\n    }\n    if isPrime(e - s) {\n    \
    \    return \"YES\"\n    }\n    return \"NO\"\n}\n", "    // this is really not\
    \ a go solution to the challenge, because of interface{}\n    // a better solution\
    \ would be to create a proper data ", "    // your code here\n    var start, end\
    \ int\n    var i1, i2 []int\n    if interval1[0].(int) <= interval2[0].(int) {\n\
    \        start = interval2[0].(int)\n        i1 = interval1\n        i2 = interval2\n\
    \    } else {\n        start = interval1[0].(int)\n        i1 = interval2\n  \
    \      i2 = interval1\n    }\n    if i1[1].(int) < i2[0].(int) {\n        return\
    \ \"NO\"\n    }\n    if i1[1].(int) < i2[1].(int) {\n        end = i1[1].(int)\n\
    \    } else {\n        end = i2[1].(int)\n    }\n    if end <= start {\n     \
    \   return \"NO\"\n    }\n    if end - start == 1 {\n        return \"YES\"\n\
    \    }\n    for i := start + 1; i < end; i++ {\n        for j := 2; j < i; j++\
    \ {\n            if i % j == 0 {\n                return \"NO\"\n            }\n\
    \        }\n    }\n    return \"YES\"\n}\n", "    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    if start1 <= start2 {\n        if end1 < start2 {\n\
    \            return \"NO\"\n        }\n        if end1 < end2 {\n            if\
    \ isPrime(end1 - start2 + 1) {\n                return \"YES\"\n            }\n\
    \            return \"NO\"\n        }\n        if isPrime(end2 - start2 + 1) {\n\
    \            return \"YES\"\n        }\n        return \"NO\"\n    }\n    if end2\
    \ < start1 {\n        return \"NO\"\n    }\n    if end2 < end1 {\n        if isPrime(end2\
    \ - start1 + 1) {\n            return \"YES\"\n        }\n        return \"NO\"\
    \n    }\n    if isPrime(end1 - start1 + 1) {\n        return \"YES\"\n    }\n\
    \    return \"NO\"\n}\n", "    // TODO: test if the intervals are valid\n    //\
    \ if empty\n    // if not valid\n    start1 := interval1[0].(int)\n    end1 :=\
    \ interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n\
    \    if start1 > end1 || start2 > end2 {\n        return \"NO\"\n    }\n    if\
    \ start1 > end2 || start2 > end1 {\n        return \"NO\"\n    }\n    // find\
    \ the interval that starts first\n    if start1 < start2 {\n        if end1 <\
    \ start2 {\n            return \"NO\"\n        }\n        return isPrime(start2\
    \ - end1)\n    }\n    if end2 < start1 {\n        return \"NO\"\n    }\n    return\
    \ isPrime(start1 - end2)\n}\n", "    // your code here\n    return \"\"\n}\n",
  "    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n    start2 :=\
    \ interval2[0].(int)\n    end2 := interval2[1].(int)\n    iStart := max(start1,\
    \ start2)\n    iEnd := min(end1, end2)\n    if iStart > iEnd {\n        return\
    \ \"NO\"\n    }\n    if isPrime(iEnd - iStart + 1) {\n        return \"YES\"\n\
    \    }\n    return \"NO\"\n}\n", "    first_begin := interval1[0].(int)\n    first_end\
    \ := interval1[1].(int)\n    second_begin := interval2[0].(int)\n    second_end\
    \ := interval2[1].(int)\n    if first_begin > first_end {\n        return \"NO\"\
    \n    }\n    if second_begin > second_end {\n        return \"NO\"\n    }\n  \
    \  if first_begin > second_end || second_begin > first_end {\n        return \"\
    NO\"\n    }\n    begin := first_begin\n    if begin < second_begin {\n       \
    \ begin = second_begin\n    }\n    end := first_end\n    if end > second_end {\n\
    \        end = second_end\n    }\n    if begin > end {\n        return \"NO\"\n\
    \    }\n    if end - begin == 0 {\n        return \"YES\"\n    }\n    if end -\
    \ begin == 1 {\n        return \"NO\"\n    }\n    for i := 2; i < end; i++ {\n\
    \        if (end - begin) % i == 0 {\n            return \"NO\"\n        }\n \
    \   }\n    return \"YES\"\n}\n", "    start := interval1[0].(int)\n    end :=\
    \ interval1[1].(int)\n    interval := interval2[0].(int)\n    if interval < start\
    \ {\n        start = interval\n    }\n    interval = interval2[1].(int)\n    if\
    \ interval > end {\n        end = interval\n    }\n    if start < end {\n    \
    \    if (end - start) == 1 {\n            return \"YES\"\n        }\n        return\
    \ \"NO\"\n    }\n    return \"NO\"\n}\n", "    v1, v2 := interval1[0].(int), interval1[1].(int)\n\
    \    w1, w2 := interval2[0].(int), interval2[1].(int)\n    if v1 > v2 {\n    \
    \    v1, v2 = v2, v1\n    }\n    if w1 > w2 {\n        w1, w2 = w2, w1\n    }\n\
    \    var x, y int\n    if v1 > w1 {\n        x = v1\n    } else {\n        x =\
    \ w1\n    }\n    if v2 < w2 {\n        y = v2\n    } else {\n        y = w2\n\
    \    }\n    if x > y {\n        return \"NO\"\n    }\n    if y == 1 {\n      \
    \  return \"YES\"\n    }\n    if y == 2 {\n        return \"NO\"\n    }\n    if\
    \ y == 3 {\n        return \"YES\"\n    }\n    if y % 2 == 0 {\n        return\
    \ \"NO\"\n    }\n    for i := 3; i * i <= y; i = i + 2 {\n        if y % i ==\
    \ 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n",
  "    // Write your code here\n    return \"\"\n}\n", "    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    if end1 < start2 || end2 < start1 {\n        return\
    \ \"NO\"\n    }\n    max := start1\n    if start2 > max {\n        max = start2\n\
    \    }\n    min := end1\n    if end2 < min {\n        min = end2\n    }\n    len\
    \ := min - max\n    if len == 0 {\n        return \"NO\"\n    }\n    if len ==\
    \ 1 {\n        return \"YES\"\n    }\n    for i := 2; i < len; i++ {\n       \
    \ if len % i == 0 {\n            return \"NO\"\n        }\n    }\n    return \"\
    YES\"\n}\n", "    // TODO: Implement the solution\n    return \"\"\n}\n", "  \
    \  var start = interval1[0].(int)\n    var end = interval1[1].(int)\n    var i1\
    \ = []int{start, end}\n    start = interval2[0].(int)\n    end = interval2[1].(int)\n\
    \    var i2 = []int{start, end}\n    if i1[0] > i2[1] || i2[0] > i1[1] {\n   \
    \     return \"NO\"\n    }\n    start = max(i1[0], i2[0])\n    end = min(i1[1],\
    \ i2[1])\n    var isPrime = true\n    for i := 2; i <= end / 2; i++ {\n      \
    \  if end % i == 0 {\n            isPrime = false\n            break\n       \
    \ }\n    }\n    if isPrime {\n        return \"YES\"\n    }\n    return \"NO\"\
    \n}\n", "    int1 := interval1[0].(int)\n    int2 := interval1[1].(int)\n    int3\
    \ := interval2[0].(int)\n    int4 := interval2[1].(int)\n    if int1 > int2 {\n\
    \        int1, int2 = int2, int1\n    }\n    if int3 > int4 {\n        int3, int4\
    \ = int4, int3\n    }\n    if int1 > int4 || int2 < int3 {\n        return \"\
    NO\"\n    }\n    if int3 <= int1 && int2 <= int4 {\n        if int2 - int1 ==\
    \ 1 {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n \
    \   if int1 <= int3 && int4 <= int2 {\n        if int4 - int3 == 1 {\n       \
    \     return \"YES\"\n        }\n        return \"NO\"\n    }\n    if int1 <=\
    \ int3 && int3 <= int2 && int2 <= int4 {\n        if int2 - int3 == 1 {\n    \
    \        return \"YES\"\n        }\n        return \"NO\"\n    }\n    if int1\
    \ <= int3 && int3 <= int4 && int4 <= int2 {\n        if int4 - int3 == 1 {\n \
    \           return \"YES\"\n        }\n        return \"NO\"\n    }\n    return\
    \ \"NO\"\n}\n", "    // your code here\n    return \"\"\n}\n", "    return \"\"\
    ;\n}\n", "    // your code here\n    var start1, end1, start2, end2 int\n    for\
    \ i, v := range interval1 {\n        switch i {\n        case 0:\n           \
    \ start1 = v.(int)\n        case 1:\n            end1 = v.(int)\n        }\n \
    \   }\n    for i, v := range interval2 {\n        switch i {\n        case 0:\n\
    \            start2 = v.(int)\n        case 1:\n            end2 = v.(int)\n \
    \       }\n    }\n    if start1 > end1 || start2 > end2 {\n        return \"NO\"\
    \n    }\n    interStart := start1\n    if start2 > start1 {\n        interStart\
    \ = start2\n    }\n    interEnd := end1\n    if end2 < end1 {\n        interEnd\
    \ = end2\n    }\n    if interStart > interEnd {\n        return \"NO\"\n    }\n\
    \    length := interEnd - interStart + 1\n    if length == 1 {\n        return\
    \ \"NO\"\n    }\n    for i := 2; i < length; i++ {\n        if length % i == 0\
    \ {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n}\n", " \
    \   i1, i2 := interval1[0].(int), interval1[1].(int)\n    i3, i4 := interval2[0].(int),\
    \ interval2[1].(int)\n    var start, end int\n    if i1 > i3 {\n        start\
    \ = i1\n    } else {\n        start = i3\n    }\n    if i2 < i4 {\n        end\
    \ = i2\n    } else {\n        end = i4\n    }\n    if start > end {\n        return\
    \ \"NO\"\n    }\n    return isPrime(end - start + 1)\n}\n", "    // your code\
    \ goes here\n    var a, b, c, d int\n    a = interval1[0].(int)\n    b = interval1[1].(int)\n\
    \    c = interval2[0].(int)\n    d = interval2[1].(int)\n    var min, max int\n\
    \    if a > b {\n        min = b\n        max = a\n    } else {\n        min =\
    \ a\n        max = b\n    }\n    var e, f int\n    if c > d {\n        e = d\n\
    \        f = c\n    } else {\n        e = c\n        f = d\n    }\n    var isect_max\
    \ int\n    if max < f {\n        isect_max = max\n    } else {\n        isect_max\
    \ = f\n    }\n    var isect_min int\n    if min > e {\n        isect_min = min\n\
    \    } else {\n        isect_min = e\n    }\n    length := isect_max - isect_min\n\
    \    if length == 0 {\n        return \"NO\"\n    }\n    if length == 1 {\n  \
    \      return \"NO\"\n    }\n    if length == 2 {\n        return \"YES\"\n  \
    \  }\n    if length % 2 == 0 {\n        return \"NO\"\n    }\n    for i := 3;\
    \ i <= length / 2; i++ {\n        if length % i == 0 {\n            return \"\
    NO\"\n        }\n    }\n    return \"YES\"\n}\n", "    start1 := interval1[0].(int)\n\
    \    end1 := interval1[1].(int)\n    start2 := interval2[0].(int)\n    end2 :=\
    \ interval2[1].(int)\n    if start1 > end1 {\n        start1, end1 = end1, start1\n\
    \    }\n    if start2 > end2 {\n        start2, end2 = end2, start2\n    }\n \
    \   // interval 1 is left to interval 2\n    if end1 < start2 {\n        return\
    \ \"NO\"\n    }\n    // interval 1 is right to interval 2\n    if start1 > end2\
    \ {\n        return \"NO\"\n    }\n    // interval 1 contains interval 2\n   \
    \ if start1 <= start2 && end1 >= end2 {\n        // the length of interval2 is\
    \ a prime number\n        if prime(end2 - start2 + 1) {\n            return \"\
    YES\"\n        }\n        return \"NO\"\n    }\n    // interval 2 contains interval\
    \ 1\n    if start2 <= start1 && end2 >= end1 {\n        // the length of interval1\
    \ is a prime number\n        if prime(end1 - start1 + 1) {\n            return\
    \ \"YES\"\n        }\n        return \"NO\"\n    }\n    // interval 1 is overlapping\
    \ interval 2\n    start := start1\n    if start1 < start2 {\n        start = start2\n\
    \    }\n    end := end1\n    if end1 > end2 {\n        end = end2\n    }\n   \
    \ if prime(end - start + 1) {\n        return \"YES\"\n    }\n    return \"NO\"\
    \n}\n", "    start1 := interval1[0].(int)\n    end1 := interval1[1].(int)\n  \
    \  start2 := interval2[0].(int)\n    end2 := interval2[1].(int)\n    if start1\
    \ > end1 {\n        start1, end1 = end1, start1\n    }\n    if start2 > end2 {\n\
    \        start2, end2 = end2, start2\n    }\n    if start1 > end2 || start2 >\
    \ end1 {\n        return \"NO\"\n    }\n    start := start1\n    if start2 > start1\
    \ {\n        start = start2\n    }\n    end := end1\n    if end2 < end1 {\n  \
    \      end = end2\n    }\n    length := end - start\n    if length <= 1 {\n  \
    \      return \"NO\"\n    }\n    for i := 2; i < length; i++ {\n        if length\
    \ % i == 0 {\n            return \"NO\"\n        }\n    }\n    return \"YES\"\n\
    }\n", "    s1 := interval1[0].(int)\n    e1 := interval1[1].(int)\n    s2 := interval2[0].(int)\n\
    \    e2 := interval2[1].(int)\n    if s1 > e1 {\n        s1, e1 = e1, s1\n   \
    \ }\n    if s2 > e2 {\n        s2, e2 = e2, s2\n    }\n    if e1 < s2 || e2 <\
    \ s1 {\n        return \"NO\"\n    }\n    x := s1\n    if s2 > x {\n        x\
    \ = s2\n    }\n    y := e1\n    if e2 < y {\n        y = e2\n    }\n    if isPrime(y\
    \ - x + 1) {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
