name: HumanEval_68_pluck
language: go_test.go
prompt: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// \"\
  Given a list representing a branch of a tree that has non-negative integer nodes\n\
  // your task is to pluck one of the nodes and return it.\n// The plucked node should\
  \ be the node with the smallest even value.\n// If multiple nodes with the same\
  \ smallest even value are found return the node that has smallest index.\n// The\
  \ plucked node should be returned in a list, [ smalest_value, its index ],\n// If\
  \ there are no even values or the given list is empty, return [].\n// Example 1:\n\
  // >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
  \ even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck([]int{1,\
  \ 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest even value, and 2 has\
  \ the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n// PATCH list\n// Example\
  \ 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0, 1}\n// Explanation: 0 is\
  \ the smallest value, but  there are two zeros,\n// so we will choose the first\
  \ zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <=\
  \ 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int {\n"
tests: "func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\
  \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
  \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
  \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
  \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
  \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0,\
  \ 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
  \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
  \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
  \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\
  \tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
  \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    // your code here\n    return nil\n}\n", "    newArr := []int{}\n\
    \    for i, v := range arr {\n        if v % 2 == 0 {\n            newArr = append(newArr,\
    \ v)\n            if i < len(arr) - 1 {\n                newArr = append(newArr,\
    \ arr[i+1])\n            }\n            break\n        }\n    }\n    if len(newArr)\
    \ == 0 {\n        return []int{}\n    } else {\n        return newArr\n    }\n\
    }\n", "    minValue := 0\n    minIndex := 0\n    index := 0\n    gotFirstEven\
    \ := false\n    for i := 0; i < len(arr); i++ {\n        if arr[i] % 2 == 0 {\n\
    \            gotFirstEven = true\n            if minValue == 0 || arr[i] < minValue\
    \ {\n                minValue = arr[i]\n                minIndex = i\n       \
    \     }\n        }\n    }\n    if gotFirstEven {\n        return []int{minValue,\
    \ minIndex}\n    }\n    return []int{}\n}\n", "    return []int{}\n}\n", "\tvar\
    \ result []int\n\t// var reultArray []int\n\tfor i, num := range arr {\n\t\tif\
    \ num % 2 == 0 {\n\t\t\tresult = append(result, num)\n\t\t\tresult = append(result,\
    \ i)\n\t\t\treturn result\n\t\t}\n\t}\n\treturn result\n}\n", "    if len(arr)\
    \ == 0 {\n        return []int{}\n    }\n    res := []int{}\n    for k, v := range\
    \ arr {\n        if v%2 == 0 {\n            if len(res) == 0 {\n             \
    \   res = []int{v, k}\n            } else if v < res[0] {\n                res\
    \ = []int{v, k}\n            }\n        }\n    }\n    return res\n}\n", "    if\
    \ len(arr) == 0 {\n        return []int{}\n    }\n    min_even := arr[0]\n   \
    \ min_even_idx := 0\n    for i, v := range arr {\n        if v % 2 == 0 && v <\
    \ min_even {\n            min_even = v\n            min_even_idx = i\n       \
    \ }\n    }\n    if min_even % 2 == 0 {\n        return []int{min_even, min_even_idx}\n\
    \    }\n    return []int{}\n}\n", "    if len(arr) == 0 {\n        return []int{}\n\
    \    }\n    plucked := []int{}\n    index := -1\n    for i, e := range arr {\n\
    \        if e % 2 == 0 {\n            if len(plucked) == 0 {\n               \
    \ plucked = []int{e, i}\n            } else if e < plucked[0] {\n            \
    \    plucked = []int{e, i}\n            }\n        }\n    }\n    return plucked\n\
    }\n", "    if len(arr) == 0 {\n        return []int{}\n    }\n    if len(arr)\
    \ == 1 {\n        if arr[0]%2 == 0 {\n            return []int{arr[0], 0}\n  \
    \      }\n        return []int{}\n    }\n    output := []int{}\n    evenNum :=\
    \ -1\n    index := -1\n    for i, v := range arr {\n        if v%2 == 0 {\n  \
    \          if evenNum == -1 {\n                evenNum = v\n                index\
    \ = i\n            } else if v < evenNum {\n                evenNum = v\n    \
    \            index = i\n            }\n        }\n    }\n    if evenNum == -1\
    \ {\n        return []int{}\n    }\n    output = append(output, evenNum)\n   \
    \ output = append(output, index)\n    return output\n}\n", "    if len(arr) ==\
    \ 0 {\n        return []int{}\n    }\n    var results []int\n    for _, value\
    \ := range arr {\n        if value % 2 == 0 {\n            results = append(results,\
    \ value)\n        }\n    }\n    if len(results) == 0 {\n        return []int{}\n\
    \    }\n    minIndex := min(results)\n    return []int{results[minIndex], minIndex\
    \ + 1}\n}\n", "    m := make(map[int]bool)\n    for _, v := range arr {\n    \
    \    if v % 2 == 0 {\n            m[v] = true\n        }\n    }\n    if len(m)\
    \ == 0 {\n        return []int{}\n    }\n    min := 2\n    for min <= 1000000\
    \ {\n        if _, ok := m[min]; ok {\n            break\n        }\n        min\
    \ += 2\n    }\n    idx := -1\n    for i, v := range arr {\n        if v == min\
    \ {\n            idx = i\n            break\n        }\n    }\n    return []int{min,\
    \ idx}\n}\n", "    var result []int\n    var minVal, minInd int\n    minVal =\
    \ -1\n    minInd = -1\n    for ind, val := range arr {\n        if val % 2 ==\
    \ 0 {\n            if val < minVal || minVal == -1 {\n                minVal =\
    \ val\n                minInd = ind\n            }\n        }\n    }\n    if minVal\
    \ == -1 {\n        return result\n    }\n    result = append(result, minVal)\n\
    \    result = append(result, minInd)\n    return result\n}\n", "    if len(arr)\
    \ == 0 {\n        return nil\n    }\n    even_index := -1\n    even_val := 0\n\
    \    for i, v := range arr {\n        if v % 2 == 0 {\n            if even_index\
    \ == -1 {\n                even_index = i\n                even_val = v\n    \
    \        } else if v < even_val {\n                even_index = i\n          \
    \      even_val = v\n            }\n        }\n    }\n    if even_index != -1\
    \ {\n        return []int{even_val, even_index}\n    }\n    return nil\n}\n",
  "    // your code goes here\n    var current int\n    for i, v := range arr {\n\
    \        if v % 2 == 0 {\n            current = v\n            break\n       \
    \ }\n    }\n    var index int\n    for i, v := range arr {\n        if v % 2 ==\
    \ 0 && v < current {\n            current = v\n            index = i\n       \
    \ }\n    }\n    fmt.Println(index)\n    if current != 0 {\n        return []int{current,\
    \ index}\n    }\n    return []int{}\n}\n", "    // your code here...\n    return\
    \ []int{}\n}\n", "    var min_index int\n    var has_even bool\n    min_value\
    \ := -1\n    for i, v := range arr {\n        if v % 2 == 0 {\n            if\
    \ !has_even {\n                has_even = true\n                min_value = v\n\
    \                min_index = i\n            } else {\n                if v < min_value\
    \ {\n                    min_value = v\n                    min_index = i\n  \
    \              }\n            }\n        }\n    }\n    if !has_even {\n      \
    \  return []int{}\n    }\n    return []int{min_value, min_index}\n}\n", "    smallestEven\
    \ := -1\n    var answer []int\n    for i, v := range arr {\n        if v % 2 ==\
    \ 0 {\n            if smallestEven == -1 || smallestEven > v {\n             \
    \   smallestEven = v\n                answer = []int{smallestEven, i}\n      \
    \      }\n        }\n    }\n    return answer\n}\n", "    return []int{}\n}\n\n\
    type pluckTest ", "\tminEven := 10001\n\tindex := 0\n\tfor i, el := range arr\
    \ {\n\t\tif el % 2 == 0 && el < minEven {\n\t\t\tminEven = el\n\t\t\tindex = i\n\
    \t\t}\n\t}\n\tif minEven == 10001 {\n\t\treturn []int{}\n\t}\n\treturn []int{minEven,\
    \ index}\n}\n", "    // Place your code here\n    return []int{}\n}\n\ntype testpair "]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
