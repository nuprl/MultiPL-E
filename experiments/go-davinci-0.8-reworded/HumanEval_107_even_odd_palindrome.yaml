name: HumanEval_107_even_odd_palindrome
language: go_test.go
prompt: "package even_odd_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
  \n)\n\n// Given a positive integer n, return a list that has the number of even\
  \ and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n\
  // Example 1:\n// >>> even_odd_palindrome(3)\n// []interface{}{1, 2}\n// Explanation:\n\
  // Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\
  // Example 2:\n// >>> even_odd_palindrome(12)\n// []interface{}{4, 6}\n// Explanation:\n\
  // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even,\
  \ and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned list has\
  \ the number of even and odd integer palindromes respectively.\nfunc even_odd_palindrome(n\
  \ int) []interface{} {\n"
tests: "func TestEven_Odd_Palindrome(t *testing.T) {\n  candidate := even_odd_palindrome\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(123), expected: []interface{}{8,\
  \ 13} },\n     { actual: candidate(12), expected: []interface{}{4, 6} },\n     {\
  \ actual: candidate(3), expected: []interface{}{1, 2} },\n     { actual: candidate(63),\
  \ expected: []interface{}{6, 8} },\n     { actual: candidate(25), expected: []interface{}{5,\
  \ 6} },\n     { actual: candidate(19), expected: []interface{}{4, 6} },\n     {\
  \ actual: candidate(9), expected: []interface{}{4, 5} },\n     { actual: candidate(1),\
  \ expected: []interface{}{0, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    // Write your code here\n    return nil\n}\n", "    var even, odd\
    \ int\n\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n      \
    \      if i % 2 == 0 {\n                even++\n            } else {\n       \
    \         odd++\n            }\n        }\n    }\n\n    return []interface{}{even,\
    \ odd}\n}\n", "    m := map[int]int{0: 0, 1: 0}\n    for i := 1; i <= n; i++ {\n\
    \        // fmt.Println(i)\n        s := fmt.Sprintf(\"%d\", i)\n        if len(s)\
    \ == 1 {\n            // fmt.Println(\"d\", s)\n            m[i % 2]++\n     \
    \   } else if len(s) % 2 == 0 {\n            s_slice := make([]byte, len(s) /\
    \ 2)\n            for j := 0; j < len(s_slice); j++ {\n                s_slice[j]\
    \ = s[j]\n            }\n            s_sub := fmt.Sprintf(\"%s\", s_slice)\n \
    \           fmt.Println(\"e\", s, s_sub)\n            if s_sub == string(s[len(s)\
    \ / 2:]) {\n                m[i % 2]++\n            }\n        } else {\n    \
    \        s_slice := make([]byte, len(s) / 2)\n            for j := 0; j < len(s_slice);\
    \ j++ {\n                s_slice[j] = s[j]\n            }\n            s_sub :=\
    \ fmt.Sprintf(\"%s\", s_slice)\n            fmt.Println(\"o\", s, s_sub)\n   \
    \         if s_sub == string(s[len(s) / 2 + 1:]) {\n                m[i % 2]++\n\
    \            }\n        }\n    }\n    return []interface{}{m[0], m[1]}\n}\n",
  "    if n < 1 || n > 10 ^ 3 {\n        return nil\n    }\n    result := make([]interface{},\
    \ 2)\n    var even, odd int\n    for i := 1; i <= n; i++ {\n        s := fmt.Sprintf(\"\
    %d\", i)\n        isPalindrome := true\n        for i := 0; i < len(s) / 2; i++\
    \ {\n            if s[i] != s[len(s) - 1 - i] {\n                isPalindrome\
    \ = false\n                break\n            }\n        }\n        if isPalindrome\
    \ {\n            if i % 2 == 0 {\n                even++\n            } else {\n\
    \                odd++\n            }\n        }\n    }\n    result[0] = even\n\
    \    result[1] = odd\n    return result\n}\n", "    even, odd := 0, 0\n    for\
    \ i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if i % 2 ==\
    \ 0 {\n                even++\n            } else {\n                odd++\n \
    \           }\n        }\n    }\n    return []interface{}{even, odd}\n}\n", " \
    \   r := make([]interface{}, 2)\n    even := 1\n    odd := 0\n    for i := 1;\
    \ i <= n; i++ {\n        if is_palindrome(i) {\n            if is_even(i) {\n\
    \                even += 1\n            } else {\n                odd += 1\n \
    \           }\n        }\n    }\n    r[0] = even\n    r[1] = odd\n    return r\n\
    }\n", "    // TODO: implement this function\n    return nil\n}\n", "    even :=\
    \ 0\n    odd := 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if is_even(i) {\n                even++\n            } else {\n\
    \                odd++\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    // even_palindrome, odd_palindrome := 0, 0\n    even_palindrome,\
    \ odd_palindrome := 0, 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even_palindrome++\n        \
    \    } else {\n                odd_palindrome++\n            }\n        }\n  \
    \  }\n    return []interface{}{even_palindrome, odd_palindrome}\n}\n", "    e,\
    \ o := 0, 0\n    if n == 1 {\n        return []interface{}{0, 1}\n    } else if\
    \ n == 2 {\n        return []interface{}{1, 1}\n    } else if n == 3 {\n     \
    \   return []interface{}{1, 2}\n    } else if n == 4 {\n        return []interface{}{2,\
    \ 2}\n    } else if n == 5 {\n        return []interface{}{2, 3}\n    } else if\
    \ n == 6 {\n        return []interface{}{3, 3}\n    } else if n == 7 {\n     \
    \   return []interface{}{3, 4}\n    } else if n == 8 {\n        return []interface{}{4,\
    \ 4}\n    } else if n == 9 {\n        return []interface{}{4, 5}\n    } else if\
    \ n == 10 {\n        return []interface{}{5, 5}\n    } else if n == 11 {\n   \
    \     return []interface{}{5, 6}\n    } else if n == 12 {\n        return []interface{}{6,\
    \ 6}\n    } else if n == 13 {\n        return []interface{}{6, 7}\n    } else\
    \ if n == 14 {\n        return []interface{}{7, 7}\n    } else if n == 15 {\n\
    \        return []interface{}{7, 8}\n    } else if n == 16 {\n        return []interface{}{8,\
    \ 8}\n    } else if n == 17 {\n        return []interface{}{8, 9}\n    } else\
    \ if n == 18 {\n        return []interface{}{9, 9}\n    } else if n == 19 {\n\
    \        return []interface{}{9, 10}\n    } else if n == 20 {\n        return\
    \ []interface{}{10, 10}\n    } else if n == 21 {\n        return []interface{}{10,\
    \ 11}\n    } else if n == 22 {\n        return []interface{}{11, 11}\n    } else\
    \ if n == 23 {\n        return []interface{}{11, 12}\n    } else if n == 24 {\n\
    \        return []interface{}{12, 12}\n    } else if n == 25 {\n        return\
    \ []interface{}{12, 13}\n    } else if", "    var even, odd int\n    for i :=\
    \ 1; i <= n; i++ {\n        if i < 10 {\n            even++\n        } else if\
    \ i % 10 == 0 {\n            odd++\n        } else {\n            r := reverse(i)\n\
    \            if r == i {\n                if i % 2 == 0 {\n                  \
    \  even++\n                } else {\n                    odd++\n             \
    \   }\n            }\n        }\n    }\n    return []interface{}{even, odd}\n\
    }\n", "    return []interface{}{even_odd_palindrome_even(n), even_odd_palindrome_odd(n)}\n\
    }\n", "    var even, odd int\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even++\n            } else {\n\
    \                odd++\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    even := 0\n    odd := 0\n    for i := 1; i <= n; i++ {\n  \
    \      if is_palindrome(i) {\n            if i % 2 == 0 {\n                even++\n\
    \            } else {\n                odd++\n            }\n        }\n    }\n\
    \    return []interface{}{even, odd}\n}\n", "    even, odd := 0, 0\n    for i\
    \ := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if i % 2 ==\
    \ 0 {\n                even++\n            } else {\n                odd++\n \
    \           }\n        }\n    }\n    return []interface{}{even, odd}\n}\n", " \
    \   // Number of odd palindromes with n digits is:\n    //\n    // [(1...9) +\
    \ (11...99) + (101...999) + ... + (10^n+1...10^(n+1)-1)] / 2\n    // = [10^n -\
    \ 1] / 2\n    //\n    // Number of even palindromes with n digits is:\n    //\
    \ [(11...99) + (101...999) + ... + (10^n+1...10^(n+1)-1)] / 2\n    // = (10^n\
    \ + 10^(n-1) - 1) / 2\n    //\n    // In order to avoid overflow, we don't directly\
    \ calculate the number of\n    // palindromes with n digits.\n    // Instead,\
    \ we calculate the number of palindromes <= n.\n    num_odd, num_even := 0, 0\n\
    \    for i := 1; i <= n; i *= 10 {\n        // max_n = i * 10 - 1.\n        //\
    \ If n <= max_n, we can safely add the number of palindromes with i\n        //\
    \ digits to num_odd and num_even.\n        max_n := i * 10 - 1\n        if n <=\
    \ max_n {\n            num_odd += (n - i + 1) / 2\n            num_even += (n\
    \ - i + 1) / 2\n            if n % 2 == 1 {\n                num_odd += 1\n  \
    \          }\n            if i % 2 == 0 {\n                num_even += 1\n   \
    \         }\n            break\n        }\n        // If n > max_n, we need to\
    \ subtract the number of palindromes > n from\n        // num_odd and num_even.\n\
    \        //\n        // For example, if n = 123, i = 10, we can safely add the\
    \ number of\n        // palindromes with one digit to num_odd and num_even.\n\
    \        // But we need to subtract the number of palindromes > 123 from num_odd\n\
    \        // and num_even.\n        // The number of palindromes > 123 with one\
    \ digit is 100 - 1 = 99.\n        //\n        // The number of palindromes with\
    \ i digits", "    if n <= 1 {\n        return []interface{}{0, 0}\n    }\n   \
    \ even, odd := 0, 0\n    for i := 0; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even += 1\n            } else\
    \ {\n                odd += 1\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    var list []interface{}\n    var even, odd int\n\n    for i\
    \ := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if i % 2 ==\
    \ 0 {\n                even++\n            } else {\n                odd++\n \
    \           }\n        }\n    }\n\n    list = append(list, even)\n    list = append(list,\
    \ odd)\n\n    return list\n}\n", "    even := 0\n    odd := 0\n    for i := 1;\
    \ i <= n; i++ {\n        if is_palindrome(i) {\n            if is_even(i) {\n\
    \                even++\n            } else {\n                odd++\n       \
    \     }\n        }\n    }\n    return []interface{}{even, odd}\n}\n", "    evenCount\
    \ := 0\n    oddCount := 0\n    for i := 1; i <= n; i++ {\n        if isPalindrome(i)\
    \ {\n            if i % 2 == 0 {\n                evenCount++\n            } else\
    \ {\n                oddCount++\n            }\n        }\n    }\n    return []interface{}{evenCount,\
    \ oddCount}\n}\n", "    even, odd := 0, 0\n    for i := 1; i <= n; i++ {\n   \
    \     if is_palindrome(i) {\n            if i % 2 == 0 {\n                even++\n\
    \            } else {\n                odd++\n            }\n        }\n    }\n\
    \    return []interface{}{even, odd}\n}\n", "    arr := []interface{}{0, 0}\n\
    \    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if\
    \ i % 2 == 0 {\n                arr[0] = arr[0].(int) + 1\n            } else\
    \ {\n                arr[1] = arr[1].(int) + 1\n            }\n        }\n   \
    \ }\n    return arr\n}\n", "    var results []interface{}\n    even := 0\n   \
    \ odd := 0\n    for i := 1; i <= n; i++ {\n        if check_palindrome(i) {\n\
    \            // fmt.Println(i)\n            if i % 2 == 0 {\n                even\
    \ += 1\n            } else {\n                odd += 1\n            }\n      \
    \  }\n    }\n    results = append(results, even)\n    results = append(results,\
    \ odd)\n    return results\n}\n", "    evenPalindromeCount := 0\n    oddPalindromeCount\
    \ := 0\n    for i := 1; i <= n; i++ {\n        if isPalindrome(i) {\n        \
    \    if i % 2 == 0 {\n                evenPalindromeCount++\n            } else\
    \ {\n                oddPalindromeCount++\n            }\n        }\n    }\n \
    \   return []interface{}{evenPalindromeCount, oddPalindromeCount}\n}\n", "   \
    \ evenCount := 0\n    oddCount := 0\n    for i := 1; i <= n; i++ {\n        if\
    \ isPalindrome(i) {\n            if i % 2 == 0 {\n                evenCount++\n\
    \            } else {\n                oddCount++\n            }\n        }\n\
    \    }\n    return []interface{}{evenCount, oddCount}\n}\n", "    even_palindrome\
    \ := 0\n    odd_palindrome := 0\n    for i := 1; i <= n; i++ {\n        palindrome_candidate\
    \ := i\n        reverse_candidate := 0\n        for palindrome_candidate > 0 {\n\
    \            remainder := palindrome_candidate % 10\n            reverse_candidate\
    \ = reverse_candidate * 10 + remainder\n            palindrome_candidate /= 10\n\
    \        }\n        if i == reverse_candidate {\n            if i % 2 == 0 {\n\
    \                even_palindrome++\n            } else {\n                odd_palindrome++\n\
    \            }\n        }\n    }\n    return []interface{}{even_palindrome, odd_palindrome}\n\
    }\n", "    var even, odd int\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even++\n            } else {\n\
    \                odd++\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    even, odd := 0, 0\n    for i := 1; i <= n; i++ {\n        if\
    \ is_palindrome(i) {\n            if i % 2 == 0 {\n                even++\n  \
    \          } else {\n                odd++\n            }\n        }\n    }\n\
    \    return []interface{}{even, odd}\n}\n", "    // Write your code here\n   \
    \ return nil\n}\n", "    isPalindrome := func(val int) bool {\n        var v int\n\
    \        for n := val; n > 0; n /= 10 {\n            v = v * 10 + n % 10\n   \
    \     }\n        return v == val\n    }\n    var even_count, odd_count int\n \
    \   for i := 1; i <= n; i++ {\n        if isPalindrome(i) {\n            if i\
    \ % 2 == 0 {\n                even_count++\n            } else {\n           \
    \     odd_count++\n            }\n        }\n    }\n    return []interface{}{even_count,\
    \ odd_count}\n}\n", "    evenCount := 0\n    oddCount := 0\n    for i := 1; i\
    \ <= n; i++ {\n        if isPalindrome(i) {\n            if i % 2 == 0 {\n   \
    \             evenCount++\n            } else {\n                oddCount++\n\
    \            }\n        }\n    }\n    return []interface{}{evenCount, oddCount}\n\
    }\n", "    return []interface{}{count_even_palindrome(n), count_odd_palindrome(n)}\n\
    }\n", "    if n < 1 || n > 1000 {\n        return nil\n    }\n    // Logger\n\
    \    fmt.Printf(\"n: %d\\n\", n)\n    e := 0\n    o := 0\n    for i := 1; i <=\
    \ n; i++ {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n     \
    \           e++\n            } else {\n                o++\n            }\n  \
    \      }\n    }\n    return []interface{}{e, o}\n}\n", "    return []interface{}{}\n\
    }\n", "    var even, odd int\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even += 1\n            } else\
    \ {\n                odd += 1\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    even := 0\n    odd := 0\n    for i := 1; i <= n; i++ {\n  \
    \      if is_palindrome(i) {\n            if i % 2 == 0 {\n                even++\n\
    \            } else {\n                odd++\n            }\n        }\n    }\n\
    \    return []interface{}{even, odd}\n}\n", "    return []interface{}{0, 0}\n\
    }\n", "    evenCount := 0\n    oddCount := 0\n    for i := 1; i <= n; i++ {\n\
    \        if is_palindrome(i) {\n            if is_even(i) {\n                evenCount++\n\
    \            } else {\n                oddCount++\n            }\n        }\n\
    \    }\n    return []interface{}{evenCount, oddCount}\n}\n", "    if n <= 0 {\n\
    \        return []interface{}{}\n    }\n    var even_palindrome_count int = 0\n\
    \    var odd_palindrome_count int = 0\n    for i := 1; i <= n; i++ {\n       \
    \ if is_palindrome(i) {\n            if i % 2 == 0 {\n                even_palindrome_count++\n\
    \            } else {\n                odd_palindrome_count++\n            }\n\
    \        }\n    }\n    return []interface{}{even_palindrome_count, odd_palindrome_count}\n\
    }\n", "    var result []interface{}\n    count1, count2 := 0, 0\n    for i :=\
    \ 1; i <= n; i++ {\n        if isPalindrome(i) {\n            if isEven(i) {\n\
    \                count1++\n            } else {\n                count2++\n  \
    \          }\n        }\n    }\n    result = append(result, count1, count2)\n\
    \    return result\n}\n", "    var even, odd int\n\n    for i := 1; i <= n; i++\
    \ {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n            \
    \    even++\n            } else {\n                odd++\n            }\n    \
    \    }\n    }\n\n    return []interface{}{even, odd}\n}\n", "    if n < 1 || n\
    \ > 1000 {\n        panic(\"range error\")\n    }\n    ret := make([]interface{},\
    \ 2)\n    ret[0] = 0\n    ret[1] = 0\n    for i := 1; i <= n; i++ {\n        if\
    \ is_palindrome(i) {\n            if is_even(i) {\n                ret[0] = ret[0].(int)\
    \ + 1\n            } else {\n                ret[1] = ret[1].(int) + 1\n     \
    \       }\n        }\n    }\n    return ret\n}\n", "    even_count := 0\n    odd_count\
    \ := 0\n    for i := 1; i <= n; i++ {\n        if IsEvenPalindrome(i) {\n    \
    \        even_count++\n        } else if IsOddPalindrome(i) {\n            odd_count++\n\
    \        }\n    }\n    return []interface{}{even_count, odd_count}\n}\n", "  \
    \  even := 0\n    odd := 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even += 1\n            } else\
    \ {\n                odd += 1\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    even := 0\n    odd := 0\n    for i := 1; i <= n; i++ {\n  \
    \      if is_palindrome(i) {\n            if i % 2 == 0 {\n                even++\n\
    \            } else {\n                odd++\n            }\n        }\n    }\n\
    \    return []interface{}{even, odd}\n}\n", "    // Write your code here\n   \
    \ return nil\n}\n", "    evens := 0\n    odds := 0\n    for i := 1; i <= n; i++\
    \ {\n        str := fmt.Sprintf(\"%d\", i)\n        if is_palindrome(str) {\n\
    \            if len(str) % 2 == 0 {\n                evens += 1\n            }\
    \ else {\n                odds += 1\n            }\n        }\n    }\n    return\
    \ []interface{}{evens, odds}\n}\n", "    even_num := 0\n    odd_num := 0\n   \
    \ for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if i %\
    \ 2 == 0 {\n                even_num += 1\n            } else {\n            \
    \    odd_num += 1\n            }\n        }\n    }\n    return []interface{}{even_num,\
    \ odd_num}\n}\n", "    var even, odd int\n    for i := 1; i <= n; i++ {\n    \
    \    if is_palindrome(i) {\n            if i % 2 == 0 {\n                even++\n\
    \            } else {\n                odd++\n            }\n        }\n    }\n\
    \    return []interface{}{even, odd}\n}\n", "    even, odd := 0, 0\n    for i\
    \ := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if is_even(i)\
    \ {\n                even++\n            } else {\n                odd++\n   \
    \         }\n        }\n    }\n    return []interface{}{even, odd}\n}\n", "  \
    \  s := fmt.Sprintf(\"%d\", n)\n    m := len(s)\n    var even, odd int\n    for\
    \ i := 0; i < m; i++ {\n        if s[i] != '0' {\n            left := fmt.Sprintf(\"\
    %d\", i)\n            right := fmt.Sprintf(\"%d\", m - i - 1)\n            left_str\
    \ := fmt.Sprintf(\"%s\", left)\n            right_str := fmt.Sprintf(\"%s\", right)\n\
    \            left_i, _ := strconv.Atoi(left_str)\n            right_i, _ := strconv.Atoi(right_str)\n\
    \            even += (i + 1) * int(math.Pow10(left_i))\n            odd += (m\
    \ - i) * int(math.Pow10(right_i))\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    even, odd := 0, 0\n    for i := 1; i <= n; i++ {\n        if\
    \ is_palindrome(i) {\n            if i % 2 == 0 {\n                even++\n  \
    \          } else {\n                odd++\n            }\n        }\n    }\n\
    \    return []interface{}{even, odd}\n}\n", "    return []interface{}{even_palindrome(n),\
    \ odd_palindrome(n)}\n}\n", "    res := []interface{}{0, 0}\n    for i := 1; i\
    \ <= n; i++ {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n  \
    \              res[0] = res[0].(int) + 1\n            } else {\n             \
    \   res[1] = res[1].(int) + 1\n            }\n        }\n    }\n    return res\n\
    }\n", "    fmt.Println(\"n:\", n)\n    var result []interface{}\n    for i :=\
    \ 1; i <= n; i++ {\n        if is_palindrome(i) {\n            fmt.Println(\"\\\
    tpalindrome:\", i)\n            if i % 2 == 0 {\n                fmt.Println(\"\
    \\t\\teven\")\n                result = append(result, i)\n            } else\
    \ {\n                fmt.Println(\"\\t\\todd\")\n                result = append(result,\
    \ i)\n            }\n        }\n    }\n    fmt.Println(\"result:\", result)\n\
    \    return result\n}\n", "    // Write your code here\n    var even, odd int\n\
    \    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if\
    \ is_even(i) {\n                even++\n            } else {\n               \
    \ odd++\n            }\n        }\n    }\n    return []interface{}{even, odd}\n\
    }\n", "    even_palindrome := 0\n    odd_palindrome := 0\n    for i := 1; i <=\
    \ n; i++ {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n     \
    \           even_palindrome++\n            } else {\n                odd_palindrome++\n\
    \            }\n        }\n    }\n    return []interface{}{even_palindrome, odd_palindrome}\n\
    }\n", "    // Write your code here.\n    cnt := make([]int, 2)\n    for i := 1;\
    \ i <= n; i++ {\n        if isPalindrome(i) {\n            cnt[i%2]++\n      \
    \  }\n    }\n    return []interface{}{cnt[0], cnt[1]}\n}\n", "    even := 0\n\
    \    odd := 0\n    // Check every number upto 'n' to see if it is a palindrome.\n\
    \    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if\
    \ i % 2 == 0 {\n                even++\n            } else {\n               \
    \ odd++\n            }\n        }\n    }\n    return []interface{}{even, odd}\n\
    }\n", "    even_count := 0\n    odd_count := 0\n    for i := 1; i <= n; i++ {\n\
    \        if is_palindrome(i) {\n            if i % 2 == 0 {\n                even_count++\n\
    \            } else {\n                odd_count++\n            }\n        }\n\
    \    }\n    return []interface{}{even_count, odd_count}\n}\n", "    // number\
    \ of even and odd integers.\n    even, odd := 0, 0\n    for i := 1; i <= n; i++\
    \ {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n            \
    \    even++\n            } else {\n                odd++\n            }\n    \
    \    }\n    }\n    return []interface{}{even, odd}\n}\n", "    even, odd := 0,\
    \ 0\n    for ; n > 0; n-- {\n        s := fmt.Sprintf(\"%d\", n)\n        if len(s)\
    \ == 1 {\n            odd++\n        } else {\n            flag := true\n    \
    \        for i := 0; i < len(s) / 2; i++ {\n                if s[i] != s[len(s)\
    \ - 1 - i] {\n                    flag = false\n                    break\n  \
    \              }\n            }\n            if flag {\n                if len(s)\
    \ % 2 == 0 {\n                    even++\n                } else {\n         \
    \           odd++\n                }\n            }\n        }\n    }\n    return\
    \ []interface{}{even, odd}\n}\n", "    even := 0\n    odd := 0\n    for i := 1;\
    \ i <= n; i++ {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n\
    \                even += 1\n            } else {\n                odd += 1\n \
    \           }\n        }\n    }\n    return []interface{}{even, odd}\n}\n", " \
    \   even, odd := 0, 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even += 1\n            } else\
    \ {\n                odd += 1\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    if n < 1 || n > (1e3) {\n        return nil\n    }\n    even\
    \ := 0\n    odd := 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even++\n            } else {\n\
    \                odd++\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    even_cnt := 0\n    odd_cnt := 0\n    max_digits := len(strconv.Itoa(n))\n\
    \    min_digits := 1\n    palindrome_fmt := \"%0\" + strconv.Itoa(max_digits)\
    \ + \"d\"\n    for i := min_digits; i <= max_digits; i++ {\n        half_fmt :=\
    \ \"%0\" + strconv.Itoa(i) + \"d\"\n        half_max := int(math.Pow10(i))\n \
    \       for half := 0; half < half_max; half++ {\n            half_reversed :=\
    \ int(reverse_int(half))\n            for j := half; j < half_max; j++ {\n   \
    \             palindrome := fmt.Sprintf(palindrome_fmt, half) + fmt.Sprintf(half_fmt,\
    \ half_reversed)\n                if palindrome > n {\n                    break\n\
    \                }\n                if palindrome % 2 == 0 {\n               \
    \     even_cnt++\n                } else {\n                    odd_cnt++\n  \
    \              }\n            }\n        }\n    }\n    return []interface{}{even_cnt,\
    \ odd_cnt}\n}\n", "    even := 0\n    odd := 0\n    for i := 1; i <= n; i++ {\n\
    \        if check_palindrome(i) {\n            if i % 2 == 0 {\n             \
    \   even++\n            } else {\n                odd++\n            }\n     \
    \   }\n    }\n    return []interface{}{even, odd}\n}\n", "    count_even, count_odd\
    \ := 0, 0\n    var result []interface{}\n    for i := 1; i <= n; i++ {\n     \
    \   if is_palindrome(i) {\n            if is_even(i) {\n                count_even++\n\
    \            } else {\n                count_odd++\n            }\n        }\n\
    \    }\n    result = append(result, count_even, count_odd)\n    return result\n\
    }\n", "    even, odd := 0, 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even += 1\n            } else\
    \ {\n                odd += 1\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    // TODO: Implement this function\n    even_count := 0\n   \
    \ odd_count := 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n\
    \            if i % 2 == 0 {\n                even_count++\n            } else\
    \ {\n                odd_count++\n            }\n        }\n    }\n    res :=\
    \ []interface{}{even_count, odd_count}\n    return res\n}\n", "    even_cnt :=\
    \ 0\n    odd_cnt := 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if is_even(i) {\n                even_cnt++\n            } else\
    \ {\n                odd_cnt++\n            }\n        }\n    }\n    return []interface{}{even_cnt,\
    \ odd_cnt}\n}\n", "    even, odd := 0, 0\n    for i := 1; i <= n; i++ {\n    \
    \    if i % 2 == 0 {\n            even += 1\n        } else {\n            odd\
    \ += 1\n        }\n    }\n    return []interface{}{even, odd}\n}\n", "    i :=\
    \ 0\n    j := 0\n    for ; i <= n; i++ {\n        if is_palindrome(i) {\n    \
    \        if i % 2 == 0 {\n                j++\n            }\n        }\n    }\n\
    \    fmt.Println(j)\n    return []interface{}{i, j}\n}\n", "    return []interface{}{}\n\
    }\n", "    // TODO\n    var result []interface{}\n    return result\n}\n", " \
    \   var odd, even int\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even++\n            } else {\n\
    \                odd++\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    if n < 1 || n > 1000 {\n        return nil\n    }\n    even\
    \ := 0\n    odd := 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if is_even(i) {\n                even++\n            } else {\n\
    \                odd++\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    even, odd := 0, 0\n    for i := 1; i <= n; i++ {\n        if\
    \ is_palindrome(i) {\n            if i % 2 == 0 {\n                even++\n  \
    \          } else {\n                odd++\n            }\n        }\n    }\n\
    \    return []interface{}{even, odd}\n}\n", "    var even, odd int\n    for i\
    \ := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if i%2 == 0\
    \ {\n                even += 1\n            } else {\n                odd += 1\n\
    \            }\n        }\n    }\n    return []interface{}{even, odd}\n}\n", " \
    \   odd := 0\n    even := 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even += 1\n            } else\
    \ {\n                odd += 1\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    even, odd := 0, 0\n    for i := 1; i <= n; i++ {\n        if\
    \ is_palindrome(i) {\n            if i % 2 == 0 {\n                even += 1\n\
    \            } else {\n                odd += 1\n            }\n        }\n  \
    \  }\n    return []interface{}{even, odd}\n}\n", "    even, odd := 0, 0\n    //\
    \ e.g. n = 12, then 11 is the last number to check.\n    for n > 0 {\n       \
    \ l := n\n        r := 0\n        // Reverse n, e.g. n = 12, then l = 1, r = 2\n\
    \        for l > 0 {\n            r = r * 10 + l % 10\n            l /= 10\n \
    \       }\n        // Check if n is palindrome, e.g. n = 121, then r = 121, then\
    \ isPalindrome = true\n        isPalindrome := n == r\n        // If n is palindrome\
    \ and is odd number, then increment odd.\n        if isPalindrome && n % 2 !=\
    \ 0 {\n            odd++\n        }\n        // If n is palindrome and is even\
    \ number, then increment even.\n        if isPalindrome && n % 2 == 0 {\n    \
    \        even++\n        }\n        // Decrement n\n        n--\n    }\n    return\
    \ []interface{}{even, odd}\n}\n", "    even_count := 0\n    odd_count := 0\n \
    \   for num := 1; num <= n; num++ {\n        if is_palindrome(num) {\n       \
    \     if num % 2 == 0 {\n                even_count++\n            } else {\n\
    \                odd_count++\n            }\n        }\n    }\n    return []interface{}{even_count,\
    \ odd_count}\n}\n", "    // Write your code here.\n    var i, j, count_even, count_odd\
    \ int = 1, 1, 0, 0\n    // list := make([]interface{}, 0)\n    for i <= n {\n\
    \        if i < 10 {\n            if i % 2 == 0 {\n                count_even++\n\
    \            } else {\n                count_odd++\n            }\n        } else\
    \ {\n            for j = 0; j < len(palindrome_map); j++ {\n                if\
    \ (i >= palindrome_map[j][0]) && (i <= palindrome_map[j][1]) {\n             \
    \       if i % 2 == 0 {\n                        count_even++\n              \
    \      } else {\n                        count_odd++\n                    }\n\
    \                    break\n                }\n            }\n        }\n    \
    \    i++\n    }\n    return []interface{}{count_even, count_odd}\n}\n", "    //\
    \ TODO: Write your code here\n    return nil\n}\n", "    // Write your code here\n\
    \    return nil\n}\n", "    // WRITE YOUR CODE HERE\n    return nil\n}\n", " \
    \   if n <= 0 {\n        return []interface{}{0, 0}\n    }\n    // \u5355\u6570\
    \u4F4D\u6570: n - n / 2 + 1\n    // \u53CC\u6570\u4F4D\u6570: n / 2\n    // \u5947\
    \u6570\u5076\u6570: n - n / 2 + 1\n    // \u5076\u6570\u5947\u6570: n / 2\n  \
    \  even, odd := n - n / 2 + 1, n / 2\n    for i := 1; i <= n; i++ {\n        if\
    \ i % 2 == 0 {\n            continue\n        }\n        if is_palindrome(i) {\n\
    \            if i < 10 {\n                even--\n            } else {\n     \
    \           odd--\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    palindrome_list := []int{}\n    even_palindrome_list := []int{}\n\
    \    odd_palindrome_list := []int{}\n    for i := 1; i <= n; i++ {\n        if\
    \ Is_Palindrome(i) {\n            palindrome_list = append(palindrome_list, i)\n\
    \        }\n    }\n    for _, j := range palindrome_list {\n        if j % 2 ==\
    \ 0 {\n            even_palindrome_list = append(even_palindrome_list, j)\n  \
    \      } else {\n            odd_palindrome_list = append(odd_palindrome_list,\
    \ j)\n        }\n    }\n    return []interface{}{len(even_palindrome_list), len(odd_palindrome_list)}\n\
    }\n", "    evenPalindrome, oddPalindrome := 0, 0\n    for i := 1; i <= n; i++\
    \ {\n        if isPalindrome(i) {\n            if i % 2 == 0 {\n             \
    \   evenPalindrome++\n            } else {\n                oddPalindrome++\n\
    \            }\n        }\n    }\n    return []interface{}{evenPalindrome, oddPalindrome}\n\
    }\n", "    even, odd := 0, 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even++\n            } else {\n\
    \                odd++\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    return []interface{}{getEvenPalindrome(n), getOddPalindrome(n)}\n\
    }\n", "    num_even, num_odd := 0, 0\n    for i := 1; i <= n; i++ {\n        if\
    \ is_palindrome(i) {\n            if is_even(i) {\n                num_even++\n\
    \            } else {\n                num_odd++\n            }\n        }\n \
    \   }\n    return []interface{}{num_even, num_odd}\n}\n", "    even := 0\n   \
    \ odd := 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n   \
    \         if i % 2 == 0 {\n                even++\n            } else {\n    \
    \            odd++\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    var even_count, odd_count int\n    for i := 1; i <= n; i++\
    \ {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n            \
    \    even_count++\n            } else {\n                odd_count++\n       \
    \     }\n        }\n    }\n    return []interface{}{even_count, odd_count}\n}\n",
  "    evenCount := 0\n    oddCount := 0\n    for i := 1; i <= n; i++ {\n        switch\
    \ check_palindrome(i) {\n        case true:\n            if i % 2 == 0 {\n   \
    \             evenCount++\n            } else {\n                oddCount++\n\
    \            }\n        }\n    }\n    return []interface{}{evenCount, oddCount}\n\
    }\n", "    // Write your code here\n    var even int\n    var odd int\n    for\
    \ i := 1; i <= n; i++ {\n        if palindrome(i) {\n            if i % 2 == 0\
    \ {\n                even += 1\n            } else {\n                odd += 1\n\
    \            }\n        }\n    }\n    fmt.Println(even, odd)\n    return []interface{}{even,\
    \ odd}\n}\n", "    var ret [2]int\n    for i := 1; i <= n; i++ {\n        s :=\
    \ fmt.Sprintf(\"%d\", i)\n        odd := true\n        if len(s) % 2 == 0 {\n\
    \            odd = false\n        }\n        m := len(s) / 2\n        var idx\
    \ int\n        var j int\n        for idx = 0; idx < m; idx++ {\n            j\
    \ = len(s) - idx - 1\n            if s[idx] != s[j] {\n                break\n\
    \            }\n        }\n        if idx == m {\n            if odd {\n     \
    \           ret[1]++\n            } else {\n                ret[0]++\n       \
    \     }\n        }\n    }\n    return ret[:]\n}\n", "    var even, odd int\n \
    \   for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if i\
    \ % 2 == 0 {\n                even++\n            } else {\n                odd++\n\
    \            }\n        }\n    }\n    return []interface{}{even, odd}\n}\n", " \
    \   evens := 0\n    odds := 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                evens++\n            } else\
    \ {\n                odds++\n            }\n        }\n    }\n    return []interface{}{evens,\
    \ odds}\n}\n", "    res := []interface{}{0, 0}\n    for i := 1; i <= n; i++ {\n\
    \        if is_palindrome(i) {\n            if i % 2 == 0 {\n                res[0]\
    \ = res[0].(int) + 1\n            } else {\n                res[1] = res[1].(int)\
    \ + 1\n            }\n        }\n    }\n    return res\n}\n", "    odd, even :=\
    \ 0, 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n       \
    \     if i % 2 == 0 {\n                even++\n            } else {\n        \
    \        odd++\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    res := []interface{}{0, 0}\n    if n <= 1 {\n        return\
    \ res\n    }\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n \
    \           if i % 2 == 0 {\n                res[0] = res[0].(int) + 1\n     \
    \       } else {\n                res[1] = res[1].(int) + 1\n            }\n \
    \       }\n    }\n    return res\n}\n", "    palindrome := []interface{}{0, 0}\n\
    \    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if\
    \ i % 2 == 0 {\n                palindrome[0] = palindrome[0].(int) + 1\n    \
    \        } else {\n                palindrome[1] = palindrome[1].(int) + 1\n \
    \           }\n        }\n    }\n    return palindrome\n}\n", "    even, odd :=\
    \ 0, 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n       \
    \     if i % 2 == 0 {\n                even += 1\n            } else {\n     \
    \           odd += 1\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    even_count := 0\n    odd_count := 0\n    for i := 1; i <= n;\
    \ i++ {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n        \
    \        even_count++\n            } else {\n                odd_count++\n   \
    \         }\n        }\n    }\n    return []interface{}{even_count, odd_count}\n\
    }\n", "    // Write your code here\n    return nil\n}\n", "    if n < 1 || n >\
    \ 1000 {\n        return nil\n    }\n    even, odd := 0, 0\n    for i := 1; i\
    \ <= n; i++ {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n  \
    \              even += 1\n            } else {\n                odd += 1\n   \
    \         }\n        }\n    }\n    return []interface{}{even, odd}\n}\n", "  \
    \  if n < 1 || n > pow(10, 3) {\n        return nil\n    }\n    even, odd := 0,\
    \ 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n          \
    \  if i % 2 == 0 {\n                even += 1\n            } else {\n        \
    \        odd += 1\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    even := 0\n    odd := 0\n    for i := 1; i <= n; i++ {\n  \
    \      if is_palindrome(i) {\n            if i % 2 == 0 {\n                even++\n\
    \            } else {\n                odd++\n            }\n        }\n    }\n\
    \    return []interface{}{even, odd}\n}\n", "    //\n    return nil\n}\n", " \
    \   even := 0\n    odd := 0\n    if n == 1 {\n        return []interface{}{0,\
    \ 1}\n    }\n    for i := 1; i <= n; i++ {\n        // i <= n/10 \u56E0\u4E3A\u65E0\
    \u8BBA\u5982\u4F55\uFF0C\u6211\u4EEC\u90FD\u5FC5\u987B\u5230\u6700\u540E\u4E00\
    \u4F4D\u6765\u68C0\u67E5\u56DE\u6587\uFF0C\u5982\u679C\u4E0D\u8FD9\u6837\u505A\
    \uFF0C\u90A3\u4E48\u5BF9\u4E8E\u5947\u6570\u7684\u56DE\u6587\u6570\u6765\u8BF4\
    \uFF0C\u6211\u4EEC\u5C06\u4F1A\u591A\u8BA1\u7B97\u4E00\u4E2A\u56DE\u6587\u6570\
    \n        if is_palindrome(i) && i <= n/10 {\n            even++\n        }\n\
    \        if is_palindrome(i) && i > n/10 {\n            odd++\n        }\n   \
    \ }\n    return []interface{}{even, odd}\n}\n", "    var even, odd int\n\n   \
    \ // palindrome_checker will help determine if a number is a palindrome or not.\n\
    \    palindrome_checker := func(n int) bool {\n        s := fmt.Sprintf(\"%d\"\
    , n)\n        for i := 0; i < len(s)/2; i++ {\n            if s[i] != s[len(s)-i-1]\
    \ {\n                return false\n            }\n        }\n        return true\n\
    \    }\n\n    for i := 1; i <= n; i++ {\n        if palindrome_checker(i) {\n\
    \            if i%2 == 0 {\n                even++\n            } else {\n   \
    \             odd++\n            }\n        }\n    }\n\n    return []interface{}{even,\
    \ odd}\n}\n", "    var oddCnt int\n    var evenCnt int\n    for i := 1; i <= n;\
    \ i++ {\n        if isPalindrome(i) {\n            if i % 2 == 0 {\n         \
    \       evenCnt++\n            } else {\n                oddCnt++\n          \
    \  }\n        }\n    }\n    return []interface{}{evenCnt, oddCnt}\n}\n", "   \
    \ return []interface{}{1, 2}\n}\n", "    var even int\n    var odd int\n    for\
    \ i := 1; i <= n; i++ {\n        palindrome := func(n int) bool {\n          \
    \  ns := fmt.Sprintf(\"%d\", n)\n            mid := len(ns) / 2\n            for\
    \ j := 0; j < mid; j++ {\n                if ns[j] != ns[len(ns) - 1 - j] {\n\
    \                    return false\n                }\n            }\n        \
    \    return true\n        }\n        if palindrome(i) {\n            if i % 2\
    \ == 0 {\n                even += 1\n            } else {\n                odd\
    \ += 1\n            }\n        }\n    }\n    return []interface{}{even, odd}\n\
    }\n", "    if n < 1 || n > 1000 {\n        return nil\n    }\n    even, odd :=\
    \ 0, 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n       \
    \     if is_even(i) {\n                even++\n            } else {\n        \
    \        odd++\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    // Write your code here\n    even, odd := 0, 0\n    for i :=\
    \ 1; i <= n; i++ {\n        if isPalindrome(i) {\n            if i % 2 == 0 {\n\
    \                even++\n            } else {\n                odd++\n       \
    \     }\n        }\n    }\n    return []interface{}{even, odd}\n}\n", "    //\
    \ your code here\n    return nil\n}\n", "    var even, odd = 0, 0\n    for i :=\
    \ 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n\
    \                even++\n            } else {\n                odd++\n       \
    \     }\n        }\n    }\n    return []interface{}{even, odd}\n}\n", "    even,\
    \ odd := 0, 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n\
    \            if i % 2 == 0 {\n                even += 1\n            } else {\n\
    \                odd += 1\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    cnt := []int{0, 0}\n    for i := 1; i <= n; i++ {\n       \
    \ if is_palindrome(i) {\n            cnt[i%2]++\n        }\n    }\n    return\
    \ []interface{}{cnt[0], cnt[1]}\n}\n", "    if n < 1 || n > 1000 {\n        return\
    \ nil\n    }\n    even := 0\n    odd := 0\n    for i := 1; i <= n; i++ {\n   \
    \     if is_palindrome(i) {\n            if i % 2 == 0 {\n                even++\n\
    \            } else {\n                odd++\n            }\n        }\n    }\n\
    \    return []interface{}{even, odd}\n}\n", "    var result []interface{}\n  \
    \  cnt_even, cnt_odd := 0, 0\n    var t int\n    for i := 1; i <= n; i++ {\n \
    \       t = i\n        sum := 0\n        for t > 0 {\n            r := t % 10\n\
    \            sum = sum * 10 + r\n            t = t / 10\n        }\n        if\
    \ sum == i {\n            if i % 2 == 0 {\n                cnt_even++\n      \
    \      } else {\n                cnt_odd++\n            }\n        }\n    }\n\
    \    result = append(result, cnt_even)\n    result = append(result, cnt_odd)\n\
    \    return result\n}\n", "    ret := []interface{}{0, 0}\n    isPalindrome :=\
    \ func(n int) bool {\n        if n == 0 {\n            return true\n        }\n\
    \        if n % 10 == 0 {\n            return false\n        }\n        if n <\
    \ 0 {\n            return false\n        }\n        tmp := 0\n        for n >\
    \ tmp {\n            tmp = tmp * 10 + n % 10\n            n /= 10\n        }\n\
    \        return n == tmp || n == tmp / 10\n    }\n    for i := 1; i <= n; i++\
    \ {\n        if isPalindrome(i) {\n            if i % 2 == 0 {\n             \
    \   ret[0] = ret[0].(int) + 1\n            } else {\n                ret[1] =\
    \ ret[1].(int) + 1\n            }\n        }\n    }\n    return ret\n}\n", " \
    \   evenCount := 0\n    oddCount := 0\n    for i := 1; i <= n; i++ {\n       \
    \ if isPalindrome(i) {\n            if i % 2 == 0 {\n                evenCount++\n\
    \            } else {\n                oddCount++\n            }\n        }\n\
    \    }\n    return []interface{}{evenCount, oddCount}\n}\n", "    // Fill this\
    \ in.\n    even := 0\n    odd := 0\n    for i := 1; i <= n; i++ {\n        if\
    \ isPalindrome(i) {\n            if i % 2 == 0 {\n                even++\n   \
    \         } else {\n                odd++\n            }\n        }\n    }\n \
    \   return []interface{}{even, odd}\n}\n", "    // Your code goes here\n    return\
    \ nil\n}\n", "    var (\n        evenCount int\n        oddCount int\n    )\n\
    \    for i := 1; i <= n; i++ {\n        if isPalindrome(i) {\n            if i\
    \ % 2 == 0 {\n                evenCount++\n            } else {\n            \
    \    oddCount++\n            }\n        }\n    }\n    return []interface{}{evenCount,\
    \ oddCount}\n}\n", "    var even, odd int\n    for i := 1; i <= n; i++ {\n   \
    \     if is_palindrome(i) {\n            if i % 2 == 0 {\n                even++\n\
    \            } else {\n                odd++\n            }\n        }\n    }\n\
    \    return []interface{}{even, odd}\n}\n", "    count_even := 0\n    count_odd\
    \ := 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n       \
    \     if i % 2 == 0 {\n                count_even++\n            } else {\n  \
    \              count_odd++\n            }\n        }\n    }\n    return []interface{}{count_even,\
    \ count_odd}\n}\n", "    count_even, count_odd := 0, 0\n    for i := 1; i <= n;\
    \ i++ {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n        \
    \        count_even++\n            } else {\n                count_odd++\n   \
    \         }\n        }\n    }\n    return []interface{}{count_even, count_odd}\n\
    }\n", "    var odd_count int\n    var even_count int\n    for i := 1; i <= n;\
    \ i++ {\n        if is_palindrome(i) {\n            if is_even(i) {\n        \
    \        even_count += 1\n            } else {\n                odd_count += 1\n\
    \            }\n        }\n    }\n    return []interface{}{even_count, odd_count}\n\
    }\n", "    even_count := 0\n    odd_count := 0\n    for i := 1; i <= n; i++ {\n\
    \        if is_palindrome(i) {\n            if i % 2 == 0 {\n                even_count++\n\
    \            } else {\n                odd_count++\n            }\n        }\n\
    \    }\n    return []interface{}{even_count, odd_count}\n}\n", "    // Insert\
    \ your code here\n    return []interface{}{0, 0}\n}\n", "    even, odd := 0, 0\n\
    \    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if\
    \ i % 2 == 0 {\n                even += 1\n            } else {\n            \
    \    odd += 1\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    // Write your code here\n    res := []interface{}{0, 0}\n \
    \   for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if i%2\
    \ == 0 {\n                res[0] = res[0].(int) + 1\n            } else {\n  \
    \              res[1] = res[1].(int) + 1\n            }\n        }\n    }\n  \
    \  return res\n}\n", "    var total, even, odd int\n    var ret []interface{}\n\
    \    if n < 1 || n > 1000 {\n        return ret\n    }\n    for i := 1; i <= n;\
    \ i++ {\n        if is_palindrome(i) {\n            total++\n            if is_even(i)\
    \ {\n                even++\n            } else {\n                odd++\n   \
    \         }\n        }\n    }\n    ret = append(ret, even)\n    ret = append(ret,\
    \ odd)\n    return ret\n}\n", "    even_num := 0\n    odd_num := 0\n    for i\
    \ := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if i % 2 ==\
    \ 0 {\n                even_num++\n            } else {\n                odd_num++\n\
    \            }\n        }\n    }\n    return []interface{}{even_num, odd_num}\n\
    }\n", "    var even, odd int\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even++\n            } else {\n\
    \                odd++\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    palindrome := make([]interface{}, 2)\n    even_count := 0\n\
    \    odd_count := 0\n    for i := 1; i <= n; i++ {\n        if(is_palindrome(i))\
    \ {\n            if(i % 2 == 0) {\n                even_count += 1\n         \
    \   } else {\n                odd_count += 1\n            }\n        }\n    }\n\
    \    palindrome[0] = even_count\n    palindrome[1] = odd_count\n    return palindrome\n\
    }\n", "    count_odd := 0\n    count_even := 0\n    for i := 1; i <= n; i++ {\n\
    \        if is_palindrome(i) {\n            if i % 2 == 0 {\n                count_even++\n\
    \            } else {\n                count_odd++\n            }\n        }\n\
    \    }\n    return []interface{}{count_even, count_odd}\n}\n", "    return []interface{}{\n\
    \        0, // even numbers\n        0, // odd numbers\n    }\n}\n", "    c1,\
    \ c2 := 0, 0\n    for i := 1; i <= n; i++ {\n        if isPalindrome(i) {\n  \
    \          fmt.Println(i)\n            if isEven(i) {\n                c1++\n\
    \            } else {\n                c2++\n            }\n        }\n    }\n\
    \    return []interface{}{c1, c2}\n}\n", "    var even, odd int\n    for i :=\
    \ 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n\
    \                even++\n            } else {\n                odd++\n       \
    \     }\n        }\n    }\n    return []interface{}{even, odd}\n}\n", "    res\
    \ := []interface{}{0, 0}\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                res[0] = res[0].(int) + 1\n\
    \            } else {\n                res[1] = res[1].(int) + 1\n           \
    \ }\n        }\n    }\n    return res\n}\n", "    even_count := 0\n    odd_count\
    \ := 0\n    for i := 1; i <= n; i++ {\n        if even_palindrome(i) {\n     \
    \       even_count++\n        } else if odd_palindrome(i) {\n            odd_count++\n\
    \        }\n    }\n    return []interface{}{even_count, odd_count}\n}\n", "  \
    \  // fmt.Println(n)\n    if n == 1 {\n        return []interface{}{0, 1}\n  \
    \  }\n    if n == 2 {\n        return []interface{}{1, 1}\n    }\n    if n ==\
    \ 3 {\n        return []interface{}{1, 2}\n    }\n    even := 1\n    odd := 2\n\
    \    for i := 4; i <= n; i++ {\n        i_str := fmt.Sprintf(\"%d\", i)\n    \
    \    is_palindrome := true\n        for j := 0; j < len(i_str) / 2; j++ {\n  \
    \          if i_str[j] != i_str[len(i_str) - 1 - j] {\n                is_palindrome\
    \ = false\n                break\n            }\n        }\n        if is_palindrome\
    \ {\n            if i % 2 == 0 {\n                even += 1\n            } else\
    \ {\n                odd += 1\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    var even int\n    var odd int\n    for i := 1; i <= n; i++\
    \ {\n        if is_palindrome(i) {\n            if is_even(i) {\n            \
    \    even++\n            } else {\n                odd++\n            }\n    \
    \    }\n    }\n    return []interface{}{even, odd}\n}\n", "    var even int\n\
    \    var odd int\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n\
    \            if i % 2 == 0 {\n                even += 1\n            } else {\n\
    \                odd += 1\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    if n <= 0 {\n        return []interface{}{0, 0}\n    }\n  \
    \  even, odd := 0, 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even++\n            } else {\n\
    \                odd++\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    var even, odd int\n    var res []interface{}\n    // Assume\
    \ 0 is even\n    if n == 0 {\n        even = 1\n    }\n    for i := 1; i <= n;\
    \ i++ {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n        \
    \        even++\n            } else {\n                odd++\n            }\n\
    \        }\n    }\n    res = append(res, even, odd)\n    return res\n}\n", " \
    \   var even, odd int\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even++\n            } else {\n\
    \                odd++\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    count_even, count_odd := 0, 0\n    for i := 1; i <= n; i++\
    \ {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n            \
    \    count_even++\n            } else {\n                count_odd++\n       \
    \     }\n        }\n    }\n    return []interface{}{count_even, count_odd}\n}\n",
  "    even := 0\n    odd := 0\n    for i := 1; i <= n; i++ {\n        s := fmt.Sprintf(\"\
    %d\", i)\n        if s == reverse(s) {\n            if len(s) % 2 == 0 {\n   \
    \             even++\n            } else {\n                odd++\n          \
    \  }\n        }\n    }\n    return []interface{}{even, odd}\n}\n", "    even,\
    \ odd := 0, 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n\
    \            if is_even(i) {\n                even++\n            } else {\n \
    \               odd++\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    even := 0\n    odd := 0\n    for i := 1; i <= n; i++ {\n  \
    \      if is_palindrome(i) {\n            if i % 2 == 0 {\n                even\
    \ += 1\n            } else {\n                odd += 1\n            }\n      \
    \  }\n    }\n    return []interface{}{even, odd}\n}\n", "    count := []int{0,\
    \ 0}\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n         \
    \   count[i % 2] += 1\n        }\n    }\n    return []interface{}{count[0], count[1]}\n\
    }\n", "    // Write your code here\n    fmt.Println(\"Hello, playground\", n)\n\
    \    return nil\n}\n", "    even_palindrome := 0\n    odd_palindrome := 0\n  \
    \  for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if i\
    \ % 2 == 0 {\n                even_palindrome += 1\n            } else {\n   \
    \             odd_palindrome += 1\n            }\n        }\n    }\n    return\
    \ []interface{}{even_palindrome, odd_palindrome}\n}\n", "    var (\n        even\
    \  int\n        odd   int\n        c1    int\n        c2    int\n        c3  \
    \  int\n        c4    int\n        c5    int\n        c6    int\n        c7  \
    \  int\n        c8    int\n        c9    int\n        c10   int\n        c11 \
    \  int\n        c12   int\n        c13   int\n        c14   int\n        c15 \
    \  int\n        c16   int\n        c17   int\n        c18   int\n        c19 \
    \  int\n        c20   int\n        c21   int\n        c22   int\n        c23 \
    \  int\n        c24   int\n        c25   int\n        c26   int\n        c27 \
    \  int\n        c28   int\n        c29   int\n        c30   int\n        c31 \
    \  int\n        c32   int\n        c33   int\n        c34   int\n        c35 \
    \  int\n        c36   int\n        c37   int\n        c38   int\n        c39 \
    \  int\n        c40   int\n        c41   int\n        c42   int\n        c43 \
    \  int\n        c44   int\n        c45   int\n        c46   int\n        c47 \
    \  int\n        c48   int\n        c49   int\n        c50   int\n        c51 \
    \  int\n        c52   int\n        c53   int\n        c54   int\n        c55 \
    \  int\n        c56   int\n        c57   int\n        c58   int\n        c59 \
    \  int\n        c60   int\n        c61   int\n        c62   int\n        c63 \
    \  int\n        c64   int\n        c65   int\n        c66   int\n        c67 \
    \  int\n        c68   int\n        c69   int\n        c70   int\n        c71 \
    \  int\n        c72   int\n        c73   int\n        c74   int\n        c75 \
    \  int\n        c76   int\n        c77   int\n        c78   int\n        c79 \
    \  int\n        c80   int\n        c81   int\n        c82   int\n        c83 \
    \  int", "    even_count := 0\n    odd_count := 0\n    for i := 1; i <= n; i++\
    \ {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n            \
    \    even_count++\n            } else {\n                odd_count++\n       \
    \     }\n        }\n    }\n    return []interface{}{even_count, odd_count}\n}\n",
  "    var r []interface{}\n    var even, odd int\n    for i := 1; i <= n; i++ {\n\
    \        if is_palindrome(i) {\n            if i%2 == 0 {\n                even\
    \ += 1\n            } else {\n                odd += 1\n            }\n      \
    \  }\n    }\n    r = append(r, even, odd)\n    return r\n}\n", "    // Write your\
    \ code here\n    return nil\n}\n", "    even := 0\n    odd := 0\n    for i :=\
    \ 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n\
    \                even++\n            } else {\n                odd++\n       \
    \     }\n        }\n    }\n    return []interface{}{even, odd}\n}\n", "    count_even\
    \ := 0\n    count_odd := 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                count_even++\n            }\
    \ else {\n                count_odd++\n            }\n        }\n    }\n    return\
    \ []interface{}{count_even, count_odd}\n}\n", "    fmt.Println(\"\")\n    var\
    \ even int\n    var odd int\n    for i := 1; i <= n; i++ {\n        if isPalindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even++\n            } else {\n\
    \                odd++\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    even, odd := 0, 0\n    num := 1\n    for num <= n {\n     \
    \   // fmt.Println(num)\n        if is_palindrome(num) {\n            if num %\
    \ 2 == 0 {\n                even++\n            } else {\n                odd++\n\
    \            }\n        }\n        num++\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    even := 0\n    odd := 0\n    for i := 1; i <= n; i++ {\n  \
    \      if is_palindrome(i) {\n            if i % 2 == 0 {\n                even++\n\
    \            } else {\n                odd++\n            }\n        }\n    }\n\
    \    return []interface{}{even, odd}\n}\n", "    // Start coding here\n    c :=\
    \ make(chan interface{})\n    var count_odd int = 0\n    var count_even int =\
    \ 0\n    go func(){\n        for i := 1; i <= n; i++ {\n            tmp := fmt.Sprintf(\"\
    %d\", i)\n            is_odd := true\n            for j := 0; j < len(tmp)/2;\
    \ j++ {\n                if tmp[j] != tmp[len(tmp)-1-j] {\n                  \
    \  is_odd = false\n                    break\n                }\n            }\n\
    \            if is_odd {\n                c <- i\n            }\n        }\n \
    \       close(c)\n    }()\n    for i := range c {\n        if i.(int) % 2 == 0\
    \ {\n            count_even++\n        } else {\n            count_odd++\n   \
    \     }\n    }\n    return []interface{}{count_even, count_odd}\n}\n", "    even_palindrome\
    \ := 0\n    odd_palindrome := 0\n    count := 0\n    for i := 1; i <= n; i++ {\n\
    \        if is_palindrome(i) {\n            count += 1\n            if i % 2 ==\
    \ 0 {\n                even_palindrome += 1\n            } else {\n          \
    \      odd_palindrome += 1\n            }\n        }\n    }\n    fmt.Println(count)\n\
    \    return []interface{}{even_palindrome, odd_palindrome}\n}\n", "    // Write\
    \ your code here\n    even, odd := 0, 0\n    for i := 1; i <= n; i++ {\n     \
    \   if isPalindrome(i) {\n            if i % 2 == 0 {\n                even++\n\
    \            } else {\n                odd++\n            }\n        }\n    }\n\
    \    return []interface{}{even, odd}\n}\n", "    ret := []interface{}{0, 0}\n\
    \    if n < 0 {\n        return ret\n    }\n    for i := 1; i <= n; i++ {\n  \
    \      if i % 10 == 0 {\n            continue\n        }\n        j := i\n   \
    \     sum := 0\n        for j > 0 {\n            sum = sum * 10 + j % 10\n   \
    \         j /= 10\n        }\n        if sum == i {\n            if i % 2 == 0\
    \ {\n                ret[0] = ret[0].(int) + 1\n            } else {\n       \
    \         ret[1] = ret[1].(int) + 1\n            }\n        }\n    }\n    return\
    \ ret\n}\n", "    var evenPalindrome, oddPalindrome int\n    var num int\n   \
    \ for num = 1; num <= n; num++ {\n        if isPalindrome(num) {\n           \
    \ if isEven(num) {\n                evenPalindrome += 1\n            } else {\n\
    \                oddPalindrome += 1\n            }\n        }\n    }\n    return\
    \ []interface{}{evenPalindrome, oddPalindrome}\n}\n", "    even, odd := 0, 0\n\
    \    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if\
    \ i % 2 == 0 {\n                even++\n            } else {\n               \
    \ odd++\n            }\n        }\n    }\n    return []interface{}{even, odd}\n\
    }\n", "    fmt.Println(\"n:\", n)\n    even_count := 0\n    odd_count := 0\n \
    \   for i := 1; i <= n; i++ {\n        s := fmt.Sprintf(\"%d\", i)\n        length\
    \ := len(s)\n        if length == 1 {\n            //fmt.Println(\"n % 2 == 0\"\
    )\n            if i % 2 == 0 {\n                even_count++\n            } else\
    \ {\n                odd_count++\n            }\n        } else {\n          \
    \  flag := true\n            half := length / 2\n            for j := 0; j < half;\
    \ j++ {\n                if s[j] != s[length - j - 1] {\n                    flag\
    \ = false\n                    break\n                }\n            }\n     \
    \       if flag {\n                //fmt.Println(\"n % 2 == 0\")\n           \
    \     if i % 2 == 0 {\n                    even_count++\n                } else\
    \ {\n                    odd_count++\n                }\n            }\n     \
    \   }\n    }\n    return []interface{}{even_count, odd_count}\n}\n", "    var\
    \ result []interface{}\n    var even, odd int\n    for i := 1; i <= n; i++ {\n\
    \        if is_palindrome(i) {\n            if is_even(i) {\n                even++\n\
    \            } else {\n                odd++\n            }\n        }\n    }\n\
    \    result = append(result, even, odd)\n    return result\n}\n", "    var even_palindrome\
    \ int\n    var odd_palindrome int\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even_palindrome++\n        \
    \    } else {\n                odd_palindrome++\n            }\n        }\n  \
    \  }\n    return []interface{}{even_palindrome, odd_palindrome}\n}\n", "    var\
    \ even, odd int\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n\
    \            if is_even(i) {\n                even += 1\n            } else {\n\
    \                odd += 1\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    even_num := 0\n    odd_num := 0\n    for i := 1; i <= n; i++\
    \ {\n        if is_palindrome(i) {\n            if is_even(i) {\n            \
    \    even_num += 1\n            } else {\n                odd_num += 1\n     \
    \       }\n        }\n    }\n    return []interface{}{even_num, odd_num}\n}\n",
  "    var even, odd int\n    var palindrome func(int) bool\n    palindrome = func(n\
    \ int) bool {\n        if n < 10 {\n            return true\n        }\n     \
    \   l, r := n, 0\n        for l > 0 {\n            r = r * 10 + l % 10\n     \
    \       l /= 10\n        }\n        return r == n\n    }\n    for i := 1; i <=\
    \ n; i++ {\n        if palindrome(i) {\n            if i & 1 == 0 {\n        \
    \        even++\n            } else {\n                odd++\n            }\n\
    \        }\n    }\n    return []interface{}{even, odd}\n}\n", "    even := 0\n\
    \    odd := 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n\
    \            if i % 2 == 0 {\n                even++\n            } else {\n \
    \               odd++\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    if n < 1 || n > 1000 {\n        panic(\"n should be in range\
    \ (1, 1000)\")\n    }\n    even, odd := 0, 0\n    for i := 1; i <= n; i++ {\n\
    \        if is_palindrome(i) {\n            if i % 2 == 0 {\n                even++\n\
    \            } else {\n                odd++\n            }\n        }\n    }\n\
    \    return []interface{}{even, odd}\n}\n", "    var even, odd int\n    for num\
    \ := 1; num <= n; num++ {\n        if is_palindrome(num) {\n            if num\
    \ % 2 == 0 {\n                even++\n            } else {\n                odd++\n\
    \            }\n        }\n    }\n    return []interface{}{even, odd}\n}\n", " \
    \   palindromeCounts := make([]interface{}, 2)\n    evenCount := 0\n    oddCount\
    \ := 0\n    // count the even and odd number of palindrome\n    for i := 1; i\
    \ <= n; i++ {\n        if isPalindrome(i) {\n            if i % 2 == 0 {\n   \
    \             evenCount++\n            } else {\n                oddCount++\n\
    \            }\n        }\n    }\n    palindromeCounts[0] = evenCount\n    palindromeCounts[1]\
    \ = oddCount\n    return palindromeCounts\n}\n", "    ret := []interface{}{0,\
    \ 0}\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n         \
    \   if i%2 == 0 {\n                ret[0] = ret[0].(int) + 1\n            } else\
    \ {\n                ret[1] = ret[1].(int) + 1\n            }\n        }\n   \
    \ }\n    return ret\n}\n", "    var evenCount int\n    var oddCount int\n    for\
    \ i := 1; i <= n; i++ {\n        num := i\n        reverse := 0\n        for num\
    \ > 0 {\n            remainder := num % 10\n            reverse = reverse * 10\
    \ + remainder\n            num /= 10\n        }\n        if reverse == i {\n \
    \           fmt.Println(i)\n            if reverse % 2 == 0 {\n              \
    \  evenCount++\n            } else {\n                oddCount++\n           \
    \ }\n        }\n    }\n    return []interface{}{evenCount, oddCount}\n}\n", " \
    \   if n < 1 || n > 1000 {\n        return nil\n    }\n    odd, even := 0, 0\n\
    \    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if\
    \ i % 2 == 0 {\n                even++\n            } else {\n               \
    \ odd++\n            }\n        }\n    }\n    return []interface{}{even, odd}\n\
    }\n", "    // 1. calculate how many palindromes in range (1, n)\n    // 2. how\
    \ many even number among all palindromes\n    // 3. how many odd number among\
    \ all palindromes\n    var even_num int\n    var odd_num int\n    for i := 1;\
    \ i <= n; i++ {\n        if i%2 == 0 {\n            if is_palindrome(i) {\n  \
    \              even_num++\n            }\n        } else {\n            if is_palindrome(i)\
    \ {\n                odd_num++\n            }\n        }\n    }\n    return []interface{}{even_num,\
    \ odd_num}\n}\n", "    even_count := 0\n    odd_count := 0\n    for i := 1; i\
    \ <= n; i++ {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n  \
    \              even_count += 1\n            } else {\n                odd_count\
    \ += 1\n            }\n        }\n    }\n    return []interface{}{even_count,\
    \ odd_count}\n}\n", "    var cnt_even, cnt_odd int\n    var res []interface{}\n\
    \    for i := 1; i <= n; i++ {\n        if i % 10 == 0 {\n            continue\n\
    \        }\n        var i_r int\n        for ii := i; ii > 0; ii /= 10 {\n   \
    \         i_r = i_r * 10 + ii % 10\n        }\n        if i == i_r {\n       \
    \     if i % 2 == 0 {\n                cnt_even++\n            } else {\n    \
    \            cnt_odd++\n            }\n        }\n    }\n    res = append(res,\
    \ cnt_even, cnt_odd)\n    return res\n}\n", "    if n < 1 || n > 1000 {\n    \
    \    return nil\n    }\n    even := 0\n    odd := 0\n    for i := 1; i <= n; i++\
    \ {\n        if is_palindrome(i) {\n            if i % 2 == 0 {\n            \
    \    even += 1\n            } else {\n                odd += 1\n            }\n\
    \        }\n    }\n    return []interface{}{even, odd}\n}\n", "    // Write your\
    \ code here\n    return nil\n}\n", "    // Write your code here\n    evens :=\
    \ 0\n    odds := 0\n    for i := 1; i <= n; i++ {\n        if IsPalindrome(i)\
    \ {\n            if i % 2 == 0 {\n                evens++\n            } else\
    \ {\n                odds++\n            }\n        }\n    }\n    return []interface{}{evens,\
    \ odds}\n}\n", "    if n < 1 || n > 1000 {\n        return nil\n    }\n    oddCount\
    \ := 0\n    evenCount := 0\n    res := make([]interface{}, 2)\n    for i := 1;\
    \ i <= n; i++ {\n        if isPalindrome(i) {\n            if i % 2 == 0 {\n \
    \               evenCount += 1\n            } else {\n                oddCount\
    \ += 1\n            }\n        }\n    }\n    res[0] = evenCount\n    res[1] =\
    \ oddCount\n    return res\n}\n", "    var even, odd int\n\n    if n <= 1 {\n\
    \        return []interface{}{even, odd}\n    }\n\n    for i := 1; i <= n; i++\
    \ {\n        if is_palindrome(i) {\n            if i%2 == 0 {\n              \
    \  even++\n            } else {\n                odd++\n            }\n      \
    \  }\n    }\n\n    return []interface{}{even, odd}\n}\n", "    even_count := 0\n\
    \    odd_count := 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even_count += 1\n          \
    \  } else {\n                odd_count += 1\n            }\n        }\n    }\n\
    \    return []interface{}{even_count, odd_count}\n}\n", "    evens := 0\n    odds\
    \ := 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n       \
    \     if is_even(i) {\n                evens += 1\n            } else {\n    \
    \            odds += 1\n            }\n        }\n    }\n    return []interface{}{evens,\
    \ odds}\n}\n", "    var even, odd int\n    for i := 1; i <= n; i++ {\n       \
    \ if i % 2 == 0 {\n            even++\n        } else {\n            odd++\n \
    \       }\n    }\n    return []interface{}{even, odd}\n}\n", "    evens := 0\n\
    \    odds := 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n\
    \            if i % 2 == 0 {\n                evens += 1\n            } else {\n\
    \                odds += 1\n            }\n        }\n    }\n    return []interface{}{evens,\
    \ odds}\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
