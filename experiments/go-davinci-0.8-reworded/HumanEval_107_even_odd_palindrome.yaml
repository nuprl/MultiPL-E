name: HumanEval_107_even_odd_palindrome
language: go_test.go
prompt: "package even_odd_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
  \n)\n\n// Given a positive integer n, return a list that has the number of even\
  \ and odd\n// integer palindromes that fall within the range(1, n), inclusive.\n\
  // Example 1:\n// >>> even_odd_palindrome(3)\n// []interface{}{1, 2}\n// Explanation:\n\
  // Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\
  // Example 2:\n// >>> even_odd_palindrome(12)\n// []interface{}{4, 6}\n// Explanation:\n\
  // Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even,\
  \ and 6 of them are odd.\n// Note:\n// 1. 1 <= n <= 10^3\n// 2. returned list has\
  \ the number of even and odd integer palindromes respectively.\nfunc even_odd_palindrome(n\
  \ int) []interface{} {\n"
tests: "func TestEven_Odd_Palindrome(t *testing.T) {\n  candidate := even_odd_palindrome\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(123), expected: []interface{}{8,\
  \ 13} },\n     { actual: candidate(12), expected: []interface{}{4, 6} },\n     {\
  \ actual: candidate(3), expected: []interface{}{1, 2} },\n     { actual: candidate(63),\
  \ expected: []interface{}{6, 8} },\n     { actual: candidate(25), expected: []interface{}{5,\
  \ 6} },\n     { actual: candidate(19), expected: []interface{}{4, 6} },\n     {\
  \ actual: candidate(9), expected: []interface{}{4, 5} },\n     { actual: candidate(1),\
  \ expected: []interface{}{0, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    // Write your code here\n    return nil\n}\n", "    var even, odd\
    \ int\n\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n      \
    \      if i % 2 == 0 {\n                even++\n            } else {\n       \
    \         odd++\n            }\n        }\n    }\n\n    return []interface{}{even,\
    \ odd}\n}\n", "    m := map[int]int{0: 0, 1: 0}\n    for i := 1; i <= n; i++ {\n\
    \        // fmt.Println(i)\n        s := fmt.Sprintf(\"%d\", i)\n        if len(s)\
    \ == 1 {\n            // fmt.Println(\"d\", s)\n            m[i % 2]++\n     \
    \   } else if len(s) % 2 == 0 {\n            s_slice := make([]byte, len(s) /\
    \ 2)\n            for j := 0; j < len(s_slice); j++ {\n                s_slice[j]\
    \ = s[j]\n            }\n            s_sub := fmt.Sprintf(\"%s\", s_slice)\n \
    \           fmt.Println(\"e\", s, s_sub)\n            if s_sub == string(s[len(s)\
    \ / 2:]) {\n                m[i % 2]++\n            }\n        } else {\n    \
    \        s_slice := make([]byte, len(s) / 2)\n            for j := 0; j < len(s_slice);\
    \ j++ {\n                s_slice[j] = s[j]\n            }\n            s_sub :=\
    \ fmt.Sprintf(\"%s\", s_slice)\n            fmt.Println(\"o\", s, s_sub)\n   \
    \         if s_sub == string(s[len(s) / 2 + 1:]) {\n                m[i % 2]++\n\
    \            }\n        }\n    }\n    return []interface{}{m[0], m[1]}\n}\n",
  "    if n < 1 || n > 10 ^ 3 {\n        return nil\n    }\n    result := make([]interface{},\
    \ 2)\n    var even, odd int\n    for i := 1; i <= n; i++ {\n        s := fmt.Sprintf(\"\
    %d\", i)\n        isPalindrome := true\n        for i := 0; i < len(s) / 2; i++\
    \ {\n            if s[i] != s[len(s) - 1 - i] {\n                isPalindrome\
    \ = false\n                break\n            }\n        }\n        if isPalindrome\
    \ {\n            if i % 2 == 0 {\n                even++\n            } else {\n\
    \                odd++\n            }\n        }\n    }\n    result[0] = even\n\
    \    result[1] = odd\n    return result\n}\n", "    even, odd := 0, 0\n    for\
    \ i := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if i % 2 ==\
    \ 0 {\n                even++\n            } else {\n                odd++\n \
    \           }\n        }\n    }\n    return []interface{}{even, odd}\n}\n", " \
    \   r := make([]interface{}, 2)\n    even := 1\n    odd := 0\n    for i := 1;\
    \ i <= n; i++ {\n        if is_palindrome(i) {\n            if is_even(i) {\n\
    \                even += 1\n            } else {\n                odd += 1\n \
    \           }\n        }\n    }\n    r[0] = even\n    r[1] = odd\n    return r\n\
    }\n", "    // TODO: implement this function\n    return nil\n}\n", "    even :=\
    \ 0\n    odd := 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if is_even(i) {\n                even++\n            } else {\n\
    \                odd++\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    // even_palindrome, odd_palindrome := 0, 0\n    even_palindrome,\
    \ odd_palindrome := 0, 0\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even_palindrome++\n        \
    \    } else {\n                odd_palindrome++\n            }\n        }\n  \
    \  }\n    return []interface{}{even_palindrome, odd_palindrome}\n}\n", "    e,\
    \ o := 0, 0\n    if n == 1 {\n        return []interface{}{0, 1}\n    } else if\
    \ n == 2 {\n        return []interface{}{1, 1}\n    } else if n == 3 {\n     \
    \   return []interface{}{1, 2}\n    } else if n == 4 {\n        return []interface{}{2,\
    \ 2}\n    } else if n == 5 {\n        return []interface{}{2, 3}\n    } else if\
    \ n == 6 {\n        return []interface{}{3, 3}\n    } else if n == 7 {\n     \
    \   return []interface{}{3, 4}\n    } else if n == 8 {\n        return []interface{}{4,\
    \ 4}\n    } else if n == 9 {\n        return []interface{}{4, 5}\n    } else if\
    \ n == 10 {\n        return []interface{}{5, 5}\n    } else if n == 11 {\n   \
    \     return []interface{}{5, 6}\n    } else if n == 12 {\n        return []interface{}{6,\
    \ 6}\n    } else if n == 13 {\n        return []interface{}{6, 7}\n    } else\
    \ if n == 14 {\n        return []interface{}{7, 7}\n    } else if n == 15 {\n\
    \        return []interface{}{7, 8}\n    } else if n == 16 {\n        return []interface{}{8,\
    \ 8}\n    } else if n == 17 {\n        return []interface{}{8, 9}\n    } else\
    \ if n == 18 {\n        return []interface{}{9, 9}\n    } else if n == 19 {\n\
    \        return []interface{}{9, 10}\n    } else if n == 20 {\n        return\
    \ []interface{}{10, 10}\n    } else if n == 21 {\n        return []interface{}{10,\
    \ 11}\n    } else if n == 22 {\n        return []interface{}{11, 11}\n    } else\
    \ if n == 23 {\n        return []interface{}{11, 12}\n    } else if n == 24 {\n\
    \        return []interface{}{12, 12}\n    } else if n == 25 {\n        return\
    \ []interface{}{12, 13}\n    } else if", "    var even, odd int\n    for i :=\
    \ 1; i <= n; i++ {\n        if i < 10 {\n            even++\n        } else if\
    \ i % 10 == 0 {\n            odd++\n        } else {\n            r := reverse(i)\n\
    \            if r == i {\n                if i % 2 == 0 {\n                  \
    \  even++\n                } else {\n                    odd++\n             \
    \   }\n            }\n        }\n    }\n    return []interface{}{even, odd}\n\
    }\n", "    return []interface{}{even_odd_palindrome_even(n), even_odd_palindrome_odd(n)}\n\
    }\n", "    var even, odd int\n    for i := 1; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even++\n            } else {\n\
    \                odd++\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    even := 0\n    odd := 0\n    for i := 1; i <= n; i++ {\n  \
    \      if is_palindrome(i) {\n            if i % 2 == 0 {\n                even++\n\
    \            } else {\n                odd++\n            }\n        }\n    }\n\
    \    return []interface{}{even, odd}\n}\n", "    even, odd := 0, 0\n    for i\
    \ := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if i % 2 ==\
    \ 0 {\n                even++\n            } else {\n                odd++\n \
    \           }\n        }\n    }\n    return []interface{}{even, odd}\n}\n", " \
    \   // Number of odd palindromes with n digits is:\n    //\n    // [(1...9) +\
    \ (11...99) + (101...999) + ... + (10^n+1...10^(n+1)-1)] / 2\n    // = [10^n -\
    \ 1] / 2\n    //\n    // Number of even palindromes with n digits is:\n    //\
    \ [(11...99) + (101...999) + ... + (10^n+1...10^(n+1)-1)] / 2\n    // = (10^n\
    \ + 10^(n-1) - 1) / 2\n    //\n    // In order to avoid overflow, we don't directly\
    \ calculate the number of\n    // palindromes with n digits.\n    // Instead,\
    \ we calculate the number of palindromes <= n.\n    num_odd, num_even := 0, 0\n\
    \    for i := 1; i <= n; i *= 10 {\n        // max_n = i * 10 - 1.\n        //\
    \ If n <= max_n, we can safely add the number of palindromes with i\n        //\
    \ digits to num_odd and num_even.\n        max_n := i * 10 - 1\n        if n <=\
    \ max_n {\n            num_odd += (n - i + 1) / 2\n            num_even += (n\
    \ - i + 1) / 2\n            if n % 2 == 1 {\n                num_odd += 1\n  \
    \          }\n            if i % 2 == 0 {\n                num_even += 1\n   \
    \         }\n            break\n        }\n        // If n > max_n, we need to\
    \ subtract the number of palindromes > n from\n        // num_odd and num_even.\n\
    \        //\n        // For example, if n = 123, i = 10, we can safely add the\
    \ number of\n        // palindromes with one digit to num_odd and num_even.\n\
    \        // But we need to subtract the number of palindromes > 123 from num_odd\n\
    \        // and num_even.\n        // The number of palindromes > 123 with one\
    \ digit is 100 - 1 = 99.\n        //\n        // The number of palindromes with\
    \ i digits", "    if n <= 1 {\n        return []interface{}{0, 0}\n    }\n   \
    \ even, odd := 0, 0\n    for i := 0; i <= n; i++ {\n        if is_palindrome(i)\
    \ {\n            if i % 2 == 0 {\n                even += 1\n            } else\
    \ {\n                odd += 1\n            }\n        }\n    }\n    return []interface{}{even,\
    \ odd}\n}\n", "    var list []interface{}\n    var even, odd int\n\n    for i\
    \ := 1; i <= n; i++ {\n        if is_palindrome(i) {\n            if i % 2 ==\
    \ 0 {\n                even++\n            } else {\n                odd++\n \
    \           }\n        }\n    }\n\n    list = append(list, even)\n    list = append(list,\
    \ odd)\n\n    return list\n}\n", "    even := 0\n    odd := 0\n    for i := 1;\
    \ i <= n; i++ {\n        if is_palindrome(i) {\n            if is_even(i) {\n\
    \                even++\n            } else {\n                odd++\n       \
    \     }\n        }\n    }\n    return []interface{}{even, odd}\n}\n", "    evenCount\
    \ := 0\n    oddCount := 0\n    for i := 1; i <= n; i++ {\n        if isPalindrome(i)\
    \ {\n            if i % 2 == 0 {\n                evenCount++\n            } else\
    \ {\n                oddCount++\n            }\n        }\n    }\n    return []interface{}{evenCount,\
    \ oddCount}\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
