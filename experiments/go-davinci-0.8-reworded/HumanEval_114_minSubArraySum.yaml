name: HumanEval_114_minSubArraySum
language: go_test.go
prompt: "package minSubArraySum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
  \n// Given a list of integers nums, find the minimum sum of any non-empty sub-list\n\
  // of nums.\n// Example\n// >>> minSubArraySum([]int{2, 3, 4, 1, 2, 4})\n// 1\n\
  // >>> minSubArraySum([]int{-1, -2, -3})\n// -6\nfunc minSubArraySum(nums []int)\
  \ int {\n"
tests: "func TestMinsubarraysum(t *testing.T) {\n  candidate := minSubArraySum\n\t\
  type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n  \
  \ tests := []test{\n     { actual: candidate([]int{2, 3, 4, 1, 2, 4}), expected:\
  \ 1 },\n     { actual: candidate([]int{-1, -2, -3}), expected: -6 },\n     { actual:\
  \ candidate([]int{-1, -2, -3, 2, -10}), expected: -14 },\n     { actual: candidate([]int{-9999999999999999}),\
  \ expected: -9999999999999999 },\n     { actual: candidate([]int{0, 10, 20, 1000000}),\
  \ expected: 0 },\n     { actual: candidate([]int{-1, -2, -3, 10, -5}), expected:\
  \ -6 },\n     { actual: candidate([]int{100, -1, -2, -3, 10, -5}), expected: -6\
  \ },\n     { actual: candidate([]int{10, 11, 13, 8, 3, 4}), expected: 3 },\n   \
  \  { actual: candidate([]int{100, -33, 32, -1, 0, -2}), expected: -33 },\n     {\
  \ actual: candidate([]int{-10}), expected: -10 },\n     { actual: candidate([]int{7}),\
  \ expected: 7 },\n     { actual: candidate([]int{1, -1}), expected: -1 },\n   }\n\
  \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
  \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\",\
  \ tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
  \t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if len(nums) == 0 {\n        return 0\n    }\n    minSum := nums[0]\n\
    \    sum := 0\n    for _, n := range nums {\n        sum += n\n        if sum\
    \ < minSum {\n            minSum = sum\n        }\n        if sum > 0 {\n    \
    \        sum = 0\n        }\n    }\n    return minSum\n}\n", "    // O(n^2) time\n\
    \    // O(1) space\n    minSum := nums[0]\n    for i, _ := range nums {\n    \
    \    sum := 0\n        for j := i; j < len(nums); j++ {\n            sum += nums[j]\n\
    \            if sum < minSum {\n                minSum = sum\n            }\n\
    \        }\n    }\n    return minSum\n}\n", "    if len(nums) == 0 {\n       \
    \ return 0\n    }\n    minS := nums[0]\n    curS := nums[0]\n    for i := 1; i\
    \ < len(nums); i++ {\n        curS = max(nums[i], curS + nums[i])\n        minS\
    \ = min(minS, curS)\n    }\n    return minS\n}\n", "    var minSum int = nums[0]\n\
    \    var sum int = nums[0]\n    var i int = 1\n    var len int = len(nums)\n \
    \   for i < len {\n        sum += nums[i]\n        if sum < minSum {\n       \
    \     minSum = sum\n        }\n        if sum < 0 {\n            sum = 0\n   \
    \     }\n        i += 1\n    }\n    return minSum\n}\n", "    m := nums[0]\n \
    \   sum := nums[0]\n    for i := 1; i < len(nums); i++ {\n        sum += nums[i]\n\
    \        if sum < m {\n            m = sum\n        }\n        if sum < 0 {\n\
    \            sum = 0\n        }\n    }\n    return m\n}\n", "    sum := 0\n  \
    \  minSum := 0\n    for _, num := range nums {\n        sum += num\n        if\
    \ sum < minSum {\n            minSum = sum\n        }\n    }\n    return minSum\n\
    }\n", "    if len(nums) == 0 {\n        return 0\n    }\n    min, csum := nums[0],\
    \ nums[0]\n    for i := 1; i < len(nums); i++ {\n        csum = minInt(csum +\
    \ nums[i], nums[i])\n        min = minInt(min, csum)\n    }\n    return min\n\
    }\n", "    n := len(nums)\n    var minSum, curSum int\n    if n == 0 {\n     \
    \   return minSum\n    }\n    minSum = nums[0]\n    curSum = minSum\n    for i\
    \ := 1; i < n; i++ {\n        if curSum < 0 {\n            curSum = nums[i]\n\
    \        } else {\n            curSum += nums[i]\n        }\n        if curSum\
    \ < minSum {\n            minSum = curSum\n        }\n    }\n    return minSum\n\
    }\n", "    if len(nums) == 0 {\n        return 0\n    }\n    min := nums[0]\n\
    \    sum := 0\n    for _, num := range nums {\n        sum += num\n        if\
    \ sum < min {\n            min = sum\n        }\n        if sum > 0 {\n      \
    \      sum = 0\n        }\n    }\n    return min\n}\n", "    if len(nums) < 1\
    \ {\n        return 0\n    }\n    minSum := nums[0]\n    for _, v := range nums\
    \ {\n        if v < minSum {\n            minSum = v\n        }\n    }\n    currentSum\
    \ := minSum\n    for i, v := range nums {\n        currentSum = v\n        for\
    \ j := i + 1; j < len(nums); j++ {\n            currentSum += nums[j]\n      \
    \      if currentSum < minSum {\n                minSum = currentSum\n       \
    \     }\n        }\n    }\n    return minSum\n}\n", "    minSum := nums[0]\n \
    \   for i := 0; i < len(nums); i++ {\n        if nums[i] < minSum {\n        \
    \    minSum = nums[i]\n        }\n        sum := nums[i]\n        for j := i +\
    \ 1; j < len(nums); j++ {\n            sum += nums[j]\n            if sum < minSum\
    \ {\n                minSum = sum\n            }\n        }\n    }\n    return\
    \ minSum\n}\n", "    if len(nums) == 0 {\n        return 0\n    }\n    min_sum\
    \ := nums[0]\n    for i := 0; i < len(nums); i++ {\n        sum := 0\n       \
    \ for j := i; j < len(nums); j++ {\n            sum += nums[j]\n            if\
    \ sum < min_sum {\n                min_sum = sum\n            }\n        }\n \
    \   }\n    return min_sum\n}\n", "    var (\n        minSum int\n        minLen\
    \ int\n        total  int\n        j      int\n    )\n    minSum = total = nums[0]\n\
    \    minLen = 1\n    for i := 1; i < len(nums); i++ {\n        total += nums[i]\n\
    \        if total < minSum {\n            minSum = total\n            minLen =\
    \ i + 1\n        }\n        if total > 0 {\n            total = 0\n          \
    \  j = i + 1\n        }\n    }\n    fmt.Println(nums[j:minLen])\n    return minSum\n\
    }\n", "    if len(nums) == 0 {\n        return 0\n    }\n    min := nums[0]\n\
    \    for i := 0; i < len(nums); i++ {\n        sum := 0\n        for j := i; j\
    \ < len(nums); j++ {\n            sum += nums[j]\n            if sum < min {\n\
    \                min = sum\n            }\n        }\n    }\n    return min\n\
    }\n", "    if len(nums) == 0 {\n        return 0\n    }\n    min := nums[0]\n\
    \    sum := 0\n    for _, v := range nums {\n        sum += v\n        if sum\
    \ < min {\n            min = sum\n        }\n        if sum > 0 {\n          \
    \  sum = 0\n        }\n    }\n    return min\n}\n", "    sum := 0\n    minSum\
    \ := 1 << 31\n    for _, n := range nums {\n        sum += n\n        if sum <\
    \ minSum {\n            minSum = sum\n        }\n        if sum > 0 {\n      \
    \      sum = 0\n        }\n    }\n    return minSum\n}\n", "    if len(nums) ==\
    \ 0 {\n        return 0\n    }\n    min := nums[0]\n    max := nums[0]\n    sum\
    \ := nums[0]\n    for i := 1; i < len(nums); i++ {\n        if nums[i] < min {\n\
    \            min = nums[i]\n        }\n        if nums[i] > max {\n          \
    \  max = nums[i]\n        }\n        sum += nums[i]\n    }\n    if min >= 0 {\n\
    \        return min\n    }\n    if max <= 0 {\n        return max\n    }\n   \
    \ min = sum\n    for i := 0; i < len(nums); i++ {\n        sum = 0\n        for\
    \ j := i; j < len(nums); j++ {\n            sum += nums[j]\n            if sum\
    \ < min {\n                min = sum\n            }\n        }\n    }\n    return\
    \ min\n}\n", "    minSum := nums[0]\n    currentSum := 0\n    for _, value :=\
    \ range nums {\n        currentSum += value\n        if currentSum < minSum {\n\
    \            minSum = currentSum\n        }\n        if currentSum > 0 {\n   \
    \         currentSum = 0\n        }\n    }\n    return minSum\n}\n", "    if len(nums)\
    \ == 0 {\n        return 0\n    }\n    minSum := nums[0]\n    total := nums[0]\n\
    \    for i := 1; i < len(nums); i++ {\n        if total < 0 {\n            total\
    \ = nums[i]\n        } else {\n            total += nums[i]\n        }\n     \
    \   if total < minSum {\n            minSum = total\n        }\n    }\n    return\
    \ minSum\n}\n", "    var (\n        curSum, minSum = 0, nums[0]\n    )\n    for\
    \ _, v := range nums {\n        curSum += v\n        if minSum > curSum {\n  \
    \          minSum = curSum\n        }\n        if curSum > 0 {\n            curSum\
    \ = 0\n        }\n    }\n    return minSum\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
