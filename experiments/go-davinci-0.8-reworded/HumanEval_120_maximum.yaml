name: HumanEval_120_maximum
language: go_test.go
prompt: "package maximum_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given\
  \ a list arr of integers and a positive integer k, return a sorted list \n// of\
  \ length k with the maximum k numbers in arr.\n// Example 1:\n// >>> maximum([]int{-3,\
  \ -4, 5}, 3)\n// []int{-4, -3, 5}\n// Example 2:\n// >>> maximum([]int{4, -4, 4},\
  \ 2)\n// []int{4, 4}\n// Example 3:\n// >>> maximum([]int{-3, 2, 1, 2, -1, -2, 1},\
  \ 1)\n// []int{2}\n// Note:\n// 1. The length of the list will be in the range of\
  \ [1, 1000].\n// 2. The elements in the list will be in the range of [-1000, 1000].\n\
  // 3. 0 <= k <= len(arr)\nfunc maximum(arr []int, k int) []int {\n"
tests: "func TestMaximum(t *testing.T) {\n  candidate := maximum\n\ttype test struct\
  \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
  \     { actual: candidate([]int{-3, -4, 5}, 3), expected: []int{-4, -3, 5} },\n\
  \     { actual: candidate([]int{4, -4, 4}, 2), expected: []int{4, 4} },\n     {\
  \ actual: candidate([]int{-3, 2, 1, 2, -1, -2, 1}, 1), expected: []int{2} },\n \
  \    { actual: candidate([]int{123, -123, 20, 0, 1, 2, -3}, 3), expected: []int{2,\
  \ 20, 123} },\n     { actual: candidate([]int{-123, 20, 0, 1, 2, -3}, 4), expected:\
  \ []int{0, 1, 2, 20} },\n     { actual: candidate([]int{5, 15, 0, 3, -13, -8, 0},\
  \ 7), expected: []int{-13, -8, 0, 0, 3, 5, 15} },\n     { actual: candidate([]int{-1,\
  \ 0, 2, 5, 3, -10}, 2), expected: []int{3, 5} },\n     { actual: candidate([]int{1,\
  \ 0, 5, -7}, 1), expected: []int{5} },\n     { actual: candidate([]int{4, -4}, 2),\
  \ expected: []int{-4, 4} },\n     { actual: candidate([]int{-10, 10}, 2), expected:\
  \ []int{-10, 10} },\n     { actual: candidate([]int{1, 2, 3, -23, 243, -400, 0},\
  \ 0), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    n := len(arr)\n    if n <= k {\n        return arr\n    }\n   \
    \ return quickSelect(arr, 0, n - 1, n - k)\n}\n", "    // TODO\n    return []int{}\n\
    }\n", "    // Write your code here.\n    n := len(arr)\n    ans := make([]int,\
    \ 0)\n    for i := 0; i < k; i++ {\n        idx := i\n        for j := i; j <\
    \ n; j++ {\n            if arr[j] > arr[idx] {\n                idx = j\n    \
    \        }\n        }\n        ans = append(ans, arr[idx])\n        if idx !=\
    \ i {\n            arr[i], arr[idx] = arr[idx], arr[i]\n        }\n    }\n   \
    \ return ans\n}\n", "    // TODO: implement!\n    return nil\n}\n", "    if len(arr)\
    \ == k {\n        return arr\n    }\n    indexes := make([]int, 0, k)\n    for\
    \ i, val := range arr {\n        if len(indexes) < k {\n            indexes =\
    \ append(indexes, i)\n        } else {\n            minIndex := 0\n          \
    \  for j, index := range indexes {\n                if arr[index] < arr[indexes[minIndex]]\
    \ {\n                    minIndex = j\n                }\n            }\n    \
    \        if val > arr[indexes[minIndex]] {\n                indexes[minIndex]\
    \ = i\n            }\n        }\n    }\n    ret := make([]int, k)\n    for i,\
    \ index := range indexes {\n        ret[i] = arr[index]\n    }\n    return ret\n\
    }\n", "    // Assume k <= len(arr)\n    l := len(arr)\n    max := make([]int,\
    \ k)\n    for i := 0; i < k; i++ {\n        max[i] = -1000\n    }\n    for i :=\
    \ 0; i < l; i++ {\n        if arr[i] > max[0] {\n            max[0] = arr[i]\n\
    \            max = trickleDown(max, 0)\n        }\n    }\n    return max\n}\n",
  "    size := len(arr)\n    if size <= k {\n        return arr\n    }\n    if k ==\
    \ 0 {\n        return []int{}\n    }\n    if k == 1 {\n        max := arr[0]\n\
    \        for i := 1; i < size; i++ {\n            if arr[i] > max {\n        \
    \        max = arr[i]\n            }\n        }\n        return []int{max}\n \
    \   }\n    sorted := make([]int, k)\n    copy(sorted, arr[:k])\n    quickSort(sorted,\
    \ 0, k-1)\n    for i := k; i < size; i++ {\n        if arr[i] < sorted[k-1] {\n\
    \            continue\n        }\n        sorted[k-1] = arr[i]\n        quickSort(sorted,\
    \ 0, k-1)\n    }\n    return sorted\n}\n", "    // Bubble sort algorithm\n   \
    \ // O(n^2) in worst and average case, O(n) in best case.\n    // The algorithm\
    \ is stable and adaptive.\n    l := len(arr)\n    if l <= 1 {\n        return\
    \ arr\n    }\n    if k > l {\n        k = l\n    }\n    for i := 0; i < k; i++\
    \ {\n        for j := 0; j < l-i-1; j++ {\n            if arr[j] < arr[j+1] {\n\
    \                tmp := arr[j]\n                arr[j] = arr[j+1]\n          \
    \      arr[j+1] = tmp\n            }\n        }\n    }\n    return arr[:k]\n}\n",
  "    max := []int{}\n    for i, v := range arr {\n        if len(max) == 0 {\n \
    \           max = append(max, v)\n        } else {\n            if len(max) <\
    \ k {\n                for j, u := range max {\n                    if v >= u\
    \ {\n                        max = append(max, 0)\n                        copy(max[j+1:],\
    \ max[j:])\n                        max[j] = v\n                        break\n\
    \                    }\n                }\n            } else {\n            \
    \    if v > max[0] {\n                    max = append(max, 0)\n             \
    \       copy(max[1:], max[:])\n                    max[0] = v\n              \
    \  }\n            }\n        }\n        fmt.Println(max)\n    }\n    if len(max)\
    \ > k {\n        max = max[:k]\n    }\n    return max\n}\n", "    var result []int\n\
    \    if len(arr) == 0 {\n        return result\n    }\n    if k > len(arr) {\n\
    \        k = len(arr)\n    }\n    maxK := len(arr) - k\n    for i := 0; i < k;\
    \ i++ {\n        var pos int\n        curr := arr[0]\n        for j := 1; j <\
    \ len(arr); j++ {\n            if arr[j] > curr {\n                curr = arr[j]\n\
    \                pos = j\n            }\n        }\n        result = append(result,\
    \ curr)\n        arr = append(arr[:pos], arr[pos+1:]...)\n    }\n    return result\n\
    }\n", "    nums := map[int]int{}\n    for _, num := range arr {\n        nums[num]\
    \ += 1\n    }\n    keys := make([]int, 0, len(nums))\n    for key := range nums\
    \ {\n        keys = append(keys, key)\n    }\n    quicksort(keys, 0, len(keys)\
    \ - 1)\n    result := make([]int, 0, k)\n    for i := len(keys) - 1; i >= 0; i--\
    \ {\n        num := keys[i]\n        counter := nums[num]\n        for j := 0;\
    \ j < counter; j++ {\n            result = append(result, num)\n            if\
    \ len(result) == k {\n                return result\n            }\n        }\n\
    \    }\n    return result\n}\n", "    if len(arr) <= k {\n        return arr\n\
    \    }\n    new_arr := make([]int, k)\n    for i := 0; i < k; i++ {\n        new_arr[i]\
    \ = arr[i]\n    }\n    new_arr = quickSort(new_arr)\n    fmt.Println(new_arr)\n\
    \    for i := k; i < len(arr); i++ {\n        if arr[i] > new_arr[0] {\n     \
    \       new_arr[0] = arr[i]\n            new_arr = quickSort(new_arr)\n      \
    \  }\n    }\n    return new_arr\n}\n", "    // Corner Cases\n    if len(arr) ==\
    \ 0 {\n        return []int{}\n    }\n    if k >= len(arr) {\n        return arr\n\
    \    }\n    // A \"heap\" can be used here.\n    // A heap is used for sorting\
    \ elements.\n    // The heap stores the elements in order.\n    // This means\
    \ that the minimum value is always the first\n    // element in the heap.\n  \
    \  // For a maximum heap, the maximum value is always the first\n    // element\
    \ in the heap.\n    // The first step is to initialize the heap with the first\
    \ k elements\n    // from the list arr.\n    // In this case, we use a maximum\
    \ heap.\n    // This means that the first element in the heap is the maximum value\n\
    \    // in the heap.\n    // As new elements are added to the heap, they are compared\
    \ to the maximum\n    // value.\n    // If the element added is less than the\
    \ maximum value, then it is discarded.\n    // If the element added is greater\
    \ than the maximum value, then the maximum value\n    // is removed from the heap\
    \ and the new element is added.\n    // This ensures that the heap is always of\
    \ size k, and that the elements\n    // in the heap are sorted in descending order.\n\
    \    // The elements in the heap can then be appended to a list, which will\n\
    \    // be returned.\n    // The time complexity for this algorithm is O(n * log(k)).\n\
    \    // The space complexity for this algorithm is O(k).\n    heap := new(MaxHeap)\n\
    \    heap.Init(arr[:k])\n    for i := k; i < len(arr); i++ {\n        if heap.GetMax()\
    \ < arr[i] {\n            heap.RemoveMax()\n            heap.Add(arr[i])\n   \
    \     }\n    }\n    return heap.HeapToList()\n}\n\ntype MaxHeap ", "    if k >\
    \ len(arr) {\n        k = len(arr)\n    }\n    larr := len(arr)\n    for i :=\
    \ 0; i < k; i++ {\n        for j := i; j < larr; j++ {\n            if arr[i]\
    \ < arr[j] {\n                arr[i], arr[j] = arr[j], arr[i]\n            }\n\
    \        }\n    }\n    return arr[:k]\n}\n", "    // \u8FD9\u662F\u4E00\u4E2A\u7B80\
    \u5355\u7684\u9898\u76EE\uFF0C\u7528\u63D2\u5165\u6392\u5E8F\u5C31\u53EF\u4EE5\
    \uFF0C\u4E0D\u8FC7\u7B97\u6CD5\u6BD4\u8F83\u590D\u6742\n    // \u53EF\u4EE5\u7528\
    \u5FEB\u6392\u7B97\u6CD5\u6765\u5B9E\u73B0\n    // \u6211\u4EEC\u53EA\u9700\u8981\
    \u5BF9\u6570\u7EC4\u7684\u524Dk\u4E2A\u5143\u7D20\u8FDB\u884C\u6392\u5E8F\u5C31\
    \u53EF\u4EE5\n    // \u5148\u627E\u51FA\u524Dk\u4E2A\u5143\u7D20\u7684\u6700\u5C0F\
    \u503C\u7684\u7D22\u5F15\n    // \u5982\u679C\u63A5\u4E0B\u6765\u7684\u5143\u7D20\
    \u5927\u4E8E\u6700\u5C0F\u503C\uFF0C\u5C31\u66FF\u6362\uFF0C\u5E76\u91CD\u65B0\
    \u8BA1\u7B97\u6700\u5C0F\u503C\u7684\u7D22\u5F15\n    // \u5426\u5219\u8DF3\u8FC7\
    \n    // \u6700\u540E\uFF0C\u6211\u4EEC\u5C31\u5F97\u5230\u4E86\u524Dk\u4E2A\u6700\
    \u5927\u7684\u6570\u5B57\u4E86\n\n    var minIndex int\n    for i := 0; i < k;\
    \ i++ {\n        if arr[i] > arr[minIndex] {\n            minIndex = i\n     \
    \   }\n    }\n\n    for i := k; i < len(arr); i++ {\n        if arr[i] > arr[minIndex]\
    \ {\n            arr[minIndex] = arr[i]\n            minIndex = 0\n          \
    \  for j := 0; j < k; j++ {\n                if arr[j] < arr[minIndex] {\n   \
    \                 minIndex = j\n                }\n            }\n        }\n\
    \    }\n\n    return arr[:k]\n}\n", "    if len(arr) == 0 {\n        return []int{}\n\
    \    }\n\n    if k == 0 {\n        return []int{}\n    }\n\n    if k >= len(arr)\
    \ {\n        return arr\n    }\n\n    partition := arr[len(arr)-1]\n    left :=\
    \ make([]int, 0)\n    right := make([]int, 0)\n    for i := 0; i < len(arr)-1;\
    \ i++ {\n        if arr[i] > partition {\n            left = append(left, arr[i])\n\
    \        } else {\n            right = append(right, arr[i])\n        }\n    }\n\
    \n    if len(left) >= k {\n        return maximum(left, k)\n    }\n\n    if len(left)\
    \ == k-1 {\n        return append(left, partition)\n    }\n\n    return append(maximum(left,\
    \ k-1-len(right)), append([]int{partition}, maximum(right, k-1-len(left))...)...)\n\
    }\n", "    var output []int\n    // var max int\n    // var maxIndex int\n   \
    \ // var newIndex int\n    // var subSlice []int\n    // var arrLen int = len(arr)\n\
    \    // var i int = 0\n    // var j int = 0\n    // var found bool = false\n \
    \   // for i=0; i<k; i++ {\n    //     max = arr[i]\n    //     maxIndex = i\n\
    \    //     for j=i+1; j<arrLen; j++ {\n    //         if arr[j] > max {\n   \
    \ //             max = arr[j]\n    //             maxIndex = j\n    //       \
    \  }\n    //     }\n    //     fmt.Println(\"max:\", max)\n    //     output =\
    \ append(output, max)\n    //     found = false\n    //     subSlice = arr[i:arrLen]\n\
    \    //     fmt.Println(\"subSlice:\", subSlice)\n    //     fmt.Println(\"maxIndex:\"\
    , maxIndex)\n    //     for j=0; j<len(subSlice); j++ {\n    //         if !found\
    \ && j+i == maxIndex {\n    //             found = true\n    //             continue\n\
    \    //         }\n    //         if found {\n    //             arr[newIndex]\
    \ = subSlice[j]\n    //             newIndex++\n    //         }\n    //     }\n\
    \    //     fmt.Println(\"arr:\", arr)\n    // }\n    // return output\n    return\
    \ output\n}\n", "    // Write your code here.\n}\n", "    // TODO - Add your code\
    \ here\n    return nil\n}\n", "    if len(arr) == 0 {\n        return arr\n  \
    \  }\n    if k > len(arr) {\n        k = len(arr)\n    }\n    result := []int{}\n\
    \    for _, value := range arr {\n        if len(result) < k {\n            result\
    \ = append(result, value)\n        } else {\n            if result[0] < value\
    \ {\n                result = append(result, value)\n                maxIndex\
    \ := 0\n                for i := 1; i < len(result); i++ {\n                 \
    \   if result[i] > result[maxIndex] {\n                        maxIndex = i\n\
    \                    }\n                }\n                result = append(result[:maxIndex],\
    \ result[maxIndex+1:]...)\n            }\n        }\n    }\n    return result\n\
    }\n", "    return topK(arr, k)\n}\n", "    var result []int\n    for _, item :=\
    \ range arr {\n        for k > 0 && len(result) > 0 && result[len(result)-1] <\
    \ item {\n            result = result[:len(result)-1]\n            k--\n     \
    \   }\n        result = append(result, item)\n    }\n    return result[:k]\n}\n",
  "    length := len(arr)\n    if length == 0 {\n        return []int{}\n    }\n \
    \   if k >= length {\n        return arr\n    }\n    minimum := func(a, b int)\
    \ int {\n        if a < b {\n            return a\n        }\n        return b\n\
    \    }\n    max := minimum(k, length)\n    res := make([]int, max)\n    for i\
    \ := 0; i < max; i++ {\n        for j := 0; j < length-i-1; j++ {\n          \
    \  if arr[j] > arr[j+1] {\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n\
    \            }\n        }\n        res[max-i-1] = arr[length-i-1]\n    }\n   \
    \ return res\n}\n", "    size := len(arr)\n    if size == 0 {\n        return\
    \ arr\n    }\n\n    start, end := 0, k - 1\n    if k >= size {\n        start,\
    \ end = 0, size - 1\n    }\n    // fmt.Printf(\"start=%d, end=%d\\n\", start,\
    \ end)\n    for i := start; i <= end; i++ {\n        max_pos := i\n        for\
    \ j := i + 1; j <= end; j++ {\n            if arr[j] > arr[max_pos] {\n      \
    \          max_pos = j\n            }\n        }\n        // fmt.Printf(\"max_pos=%d\\\
    n\", max_pos)\n        arr[i], arr[max_pos] = arr[max_pos], arr[i]\n    }\n  \
    \  return arr[start:end+1]\n}\n", "    if k == 0 {\n        return []int{}\n \
    \   }\n\n    if k == len(arr) {\n        return arr\n    }\n\n    left, right\
    \ := 0, len(arr) - 1\n    pivot := left + (right - left) / 2\n    for left < right\
    \ {\n        pivot = partition(arr, left, right)\n        if pivot == k - 1 {\n\
    \            break\n        } else if pivot < k - 1 {\n            left = pivot\
    \ + 1\n        } else {\n            right = pivot - 1\n        }\n    }\n\n \
    \   return arr[:k]\n}\n", "    if len(arr) == 0 {\n        return []int{}\n  \
    \  }\n    if k <= 0 {\n        return []int{}\n    }\n    if k > len(arr) {\n\
    \        k = len(arr)\n    }\n    result := []int{}\n    for _, value := range\
    \ arr {\n        for i := 0; i < len(result); i++ {\n            if value >= result[i]\
    \ {\n                result = append(result, 0)\n                copy(result[i+1:],\
    \ result[i:])\n                result[i] = value\n                break\n    \
    \        }\n        }\n        if len(result) < k {\n            result = append(result,\
    \ value)\n        }\n    }\n    return result[:k]\n}\n", "    if len(arr) == k\
    \ {\n        return arr\n    }\n    var window []int\n    for _, item := range\
    \ arr {\n        for i := len(window) - 1; i >= 0; i-- {\n            if item\
    \ > window[i] {\n                window = append(window[:i], window[i+1:]...)\n\
    \            }\n        }\n        if len(window) < k {\n            window =\
    \ append(window, item)\n        }\n    }\n    return window\n}\n", "    res :=\
    \ make([]int, k)\n    copy(res, arr[:k])\n    min := min(res)\n    for i := k;\
    \ i < len(arr); i++ {\n        if arr[i] > min {\n            res[minIdx(res)]\
    \ = arr[i]\n            min = min(res)\n        }\n    }\n    return res\n}\n",
  "    if k <= 0 {\n        return []int{}\n    }\n    if k >= len(arr) {\n      \
    \  return arr\n    }\n    // a slice to store the minimum k elements in arr\n\
    \    s := make([]int, k)\n    // initialize the slice by the first k elements\
    \ in arr\n    for i := 0; i < k; i++ {\n        s[i] = arr[i]\n    }\n    // build\
    \ a max heap in the slice\n    for i := (k-2)/2; i >= 0; i-- {\n        maxHeapify(s,\
    \ i, k)\n    }\n    // replace the root of the heap by arr[k] if arr[k] is larger\
    \ than root\n    for i := k; i < len(arr); i++ {\n        if arr[i] > s[0] {\n\
    \            s[0] = arr[i]\n            maxHeapify(s, 0, k)\n        }\n    }\n\
    \    return s\n}\n", "    var res []int\n    for _, v := range arr {\n       \
    \ for len(res) > 0 && v > res[len(res)-1] && len(res) + len(arr) - 1 - k > 0 {\n\
    \            res = res[:len(res)-1]\n        }\n        if len(res) < k {\n  \
    \          res = append(res, v)\n        }\n    }\n    return res\n}\n", "   \
    \ // initialize length of output\n    var out []int\n    // loop through arr\n\
    \    for _, value := range arr {\n        out = append(out, value)\n        //\
    \ bubble sort out\n        for i := len(out) - 1; i > 0; i-- {\n            if\
    \ out[i - 1] < out[i] {\n                out[i - 1], out[i] = out[i], out[i -\
    \ 1]\n            }\n        }\n        // prune out if too big\n        if len(out)\
    \ > k {\n            out = out[1:]\n        }\n    }\n    return out\n}\n", " \
    \   // TODO: Implement this function\n    return []int{}\n}\n", "    if k == 0\
    \ {\n        return nil\n    }\n    if k == len(arr) {\n        return arr\n \
    \   }\n    maxArr := make([]int, k)\n    copy(maxArr, arr[:k])\n    quicksort(maxArr)\n\
    \    for i := k; i < len(arr); i++ {\n        if arr[i] > maxArr[0] {\n      \
    \      maxArr[0] = arr[i]\n            quicksort(maxArr)\n        }\n    }\n \
    \   return maxArr\n}\n", "    arrlen := len(arr)\n    if arrlen == 0 {\n     \
    \   return []int{}\n    }\n\n    sorted_arr := make([]int, arrlen)\n    copy(sorted_arr,\
    \ arr)\n    if arrlen <= k {\n        return bubbleSort(sorted_arr)\n    }\n \
    \   return bubbleSort(sorted_arr)[arrlen-k:]\n}\n", "    if k == 0 {\n       \
    \ return []int{}\n    }\n    var res []int\n    for i, num := range arr {\n  \
    \      for len(res) > 0 && num > res[len(res)-1] && len(res) + len(arr) - i -\
    \ 1 >= k {\n            res = res[:len(res)-1]\n        }\n        if len(res)\
    \ < k {\n            res = append(res, num)\n        }\n    }\n    return res\n\
    }\n", "    if k == 0 {\n        return []int{}\n    }\n\n    if k == len(arr)\
    \ {\n        return arr\n    }\n\n    // O(n log k) solution\n    // // create\
    \ a max heap of k elements\n    // heap := make([]int, k)\n    // for i := 0;\
    \ i < k; i++ {\n    //     heap[i] = arr[i]\n    // }\n    // heapify(heap)\n\n\
    \    // // go through the rest of the array and compare each element with the\
    \ top\n    // // element of the heap\n    // for i := k; i < len(arr); i++ {\n\
    \    //     if arr[i] > heap[0] {\n    //         heap[0] = arr[i]\n    //   \
    \      shiftDown(heap, 0)\n    //     }\n    // }\n\n    // return heap\n\n  \
    \  // O(n) solution with quicksort\n    qsort(arr, 0, len(arr) - 1)\n    return\
    \ arr[len(arr) - k:]\n}\n", "    if k <= 0 {\n        return []int{}\n    }\n\
    \    if k >= len(arr) {\n        return arr\n    }\n    q := make([]int, k)\n\
    \    for i := 0; i < k; i++ {\n        q[i] = arr[i]\n    }\n    for i := k; i\
    \ < len(arr); i++ {\n        if arr[i] <= q[0] {\n            continue\n     \
    \   }\n        j := 0\n        for ; arr[i] > q[j]; j++ {\n            if j <\
    \ k-1 {\n                q[j] = q[j+1]\n            }\n        }\n        q[j]\
    \ = arr[i]\n    }\n    return q\n}\n", "    n := len(arr)\n    if n == k {\n \
    \       return arr\n    }\n\n    heap := make([]int, k + 1)\n    copy(heap, arr[:k])\n\
    \    i := k / 2\n    for i >= 0 {\n        heapify(heap, i, k)\n        i--\n\
    \    }\n\n    for i = k; i < n; i++ {\n        if arr[i] > heap[0] {\n       \
    \     heap[0] = arr[i]\n            heapify(heap, 0, k)\n        }\n    }\n\n\
    \    return heap[1:]\n}\n", "    if k > len(arr) {\n        return arr\n    }\n\
    \n    res := make([]int, k)\n    for i := 0; i < k; i++ {\n        res[i] = arr[i]\n\
    \    }\n\n    BuildMaxHeap(res)\n    for i := k; i < len(arr); i++ {\n       \
    \ if arr[i] > res[0] {\n            res[0] = arr[i]\n            Heapify(res,\
    \ 0)\n        }\n    }\n\n    return res\n}\n", "    if len(arr) == 0 {\n    \
    \    return arr\n    }\n    for i := 0; i < k; i++ {\n        for j := 0; j <\
    \ len(arr) - i - 1; j++ {\n            if arr[j] > arr[j + 1] {\n            \
    \    arr[j], arr[j + 1] = arr[j + 1], arr[j]\n            }\n        }\n    }\n\
    \    return arr[len(arr) - k:]\n}\n", "    return arr\n}\n", "    size := len(arr)\n\
    \    if size == k {\n        return arr\n    }\n    if size == 0 {\n        return\
    \ []int{}\n    }\n    // define the queue to store the index\n    queue := make([]int,\
    \ k)\n    // initialize the queue\n    for i := 0; i < k; i++ {\n        queue[i]\
    \ = i\n    }\n    // sort the queue (greater than)\n    for i := 0; i < k - 1;\
    \ i++ {\n        for j := i + 1; j < k; j++ {\n            if arr[queue[i]] <\
    \ arr[queue[j]] {\n                queue[i], queue[j] = queue[j], queue[i]\n \
    \           }\n        }\n    }\n    // try to make the queue to be minimum \n\
    \    for i := k; i < size; i++ {\n        if arr[i] > arr[queue[k - 1]] {\n  \
    \          // find the position to insert\n            for j := 0; j < k; j++\
    \ {\n                if arr[i] > arr[queue[j]] {\n                    insert :=\
    \ j\n                    // insert position change the queue element\n       \
    \             for j := k - 1; j > insert; j-- {\n                        queue[j]\
    \ = queue[j - 1]\n                    }\n                    queue[insert] = i\n\
    \                    break\n                }\n            }\n        }\n    }\n\
    \    result := make([]int, k)\n    for i := 0; i < k; i++ {\n        result[i]\
    \ = arr[queue[i]]\n    }\n    return result\n}\n", "    // Return the maximum\
    \ k numbers in arr in sorted order.\n    if len(arr) == 0 {\n        return []int{}\n\
    \    }\n    result := make([]int, 0)\n    for _, x := range arr {\n        //\
    \ insert into sorted list\n        n := len(result)\n        if n == 0 {\n   \
    \         result = append(result, x)\n        } else {\n            if x < result[n-1]\
    \ {\n                result = append(result, x)\n            } else {\n      \
    \          i := 0\n                for i < n && x > result[i] {\n            \
    \        i++\n                }\n                result = append(result, 0)\n\
    \                copy(result[i+1:], result[i:])\n                result[i] = x\n\
    \            }\n        }\n        // trim\n        if n+1 > k {\n           \
    \ result = result[:k]\n        }\n    }\n    return result\n}\n", "    arrLen\
    \ := len(arr)\n    var ret = make([]int, k)\n    if arrLen <= k {\n        return\
    \ arr\n    }\n\n    for i := 0; i < k; i++ {\n        ret[i] = arr[i]\n    }\n\
    \n    heapSort(ret)\n\n    for i := k; i < arrLen; i++ {\n        if arr[i] >\
    \ ret[0] {\n            ret[0] = arr[i]\n            heapSort(ret)\n        }\n\
    \    }\n\n    return ret\n}\n", "    if len(arr) == 0 {\n        return []int{}\n\
    \    }\n    if k == 0 {\n        return []int{}\n    }\n    if k == 1 {\n    \
    \    max := arr[0]\n        maxIdx := 0\n        for i, val := range arr {\n \
    \           if val > max {\n                max = val\n                maxIdx\
    \ = i\n            }\n        }\n        return []int{max}\n    }\n    if k ==\
    \ len(arr) {\n        return arr\n    }\n    if k > len(arr) {\n        return\
    \ []int{}\n    }\n    maxIdx := 0\n    for i := 0; i < k; i++ {\n        maxIdx\
    \ = i\n        for j := i + 1; j < len(arr); j++ {\n            if arr[j] > arr[maxIdx]\
    \ {\n                maxIdx = j\n            }\n        }\n        tmp := arr[i]\n\
    \        arr[i] = arr[maxIdx]\n        arr[maxIdx] = tmp\n    }\n    return arr[:k]\n\
    }\n", "    n := len(arr)\n    if n <= k {\n        return arr\n    }\n    var\
    \ result []int\n    for i := 0; i < k; i++ {\n        maxIdx := i\n        for\
    \ j := i + 1; j < n; j++ {\n            if arr[j] > arr[maxIdx] {\n          \
    \      maxIdx = j\n            }\n        }\n        result = append(result, arr[maxIdx])\n\
    \        arr[maxIdx], arr[i] = arr[i], arr[maxIdx]\n    }\n    return result\n\
    }\n", "    if len(arr) == k {\n        return arr\n    }\n\n    idx := 0\n   \
    \ for i, e := range arr {\n        if e > arr[idx] {\n            idx = i\n  \
    \      }\n    }\n\n    arr[idx], arr[len(arr)-1] = arr[len(arr)-1], arr[idx]\n\
    \    return append(maximum(arr[:len(arr)-1], k), arr[len(arr)-1])\n}\n", "   \
    \ var ret []int\n    if k > len(arr) {\n        return ret\n    }\n    sorted\
    \ := insertionSort(arr)\n    ret = sorted[len(sorted)-k:]\n    return ret\n}\n",
  "    if len(arr) == 0 {\n        return []int{}\n    }\n    if k == 0 {\n      \
    \  return []int{}\n    }\n    if k >= len(arr) {\n        return arr\n    }\n\
    \    result := make([]int, k)\n    index := 0\n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] > result[0] {\n            if index < k {\n           \
    \     result[index] = arr[i]\n                index++\n            } else {\n\
    \                for j := 1; j < k; j++ {\n                    result[j - 1] =\
    \ result[j]\n                }\n                result[k - 1] = arr[i]\n     \
    \       }\n        }\n    }\n    for i := index; i < k; i++ {\n        result[i]\
    \ = result[index - 1]\n    }\n    return result\n}\n", "    if k == 0 {\n    \
    \    return []int{}\n    }\n    if k == len(arr) {\n        return arr\n    }\n\
    \    ans := make([]int, k)\n    for i := 0; i < k; i++ {\n        ans[i] = -1000000\n\
    \    }\n    for _, a := range arr {\n        if a > ans[0] {\n            ans[0]\
    \ = a\n            for i := 1; i < k; i++ {\n                if ans[i] < ans[i-1]\
    \ {\n                    ans[i], ans[i-1] = ans[i-1], ans[i]\n               \
    \ } else {\n                    break\n                }\n            }\n    \
    \    }\n    }\n    return ans\n}\n", "    for i := 0; i < k; i++ {\n        for\
    \ j := 0; j < len(arr) - i - 1; j++ {\n            if arr[j] > arr[j + 1] {\n\
    \                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n            }\n    \
    \    }\n    }\n    return arr[len(arr) - k:]\n}\n", "    if len(arr) == k {\n\
    \        return arr\n    }\n    if k == 0 {\n        return []int{}\n    }\n \
    \   res := make([]int, k)\n    for i := 0; i < k; i++ {\n        res[i] = arr[i]\n\
    \    }\n    for i := k; i < len(arr); i++ {\n        if arr[i] > res[0] {\n  \
    \          res[0] = arr[i]\n            heapSort(res)\n        }\n    }\n    return\
    \ res\n}\n", "    // Write your code here\n    if k == 0 {\n        return []int{}\n\
    \    }\n\n    if k == len(arr) {\n        return arr\n    }\n\n    // Time O(k)\n\
    \    heap := make([]int, k)\n    copy(heap, arr[:k])\n    buildHeap(heap)\n\n\
    \    // Time O(n-k)\n    for i := k; i < len(arr); i++ {\n        if arr[i] >\
    \ heap[0] {\n            heap[0] = arr[i]\n            heapify(heap, 0)\n    \
    \    }\n    }\n\n    return heap\n}\n", "    if k <= 0 {\n        return nil\n\
    \    }\n    length := len(arr)\n    result := make([]int, k)\n    for i := 0;\
    \ i < k; i++ {\n        min := arr[i]\n        for j := i; j < length; j++ {\n\
    \            if arr[j] > min {\n                min = arr[j]\n               \
    \ if j != i {\n                    arr[i], arr[j] = arr[j], arr[i]\n         \
    \       }\n            }\n        }\n        result[i] = min\n    }\n    return\
    \ result\n}\n", "    if len(arr) == 0 {\n        return []int{}\n    }\n    if\
    \ k >= len(arr) {\n        return arr\n    }\n    // minHeap := make(MinHeap,\
    \ k)\n    // for i := 0; i < k; i++ {\n    //     minHeap[i] = arr[i]\n    //\
    \ }\n    // heap.Init(&minHeap)\n    // for i := k; i < len(arr); i++ {\n    //\
    \     top := heap.Pop(&minHeap).(int)\n    //     if arr[i] > top {\n    //  \
    \       heap.Push(&minHeap, arr[i])\n    //     } else {\n    //         heap.Push(&minHeap,\
    \ top)\n    //     }\n    // }\n    // return minHeap.arr()\n    return quickSelect(arr,\
    \ k)\n}\n", "    n := len(arr)\n    if n == k {\n        return arr\n    }\n\n\
    \    result := make([]int, k)\n    // solution 1: \u5192\u6CE1\u6392\u5E8F\n \
    \   // solution 2: \u53CC\u5411\u961F\u5217\n    // solution 3: \u5806\u6392\u5E8F\
    \n    // solution 4: \u8BA1\u6570\u6392\u5E8F\n    // solution 5: \u5FEB\u901F\
    \u6392\u5E8F\n    quickSort(arr, 0, n - 1)\n    for i := 0; i < k; i++ {\n   \
    \     result[i] = arr[i]\n    }\n    return result\n}\n", "    if len(arr) ==\
    \ 0 {\n        return []int{}\n    }\n    max := k\n    result := make([]int,\
    \ k)\n    for i := 0; i < k; i++ {\n        result[i] = arr[i]\n    }\n    for\
    \ i := k; i < len(arr); i++ {\n        for j := k - 1; j >= 0; j-- {\n       \
    \     if result[j] < arr[i] {\n                result[j] = arr[i]\n          \
    \      fmt.Println(result)\n                return result\n            }\n   \
    \     }\n    }\n    return result\n}\n", "    return arr\n}\n", "    if k > len(arr)\
    \ {\n        return nil\n    }\n    var stack []int\n    var result []int\n  \
    \  for _, v := range arr {\n        for len(stack) > 0 && v > stack[len(stack)-1]\
    \ && len(stack)+len(arr)-k >= len(stack) {\n            stack = stack[:len(stack)-1]\n\
    \        }\n        if len(stack) < k {\n            stack = append(stack, v)\n\
    \        }\n    }\n    for i := 0; i < k; i++ {\n        result = append(result,\
    \ stack[len(stack)-1-i])\n    }\n    return result\n}\n", "    q := []int{}\n\
    \    for i := 0; i < len(arr); i++ {\n        for len(q) > 0 && len(q) + len(arr)\
    \ - i > k && arr[i] > q[0] {\n            q = q[1:]\n        }\n        if len(q)\
    \ < k {\n            q = append(q, arr[i])\n        }\n    }\n    return q\n}\n",
  "    if k == 0 {\n        return []int{}\n    }\n    if k == len(arr) {\n      \
    \  return arr\n    }\n    // Use max heap\n    heap := arr[:k]\n    for i := k\
    \ / 2 - 1; i >= 0; i-- {\n        heapify(heap, i, k)\n    }\n    for i := k;\
    \ i < len(arr); i++ {\n        if arr[i] > heap[0] {\n            heap[0] = arr[i]\n\
    \            heapify(heap, 0, k)\n        }\n    }\n    for i := 0; i < k / 2;\
    \ i++ {\n        temp := heap[i]\n        heap[i] = heap[k - 1 - i]\n        heap[k\
    \ - 1 - i] = temp\n    }\n    return heap\n}\n", "    var max []int\n    if k\
    \ > len(arr) {\n        return max\n    }\n    var tmp int\n    for i := 0; i\
    \ < k; i++ {\n        tmp = i\n        for j := i; j < len(arr); j++ {\n     \
    \       if arr[j] > arr[tmp] {\n                tmp = j\n            }\n     \
    \   }\n        arr[i], arr[tmp] = arr[tmp], arr[i]\n        max = append(max,\
    \ arr[i])\n    }\n    return max\n}\n", "    max := 0\n    var r []int\n    for\
    \ i := 0; i < k; i++ {\n        max = arr[i]\n        for j := i; j < len(arr);\
    \ j++ {\n            if arr[j] > max {\n                max = arr[j]\n       \
    \         arr[i], arr[j] = arr[j], arr[i]\n            }\n        }\n        r\
    \ = append(r, max)\n    }\n    return r\n}\n", "    m := arr[:k]\n    heapify(m)\n\
    \    for i := k; i < len(arr); i++ {\n        if arr[i] > m[0] {\n           \
    \ m[0] = arr[i]\n            heapify(m)\n        }\n    }\n    return m\n}\n",
  "    if k == 0 {\n        return []int{}\n    }\n\n    m := make([]int, k)\n   \
    \ for i := 0; i < k; i++ {\n        m[i] = arr[i]\n    }\n\n    for i := k; i\
    \ < len(arr); i++ {\n        min := m[0]\n        minIdx := 0\n        for j :=\
    \ 1; j < k; j++ {\n            if m[j] < min {\n                min = m[j]\n \
    \               minIdx = j\n            }\n        }\n        if arr[i] > min\
    \ {\n            m[minIdx] = arr[i]\n        }\n    }\n\n    for i := 0; i < k;\
    \ i++ {\n        min := m[i]\n        minIdx := i\n        for j := i+1; j < k;\
    \ j++ {\n            if m[j] < min {\n                min = m[j]\n           \
    \     minIdx = j\n            }\n        }\n        if minIdx != i {\n       \
    \     m[minIdx] = m[i]\n            m[i] = min\n        }\n    }\n\n    return\
    \ m\n}\n", "    if k == 0 {\n        return []int{}\n    }\n    if k >= len(arr)\
    \ {\n        return arr\n    }\n    r := make([]int, k)\n    copy(r, arr[:k])\n\
    \    return maximumReqursive(r, arr[k:])\n}\n", "    var tmp []int\n    if k >=\
    \ len(arr) {\n        return arr\n    }\n    for i := 0; i < k; i++ {\n      \
    \  tmp = append(tmp, arr[i])\n    }\n    tmp = qsort(tmp)\n    fmt.Println(tmp)\n\
    \    for i := k; i < len(arr); i++ {\n        if arr[i] > tmp[0] {\n         \
    \   tmp[0] = arr[i]\n            tmp = qsort(tmp)\n        }\n    }\n    return\
    \ tmp\n}\n", "    // Sort the list\n    for i := 0; i < len(arr); i++ {\n    \
    \    for j := i; j < len(arr); j++ {\n            if arr[i] < arr[j] {\n     \
    \           tmp := arr[i]\n                arr[i] = arr[j]\n                arr[j]\
    \ = tmp\n            }\n        }\n    }\n    // Return the first k elements\n\
    \    return arr[:k]\n}\n", "    if k == 0 {\n        return []int{}\n    }\n\n\
    \    l := len(arr)\n    if l <= k {\n        return arr\n    }\n\n    res := make([]int,\
    \ k)\n    lr := k - 1\n    for i := 0; i < k; i++ {\n        res[i] = arr[i]\n\
    \    }\n\n    for i := k; i < l; i++ {\n        // find the smallest number in\
    \ res, and replace it if arr[i] is bigger\n        // TODO: optimize this, using\
    \ binary search and get rid of the for loop\n        for j := lr; j >= 0; j--\
    \ {\n            if arr[i] > res[j] {\n                res[j] = arr[i]\n     \
    \           lr = j\n                break\n            }\n        }\n    }\n\n\
    \    return res\n}\n", "    // TODO\n    return []int{}\n}\n", "    return arr\n\
    }\n", "    var temp []int\n    if k <= 0 {\n        return []int{}\n    }\n  \
    \  result := make([]int, k)\n    for _, v := range arr {\n        temp = append(temp,\
    \ v)\n        bubbleSort(temp)\n        if len(temp) > k {\n            temp =\
    \ temp[:k]\n        }\n    }\n    for i, v := range temp {\n        result[i]\
    \ = v\n    }\n    return result\n}\n", "    if k == len(arr) {\n        return\
    \ arr\n    }\n    if k == 0 {\n        return []int{}\n    }\n    res := make([]int,\
    \ k)\n    for i := 0; i < k; i++ {\n        res[i] = arr[i]\n    }\n    for i\
    \ := k; i < len(arr); i++ {\n        if arr[i] > res[0] {\n            for j :=\
    \ 0; j < k; j++ {\n                if arr[i] <= res[j] {\n                   \
    \ insert(res, j, arr[i])\n                    break\n                }\n     \
    \       }\n        }\n    }\n    return res\n}\n", "    size := len(arr)\n   \
    \ if size <= k {\n        return arr\n    }\n    if k == 0 {\n        return []int{}\n\
    \    }\n    for i := k - 1; i >= 0; i-- {\n        for j := i - 1; j >= 0; j--\
    \ {\n            if arr[i] > arr[j] {\n                temp := arr[i]\n      \
    \          arr[i] = arr[j]\n                arr[j] = temp\n            }\n   \
    \     }\n    }\n    return arr[:k]\n}\n", "    fmt.Println(fmt.Sprintf(\"Input:\
    \ %v\", arr))\n    fmt.Println(fmt.Sprintf(\"Positive integer: %d\", k))\n   \
    \ // Implement your function here\n    return arr\n}\n", "    var ret []int\n\
    \    var s, e int\n    var i int\n    n := len(arr)\n    for s < n {\n       \
    \ e = s + k\n        if e > n {\n            e = n\n        }\n        m := maximumRange(arr,\
    \ s, e)\n        if i < k {\n            ret = append(ret, m)\n        } else\
    \ {\n            ret[i] = m\n        }\n        i++\n        s = e\n    }\n  \
    \  return ret\n}\n", "    // Implement here\n    if len(arr) <= k {\n        return\
    \ arr\n    }\n    for i := 0; i < k; i++ {\n        for j := i; j < len(arr);\
    \ j++ {\n            if arr[i] < arr[j] {\n                arr[i], arr[j] = arr[j],\
    \ arr[i]\n            }\n        }\n    }\n    return arr[:k]\n}\n", "    if len(arr)\
    \ == 0 {\n        return []int{}\n    }\n    if k == 0 {\n        return []int{}\n\
    \    }\n    if k == 1 {\n        biggest := arr[0]\n        for _, num := range\
    \ arr {\n            if num > biggest {\n                biggest = num\n     \
    \       }\n        }\n        return []int{biggest}\n    }\n    if k >= len(arr)\
    \ {\n        return arr\n    }\n    result := make([]int, k)\n    for i := 0;\
    \ i < k; i++ {\n        result[i] = arr[i]\n    }\n    for i := k; i < len(arr);\
    \ i++ {\n        for j := 0; j < k; j++ {\n            if arr[i] > result[j] {\n\
    \                for m := k - 1; m > j; m-- {\n                    result[m] =\
    \ result[m - 1]\n                }\n                result[j] = arr[i]\n     \
    \           break\n            }\n        }\n    }\n    return result\n}\n", " \
    \   return MergeSort(arr)[len(arr)-k:]\n}\n", "    return []int{}\n}\n", "   \
    \ // Bubble sort the list\n    for i:=0; i<len(arr); i++ {\n        for j:=i+1;\
    \ j<len(arr); j++ {\n            if arr[i] > arr[j] {\n                arr[i],\
    \ arr[j] = arr[j], arr[i]\n            }\n        }\n    }\n    // Trim off unwanted\
    \ elements\n    return arr[:k]\n}\n", "    l := len(arr)\n    m := make([]int,\
    \ k)\n    j := 0\n    for i := 0; i < l; i++ {\n        if arr[i] > m[j] {\n \
    \           m[j] = arr[i]\n            j++\n            if j == k {\n        \
    \        j = 0\n            }\n        }\n    }\n    return m\n}\n", "    var\
    \ result []int\n    var index int\n\n    // While we have values to add and the\
    \ result isn't full\n    for k > 0 && index < len(arr) {\n        var max int\n\
    \        // Check if the item is greater than the last value\n        if len(result)\
    \ == 0 || arr[index] > result[len(result) - 1] {\n            max = arr[index]\n\
    \        } else {\n            max = result[len(result) - 1]\n        }\n    \
    \    result = append(result, max)\n        index++\n    }\n\n    return result\n\
    }\n", "    maxSlice := make([]int, k)\n    // for i := 0; i < k; i++ {\n    //\
    \     maxSlice[i] = arr[i]\n    // }\n    copy(maxSlice, arr[:k])\n    for i :=\
    \ k; i < len(arr); i++ {\n        if arr[i] > maxSlice[0] {\n            maxSlice[0]\
    \ = arr[i]\n            maxSlice = fixMaxSlice(maxSlice)\n        }\n    }\n \
    \   // sort.Ints(maxSlice)\n    return maxSlice\n}\n", "    n := len(arr)\n  \
    \  if n == 0 {\n        return arr\n    }\n    // maxHeap stores the top k elements\
    \ of arr.\n    maxHeap := make([]int, k)\n    // Initially, the maxHeap consists\
    \ of the first k elements of arr.\n    for i := 0; i < k; i++ {\n        maxHeap[i]\
    \ = arr[i]\n    }\n    // The above algorithm only works when the minHeap is con",
  "    var result []int\n    for i := 0; i < k; i++ {\n        max := arr[0]\n   \
    \     for _, v := range arr {\n            if v > max {\n                max =\
    \ v\n            }\n        }\n        result = append(result, max)\n        for\
    \ j, v := range arr {\n            if v == max {\n                arr = append(arr[:j],\
    \ arr[j+1:]...)\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n", "    size := len(arr)\n    if size == 0 {\n        return []int{}\n\
    \    }\n    if size == 1 {\n        return arr\n    }\n    if k == 0 {\n     \
    \   return []int{}\n    }\n    if k >= size {\n        arr = quickSort(arr)\n\
    \        return arr\n    }\n    index := -1\n    return quickSelect(arr, 0, size\
    \ - 1, index, k)\n}\n", "    // fmt.Println(arr, k)\n    if k == 0 {\n       \
    \ return nil\n    }\n    if k == 1 {\n        max := arr[0]\n        for _, v\
    \ := range arr {\n            if v > max {\n                max = v\n        \
    \    }\n        }\n        return []int{max}\n    }\n    if k >= len(arr) {\n\
    \        return arr\n    }\n    result := []int{}\n    for i := 0; i < k; i++\
    \ {\n        max := arr[0]\n        for _, v := range arr {\n            if v\
    \ > max {\n                max = v\n            }\n        }\n        result =\
    \ append(result, max)\n        arr = deleteMax(arr, max)\n    }\n    return result\n\
    }\n", "    var (\n        res = make([]int, k)\n        i, j int\n    )\n    for\
    \ i, j = 0, 0; i < len(arr) && j < k; i++ {\n        for j > 0 && arr[i] > res[j-1]\
    \ {\n            j--\n        }\n        res[j] = arr[i]\n        j++\n    }\n\
    \    for i < len(arr) {\n        for j > 0 && arr[i] > res[j-1] {\n          \
    \  j--\n        }\n        if j < k {\n            res[j] = arr[i]\n         \
    \   j++\n        }\n        i++\n    }\n    return res\n}\n", "    // n := len(arr)\n\
    \    res := make([]int, k)\n    // Compare val with all of res, if val is larger\
    \ than one of them, \n    // remove the last item and insert val at the appopriate\
    \ position.\n    var insert = func(val int) {\n        for i := 0; i < k; i++\
    \ {\n            if res[i] < val {\n                res = append(res[:i], append([]int{val},\
    \ res[i:k-1]...)...)\n                return\n            }\n        }\n    }\n\
    \    for _, v := range arr {\n        insert(v)\n    }\n    return res\n}\n",
  "    if k <= 0 {\n        return nil\n    }\n    if k >= len(arr) {\n        return\
    \ quicksort(arr)\n    }\n    idx := partition(arr)\n    i := 0\n    for idx !=\
    \ k {\n        if idx > k {\n            idx = partition(arr[:idx])\n        }\
    \ else {\n            i += idx + 1\n            idx = partition(arr[i:])\n   \
    \     }\n    }\n    return arr[:k]\n}\n", "    // Write your code here\n    return\
    \ []int{}\n}\n", "    if len(arr) == 0 {\n        return []int{}\n    }\n    if\
    \ k == 0 {\n        return []int{}\n    }\n    if k == 1 {\n        arr[0] = findMax(arr)\n\
    \        return arr[:1]\n    }\n    if k == len(arr) {\n        return arr\n \
    \   }\n    var res = make([]int, k)\n    copy(res, arr[:k])\n    heapSort(res)\n\
    \    for i := k; i < len(arr); i++ {\n        if arr[i] > res[0] {\n         \
    \   res[0] = arr[i]\n            heapSort(res)\n        }\n    }\n    return res\n\
    }\n", "    // insert numbers in a min-heap\n    minHeap := make([]int, 0)\n  \
    \  for _, num := range arr {\n        if len(minHeap) < k {\n            insert(minHeap,\
    \ num)\n        } else {\n            if num > minHeap[0] {\n                removeMin(minHeap)\n\
    \                insert(minHeap, num)\n            }\n        }\n    }\n    return\
    \ minHeap\n}\n", "    return arr\n}\n", "    if len(arr) == 0 {\n        return\
    \ []int{}\n    }\n\n    if k == 0 {\n        return []int{}\n    }\n\n    if k\
    \ >= len(arr) {\n        return arr\n    }\n\n    for i := 0; i < k; i++ {\n \
    \       for j := i; j < len(arr) - 1; j++ {\n            if arr[j] > arr[j + 1]\
    \ {\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n            }\n\
    \        }\n    }\n\n    return arr[len(arr) - k:]\n}\n", "    var result []int\n\
    \    for i := 0; i < k; i++ {\n        max_index := i\n        for j := i; j <\
    \ len(arr); j++ {\n            if arr[j] > arr[max_index] {\n                max_index\
    \ = j\n            }\n        }\n        arr[i], arr[max_index] = arr[max_index],\
    \ arr[i]\n        result = append(result, arr[i])\n    }\n    return result\n\
    }\n", "    max := 0\n    for _, v := range arr {\n        if v > max {\n     \
    \       max = v\n        }\n    }\n    count := 0\n    for _, v := range arr {\n\
    \        if v == max {\n            count++\n        }\n    }\n    var r []int\n\
    \    if count >= k {\n        for _, v := range arr {\n            if v == max\
    \ {\n                r = append(r, v)\n            }\n        }\n    } else {\n\
    \        r = append(r, max)\n        k--\n        i := 0\n        j := len(arr)\
    \ - 1\n        n := arr[i]\n        m := arr[j]\n        for k > 0 {\n       \
    \     if n >= m {\n                if n < max {\n                    r = append(r,\
    \ n)\n                    k--\n                }\n                i++\n      \
    \          n = arr[i]\n            } else {\n                if m < max {\n  \
    \                  r = append(r, m)\n                    k--\n               \
    \ }\n                j--\n                m = arr[j]\n            }\n        }\n\
    \    }\n    return r\n}\n", "    n := len(arr)\n    for i := 0; i < k; i++ {\n\
    \        // find max arr[j]\n        max_idx := -1\n        for j := i; j < n;\
    \ j++ {\n            if max_idx == -1 || arr[j] > arr[max_idx] {\n           \
    \     max_idx = j\n            }\n        }\n        // swap max with current\
    \ idx\n        if max_idx != i {\n            arr[i], arr[max_idx] = arr[max_idx],\
    \ arr[i]\n        }\n    }\n    return arr[:k]\n}\n", "    if len(arr) == 0 {\n\
    \        return arr\n    }\n    if k <= 0 {\n        return []int{}\n    }\n \
    \   if k > len(arr) {\n        k = len(arr)\n    }\n    result := make([]int,\
    \ k)\n    for i, x := range arr {\n        if i < k {\n            result[i] =\
    \ x\n        } else {\n            insertMinHeap(result, x)\n        }\n    }\n\
    \    return heapSort(result)\n}\n", "    var (\n        result = make([]int, k)\n\
    \        minIdx int\n    )\n    for i := 0; i < k; i++ {\n        minIdx = i\n\
    \        for j := i + 1; j < len(arr); j++ {\n            if arr[j] > arr[minIdx]\
    \ {\n                minIdx = j\n            }\n        }\n        if minIdx !=\
    \ i {\n            arr[i], arr[minIdx] = arr[minIdx], arr[i]\n        }\n    \
    \    result[i] = arr[i]\n    }\n    return result\n}\n", "    if k == 0 {\n  \
    \      return []int{}\n    }\n    if k == len(arr) {\n        return arr\n   \
    \ }\n    var stack []int\n    var res []int\n    for i, v := range arr {\n   \
    \     for len(stack) > 0 && len(stack) + len(arr) - i > k && v > stack[len(stack)\
    \ - 1] {\n            stack = stack[:len(stack) - 1]\n        }\n        if len(stack)\
    \ < k {\n            stack = append(stack, v)\n        }\n    }\n    return stack\n\
    }\n", "    if len(arr) == 0 {\n        return []int{}\n    }\n    if k == 0 {\n\
    \        return []int{}\n    }\n    if k >= len(arr) {\n        return arr\n \
    \   }\n    ret := make([]int, k)\n    copy(ret, arr[:k])\n    k += k/2\n    for\
    \ i := k/2; i >= 0; i-- {\n        heapify(ret, i, k)\n    }\n    for i := k;\
    \ i < len(arr); i++ {\n        if arr[i] > ret[0] {\n            ret[0] = arr[i]\n\
    \            heapify(ret, 0, k)\n        }\n    }\n    return ret\n}\n", "   \
    \ return nil\n}\n", "    if len(arr) == 0 {\n        return []int{}\n    }\n\n\
    \    q := make([]int, 0)\n    for i := 0; i < len(arr); i++ {\n        q = append(q,\
    \ arr[i])\n        maxHeapify(q, i)\n        if len(q) > k {\n            q =\
    \ q[1:]\n        }\n    }\n    return q\n}\n", "    // corner case\n    if k <=\
    \ 0 {\n        return []int{}\n    }\n    if k >= len(arr) {\n        return arr\n\
    \    }\n    // create a new slice with length k\n    ret := make([]int, k)\n \
    \   for i := 0; i < k; i++ {\n        ret[i] = arr[i]\n    }\n    // sort the\
    \ new slice\n    quicksort(ret, 0, k - 1)\n    // iterate the rest of the slice\n\
    \    for i := k; i < len(arr); i++ {\n        if arr[i] > ret[0] {\n         \
    \   ret[0] = arr[i]\n            quicksort(ret, 0, k - 1)\n        }\n    }\n\
    \    return ret\n}\n", "    res := make([]int, k)\n    copy(res, arr[:k])\n  \
    \  k = len(res)\n    for i := k; i < len(arr); i++ {\n        if arr[i] > res[0]\
    \ {\n            res[0] = arr[i]\n            rebuild(res)\n        }\n    }\n\
    \    return res\n}\n", "    length := len(arr)\n    if length == 0 {\n       \
    \ return []int{}\n    }\n    if k > length {\n        k = length\n    }\n    heap\
    \ := NewMaxHeap(arr)\n    for heap.Size() > k {\n        heap.Pop()\n    }\n \
    \   return heap.Data()\n}\n", "    // TODO: Write your code here\n    return nil\n\
    }\n", "    var result []int\n    if k == 0 {\n        return result\n    }\n \
    \   for i := 0; i < k; i++ {\n        result = append(result, arr[i])\n    }\n\
    \    for i := k; i < len(arr); i++ {\n        for j := 0; j < k; j++ {\n     \
    \       if arr[i] > result[j] {\n                result = append(result[:j], result[j+1:]...)\n\
    \                result = append(result, arr[i])\n                break\n    \
    \        }\n        }\n    }\n    return result[:k]\n}\n", "    arrLen := len(arr)\n\
    \    if arrLen <= 0 || k <= 0 || k > arrLen {\n        return nil\n    }\n   \
    \ arrResult := make([]int, k)\n    copy(arrResult, arr[:k])\n    for i := k /\
    \ 2 - 1; i >= 0; i-- {\n        heapfiy(arrResult, i, k)\n    }\n    for i :=\
    \ k; i < arrLen; i++ {\n        if arr[i] > arrResult[0] {\n            arrResult[0]\
    \ = arr[i]\n            heapfiy(arrResult, 0, k)\n        }\n    }\n    return\
    \ arrResult\n}\n", "    var res []int\n    if k == 1 {\n        res = make([]int,\
    \ 1)\n        res[0] = arr[0]\n        for i := 1; i < len(arr); i++ {\n     \
    \       if arr[i] > res[0] {\n                res[0] = arr[i]\n            }\n\
    \        }\n        return res\n    }\n    // no need to sort the first k elements\n\
    \    res = arr[:k]\n    for i := 1; i < k; i++ {\n        for j := 0; j < i; j++\
    \ {\n            if res[j] > res[i] {\n                // insert at pos i\n  \
    \              temp := res[i]\n                copy(res[j+1:i+1], res[j:i])\n\
    \                res[j] = temp\n            }\n        }\n    }\n    // sort the\
    \ rest of elements\n    for i := k; i < len(arr); i++ {\n        // compare with\
    \ the last element in the sorted array\n        if arr[i] > res[k-1] {\n     \
    \       // insert at pos k\n            temp := arr[i]\n            copy(res[1:k],\
    \ res[:k-1])\n            res[0] = temp\n        }\n    }\n    return res\n}\n",
  "    // Your implementation goes here.\n    var slice []int\n    fmt.Println(slice)\n\
    \    return arr\n}\n", "    if len(arr) == 0 {\n        return arr\n    }\n  \
    \  if k == 0 {\n        return []int{}\n    }\n    if k >= len(arr) {\n      \
    \  return arr\n    }\n    result := make([]int, k)\n    for i := 0; i < k; i++\
    \ {\n        result[i] = arr[i]\n    }\n    heapify(result)\n    for i := k; i\
    \ < len(arr); i++ {\n        if arr[i] > result[0] {\n            result[0] =\
    \ arr[i]\n            heapify(result)\n        }\n    }\n    return result\n}\n",
  "    res := make([]int, k)\n    return res\n}\n", "    if len(arr) == 0 {\n    \
    \    return []int{}\n    }\n    if k == 0 {\n        return []int{}\n    }\n \
    \   if k >= len(arr) {\n        return arr\n    }\n    var ind, to_delete int\n\
    \    var i, j int\n    r := make([]int, k)\n    for i, to_delete = 0, len(arr)\
    \ - k; i < to_delete; i++ {\n        ind = 0\n        for j = 1; j < k; j++ {\n\
    \            if arr[j] > arr[ind] {\n                ind = j\n            }\n\
    \        }\n        arr[ind] = arr[len(arr) - 1 - i]\n    }\n    copy(r, arr[i:])\n\
    \    return r\n}\n", "    var res []int\n    if k == 0 {\n        return res\n\
    \    }\n    if k >= len(arr) {\n        return arr\n    }\n    for _, n := range\
    \ arr {\n        l := len(res)\n        if l == 0 {\n            res = append(res,\
    \ n)\n            continue\n        }\n        if l < k {\n            i := l\
    \ - 1\n            for ; i >= 0; i-- {\n                if res[i] < n {\n    \
    \                res = append(res[:i], append([]int{n}, res[i:]...)...)\n    \
    \                break\n                }\n            }\n            if i ==\
    \ -1 {\n                res = append([]int{n}, res...)\n            }\n      \
    \  } else {\n            i := l - 1\n            for ; i >= 0; i-- {\n       \
    \         if res[i] < n {\n                    res = append(res[:i], append([]int{n},\
    \ res[i:]...)...)\n                    res = res[:k]\n                    break\n\
    \                }\n            }\n        }\n    }\n    return res\n}\n", " \
    \   heap := make([]int, 0)\n    if k > len(arr) {\n        k = len(arr)\n    }\n\
    \    for i := 0; i < k; i++ {\n        heap = append(heap, arr[i])\n    }\n  \
    \  heapify(heap)\n    for i := k; i < len(arr); i++ {\n        if arr[i] > heap[0]\
    \ {\n            heap[0] = arr[i]\n            heapify(heap)\n        }\n    }\n\
    \    return heap\n}\n", "    if k == 0 {\n        return []int{}\n    }\n    var\
    \ max []int\n    for i := 0; i < k; i++ {\n        max = append(max, arr[i])\n\
    \    }\n    for i := k; i < len(arr); i++ {\n        for j := 0; j < k; j++ {\n\
    \            if arr[i] > max[j] {\n                max[j] = arr[i]\n         \
    \       break\n            }\n        }\n    }\n    return max\n}\n", "    if\
    \ len(arr) == 0 {\n        return arr\n    }\n    if k > len(arr) {\n        k\
    \ = len(arr)\n    }\n    result := make([]int, k)\n    for i := 0; i < k; i++\
    \ {\n        result[i] = arr[i]\n    }\n    for i := k / 2 - 1; i >= 0; i-- {\n\
    \        min_heapify(result, i, k)\n    }\n    for i := k; i < len(arr); i++ {\n\
    \        if arr[i] > result[0] {\n            result[0] = arr[i]\n           \
    \ min_heapify(result, 0, k)\n        }\n    }\n    return result\n}\n", "    if\
    \ k == 0 {\n        return []int{}\n    }\n    n := len(arr)\n    if k >= n {\n\
    \        return arr\n    }\n    // Insertion Sort\n    // Worst Case: O(n^2)\n\
    \    // O(nk)\n    for i := 1; i < k; i++ {\n        x := arr[i]\n        j :=\
    \ i - 1\n        for ; j >= 0 && arr[j] < x; j-- {\n            arr[j+1] = arr[j]\n\
    \        }\n        arr[j+1] = x\n    }\n    for i := k; i < n; i++ {\n      \
    \  if arr[i] > arr[0] {\n            arr[0] = arr[i]\n            for j := 1;\
    \ j < k; j++ {\n                x := arr[j]\n                t := j - 1\n    \
    \            for ; t >= 0 && arr[t] < x; t-- {\n                    arr[t+1] =\
    \ arr[t]\n                }\n                arr[t+1] = x\n            }\n   \
    \     }\n    }\n    return arr[:k]\n}\n", "    // your code here\n    var res\
    \ []int\n    for _, v := range arr {\n        i := len(res) - 1\n        for ;\
    \ i >= 0; i-- {\n            if res[i] < v {\n                break\n        \
    \    }\n        }\n        i++\n        if i == k {\n            continue\n  \
    \      }\n        if len(res) < k {\n            res = append(res, v)\n      \
    \  } else {\n            res = append(res[:i], append([]int{v}, res[i:]...)...)\n\
    \        }\n    }\n    return res\n}\n", "    if k == len(arr) {\n        return\
    \ arr\n    }\n    if k == 0 {\n        return []int{}\n    }\n    if k == 1 {\n\
    \        max := arr[0]\n        for _, e := range arr {\n            if e > max\
    \ {\n                max = e\n            }\n        }\n        return []int{max}\n\
    \    }\n    half := k/2\n    left := maximum(arr[:len(arr)-half], half)\n    right\
    \ := maximum(arr[len(arr)-half:], k-half)\n    ans := make([]int, 0, k)\n    i,\
    \ j := 0, 0\n    for len(ans) < k {\n        if i < len(left) && j < len(right)\
    \ {\n            if left[i] > right[j] {\n                ans = append(ans, left[i])\n\
    \                i++\n            } else {\n                ans = append(ans,\
    \ right[j])\n                j++\n            }\n        } else if i < len(left)\
    \ {\n            ans = append(ans, left[i])\n            i++\n        } else {\n\
    \            ans = append(ans, right[j])\n            j++\n        }\n    }\n\
    \    return ans\n}\n", "    if k <= 0 {\n        return []int{}\n    }\n    if\
    \ k >= len(arr) {\n        return arr\n    }\n    pivot := arr[0]\n    pivotIdx\
    \ := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < pivot {\n   \
    \         pivotIdx = i\n            pivot = arr[i]\n        }\n    }\n    left\
    \ := []int{}\n    right := []int{}\n    for i := 1; i < len(arr); i++ {\n    \
    \    if i != pivotIdx {\n            if arr[i] > pivot {\n                left\
    \ = append(left, arr[i])\n            } else {\n                right = append(right,\
    \ arr[i])\n            }\n        }\n    }\n    if len(left) >= k {\n        return\
    \ maximum(left, k)\n    } else if len(left) + 1 == k {\n        return append(maximum(left,\
    \ len(left)), pivot)\n    } else {\n        return append(maximum(left, len(left)),\
    \ maximum(right, k - len(left) - 1)...)\n    }\n}\n", "    fmt.Println(arr, k)\n\
    \    if len(arr) <= k {\n        return arr\n    }\n    if k == 0 {\n        return\
    \ []int{}\n    }\n    maxIdx := 0\n    for i := 1; i < k; i++ {\n        if arr[i]\
    \ > arr[maxIdx] {\n            maxIdx = i\n        }\n    }\n    for i := k; i\
    \ < len(arr); i++ {\n        if arr[i] > arr[maxIdx] {\n            arr[maxIdx]\
    \ = arr[i]\n            maxIdx = i\n            for j := 0; j < k; j++ {\n   \
    \             if j == maxIdx {\n                    continue\n               \
    \ }\n                if arr[j] > arr[maxIdx] {\n                    maxIdx = j\n\
    \                }\n            }\n        }\n    }\n    return arr[:k]\n}\n",
  "    if k == 0 {\n        return []int{}\n    }\n    if k == len(arr) {\n      \
    \  return arr\n    }\n    if len(arr) < k {\n        return []int{}\n    }\n \
    \   for i := 0; i < k; i++ {\n        for j := i; j < len(arr); j++ {\n      \
    \      if arr[i] < arr[j] {\n                arr[i], arr[j] = arr[j], arr[i]\n\
    \            }\n        }\n    }\n    return arr[:k]\n}\n", "    res := make([]int,\
    \ k)\n    for i := 0; i < k; i++ {\n        index := -1\n        val := -1001\n\
    \        for j := 0; j < len(arr); j++ {\n            if arr[j] > val {\n    \
    \            index = j\n                val = arr[j]\n            }\n        }\n\
    \        res[i] = val\n        arr = append(arr[:index], arr[index+1:]...)\n \
    \   }\n    return res\n}\n", "    if k == 0 {\n        return []int{}\n    }\n\
    \    if k == len(arr) {\n        return arr\n    }\n    result := make([]int,\
    \ k)\n    found := 0\n    for i := 0; i < len(arr); i++ {\n        value := arr[i]\n\
    \        j := found\n        for ; j > 0 && result[j - 1] < value; j-- {\n   \
    \         result[j] = result[j - 1]\n        }\n        result[j] = value\n  \
    \      if found < k {\n            found++\n        }\n    }\n    return result\n\
    }\n", "    if k == 0 {\n        return []int{}\n    }\n\n    // n is the length\
    \ of subarray that we need to sort.\n    n := len(arr) - k + 1\n    // \n    subarr\
    \ := arr[:n]\n    // fmt.Println(subarr)\n    for i := 1; i < n; i++ {\n     \
    \   for j := i; j > 0 && subarr[j] > subarr[j-1]; j-- {\n            // fmt.Println(subarr[j],\
    \ subarr[j-1])\n            subarr[j], subarr[j-1] = subarr[j-1], subarr[j]\n\
    \        }\n    }\n    // fmt.Println(subarr)\n    for i := n; i < len(arr); i++\
    \ {\n        if arr[i] > subarr[0] {\n            subarr[0] = arr[i]\n       \
    \     for j := 1; j < n && subarr[j] > subarr[j-1]; j++ {\n                subarr[j],\
    \ subarr[j-1] = subarr[j-1], subarr[j]\n            }\n        }\n    }\n    return\
    \ subarr\n}\n", "    if len(arr) == 0 {\n        return []int{}\n    }\n    if\
    \ k > len(arr) {\n        k = len(arr)\n    }\n    // Create a new slice of integers\
    \ containing length k.\n    res := make([]int, k)\n    // Copy first k elements\
    \ from the origin array to the new slice.\n    copy(res, arr[:k])\n    // Put\
    \ the minimum number of the new slice at the end.\n    min := min(res)\n    for\
    \ i := k; i < len(arr); i++ {\n        if arr[i] > res[min] {\n            res[min]\
    \ = arr[i]\n            min = min(res)\n        }\n    }\n    return res\n}\n",
  "    if k == 0 {\n        return nil\n    }\n    if k == len(arr) {\n        return\
    \ arr\n    }\n    arr = quicksort(arr)\n    return arr[:k]\n}\n", "    // keep\
    \ track of the number of elements in the list. if the current element \n    //\
    \ is less than the current minimum, insert it and remove the last element \n \
    \   // of the list to keep the size of the list constant\n    res := make([]int,\
    \ 0, k)\n    for _, i := range arr {\n        if len(res) < k {\n            res\
    \ = append(res, i)\n        } else {\n            if res[k-1] < i {\n        \
    \        res = append(res, i)\n                res = res[1:]\n            }\n\
    \        }\n    }\n    return res\n}\n", "    if len(arr) <= k {\n        return\
    \ arr\n    }\n    ans := make([]int, k)\n    for i := 0; i < k; i++ {\n      \
    \  ans[i] = arr[i]\n    }\n    return quickSort(ans, k)\n}\n", "    if k <= 0\
    \ {\n        return nil\n    }\n    result := make([]int, k)\n    n := len(arr)\n\
    \    if n == 0 {\n        return result\n    }\n    max := -1000000000\n    index\
    \ := -1\n    // Find max value of the first k numbers\n    for i := 0; i < k;\
    \ i++ {\n        v := arr[i]\n        if v > max {\n            max = v\n    \
    \        index = i\n        }\n    }\n    result[0] = max\n    for i := k; i <\
    \ n; i++ {\n        v := arr[i]\n        if v > max {\n            result[0] =\
    \ v\n            max = v\n            index = i\n        }\n    }\n    current\
    \ := 1\n    for current < k {\n        // Remove the previous max number\n   \
    \     n = n - 1\n        if index == n {\n            // Already removed the previous\
    \ max number\n            arr = arr[:n]\n        } else {\n            arr = append(arr[:index],\
    \ arr[index+1:]...)\n        }\n        if n == 0 {\n            break\n     \
    \   }\n        max = -1000000000\n        index = -1\n        // Find max value\
    \ of the first k numbers\n        for i := 0; i < n; i++ {\n            v := arr[i]\n\
    \            if v > max {\n                max = v\n                index = i\n\
    \            }\n        }\n        result[current] = max\n        current = current\
    \ + 1\n    }\n    return result\n}\n", "    return heapMaximum(arr, k)\n}\n",
  "    var results []int\n    if k > len(arr) {\n        k = len(arr)\n    }\n   \
    \ // Use a hash-map to store integers and frequency.\n    store := make(map[int]int)\n\
    \    for _, v := range arr {\n        store[v]++\n    }\n    // Use a min-heap\
    \ to store integers according to frequency.\n    heap := new(Heap)\n    for key,\
    \ v := range store {\n        heap.Push(KeyValue{key, v})\n    }\n    for i :=\
    \ 0; i < k; i++ {\n        results = append(results, heap.Pop().Key)\n    }\n\
    \    return results\n}\n\ntype KeyValue ", "    // \u957F\u5EA6\u4E3Ak\u7684\u6700\
    \u5927\u6570\u5217\uFF0C\u5C31\u662F\u957F\u5EA6\u4E3Ak-1\u7684\u6700\u5927\u6570\
    \u5217\uFF0C+\u65B0\u6570\u636E\uFF0C\u518D+1\u8BA1\u7B97\u6700\u5927\u6570\u5217\
    \n    // \u5982\u679C\u65B0\u6570\u636E\u6BD4\u539F\u5217\u6700\u5C0F\u7684\u6570\
    \u5C0F\uFF0C\u5C31\u66FF\u6362\uFF0C\u539F\u5217\u6700\u5C0F\u6570\u53F3\u79FB\
    \u4E00\u4F4D\uFF0C\u91CD\u590D\u8BA1\u7B97\n    var ans []int\n    n := len(arr)\n\
    \    if n <= k {\n        return arr\n    }\n    for i := 0; i < k; i++ {\n  \
    \      ans = append(ans, arr[i])\n    }\n    for i := k; i < n; i++ {\n      \
    \  if arr[i] <= ans[0] {\n            ans = ans[1:]\n            ans = append(ans,\
    \ arr[i])\n        } else {\n            ans = append(ans, arr[i])\n         \
    \   for j := k; j > 0; j-- {\n                if ans[j] > ans[j-1] {\n       \
    \             ans[j], ans[j-1] = ans[j-1], ans[j]\n                } else {\n\
    \                    break\n                }\n            }\n        }\n    }\n\
    \    return ans\n}\n", "    // Fill this in.\n    var result []int\n    var item\
    \ int\n    for _, item = range arr {\n        // \u5148\u52A0\u5165k\u4E2A\u6570\
    \n        if len(result) < k {\n            result = append(result, item)\n  \
    \          continue\n        }\n        fmt.Println(item, result)\n        var\
    \ index int\n        for i, v := range result {\n            if v > item {\n \
    \               index = i\n                break\n            }\n        }\n \
    \       if index == 0 {\n            continue\n        }\n        result = append(result[:index-1],\
    \ result[index:]...)\n        result = append(result, item)\n    }\n    return\
    \ result\n}\n", "    var result []int\n    if len(arr) <= k {\n        return\
    \ arr\n    }\n    for i := 0; i < k; i++ {\n        max := findMaximum(arr)\n\
    \        if max == -1 {\n            break\n        }\n        result = append(result,\
    \ arr[max])\n        arr = append(arr[:max], arr[max+1:]...)\n    }\n    return\
    \ result\n}\n", "    if k == 0 {\n        return []int{}\n    }\n\n    lst :=\
    \ make([]int, k)\n    for i := 0; i < k; i++ {\n        lst[i] = arr[i]\n    }\n\
    \n    build_max_heap(lst)\n\n    // add max heap\n    for i := k; i < len(arr);\
    \ i++ {\n        if arr[i] > lst[0] {\n            lst[0] = arr[i]\n         \
    \   max_heapify(lst, 0)\n        }\n    }\n\n    return lst\n}\n", "    var res\
    \ []int\n    for i := 0; i < k; i++ {\n        max := -1000\n        maxi := -1\n\
    \        for j := 0; j < len(arr); j++ {\n            if arr[j] > max {\n    \
    \            max = arr[j]\n                maxi = j\n            }\n        }\n\
    \        res = append(res, max)\n        arr = append(arr[:maxi], arr[maxi+1:]...)\n\
    \    }\n    return res\n}\n", "    if k == len(arr) {\n        return arr\n  \
    \  }\n    // 1. Initialize a list p with size len(arr) + 1\n    // 2. If a number\
    \ is greater than the previous one, save it in p\n    // 3. Remove the first number\
    \ in p if its size is greater than k\n    // 4. Skip all duplicated numbers\n\
    \    if len(arr) == 0 {\n        return arr\n    }\n    if k == 0 {\n        return\
    \ []int{}\n    }\n    p := make([]int, len(arr)+1)\n    p[0] = arr[0]\n    pLen\
    \ := 1\n    for i := 1; i < len(arr); i++ {\n        for pLen > 0 && p[pLen-1]\
    \ < arr[i] {\n            pLen--\n        }\n        if pLen < k {\n         \
    \   p[pLen] = arr[i]\n            pLen++\n        }\n    }\n    return p[:pLen]\n\
    }\n", "    // Your implementation here\n    return []int{}\n}\n", "    var n =\
    \ len(arr)\n    var idx = 0\n    var result = make([]int, 0)\n    if n == 0 {\n\
    \        return result\n    }\n    for idx < n {\n        var i = 0\n        var\
    \ j = len(result) - 1\n        for i <= j {\n            var mid = (i + j) / 2\n\
    \            if result[mid] < arr[idx] {\n                i = mid + 1\n      \
    \      } else {\n                j = mid - 1\n            }\n        }\n     \
    \   if len(result) < k {\n            result = append(result, 0)\n        }\n\
    \        copy(result[i+1:], result[i:])\n        result[i] = arr[idx]\n      \
    \  idx++\n    }\n    return result\n}\n", "    if k == 0 {\n        return []int{}\n\
    \    }\n    if k == len(arr) {\n        return arr\n    }\n    var ret []int\n\
    \    var max int\n    var index int\n    for i := 0; i < k; i++ {\n        max\
    \ = arr[0]\n        index = 0\n        for j := 1; j < len(arr); j++ {\n     \
    \       if arr[j] > max {\n                max = arr[j]\n                index\
    \ = j\n            }\n        }\n        ret = append(ret, max)\n        arr =\
    \ append(arr[:index], arr[index+1:]...)\n    }\n    return ret\n}\n", "    var\
    \ maximum []int\n    var i, j int\n    var kLessThanK, kGreaterThanK, kEqualsK\
    \ bool\n    if k == 0 {\n        return maximum\n    }\n    if k < len(arr) {\n\
    \        kLessThanK = true\n    } else if k > len(arr) {\n        kGreaterThanK\
    \ = true\n    } else {\n        kEqualsK = true\n    }\n    if kLessThanK {\n\
    \        maximum = make([]int, k)\n        for i = range maximum {\n         \
    \   maximum[i] = arr[i]\n        }\n        for i = k; i < len(arr); i++ {\n \
    \           for j = 0; j < k; j++ {\n                if arr[i] > maximum[j] {\n\
    \                    for l := k - 1; l > j; l-- {\n                        maximum[l]\
    \ = maximum[l - 1]\n                    }\n                    maximum[j] = arr[i]\n\
    \                    break\n                }\n            }\n        }\n    }\
    \ else if kGreaterThanK {\n        maximum = make([]int, len(arr))\n        for\
    \ i = range maximum {\n            maximum[i] = arr[i]\n        }\n    } else\
    \ if kEqualsK {\n        maximum = make([]int, k)\n        for i = range maximum\
    \ {\n            maximum[i] = arr[i]\n        }\n    }\n    return maximum\n}\n",
  "    if k == 0 {\n        return []int{}\n    }\n\n    maxs := make([]int, k)\n\
    \    for i := 0; i < k; i++ {\n        maxs[i] = arr[i]\n    }\n\n    for i :=\
    \ k; i < len(arr); i++ {\n        for j := 0; j < k; j++ {\n            if arr[i]\
    \ > maxs[j] {\n                for r := k - 1; r > j; r-- {\n                \
    \    maxs[r] = maxs[r - 1]\n                }\n                maxs[j] = arr[i]\n\
    \                break\n            }\n        }\n    }\n\n    return maxs\n}\n",
  "    if k > len(arr) {\n        return arr\n    }\n    res := make([]int, k)\n \
    \   for i := 0; i < k; i++ {\n        index := i\n        // find max\n      \
    \  for j := i; j < len(arr); j++ {\n            if arr[j] > arr[index] {\n   \
    \             index = j\n            }\n        }\n        // append max\n   \
    \     res[i] = arr[index]\n        // swap max to arr[i]\n        arr[index] =\
    \ arr[i]\n    }\n    return res\n}\n", "    res := make([]int, k)\n    count :=\
    \ 0\n    tmp := make([]int, len(arr) + 1)\n    // Copy the array to tmp.\n   \
    \ copy(tmp, arr)\n    // Pick the maximum k elements.\n    for count < k {\n \
    \       maximum := tmp[0]\n        max_index := 0\n        for i := 1; i < len(tmp);\
    \ i++ {\n            if tmp[i] > maximum {\n                maximum = tmp[i]\n\
    \                max_index = i\n            }\n        }\n        // Delete the\
    \ maximum element.\n        copy(tmp[max_index:], tmp[max_index + 1:])\n     \
    \   tmp = tmp[:len(tmp) - 1]\n        res[count] = maximum\n        count += 1\n\
    \    }\n    return res\n}\n", "    var m []int\n    for _, v := range arr {\n\
    \        fmt.Println(v)\n        if len(m) < k {\n            m = append(m, v)\n\
    \            if len(m) == k {\n                fmt.Println(m)\n              \
    \  for i := 1; i < k; i++ {\n                    maxIndex := i\n             \
    \       for j := i + 1; j < k; j++ {\n                        if m[j] > m[maxIndex]\
    \ {\n                            maxIndex = j\n                        }\n   \
    \                 }\n                    m[i], m[maxIndex] = m[maxIndex], m[i]\n\
    \                }\n            }\n        } else {\n            minIndex := 0\n\
    \            for i := 1; i < k; i++ {\n                if m[i] < m[minIndex] {\n\
    \                    minIndex = i\n                }\n            }\n        \
    \    if v > m[minIndex] {\n                m[minIndex] = v\n            }\n  \
    \      }\n    }\n    return m\n}\n", "    arrlen := len(arr)\n    if arrlen ==\
    \ 0 {\n        return []int{}\n    }\n    if k > arrlen {\n        k = arrlen\n\
    \    }\n    // Use BubbleSort to sort the arr.\n    arr = BubbleSort(arr)\n  \
    \  return arr[arrlen-k:]\n}\n", "    // YOUR CODE HERE\n    return nil\n}\n",
  "    return arr\n}\n", "    n := len(arr)\n    if n == k {\n        return arr\n\
    \    }\n\n    var nums []int\n    if k < n {\n        nums = make([]int, n)\n\
    \        copy(nums, arr)\n    } else {\n        nums = arr\n    }\n\n    return\
    \ quicksort(nums, 0, n-1, k)\n}\n", "    if k == 0 {\n        return []int{}\n\
    \    }\n\n    if k == len(arr) {\n        return arr\n    }\n\n    if k == 1 {\n\
    \        return []int{max(arr)}\n    }\n\n    bucket := make([]int, 2001)\n  \
    \  for _, value := range arr {\n        bucket[1000 + value]++\n    }\n\n    var\
    \ result []int\n    for i := 2000; i >= 0; i-- {\n        if bucket[i] > 0 {\n\
    \            for bucket[i] > 0 {\n                result = append(result, i -\
    \ 1000)\n                bucket[i]--\n                if len(result) == k {\n\
    \                    return result\n                }\n            }\n       \
    \ }\n    }\n\n    return result\n}\n", "    // write your code here\n    var result\
    \ []int\n    for i := 0; i < k; i++ {\n        result = append(result, arr[i])\n\
    \    }\n    var temp int\n    for i := k; i < len(arr); i++ {\n        for j :=\
    \ 0; j < k; j++ {\n            if arr[i] > result[j] {\n                temp =\
    \ result[j]\n                result[j] = arr[i]\n                for l := j+1;\
    \ l < k; l++ {\n                    arr[i] = temp\n                    temp =\
    \ result[l]\n                    result[l] = arr[i]\n                }\n     \
    \           break\n            }\n        }\n    }\n    return result\n}\n", " \
    \   if len(arr) == 0 {\n        return arr\n    }\n    if k == 0 {\n        return\
    \ make([]int, 0)\n    }\n    quicksort(arr, 0, len(arr) - 1)\n    if k < len(arr)\
    \ {\n        return arr[len(arr) - k:]\n    }\n    return arr\n}\n", "    return\
    \ nil\n}\n", "    max := make([]int, 0)\n    for _, v := range arr {\n       \
    \ if len(max) < k {\n            max = append(max, v)\n            continue\n\
    \        }\n        if max[k-1] < v {\n            max[k-1] = v\n        }\n \
    \       for i := 0; i < k-1; i++ {\n            if max[i] < max[i+1] {\n     \
    \           max[i], max[i+1] = max[i+1], max[i]\n            }\n        }\n  \
    \  }\n    return max\n}\n", "    n := len(arr)\n    ret := make([]int, k)\n  \
    \  for i := 0; i < k; i++ {\n        ret[i] = arr[i]\n    }\n    // heapify\n\
    \    for i := (k - 2) / 2; i >= 0; i-- {\n        siftDown(ret, i, k - 1)\n  \
    \  }\n    for i := k; i < n; i++ {\n        if arr[i] > ret[0] {\n           \
    \ ret[0] = arr[i]\n            siftDown(ret, 0, k - 1)\n        }\n    }\n   \
    \ return ret\n}\n", "    // TODO: Implement\n    // quick select\n    if k > len(arr)\
    \ {\n        return arr\n    }\n    low, high := 0, len(arr) - 1\n    // first\
    \ use the partition function to find the first k\n    for low < high {\n     \
    \   // use partition to find the index of pivot\n        pivotIndex := partition(arr,\
    \ low, high)\n        if pivotIndex == k {\n            break\n        } else\
    \ if pivotIndex < k {\n            low = pivotIndex + 1\n        } else {\n  \
    \          high = pivotIndex - 1\n        }\n    }\n    return arr[:k]\n}\n",
  "    res := []int{}\n    for i := 0; i < k; i++ {\n        max := arr[0]\n     \
    \   arr = arr[1:]\n        for _, n := range arr {\n            if n > max {\n\
    \                max = n\n            }\n        }\n        res = append(res,\
    \ max)\n    }\n    return res\n}\n", "    if len(arr) == 0 {\n        return arr\n\
    \    }\n    // Sort the array.\n    sort(arr)\n    // Get the length of the array.\n\
    \    len := len(arr)\n    // Slice the array.\n    if k >= len {\n        return\
    \ arr\n    }\n    arr = arr[len-k:]\n    return arr\n}\n", "    if len(arr) ==\
    \ k {\n        return arr\n    }\n    sortedArr := make([]int, len(arr))\n   \
    \ copy(sortedArr, arr)\n    quickSort(sortedArr, 0, len(sortedArr) - 1)\n    return\
    \ sortedArr[len(sortedArr) - k:]\n}\n", "    return maximumRec(arr, k, 0, len(arr)\
    \ - 1)\n}\n", "    // Bubble sort\n    for i := 0; i < k; i++ {\n        for j\
    \ := i + 1; j < len(arr); j++ {\n            if arr[i] < arr[j] {\n          \
    \      arr[i], arr[j] = arr[j], arr[i]\n            }\n        }\n    }\n    return\
    \ arr[:k]\n}\n", "    var result []int\n    var start,end, mid int\n    var left\
    \ bool\n    if arr == nil || len(arr) == 0 {\n        return result\n    }\n \
    \   if k == 0 {\n        return result\n    }\n    if k == len(arr) {\n      \
    \  return arr\n    }\n    end = len(arr) - 1\n    start = 0\n    for end - start\
    \ > 1 {\n        mid = (start + end) / 2\n        left = isMax(arr, mid, k)\n\
    \        if left {\n            start = mid\n        } else {\n            end\
    \ = mid\n        }\n    }\n    if isMax(arr, start, k) {\n        start = start\
    \ + 1\n    }\n    for i := start; i < start + k; i++ {\n        result = append(result,\
    \ arr[i])\n    }\n    return result\n}\n", "    // Write your code here\n    var\
    \ res []int\n    if len(arr) == 0 {\n        return res\n    }\n    if k == 0\
    \ {\n        return res\n    }\n    if k > len(arr) {\n        k = len(arr)\n\
    \    }\n    copy(res, arr[0:k])\n    return res\n}\n", "    heap := NewMaxHeap(k)\n\
    \    for _, e := range arr {\n        heap.Push(e)\n    }\n    return heap.Elements()\n\
    }\n\ntype Heap interface {\n    Push(int)\n    Pop() int\n    IsEmpty() bool\n\
    \    Len() int\n    Peek() int\n    Elements() []int\n}\n\ntype MaxHeap ", " \
    \   if k >= len(arr) {\n        return arr\n    }\n\n    var res []int\n    for\
    \ i := 0; i < k; i++ {\n        cur := 0\n        for j := 1; j < len(arr); j++\
    \ {\n            if arr[j] > arr[cur] {\n                cur = j\n           \
    \ }\n        }\n        res = append(res, arr[cur])\n        arr = append(arr[:cur],\
    \ arr[cur+1:]...)\n    }\n    return res\n}\n", "    // Find the maximum k numbers\
    \ using a min-heap. Time complexity: O(n*log(k)).\n    // Space complexity: O(k).\n\
    \    if k == 0 {\n        return []int{}\n    }\n    heap := make([]int, k)\n\
    \    for i := 0; i < k; i++ {\n        heap[i] = arr[i]\n    }\n    for i := k-1;\
    \ i >= 0; i-- {\n        heapify(heap, i, k)\n    }\n    for i := k; i < len(arr);\
    \ i++ {\n        if arr[i] > heap[0] {\n            heap[0] = arr[i]\n       \
    \     heapify(heap, 0, k)\n        }\n    }\n    return heap\n}\n", "    if len(arr)\
    \ == 0 {\n        return arr\n    }\n    if k == 0 {\n        return []int{}\n\
    \    }\n    if k >= len(arr) {\n        return arr\n    }\n    for i := 0; i <\
    \ k; i++ {\n        for j := i; j < len(arr); j++ {\n            if arr[i] < arr[j]\
    \ {\n                arr[i], arr[j] = arr[j], arr[i]\n            }\n        }\n\
    \    }\n    return arr[:k]\n}\n", "    return selectionSort(arr, k)\n}\n", " \
    \   maxValues := make([]int, k)\n    insert := func(val int) {\n        if len(maxValues)\
    \ == 0 {\n            maxValues = append(maxValues, val)\n            return\n\
    \        }\n        // keep the maxValues ordered\n        i := 0\n        for\
    \ i < len(maxValues) && maxValues[i] >= val {\n            i++\n        }\n  \
    \      j := len(maxValues) - 1\n        for j >= i {\n            maxValues[j+1]\
    \ = maxValues[j]\n            j--\n        }\n        maxValues[i] = val\n   \
    \ }\n    for _, val := range arr {\n        if len(maxValues) == k {\n       \
    \     if val > maxValues[0] {\n                maxValues = maxValues[1:]\n   \
    \             insert(val)\n            }\n        } else {\n            insert(val)\n\
    \        }\n    }\n    return maxValues\n}\n", "    quickSort(arr, 0, len(arr)\
    \ - 1)\n    return arr[len(arr) - k:]\n}\n", "    return arr\n}\n", "    res :=\
    \ make([]int, k)\n    copy(res, arr[:k])\n    heapify(res)\n    for i := k; i\
    \ < len(arr); i++ {\n        if arr[i] > res[0] {\n            res[0] = arr[i]\n\
    \            siftdown(res, 0)\n        }\n    }\n    fmt.Println(res)\n    return\
    \ res\n}\n", "    if k <= 0 {\n        return []int{}\n    }\n    out := make([]int,\
    \ k)\n    for i := 0; i < k; i++ {\n        out[i] = arr[i]\n    }\n    qSort(out,\
    \ 0, k-1)\n    for i := k; i < len(arr); i++ {\n        if arr[i] > out[0] {\n\
    \            out[0] = arr[i]\n            qSort(out, 0, k-1)\n        }\n    }\n\
    \    return out\n}\n", "    n := len(arr)\n    if n <= k {\n        return arr\n\
    \    }\n    j := 0\n    if n - k == 1 {\n        j = 1\n    }\n    res := make([]int,\
    \ k)\n    for i := 0; i < k; i++ {\n        res[i] = arr[i]\n    }\n    for i\
    \ := k - 1; i >= 0; i-- {\n        if res[i] > arr[i + j] {\n            res[i]\
    \ = arr[i + j]\n        } else {\n            return res\n        }\n    }\n \
    \   return res\n}\n", "    if len(arr) == 0 {\n        return []int{}\n    }\n\
    \n    var result []int\n    var max int\n    for i := 0; i < k; i++ {\n      \
    \  for _, elem := range arr {\n            if elem > max {\n                max\
    \ = elem\n            }\n        }\n        result = append(result, max)\n   \
    \     max = 0\n    }\n    return result\n}\n", "    if k == 0 {\n        return\
    \ []int{}\n    }\n    if k == len(arr) {\n        return arr\n    }\n    res :=\
    \ arr[:k]\n    for i := k; i < len(arr); i++ {\n        t := arr[i]\n        for\
    \ j := 0; j < k; j++ {\n            if t > res[j] {\n                copy(res[j+1:],\
    \ res[j:k-1])\n                res[j] = t\n                break\n           \
    \ }\n        }\n    }\n    return res\n}\n", "    if len(arr) <= 0 || k <= 0 {\n\
    \        return []int{}\n    }\n    if k >= len(arr) {\n        quicksort(arr,\
    \ 0, len(arr) - 1)\n        return arr\n    }\n    l, r := 0, len(arr) - 1\n \
    \   for l < r {\n        p := partition(arr, l, r)\n        if p == k - 1 {\n\
    \            break\n        } else if p < k - 1 {\n            l = p + 1\n   \
    \     } else {\n            r = p - 1\n        }\n    }\n    arr = arr[:k]\n \
    \   quicksort(arr, 0, k - 1)\n    return arr\n}\n", "    n := len(arr)\n    if\
    \ n <= k {\n        return arr\n    }\n    var maxs []int\n    for i := 0; i <\
    \ k; i++ {\n        max := arr[i]\n        max_idx := i\n        for j := i +\
    \ 1; j < n; j++ {\n            if arr[j] > max {\n                max = arr[j]\n\
    \                max_idx = j\n            }\n        }\n        arr[i], arr[max_idx]\
    \ = arr[max_idx], arr[i]\n        maxs = append(maxs, max)\n    }\n    return\
    \ maxs\n}\n", "    if k >= len(arr) {\n        return arr\n    }\n    heap :=\
    \ make([]int, k)\n    for i, val := range arr {\n        if i < k {\n        \
    \    heap[i] = val\n        } else {\n            maximumOfHeap := heap[0]\n \
    \           if val > maximumOfHeap {\n                heap[0] = val\n        \
    \        heapify(heap, 0)\n            }\n        }\n    }\n    return heap\n\
    }\n", "    length := len(arr)\n    res := make([]int, k)\n    for i := 0; i <\
    \ k; i++ {\n        max := -1 << 31\n        temp := -1\n        for j := 0; j\
    \ < length; j++ {\n            if arr[j] > max {\n                max = arr[j]\n\
    \                temp = j\n            }\n        }\n        res[i] = max\n  \
    \      arr[temp] = -1 << 31\n    }\n    return res\n}\n", "    arr2 := make([]int,\
    \ len(arr))\n    copy(arr2, arr)\n    kk := k\n    // fmt.Println(arr2)\n    for\
    \ i := 1; i < len(arr2); i++ {\n        // fmt.Println(arr2[i])\n        for j\
    \ := i; j > 0; j-- {\n            if arr2[j] > arr2[j-1] {\n                arr2[j],\
    \ arr2[j-1] = arr2[j-1], arr2[j]\n            }\n        }\n        // fmt.Println(arr2)\n\
    \    }\n    // fmt.Println(arr2)\n    arr2 = arr2[len(arr2)-kk:]\n    // fmt.Println(arr2)\n\
    \    return arr2\n}\n", "    return maxHeap(arr, k)\n}\n", "    i := 0\n    j\
    \ := k - 1\n    for i < j {\n        if arr[i] > arr[j] {\n            arr[i],\
    \ arr[j] = arr[j], arr[i]\n        }\n        i++\n        j--\n    }\n    return\
    \ arr[:k]\n}\n", "    maxHeap := &MaxHeap{\n        heap: make([]int, 0),\n  \
    \  }\n    for _, num := range arr {\n        maxHeap.add(num)\n        if maxHeap.size()\
    \ > k {\n            maxHeap.pop()\n        }\n    }\n    sortedArr := make([]int,\
    \ 0)\n    for maxHeap.size() > 0 {\n        sortedArr = append(sortedArr, maxHeap.pop())\n\
    \    }\n    return sortedArr\n}\n\ntype MaxHeap ", "    if k <= 0 {\n        return\
    \ []int{}\n    }\n    if k >= len(arr) {\n        arr = bubbleSort(arr)\n    \
    \    return arr\n    }\n    for i := 0; i < k; i++ {\n        for j := len(arr)\
    \ - 1; j > i; j-- {\n            if arr[j] > arr[j - 1] {\n                arr[j],\
    \ arr[j - 1] = arr[j - 1], arr[j]\n            }\n        }\n    }\n    return\
    \ arr[len(arr) - k:]\n}\n", "    list := make([]int, 0)\n    for i, value := range\
    \ arr {\n        if i < k {\n            list = append(list, value)\n        }\
    \ else {\n            minimum := list[0]\n            min_i := 0\n           \
    \ for i, value := range list {\n                if value < minimum {\n       \
    \             minimum = value\n                    min_i = i\n               \
    \ }\n            }\n            if value > minimum {\n                list[min_i]\
    \ = value\n            }\n        }\n    }\n    return list\n}\n", "    return\
    \ maximum2(arr, k)\n}\n", "    lenArr := len(arr)\n    if lenArr < k {\n     \
    \   return arr\n    }\n    var res []int\n    for i := 0; i < k; i++ {\n     \
    \   res = append(res, arr[i])\n    }\n    for i := k; i < lenArr; i++ {\n    \
    \    if arr[i] <= res[k-1] {\n            continue\n        }\n        j := k\
    \ - 1\n        for ; j >= 0; j-- {\n            if arr[i] > res[j] {\n       \
    \         res[j+1] = res[j]\n            } else {\n                break\n   \
    \         }\n        }\n        res[j+1] = arr[i]\n    }\n    return res\n}\n",
  "    if k == 0 {\n        return arr[:0]\n    }\n    if k == len(arr) {\n      \
    \  return arr\n    }\n    return maxHeap(arr, k)\n}\n", "    if k <= 0 {\n   \
    \     return arr[:0]\n    }\n    if k >= len(arr) {\n        return arr\n    }\n\
    \    results := make([]int, k)\n    for i := 0; i < k; i++ {\n        results[i]\
    \ = arr[i]\n    }\n    // sort the first k numbers in results\n    for i := 0;\
    \ i < k; i++ {\n        minIndex := i\n        for j := i + 1; j < k; j++ {\n\
    \            if results[j] < results[minIndex] {\n                minIndex = j\n\
    \            }\n        }\n        results[i], results[minIndex] = results[minIndex],\
    \ results[i]\n    }\n    for i := k; i < len(arr); i++ {\n        if arr[i] >\
    \ results[0] {\n            results[0] = arr[i]\n            for j := 1; j < k;\
    \ j++ {\n                if results[j] < results[j - 1] {\n                  \
    \  results[j], results[j - 1] = results[j - 1], results[j]\n                }\
    \ else {\n                    break\n                }\n            }\n      \
    \  }\n    }\n    return results\n}\n", "    var ret []int\n    for i, a := range\
    \ arr {\n        for len(ret) > 0 && a > ret[len(ret)-1] && k > len(ret) {\n \
    \           ret = ret[:len(ret)-1]\n        }\n        if len(ret) < k {\n   \
    \         ret = append(ret, a)\n        }\n        fmt.Println(i, ret)\n    }\n\
    \    return ret\n}\n", "    if k <= 0 {\n        return []int{}\n    }\n\n   \
    \ length := len(arr)\n    if k >= length {\n        return arr\n    }\n\n    mergeSort(arr,\
    \ 0, length - 1)\n    return arr[length - k:]\n}\n", "    var result []int\n \
    \   if k >= len(arr) {\n        return arr\n    }\n    // The idea is: find the\
    \ right-most position of the result array.\n    // Then, compare the largest number\
    \ in the array with the right-most\n    // value in the result array. If the largest\
    \ number is larger than the \n    // right-most value, move the result array from\
    \ the right to the left\n    // by 1 position. Keep doing this process until the\
    \ largest number is\n    // no longer larger than the right-most value, or the\
    \ right-most position\n    // is reached. Then, insert the largest number into\
    \ the result array.\n    for i := 0; i < k; i++ {\n        m := i\n        for\
    \ j := len(arr) - 1; j > i; j-- {\n            if arr[j] > arr[m] {\n        \
    \        m = j\n            }\n        }\n        // Replace the right-most position\
    \ of the result array.\n        if i != m {\n            arr[i], arr[m] = arr[m],\
    \ arr[i]\n        }\n    }\n    return arr[:k]\n}\n", "    // Base case\n    if\
    \ k == 1 {\n        max := arr[0]\n        for _, v := range arr {\n         \
    \   if v > max {\n                max = v\n            }\n        }\n        return\
    \ []int{max}\n    }\n    // Recursive case\n    max := maximum(arr[1:], k-1)\n\
    \    if arr[0] > max[k-2] {\n        return append([]int{arr[0]}, max[:k-1]...)\n\
    \    }\n    return append(max, arr[0])\n}\n", "    // bubble sort\n    for i :=\
    \ 0; i < k; i++ {\n        for j := i + 1; j < len(arr); j++ {\n            if\
    \ arr[i] < arr[j] {\n                arr[i], arr[j] = arr[j], arr[i]\n       \
    \     }\n        }\n    }\n    return arr[:k]\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
