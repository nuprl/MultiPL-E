name: HumanEval_126_is_sorted
language: go_test.go
prompt: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ Given a list of numbers, return whether or not they are sorted\n// in ascending\
  \ order. If list has more than 1 duplicate of the same\n// number, return false.\
  \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
  // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
  \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n//\
  \ >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
  \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n// true\n\
  // >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst []int) bool\
  \ {\n"
tests: "func TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
  \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
  \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5,\
  \ 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}),\
  \ expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected:\
  \ false },\n     { actual: candidate([]int{}), expected: true },\n     { actual:\
  \ candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3, 2, 1}),\
  \ expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected:\
  \ false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n\
  \     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
  \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
  \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\
  \tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
  \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["\tvar prev int\n\tfor i, v := range lst {\n\t\tif i > 0 {\n\t\t\tif\
    \ prev > v {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif prev == v {\n\t\t\t\treturn\
    \ false\n\t\t\t}\n\t\t}\n\t\tprev = v\n\t}\n\treturn true\n}\n", "    if len(lst)\
    \ == 0 {\n        return true\n    }\n    prev := lst[0]\n    duplicates := map[int]bool{}\n\
    \    for _, l := range lst {\n        if l < prev {\n            return false\n\
    \        }\n        if _, ok := duplicates[l]; ok {\n            return false\n\
    \        }\n        duplicates[l] = true\n        prev = l\n    }\n    return\
    \ true\n}\n", "    return false\n}\n", "    m := make(map[int]int)\n    for _,\
    \ v := range lst {\n        m[v] += 1\n    }\n    for i := 0; i < len(lst)-1;\
    \ i++ {\n        if lst[i] > lst[i+1] {\n            return false\n        }\n\
    \        if m[lst[i]] > 1 {\n            return false\n        }\n    }\n    return\
    \ true\n}\n", "    lstLen := len(lst)\n    if lstLen == 0 {\n        return false\n\
    \    }\n    for i := 0; i < lstLen - 1; i++ {\n        if lst[i] >= lst[i + 1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    prev\
    \ := 0\n    if len(lst) > 0 {\n        prev = lst[0]\n    }\n    for _, e := range\
    \ lst {\n        if e <= prev {\n            return false\n        }\n       \
    \ prev = e\n    }\n    return true\n}\n", "\t// iterate through the list and compare\
    \ the items. If they are\n\t// not in order return false\n\tfor i := 1; i < len(lst);\
    \ i++ {\n\t\tif lst[i-1] > lst[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn\
    \ true\n}\n", "    for i, j := 0, 1; j < len(lst); i, j = i+1, j+1 {\n       \
    \ if lst[i] > lst[j] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n", "    for i := 1; i < len(lst); i++ {\n        if lst[i-1] > lst[i]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n", "    max\
    \ := lst[0]\n    for i := 1; i < len(lst); i++ {\n        if lst[i] > max {\n\
    \            max = lst[i]\n        } else {\n            return false\n      \
    \  }\n    }\n    return true\n}\n", "    var i int\n    for i = 0; i < len(lst)\
    \ - 1; i++ {\n        if lst[i] >= lst[i + 1] {\n            return false\n  \
    \      }\n    }\n    return true\n}\n", "    var res bool = true\n    prev :=\
    \ lst[0]\n    dups := make(map[int]int)\n    dups[prev] = 1\n    for i := 1; i\
    \ < len(lst); i++ {\n        if lst[i] < prev {\n            res = false\n   \
    \         break\n        }\n        _, ok := dups[lst[i]]\n        if ok {\n \
    \           res = false\n            break\n        }\n        dups[lst[i]] =\
    \ 1\n        prev = lst[i]\n    }\n    return res\n}\n", "    for i := 0; i <\
    \ len(lst) - 1; i++ {\n        if lst[i] > lst[i + 1] {\n            return false\n\
    \        }\n    }\n    return true\n}\n", "\treturn false\n}\n", "    var currentValue\
    \ int = 0\n    var previousValue int = 0\n    var dupeCount int = 0\n    for i,\
    \ val := range lst {\n        if i == 0 {\n            currentValue = val\n  \
    \          previousValue = val\n            continue\n        }\n        currentValue\
    \ = val\n        if currentValue == previousValue {\n            dupeCount++\n\
    \        }\n        if currentValue < previousValue {\n            return false\n\
    \        }\n        previousValue = currentValue\n    }\n    if dupeCount > 0\
    \ {\n        return false\n    }\n    return true\n}\n", "    // I tried the easier\
    \ solution first:\n    /*for idx, val := range lst {\n        if idx == 0 {\n\
    \            continue\n        } else if val < lst[idx-1] {\n            return\
    \ false\n        }\n    }\n    return true*/\n    if len(lst) == 0 {\n       \
    \ return true\n    }\n    for idx, val := range lst {\n        if idx == 0 {\n\
    \            continue\n        } else if val < lst[idx-1] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n", "    if len(lst) == 0 {\n  \
    \      return true\n    }\n    for i := 1; i < len(lst); i++ {\n        if lst[i]\
    \ <= lst[i-1] {\n            return false\n        }\n    }\n    return true\n\
    }\n", "    prev := lst[0]\n    for i := 1; i < len(lst); i++ {\n        if lst[i]\
    \ < prev {\n            return false\n        }\n        prev = lst[i]\n    }\n\
    \    return true\n}\n", "    if len(lst) == 0 {\n        return true\n    }\n\n\
    \    for i := 0; i < len(lst) - 1; i++ {\n        if lst[i] >= lst[i + 1] {\n\
    \            return false\n        }\n    }\n\n    return true\n}\n", "    if\
    \ len(lst) == 0 {\n        return true\n    }\n    last := lst[0]\n    for _,\
    \ value := range lst {\n        if value < last {\n            return false\n\
    \        }\n        last = value\n    }\n    return true\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
