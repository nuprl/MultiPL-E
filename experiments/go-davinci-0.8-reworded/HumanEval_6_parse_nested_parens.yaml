name: HumanEval_6_parse_nested_parens
language: go_test.go
prompt: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
  \n)\n\n// Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n// For each of the group, output the deepest\
  \ level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\"\
  )\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n"
tests: "func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"),\
  \ expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
  ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"),\
  \ expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    depths := make([]int, 0)\n    current_depth := 0\n    for _, char\
    \ := range paren_string {\n        if string(char) == \"(\" {\n            current_depth\
    \ += 1\n        } else if string(char) == \")\" {\n            current_depth -=\
    \ 1\n        } else if string(char) == \" \" {\n            depths = append(depths,\
    \ current_depth)\n            current_depth = 0\n        }\n    }\n    depths\
    \ = append(depths, current_depth)\n    return depths\n}\n", "    var result []int\n\
    \    var stack_depth []int\n\n    for i, c := range paren_string {\n        if\
    \ c == '(' {\n            stack_depth = append(stack_depth, 0)\n        } else\
    \ if c == ')' {\n            depth := stack_depth[len(stack_depth) - 1]\n    \
    \        stack_depth = stack_depth[:len(stack_depth) - 1]\n            if len(stack_depth)\
    \ == 0 {\n                // This is the only way to tell the end of a parenthesis.\n\
    \                result = append(result, depth)\n            } else {\n      \
    \          stack_depth[len(stack_depth) - 1] = depth + 1\n            }\n    \
    \    } else if c == ' ' {\n            if len(stack_depth) == 0 {\n          \
    \      // This is the only way to tell the end of a parenthesis.\n           \
    \     result = append(result, 0)\n            }\n        }\n    }\n\n    return\
    \ result\n}\n", "    result := make([]int, 0)\n    // TODO - Add your code here\n\
    \    return result\n}\n", "    max_level := 0\n    current_level := 0\n    levels\
    \ := []int{}\n    for _, rune_value := range paren_string {\n        if string(rune_value)\
    \ == \"(\" {\n            current_level += 1\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if string(rune_value) == \")\" {\n            levels = append(levels, max_level)\n\
    \            current_level -= 1\n            if current_level > max_level {\n\
    \                max_level = current_level\n            }\n        }\n    }\n\
    \    return levels\n}\n", "    // Implement this placeholder.\n    return []int{0}\n\
    }\n", "    output := make([]int, 0)\n    for _, item := range paren_string {\n\
    \        if item == ' ' {\n            continue\n        }\n        if item ==\
    \ '(' {\n            output = append(output, 0)\n        } else {\n          \
    \  output[len(output) - 1] += 1\n        }\n    }\n    return output\n}\n", " \
    \   // use a stack to keep track of the current deepest level\n    stack := make([]int,\
    \ 0)\n    // append the depth of nesting 0 to the front of the stack\n    stack\
    \ = append(stack, 0)\n    result := make([]int, 0)\n    // iterate through each\
    \ of the parenthesis\n    for _, paren := range paren_string {\n        char :=\
    \ string(paren)\n        switch char {\n        case \"(\":\n            // if\
    \ it's a left paren, append the current deepest level plus one to the stack.\n\
    \            stack = append(stack, stack[len(stack)-1]+1)\n        case \")\"\
    :\n            // if it's a right paren, pop the value from the stack, which is\
    \ the deepest level for this group.\n            stack_len := len(stack)\n   \
    \         level := stack[stack_len-1]\n            stack = stack[:stack_len-1]\n\
    \            result = append(result, level)\n        default:\n            //\
    \ do nothing for spaces\n        }\n    }\n    return result\n}\n", "    max_level\
    \ := 0\n    current_level := 0\n    open_parens := 0\n    result := make([]int,\
    \ 0)\n    for _, c := range paren_string {\n        if c == '(' {\n          \
    \  open_parens++\n            current_level++\n            if current_level >\
    \ max_level {\n                max_level = current_level\n            }\n    \
    \    } else if c == ')' {\n            open_parens--\n            current_level--\n\
    \        } else if c == ' ' {\n            if open_parens == 0 {\n           \
    \     result = append(result, max_level)\n                max_level = 0\n    \
    \            current_level = 0\n            }\n        }\n    }\n    if open_parens\
    \ == 0 {\n        result = append(result, max_level)\n    }\n    return result\n\
    }\n", "    var output []int\n    var level int\n    for _, r := range paren_string\
    \ {\n        switch r {\n        case '(':\n            level++\n        case\
    \ ')':\n            output = append(output, level)\n            level--\n    \
    \    }\n    }\n    return output\n}\n", "    // TODO: Implement this function\n\
    \    return []int{}\n}\n", "    var result []int\n    var depth int = 0\n    var\
    \ max_depth int = 0\n    for _, c := range paren_string {\n        if c == '('\
    \ {\n            depth += 1\n            if depth > max_depth {\n            \
    \    max_depth = depth\n            }\n        } else if c == ')' {\n        \
    \    depth -= 1\n        } else if c == ' ' {\n            result = append(result,\
    \ max_depth)\n            max_depth = 0\n            depth = 0\n        }\n  \
    \  }\n    result = append(result, max_depth)\n    return result\n}\n", "    result\
    \ := make([]int, 0)\n    parens := []rune(paren_string)\n    left := 0\n    right\
    \ := 0\n    for _, paren := range parens {\n        if paren == '(' {\n      \
    \      left += 1\n        } else if paren == ')' {\n            right += 1\n \
    \       } else if paren == ' ' {\n            result = append(result, left - right)\n\
    \            left = 0\n            right = 0\n        }\n    }\n    if left -\
    \ right != 0 {\n        result = append(result, left - right)\n    }\n    return\
    \ result\n}\n", "    var result []int\n    return result\n}\n", "    var depth_array\
    \ []int\n    depth := 0\n    for i := 0; i < len(paren_string); i++ {\n      \
    \  if paren_string[i] == '(' {\n            depth++\n        } else if paren_string[i]\
    \ == ')' {\n            depth_array = append(depth_array, depth)\n           \
    \ depth--\n        }\n    }\n    return depth_array\n}\n", "    // Split string\
    \ by spaces.\n    paren_array := strings.Split(paren_string, \" \")\n    result\
    \ := make([]int, len(paren_array))\n    for i, paren := range paren_array {\n\
    \        result[i] = find_deepest_level(paren)\n    }\n    return result\n}\n",
  "    nest_levels := make([]int, 0)\n    nest_level := 0\n    max_nest_level := 0\n\
    \    for _, c := range paren_string {\n        switch c {\n        case '(':\n\
    \            nest_level += 1\n            if nest_level > max_nest_level {\n \
    \               max_nest_level = nest_level\n            }\n        case ')':\n\
    \            nest_level -= 1\n        case ' ':\n            if nest_level ==\
    \ 0 {\n                nest_levels = append(nest_levels, max_nest_level)\n   \
    \             max_nest_level = 0\n            }\n        }\n    }\n    return\
    \ nest_levels\n}\n", "    result := make([]int, 0)\n    for i, val := range paren_string\
    \ {\n        if string(val) == \"(\" {\n            temp_result := 0\n       \
    \     for i = i + 1; i < len(paren_string); i++ {\n                if string(paren_string[i])\
    \ == \"(\" {\n                    temp_result++\n                } else if string(paren_string[i])\
    \ == \")\" {\n                    temp_result--\n                }\n         \
    \       if temp_result == 0 {\n                    break\n                }\n\
    \            }\n            result = append(result, temp_result)\n        }\n\
    \    }\n    return result\n}\n", "    var stack []int\n    var deep_levels []int\n\
    \    var level int\n    for _, c := range paren_string {\n        if c == '('\
    \ {\n            stack = append(stack, c)\n            level++\n        } else\
    \ if c == ')' {\n            stack = stack[:len(stack)-1]\n            level--\n\
    \        } else if c == ' ' {\n            deep_levels = append(deep_levels, level)\n\
    \            level = 0\n        }\n    }\n    return deep_levels\n}\n", "    var\
    \ result []int\n    return result\n}\n", "    max_nesting := 0\n    current_nesting\
    \ := 0\n    max_nesting_per_parentheses := []int{}\n    for _, c := range paren_string\
    \ {\n        if c == '(' {\n            current_nesting++\n            if current_nesting\
    \ > max_nesting {\n                max_nesting = current_nesting\n           \
    \ }\n        } else if c == ')' {\n            max_nesting_per_parentheses = append(max_nesting_per_parentheses,\
    \ max_nesting)\n            current_nesting--\n            max_nesting = 0\n \
    \       }\n    }\n    return max_nesting_per_parentheses\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
