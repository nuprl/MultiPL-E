name: HumanEval_6_parse_nested_parens
language: go_test.go
prompt: "package parse_nested_parens_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
  \n)\n\n// Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n// For each of the group, output the deepest\
  \ level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\"\
  )\n// []int{2, 3, 1, 3}\nfunc parse_nested_parens(paren_string string) []int {\n"
tests: "func TestParse_Nested_Parens(t *testing.T) {\n  candidate := parse_nested_parens\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"),\
  \ expected: []int{2, 3, 1, 3} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
  ), expected: []int{1, 2, 3, 4} },\n     { actual: candidate(\"(()(())((())))\"),\
  \ expected: []int{4} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    depths := make([]int, 0)\n    current_depth := 0\n    for _, char\
    \ := range paren_string {\n        if string(char) == \"(\" {\n            current_depth\
    \ += 1\n        } else if string(char) == \")\" {\n            current_depth -=\
    \ 1\n        } else if string(char) == \" \" {\n            depths = append(depths,\
    \ current_depth)\n            current_depth = 0\n        }\n    }\n    depths\
    \ = append(depths, current_depth)\n    return depths\n}\n", "    var result []int\n\
    \    var stack_depth []int\n\n    for i, c := range paren_string {\n        if\
    \ c == '(' {\n            stack_depth = append(stack_depth, 0)\n        } else\
    \ if c == ')' {\n            depth := stack_depth[len(stack_depth) - 1]\n    \
    \        stack_depth = stack_depth[:len(stack_depth) - 1]\n            if len(stack_depth)\
    \ == 0 {\n                // This is the only way to tell the end of a parenthesis.\n\
    \                result = append(result, depth)\n            } else {\n      \
    \          stack_depth[len(stack_depth) - 1] = depth + 1\n            }\n    \
    \    } else if c == ' ' {\n            if len(stack_depth) == 0 {\n          \
    \      // This is the only way to tell the end of a parenthesis.\n           \
    \     result = append(result, 0)\n            }\n        }\n    }\n\n    return\
    \ result\n}\n", "    result := make([]int, 0)\n    // TODO - Add your code here\n\
    \    return result\n}\n", "    max_level := 0\n    current_level := 0\n    levels\
    \ := []int{}\n    for _, rune_value := range paren_string {\n        if string(rune_value)\
    \ == \"(\" {\n            current_level += 1\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if string(rune_value) == \")\" {\n            levels = append(levels, max_level)\n\
    \            current_level -= 1\n            if current_level > max_level {\n\
    \                max_level = current_level\n            }\n        }\n    }\n\
    \    return levels\n}\n", "    // Implement this placeholder.\n    return []int{0}\n\
    }\n", "    output := make([]int, 0)\n    for _, item := range paren_string {\n\
    \        if item == ' ' {\n            continue\n        }\n        if item ==\
    \ '(' {\n            output = append(output, 0)\n        } else {\n          \
    \  output[len(output) - 1] += 1\n        }\n    }\n    return output\n}\n", " \
    \   // use a stack to keep track of the current deepest level\n    stack := make([]int,\
    \ 0)\n    // append the depth of nesting 0 to the front of the stack\n    stack\
    \ = append(stack, 0)\n    result := make([]int, 0)\n    // iterate through each\
    \ of the parenthesis\n    for _, paren := range paren_string {\n        char :=\
    \ string(paren)\n        switch char {\n        case \"(\":\n            // if\
    \ it's a left paren, append the current deepest level plus one to the stack.\n\
    \            stack = append(stack, stack[len(stack)-1]+1)\n        case \")\"\
    :\n            // if it's a right paren, pop the value from the stack, which is\
    \ the deepest level for this group.\n            stack_len := len(stack)\n   \
    \         level := stack[stack_len-1]\n            stack = stack[:stack_len-1]\n\
    \            result = append(result, level)\n        default:\n            //\
    \ do nothing for spaces\n        }\n    }\n    return result\n}\n", "    max_level\
    \ := 0\n    current_level := 0\n    open_parens := 0\n    result := make([]int,\
    \ 0)\n    for _, c := range paren_string {\n        if c == '(' {\n          \
    \  open_parens++\n            current_level++\n            if current_level >\
    \ max_level {\n                max_level = current_level\n            }\n    \
    \    } else if c == ')' {\n            open_parens--\n            current_level--\n\
    \        } else if c == ' ' {\n            if open_parens == 0 {\n           \
    \     result = append(result, max_level)\n                max_level = 0\n    \
    \            current_level = 0\n            }\n        }\n    }\n    if open_parens\
    \ == 0 {\n        result = append(result, max_level)\n    }\n    return result\n\
    }\n", "    var output []int\n    var level int\n    for _, r := range paren_string\
    \ {\n        switch r {\n        case '(':\n            level++\n        case\
    \ ')':\n            output = append(output, level)\n            level--\n    \
    \    }\n    }\n    return output\n}\n", "    // TODO: Implement this function\n\
    \    return []int{}\n}\n", "    var result []int\n    var depth int = 0\n    var\
    \ max_depth int = 0\n    for _, c := range paren_string {\n        if c == '('\
    \ {\n            depth += 1\n            if depth > max_depth {\n            \
    \    max_depth = depth\n            }\n        } else if c == ')' {\n        \
    \    depth -= 1\n        } else if c == ' ' {\n            result = append(result,\
    \ max_depth)\n            max_depth = 0\n            depth = 0\n        }\n  \
    \  }\n    result = append(result, max_depth)\n    return result\n}\n", "    result\
    \ := make([]int, 0)\n    parens := []rune(paren_string)\n    left := 0\n    right\
    \ := 0\n    for _, paren := range parens {\n        if paren == '(' {\n      \
    \      left += 1\n        } else if paren == ')' {\n            right += 1\n \
    \       } else if paren == ' ' {\n            result = append(result, left - right)\n\
    \            left = 0\n            right = 0\n        }\n    }\n    if left -\
    \ right != 0 {\n        result = append(result, left - right)\n    }\n    return\
    \ result\n}\n", "    var result []int\n    return result\n}\n", "    var depth_array\
    \ []int\n    depth := 0\n    for i := 0; i < len(paren_string); i++ {\n      \
    \  if paren_string[i] == '(' {\n            depth++\n        } else if paren_string[i]\
    \ == ')' {\n            depth_array = append(depth_array, depth)\n           \
    \ depth--\n        }\n    }\n    return depth_array\n}\n", "    // Split string\
    \ by spaces.\n    paren_array := strings.Split(paren_string, \" \")\n    result\
    \ := make([]int, len(paren_array))\n    for i, paren := range paren_array {\n\
    \        result[i] = find_deepest_level(paren)\n    }\n    return result\n}\n",
  "    nest_levels := make([]int, 0)\n    nest_level := 0\n    max_nest_level := 0\n\
    \    for _, c := range paren_string {\n        switch c {\n        case '(':\n\
    \            nest_level += 1\n            if nest_level > max_nest_level {\n \
    \               max_nest_level = nest_level\n            }\n        case ')':\n\
    \            nest_level -= 1\n        case ' ':\n            if nest_level ==\
    \ 0 {\n                nest_levels = append(nest_levels, max_nest_level)\n   \
    \             max_nest_level = 0\n            }\n        }\n    }\n    return\
    \ nest_levels\n}\n", "    result := make([]int, 0)\n    for i, val := range paren_string\
    \ {\n        if string(val) == \"(\" {\n            temp_result := 0\n       \
    \     for i = i + 1; i < len(paren_string); i++ {\n                if string(paren_string[i])\
    \ == \"(\" {\n                    temp_result++\n                } else if string(paren_string[i])\
    \ == \")\" {\n                    temp_result--\n                }\n         \
    \       if temp_result == 0 {\n                    break\n                }\n\
    \            }\n            result = append(result, temp_result)\n        }\n\
    \    }\n    return result\n}\n", "    var stack []int\n    var deep_levels []int\n\
    \    var level int\n    for _, c := range paren_string {\n        if c == '('\
    \ {\n            stack = append(stack, c)\n            level++\n        } else\
    \ if c == ')' {\n            stack = stack[:len(stack)-1]\n            level--\n\
    \        } else if c == ' ' {\n            deep_levels = append(deep_levels, level)\n\
    \            level = 0\n        }\n    }\n    return deep_levels\n}\n", "    var\
    \ result []int\n    return result\n}\n", "    max_nesting := 0\n    current_nesting\
    \ := 0\n    max_nesting_per_parentheses := []int{}\n    for _, c := range paren_string\
    \ {\n        if c == '(' {\n            current_nesting++\n            if current_nesting\
    \ > max_nesting {\n                max_nesting = current_nesting\n           \
    \ }\n        } else if c == ')' {\n            max_nesting_per_parentheses = append(max_nesting_per_parentheses,\
    \ max_nesting)\n            current_nesting--\n            max_nesting = 0\n \
    \       }\n    }\n    return max_nesting_per_parentheses\n}\n", "    var count\
    \ int\n    var deepest_depth []int\n    for _, char := range paren_string {\n\
    \        if char == '(' {\n            count++\n        } else if char == ')'\
    \ {\n            deepest_depth = append(deepest_depth, count)\n            count--\n\
    \        }\n    }\n    return deepest_depth\n}\n", "    max_levels := []int{}\n\
    \    current_level := 0\n    max_level := 0\n    // Iterate over the string one\
    \ rune at a time\n    for _, ch := range paren_string {\n        // Keep track\
    \ of the level of nesting\n        if ch == '(' {\n            current_level +=\
    \ 1\n        } else if ch == ')' {\n            current_level -= 1\n        }\
    \ else if ch == ' ' {\n            // When a space is encountered, record the\
    \ maximum level of nesting\n            // encountered for this group of parentheses\n\
    \            max_levels = append(max_levels, max_level)\n            // Reset\
    \ current_level and max_level for the next group of parentheses\n            current_level\
    \ = 0\n            max_level = 0\n        }\n        // If the level of nesting\
    \ for the current group is greater than the\n        // maximum level of nesting\
    \ so far, update max_level\n        if current_level > max_level {\n         \
    \   max_level = current_level\n        }\n    }\n    return max_levels\n}\n",
  "    // Insert code here.\n    return []int{}\n}\n", "    level_vec := make([]int,\
    \ 0)\n    level := 0\n    max_level := 0\n    for _, val := range paren_string\
    \ {\n        if string(val) == \"(\" {\n            level += 1\n            if\
    \ level > max_level {\n                max_level = level\n            }\n    \
    \    } else if string(val) == \")\" {\n            level -= 1\n        } else\
    \ if string(val) == \" \" {\n            level_vec = append(level_vec, max_level)\n\
    \            max_level = 0\n            level = 0\n        }\n    }\n    level_vec\
    \ = append(level_vec, max_level)\n    return level_vec\n}\n", "    paren_chars\
    \ := []rune(paren_string)\n    max_nest_level := 0\n    max_nest_levels := []int{}\n\
    \    current_nest_level := 0\n    for _, paren_char := range paren_chars {\n \
    \       switch string(paren_char) {\n        case \"(\":\n            current_nest_level++\n\
    \            if current_nest_level > max_nest_level {\n                max_nest_level\
    \ = current_nest_level\n            }\n        case \")\":\n            current_nest_level--\n\
    \            if current_nest_level == 0 {\n                max_nest_levels = append(max_nest_levels,\
    \ max_nest_level)\n                max_nest_level = 0\n            }\n       \
    \ case \" \":\n            // Ignore, space is used as a separator\n        default:\n\
    \            fmt.Printf(\"Not recognized character '%v'!\\n\", paren_char)\n \
    \       }\n    }\n    return max_nest_levels\n}\n", "    var result []int\n  \
    \  for _, paren := range paren_string {\n        fmt.Println(paren)\n    }\n \
    \   return result\n}\n", "    ans := make([]int, 0)\n    levels := make([]int,\
    \ 0)\n    for _, char := range paren_string {\n        if char == '(' {\n    \
    \        levels = append(levels, 0)\n        } else if char == ')' {\n       \
    \     level := 0\n            for i := len(levels) - 1; i >= 0; i-- {\n      \
    \          if levels[i] == 0 {\n                    level = i + 1\n          \
    \          break\n                }\n            }\n            levels = levels[:level]\n\
    \            ans = append(ans, level)\n        }\n    }\n    return ans\n}\n",
  "    res := make([]int, 0)\n    paren_depth := 0\n    max_depth := 0\n    for _,\
    \ ch := range paren_string {\n        if ch == '(' {\n            paren_depth++\n\
    \            if paren_depth > max_depth {\n                max_depth = paren_depth\n\
    \            }\n        } else if ch == ')' {\n            paren_depth--\n   \
    \     } else if ch == ' ' {\n            res = append(res, max_depth)\n      \
    \      max_depth = 0\n            paren_depth = 0\n        }\n    }\n    res =\
    \ append(res, max_depth)\n    return res\n}\n", "    char_indices := make([]int,\
    \ len(paren_string))\n    for i, char := range paren_string {\n        char_indices[i]\
    \ = int(char)\n    }\n    // Number of groups\n    groups := len(char_indices)\
    \ / 6\n    // E.g. for input \"(()()) ((())) () ((())()())\", char_indices will\
    \ be [40, 40, 41, 41, 40, 41, 32, 32, 40, 40, 41, 41, 41, 32, 32, 41, 32, 32,\
    \ 40, 40, 41, 41, 41, 41, 40, 41, 41, 41, 41]\n    // so groups = 6\n    //fmt.Println(char_indices)\n\
    \    paren_depth := make([]int, groups)\n    // Loop over each group\n    for\
    \ i := 0; i < groups; i++ {\n        // Index of the beginning of the group\n\
    \        group_index := i * 6\n        // Index of the first parentheses\n   \
    \     first_paren := group_index + 1\n        // Index of the second parentheses\n\
    \        second_paren := group_index + 4\n        // Index of the end of the group\n\
    \        end_group := group_index + 5\n        if (char_indices[group_index] ==\
    \ 40 && char_indices[end_group] == 41) {\n            // If there is a nested\
    \ parentheses, call this function on the nested parentheses, then add 1 to the\
    \ result\n            if (char_indices[first_paren] == 40 && char_indices[second_paren]\
    \ == 41) {\n                paren_depth[i] = parse_nested_parens(paren_string[first_paren\
    \ + 1:second_paren])[0] + 1\n            } else {\n                paren_depth[i]\
    \ = 1\n            }\n        }\n    }\n    return paren_depth\n}\n", "    var\
    \ current_level int = 0\n    var max_level int = 0\n    var outputs []int\n  \
    \  for _, char := range paren_string {\n        if string(char) == \"(\" {\n \
    \           current_level += 1\n            if current_level > max_level {\n \
    \               max_level = current_level\n            }\n        } else if string(char)\
    \ == \")\" {\n            current_level -= 1\n        } else if string(char) ==\
    \ \" \" {\n            outputs = append(outputs, max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    outputs = append(outputs,\
    \ max_level)\n    return outputs\n}\n", "    var result []int\n    current_nest\
    \ := 0\n    max_nest := 0\n    for _, paren := range paren_string {\n        if\
    \ paren == '(' {\n            current_nest += 1\n            if current_nest >\
    \ max_nest {\n                max_nest = current_nest\n            }\n       \
    \ } else if paren == ')' {\n            result = append(result, max_nest)\n  \
    \          current_nest -= 1\n            max_nest -= 1\n        }\n    }\n  \
    \  return result\n}\n", "    results := make([]int, 0)\n    level := 0\n    highest_level\
    \ := 0\n    for _, c := range paren_string {\n        if c == '(' {\n        \
    \    level++\n            if level > highest_level {\n                highest_level\
    \ = level\n            }\n        } else if c == ')' {\n            level--\n\
    \        } else if c == ' ' {\n            results = append(results, highest_level)\n\
    \            highest_level = 0\n            level = 0\n        }\n    }\n    results\
    \ = append(results, highest_level)\n    return results\n}\n", "    paren_levels\
    \ := make([]int, 0)\n    for paren_index := 0; paren_index < len(paren_string);\
    \ paren_index++ {\n        if paren_string[paren_index] == '(' {\n           \
    \ paren_level := 1\n            paren_index++\n            for paren_index < len(paren_string)\
    \ && paren_string[paren_index] != ' ' {\n                if paren_string[paren_index]\
    \ == '(' {\n                    paren_level++\n                } else if paren_string[paren_index]\
    \ == ')' {\n                    paren_level--\n                }\n           \
    \     paren_index++\n            }\n            paren_levels = append(paren_levels,\
    \ paren_level)\n        }\n    }\n    return paren_levels\n}\n", "    max_depth\
    \ := 0\n    depth := 0\n    depth_arr := []int{}\n    for _, x := range paren_string\
    \ {\n        if x == '(' {\n            depth += 1\n            if depth > max_depth\
    \ {\n                max_depth = depth\n            }\n        } else if x ==\
    \ ')' {\n            depth -= 1\n        } else if x == ' ' {\n            depth_arr\
    \ = append(depth_arr, max_depth)\n            max_depth = 0\n            depth\
    \ = 0\n        }\n    }\n    depth_arr = append(depth_arr, max_depth)\n    return\
    \ depth_arr\n}\n", "    max_depth := 0\n    current_depth := 0\n    depths :=\
    \ []int{}\n    for _, char := range paren_string {\n        if char == '(' {\n\
    \            current_depth += 1\n            if current_depth > max_depth {\n\
    \                max_depth = current_depth\n            }\n        } else if char\
    \ == ')' {\n            if current_depth > 0 {\n                current_depth\
    \ -= 1\n            }\n        } else if char == ' ' {\n            depths = append(depths,\
    \ max_depth)\n            max_depth = 0\n            current_depth = 0\n     \
    \   }\n    }\n    depths = append(depths, max_depth)\n    return depths\n}\n",
  "    if len(paren_string) == 0 {\n        return []int{}\n    }\n    paren_string_list\
    \ := make([]string, 0)\n    cur_str := \"\"\n    for _, val := range paren_string\
    \ {\n        if val == ' ' {\n            paren_string_list = append(paren_string_list,\
    \ cur_str)\n            cur_str = \"\"\n        } else {\n            cur_str\
    \ += string(val)\n        }\n    }\n    paren_string_list = append(paren_string_list,\
    \ cur_str)\n    paren_count_list := make([]int, 0)\n    for _, val := range paren_string_list\
    \ {\n        max_count := parse_nested_parens_util(val)\n        paren_count_list\
    \ = append(paren_count_list, max_count)\n    }\n    return paren_count_list\n\
    }\n", "    ret := make([]int, 0)\n    max_level := 0\n    count := 0\n    // Loop\
    \ through the string, look for one group of parentheses.\n    for _, v := range\
    \ paren_string {\n        // If v is (, increase the level.\n        if v == '('\
    \ {\n            count++\n            if count > max_level {\n               \
    \ max_level = count\n            }\n        } else if v == ')' {\n           \
    \ // Else if v is ), decrease the level.\n            count--\n        } else\
    \ if v == ' ' {\n            // Else if v is space, add the max level of the previous\n\
    \            // group to the ret and reset the max level to 0.\n            ret\
    \ = append(ret, max_level)\n            max_level = 0\n        }\n    }\n    //\
    \ Add the last group.\n    ret = append(ret, max_level)\n    return ret\n}\n",
  "    left_paren := \"(\"\n    right_paren := \")\"\n    results := make([]int, 0)\n\
    \    for len(paren_string) > 0 {\n        if paren_string[0] != '(' {\n      \
    \      paren_string = paren_string[1:]\n            continue\n        }\n    \
    \    count := 0\n        for i, c := range paren_string {\n            if string(c)\
    \ == left_paren {\n                count += 1\n            } else if string(c)\
    \ == right_paren {\n                count -= 1\n            }\n            if\
    \ count == 0 {\n                results = append(results, i + 1)\n           \
    \     paren_string = paren_string[i + 1:]\n                break\n           \
    \ }\n        }\n    }\n    return results\n}\n", "    max_depth := 0\n    current_depth\
    \ := 0\n    result := make([]int, 0)\n    for _, paren := range paren_string {\n\
    \        if paren == '(' {\n            current_depth += 1\n            if current_depth\
    \ > max_depth {\n                max_depth = current_depth\n            }\n  \
    \      } else if paren == ')' {\n            result = append(result, max_depth)\n\
    \            current_depth -= 1\n        }\n    }\n    return result\n}\n", " \
    \   results := make([]int, 0)\n    depth := 0\n    local_max := 0\n    for _,\
    \ char := range paren_string {\n        if char == '(' {\n            depth +=\
    \ 1\n            if depth > local_max {\n                local_max = depth\n \
    \           }\n        } else if char == ')' {\n            depth -= 1\n     \
    \   } else if char == ' ' {\n            results = append(results, local_max)\n\
    \            local_max = 0\n            depth = 0\n        }\n    }\n    if local_max\
    \ > 0 {\n        results = append(results, local_max)\n    }\n    return results\n\
    }\n", "    // TODO: Implement\n    parens := []rune(paren_string)\n    level :=\
    \ 0\n    levels := []int{}\n    for _, paren := range parens {\n        if paren\
    \ == '(' {\n            level += 1\n        } else if paren == ')' {\n       \
    \     level -= 1\n        } else if paren == ' ' {\n            levels = append(levels,\
    \ level)\n            level = 0\n        }\n    }\n    return levels\n}\n", " \
    \   ret := make([]int, 0)\n    for _, paren_group := range paren_string {\n  \
    \      if paren_group == ' ' {\n            continue\n        }\n\n        count\
    \ := 0\n        max_count := 0\n        for _, paren := range paren_group {\n\
    \            if paren == '(' {\n                count++\n            } else if\
    \ paren == ')' {\n                count--\n            }\n\n            if count\
    \ > max_count {\n                max_count = count\n            }\n        }\n\
    \n        ret = append(ret, max_count)\n    }\n\n    return ret\n}\n", "    paren_list\
    \ := make([]int, 0)\n    paren_array := make([]rune, 0)\n    // traverse through\
    \ the string and create a list of parens and store the deepest level of nesting\n\
    \    paren_depth := 0\n    max_paren_depth := 0\n    for _, char := range paren_string\
    \ {\n        if char == '(' {\n            paren_depth++\n            if paren_depth\
    \ > max_paren_depth {\n                max_paren_depth = paren_depth\n       \
    \     }\n        } else if char == ')' {\n            paren_depth--\n        }\
    \ else if char == ' ' {\n            paren_list = append(paren_list, max_paren_depth)\n\
    \            max_paren_depth = 0\n            paren_depth = 0\n        }\n   \
    \ }\n    paren_list = append(paren_list, max_paren_depth)\n    return paren_list\n\
    }\n", "    parens := []rune(paren_string)\n    deepest_nesting := 0\n    running_nesting\
    \ := 0\n    nesting_levels := []int{}\n    for _, paren := range parens {\n  \
    \      if paren == '(' {\n            running_nesting++\n            if running_nesting\
    \ > deepest_nesting {\n                deepest_nesting = running_nesting\n   \
    \         }\n        } else if paren == ')' {\n            running_nesting--\n\
    \        } else if paren == ' ' {\n            nesting_levels = append(nesting_levels,\
    \ deepest_nesting)\n            deepest_nesting = 0\n            running_nesting\
    \ = 0\n        }\n    }\n    return nesting_levels\n}\n", "    var ret []int\n\
    \    var depth int\n    depth = 0\n    // TODO: implementation\n    ret = append(ret,\
    \ depth)\n    return ret\n}\n", "    // TODO:\n    // 1. convert each of the group\
    \ string to int\n    // 2. store the converted int in a slice to return\n    //\
    \ 3. return the slice\n    return nil\n}\n", "    stack := make([]int, 0)\n  \
    \  nmax := make([]int, 0)\n    var dnmax int\n    for i := 0; i < len(paren_string);\
    \ i++ {\n        if paren_string[i] == '(' {\n            stack = append(stack,\
    \ i)\n        } else if paren_string[i] == ')' {\n            if len(stack) ==\
    \ 0 {\n                return nil\n            }\n            dnmax = i - stack[len(stack)-1]\n\
    \            nmax = append(nmax, dnmax)\n            stack = stack[:len(stack)-1]\n\
    \        }\n    }\n    return nmax\n}\n", "    var paren_stack []int\n    var\
    \ result []int\n    current_max := 0\n    var left_parens = map[string]int{\n\
    \        \"(\": 1,\n    }\n    var right_parens = map[string]int{\n        \"\
    )\": -1,\n    }\n    var parens = map[string]int{\n        \"(\": 1,\n       \
    \ \")\": -1,\n    }\n    for _, c := range paren_string {\n        val, exists\
    \ := parens[string(c)]\n        if exists {\n            paren_stack = append(paren_stack,\
    \ val)\n            current_max += val\n            if val == -1 {\n         \
    \       result = append(result, current_max)\n                current_max = 0\n\
    \            }\n        }\n    }\n    return result\n}\n", "    if len(paren_string)\
    \ == 0 {\n        return []int{}\n    }\n    results := []int{}\n    current_index\
    \ := 0\n    current_max := 0\n    for _, char := range paren_string {\n      \
    \  if char == '(' {\n            current_index += 1\n            if current_index\
    \ > current_max {\n                current_max = current_index\n            }\n\
    \        } else if char == ')' {\n            current_index -= 1\n        } else\
    \ if char == ' ' {\n            results = append(results, current_max)\n     \
    \       current_index = 0\n            current_max = 0\n        }\n    }\n   \
    \ results = append(results, current_max)\n    return results\n}\n", "    var s\
    \ string = paren_string\n    var res []int\n    for len(s) > 0 {\n        var\
    \ r int = 0\n        for i, v := range s {\n            if v == '(' {\n      \
    \          r++\n            } else if v == ')' {\n                r--\n      \
    \      }\n            if r == 0 {\n                res = append(res, i+1)\n  \
    \              s = s[i+2:]\n                break\n            }\n        }\n\
    \    }\n    return res\n}\n", "    count := 0\n    max := 0\n    result := []int{}\n\
    \    for _, c := range paren_string {\n        if c == '(' {\n            count\
    \ += 1\n            if count > max {\n                max = count\n          \
    \  }\n        } else if c == ')' {\n            count -= 1\n        } else if\
    \ c == ' ' {\n            result = append(result, max)\n            max = 0\n\
    \            count = 0\n        }\n    }\n    result = append(result, max)\n \
    \   return result\n}\n", "    fmt.Println(\"Input:\", paren_string)\n    if len(paren_string)\
    \ == 0 {\n        return []int{}\n    }\n    paren_depth := 0\n    group_depth\
    \ := []int{}\n    max_depth := 0\n    for _, c := range paren_string {\n     \
    \   if c == '(' {\n            paren_depth++\n            if paren_depth > max_depth\
    \ {\n                max_depth = paren_depth\n            }\n        } else if\
    \ c == ')' {\n            paren_depth--\n        } else if c == ' ' {\n      \
    \      group_depth = append(group_depth, max_depth)\n            max_depth = 0\n\
    \        }\n    }\n    group_depth = append(group_depth, max_depth)\n    return\
    \ group_depth\n}\n", "    var nestings []int\n    var current_nesting int = 0\n\
    \    var max_nesting int = 0\n    for _, c := range paren_string {\n        if\
    \ c == '(' {\n            current_nesting++\n            if current_nesting >\
    \ max_nesting {\n                max_nesting = current_nesting\n            }\n\
    \        } else if c == ')' {\n            current_nesting--\n        } else if\
    \ c == ' ' {\n            nestings = append(nestings, max_nesting)\n         \
    \   max_nesting = 0\n            current_nesting = 0\n        }\n    }\n    nestings\
    \ = append(nestings, max_nesting)\n    return nestings\n}\n", "    var (\n   \
    \     char_array = []rune(paren_string)\n        paren_level []int\n        current_level\
    \ = 0\n    )\n    for _, c := range char_array {\n        if c == '(' {\n    \
    \        current_level++\n        } else if c == ')' {\n            current_level--\n\
    \        } else if c == ' ' {\n            paren_level = append(paren_level, current_level)\n\
    \            current_level = 0\n        }\n    }\n    paren_level = append(paren_level,\
    \ current_level)\n    return paren_level\n}\n", "    fmt.Println(\"input string\
    \ is : \" + paren_string)\n    paren_levels := make([]int, 0)\n    for _, paren_group\
    \ := range Split(paren_string, \" \") {\n        open_paren_count := 0\n     \
    \   max_open_paren_count := 0\n        for _, paren := range paren_group {\n \
    \           if paren == '(' {\n                open_paren_count++\n          \
    \      if open_paren_count > max_open_paren_count {\n                    max_open_paren_count\
    \ = open_paren_count\n                }\n            } else if paren == ')' {\n\
    \                open_paren_count--\n            }\n        }\n        paren_levels\
    \ = append(paren_levels, max_open_paren_count)\n    }\n    return paren_levels\n\
    }\n", "    // TODO: Implement the function\n    return nil\n}\n", "    pos :=\
    \ 0\n    max_level := 0\n    levels := make([]int, 0)\n    for _, r := range paren_string\
    \ {\n        if r == '(' {\n            pos++\n            if pos > max_level\
    \ {\n                max_level = pos\n            }\n        } else if r == ')'\
    \ {\n            levels = append(levels, max_level)\n            pos--\n     \
    \       if pos == 0 {\n                max_level = 0\n            }\n        }\n\
    \    }\n    return levels\n}\n", "    var ret []int\n    var current_level int\n\
    \    for _, ch := range paren_string {\n        switch ch {\n        case '(':\n\
    \            current_level += 1\n        case ')':\n            current_level\
    \ -= 1\n        case ' ':\n            ret = append(ret, current_level)\n    \
    \        current_level = 0\n        }\n    }\n    return ret\n}\n", "    levels\
    \ := make([]int, 0)\n    if paren_string == \"\" {\n        return levels\n  \
    \  }\n    level := 0\n    for _, v := range paren_string {\n        if v == '('\
    \ {\n            level += 1\n        } else if v == ')' {\n            levels\
    \ = append(levels, level)\n            level -= 1\n        }\n    }\n    return\
    \ levels\n}\n", "    max_level := 0\n    max_levels := []int{}\n    current_level\
    \ := 0\n    for _, paren := range paren_string {\n        if paren == '(' {\n\
    \            current_level += 1\n            if current_level > max_level {\n\
    \                max_level = current_level\n            }\n        } else if paren\
    \ == ')' {\n            max_levels = append(max_levels, max_level)\n         \
    \   current_level -= 1\n            if current_level < max_level {\n         \
    \       max_level = current_level\n            }\n        }\n    }\n    return\
    \ max_levels\n}\n", "    results := make([]int, 0)\n    for _, group := range\
    \ paren_string {\n        count := 0\n        max := 0\n        for _, paren :=\
    \ range group {\n            if paren == '(' {\n                count++\n    \
    \        } else if paren == ')' {\n                count--\n            }\n  \
    \          if count > max {\n                max = count\n            }\n    \
    \    }\n        results = append(results, max)\n    }\n    return results\n}\n",
  "    var res []int\n    const left_paren = '('\n    const right_paren = ')'\n  \
    \  for _, group := range paren_string {\n        var count int\n        var max\
    \ int\n        for _, paren := range group {\n            if paren == left_paren\
    \ {\n                count += 1\n            } else if paren == right_paren {\n\
    \                count -= 1\n            }\n            if count > max {\n   \
    \             max = count\n            }\n        }\n        res = append(res,\
    \ max)\n    }\n    return res\n}\n", "    var output []int\n    parens := []byte(paren_string)\n\
    \    for i, _ := range parens {\n        max := 0\n        for parens[i] == '('\
    \ {\n            i++\n            max++\n        }\n        output = append(output,\
    \ max)\n    }\n    return output\n}\n", "    res := make([]int, 0)\n    var count\
    \ int = 0\n    for _, c := range paren_string {\n        if c == '(' {\n     \
    \       count++\n        } else if c == ')' {\n            count--\n        }\
    \ else if c == ' ' {\n            res = append(res, count)\n            count\
    \ = 0\n        }\n    }\n    res = append(res, count)\n    return res\n}\n", " \
    \   var nesting_level []int\n    for _, paren := range paren_string {\n      \
    \  if paren == '(' {\n            nesting_level = append(nesting_level, 1)\n \
    \       } else if paren == ')' {\n            nesting_level = append(nesting_level,\
    \ 0)\n        }\n    }\n    return nesting_level\n}\n", "    group_result := make([]int,\
    \ 0)\n    group_stack := make([]int, 0)\n    paren_stack := make([]byte, 0)\n\
    \    for _, ch := range paren_string {\n        if ch == '(' {\n            paren_stack\
    \ = append(paren_stack, byte(ch))\n        } else if ch == ')' {\n           \
    \ if len(paren_stack) == 0 {\n                panic(\"The string is not balanced\"\
    )\n            }\n            paren_stack = paren_stack[:len(paren_stack)-1]\n\
    \        } else if ch == ' ' {\n            if len(paren_stack) > 0 {\n      \
    \          panic(\"The string is not balanced\")\n            }\n            if\
    \ len(group_stack) == 0 {\n                group_stack = append(group_stack, 1)\n\
    \            } else {\n                group_stack = append(group_stack, group_stack[len(group_stack)-1]+1)\n\
    \            }\n        }\n    }\n    if len(paren_stack) > 0 {\n        panic(\"\
    The string is not balanced\")\n    }\n    for i := 0; i < len(group_stack); i++\
    \ {\n        group_result = append(group_result, group_stack[i]-i)\n    }\n  \
    \  return group_result\n}\n", "    var ret = make([]int, 0)\n    var current =\
    \ 0\n    var max_current = 0\n    for _, char := range paren_string {\n      \
    \  if char == '(' {\n            current++\n            if current > max_current\
    \ {\n                max_current = current\n            }\n        } else if char\
    \ == ')' {\n            current--\n        } else if char == ' ' {\n         \
    \   ret = append(ret, max_current)\n            current = 0\n            max_current\
    \ = 0\n        }\n    }\n    return ret\n}\n", "    var max_nesting_levels []int\n\
    \    var max_level int\n    var level int\n    for _, char := range paren_string\
    \ {\n        if char == '(' {\n            level += 1\n        } else if char\
    \ == ')' {\n            level -= 1\n        } else if char == ' ' {\n        \
    \    max_nesting_levels = append(max_nesting_levels, max_level)\n            max_level\
    \ = 0\n            level = 0\n        }\n        if level > max_level {\n    \
    \        max_level = level\n        }\n    }\n    return max_nesting_levels\n\
    }\n", "    n_paren_group := 0\n    for _, c := range paren_string {\n        if\
    \ c == ' ' {\n            n_paren_group += 1\n        }\n    }\n    if n_paren_group\
    \ == 0 {\n        return []int{0}\n    }\n    results := make([]int, n_paren_group)\n\
    \    idx := 0\n    nested_level := 0\n    for _, c := range paren_string {\n \
    \       if c == '(' {\n            nested_level += 1\n        } else if c == ')'\
    \ {\n            nested_level -= 1\n        } else if c == ' ' {\n           \
    \ results[idx] = nested_level\n            idx += 1\n            nested_level\
    \ = 0\n        }\n    }\n    results[idx] = nested_level\n    return results\n\
    }\n", "    max_depth := 0\n    curr_depth := 0\n    curr_result := []int{}\n \
    \   isLastWasRightParen := false\n    var result []int\n    for _, r := range\
    \ paren_string {\n        if r == '(' {\n            curr_depth++\n          \
    \  if curr_depth > max_depth {\n                max_depth = curr_depth\n     \
    \       }\n            isLastWasRightParen = false\n        } else if r == ')'\
    \ {\n            curr_depth--\n            isLastWasRightParen = true\n      \
    \  } else if r == ' ' {\n            if isLastWasRightParen {\n              \
    \  curr_result = append(curr_result, max_depth)\n                max_depth = 0\n\
    \                curr_depth = 0\n            }\n        }\n    }\n    if isLastWasRightParen\
    \ {\n        curr_result = append(curr_result, max_depth)\n    }\n    return curr_result\n\
    }\n", "    paren_group := strings.Split(paren_string, \" \")\n    paren_depth\
    \ := make([]int, len(paren_group))\n    for i, paren := range paren_group {\n\
    \        current_depth := 0\n        max_depth := 0\n        for _, token := range\
    \ paren {\n            if token == '(' {\n                current_depth++\n  \
    \          } else if token == ')' {\n                current_depth--\n       \
    \     }\n            if current_depth > max_depth {\n                max_depth\
    \ = current_depth\n            }\n        }\n        paren_depth[i] = max_depth\n\
    \    }\n    return paren_depth\n}\n", "    var accum []int\n    var paren int\n\
    \    for _, v := range paren_string {\n        if v == '(' {\n            paren++\n\
    \        } else if v == ')' {\n            paren--\n        } else if v == ' '\
    \ {\n            accum = append(accum, paren)\n        }\n    }\n    return accum\n\
    }\n", "    group_strings := string_to_slice(paren_string)\n    var depths []int\n\
    \    for _, group_string := range group_strings {\n        depths = append(depths,\
    \ count_level(group_string))\n    }\n    return depths\n}\n", "    res := make([]int,\
    \ 0)\n    max_len := 0\n    open_parens := 0\n    for _, c := range paren_string\
    \ {\n        if c == '(' {\n            open_parens += 1\n            if open_parens\
    \ > max_len {\n                max_len = open_parens\n            }\n        }\
    \ else if c == ')' {\n            if open_parens == max_len {\n              \
    \  res = append(res, max_len)\n                max_len = 0\n            }\n  \
    \          open_parens -= 1\n        }\n    }\n    return res\n}\n", "    paren_stack\
    \ := make([]int, 0)\n    max_paren_stack := make([]int, 0)\n    for _, paren :=\
    \ range paren_string {\n        if paren == '(' {\n            paren_stack = append(paren_stack,\
    \ 1)\n        } else if paren == ')' {\n            if len(paren_stack) > 0 {\n\
    \                paren_stack = paren_stack[:len(paren_stack)-1]\n            }\n\
    \        } else if paren == ' ' {\n            if len(paren_stack) > len(max_paren_stack)\
    \ {\n                max_paren_stack = paren_stack\n            }\n          \
    \  paren_stack = make([]int, 0)\n        }\n    }\n    if len(paren_stack) > len(max_paren_stack)\
    \ {\n        max_paren_stack = paren_stack\n    }\n    return max_paren_stack\n\
    }\n", "    var num_nesting []int\n    var current_nesting int\n    for i := 0;\
    \ i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n        \
    \    current_nesting++\n        } else if paren_string[i] == ')' {\n         \
    \   current_nesting--\n        } else if paren_string[i] == ' ' {\n          \
    \  num_nesting = append(num_nesting, current_nesting)\n            current_nesting\
    \ = 0\n        }\n    }\n    num_nesting = append(num_nesting, current_nesting)\n\
    \    return num_nesting\n}\n", "    var result []int\n    return result\n}\n",
  "    // Parse the input string.\n    paren_groups := parse_input(paren_string)\n\
    \n    results := make([]int, len(paren_groups))\n    for i, group := range paren_groups\
    \ {\n        results[i] = analyze_paren_group(group)\n    }\n\n    return results\n\
    }\n", "    result := make([]int, 0)\n    nested_level := 0\n    curr_paren :=\
    \ make([]rune, 0)\n    for _, v := range paren_string {\n        if v == '(' {\n\
    \            nested_level++\n            curr_paren = append(curr_paren, v)\n\
    \        } else if v == ')' {\n            nested_level--\n            curr_paren\
    \ = append(curr_paren, v)\n        } else if v == ' ' {\n            if curr_paren[0]\
    \ == '(' && curr_paren[len(curr_paren)-1] == ')' {\n                result = append(result,\
    \ nested_level)\n            }\n            curr_paren = make([]rune, 0)\n   \
    \     }\n    }\n    return result\n}\n", "    paren_levels := make([]int, 0)\n\
    \    paren_depth := 0\n    start_paren_idx := 0\n    for i, paren := range paren_string\
    \ {\n        if paren == '(' {\n            if paren_depth == 0 {\n          \
    \      start_paren_idx = i\n            }\n            paren_depth++\n       \
    \ } else if paren == ')' {\n            paren_depth--\n            if paren_depth\
    \ == 0 {\n                paren_levels = append(paren_levels, i - start_paren_idx\
    \ + 1)\n            }\n        }\n    }\n    return paren_levels\n}\n", "    panic(\"\
    Not Implemented\")\n}\n", "    parens := []rune(paren_string)\n    cur_max :=\
    \ 0\n    cur_count := 0\n    output := []int{}\n    for _, val := range parens\
    \ {\n        if val == '(' {\n            cur_count += 1\n            if cur_count\
    \ > cur_max {\n                cur_max = cur_count\n            }\n        } else\
    \ if val == ')' {\n            cur_count -= 1\n        } else if val == ' ' {\n\
    \            output = append(output, cur_max)\n            cur_max = 0\n     \
    \       cur_count = 0\n        }\n    }\n    output = append(output, cur_max)\n\
    \    return output\n}\n", "    result := make([]int, 0)\n    current_depth :=\
    \ 0\n    max_depth := 0\n    for _, r := range paren_string {\n        if r ==\
    \ '(' {\n            current_depth += 1\n            if current_depth > max_depth\
    \ {\n                max_depth = current_depth\n            }\n        } else\
    \ if r == ')' {\n            current_depth -= 1\n        } else if r == ' ' {\n\
    \            result = append(result, max_depth)\n            current_depth = 0\n\
    \            max_depth = 0\n        }\n    }\n    result = append(result, max_depth)\n\
    \    return result\n}\n", "    parens := []rune(paren_string)\n    max_depth :=\
    \ 0\n    depth := 0\n    result := make([]int, 0)\n    for _, paren := range parens\
    \ {\n        if paren == '(' {\n            depth += 1\n            if depth >\
    \ max_depth {\n                max_depth = depth\n            }\n        } else\
    \ if paren == ')' {\n            depth -= 1\n        } else if paren == ' ' {\n\
    \            result = append(result, max_depth)\n            max_depth = 0\n \
    \           depth = 0\n        }\n    }\n    result = append(result, max_depth)\n\
    \    return result\n}\n", "    var left_paren, right_paren int = 0, 0\n    var\
    \ max, counter int = 0, 0\n    var res []int\n    for _, v := range paren_string\
    \ {\n        if v == '(' {\n            left_paren += 1\n            counter +=\
    \ 1\n            if counter > max {\n                max = counter\n         \
    \   }\n        } else if v == ')' {\n            right_paren += 1\n          \
    \  counter -= 1\n        } else if v == ' ' {\n            res = append(res, max)\n\
    \            left_paren, right_paren, max, counter = 0, 0, 0, 0\n        }\n \
    \   }\n    return res\n}\n", "    result := make([]int, 0)\n    max_level := 0\n\
    \    level := 0\n    for _, rune := range paren_string {\n        if rune == '('\
    \ {\n            level += 1\n            if level > max_level {\n            \
    \    max_level = level\n            }\n        } else if rune == ')' {\n     \
    \       level -= 1\n        } else if rune == ' ' {\n            result = append(result,\
    \ max_level)\n            max_level = 0\n            level = 0\n        }\n  \
    \  }\n    result = append(result, max_level)\n    return result\n}\n", "    ret\
    \ := make([]int, 0)\n    for _, paren_group := range(paren_string) {\n       \
    \ if paren_group == ' ' {\n            continue\n        }\n        if paren_group\
    \ == '(' {\n            depth := 1\n            if next_paren_group, err := paren_string.next();\
    \ err == nil {\n                if next_paren_group == '(' {\n               \
    \     depth += parse_nested_parens(paren_string)\n                }\n        \
    \    }\n            ret = append(ret, depth)\n        }\n    }\n    return ret\n\
    }\n", "    var levels []int\n    for _, group := range paren_string {\n      \
    \  count := 0\n        for _, paren := range group {\n            if paren ==\
    \ \"(\" {\n                count += 1\n            } else if paren == \")\" {\n\
    \                count -= 1\n            }\n        }\n        levels = append(levels,\
    \ count)\n    }\n    return levels\n}\n", "    var nesting_levels []int\n    var\
    \ current_level int = 0\n    var max_level int = 0\n    var nested_parens_start\
    \ int = 0\n    var nested_parens_end int = 0\n    // find the start and end locations\
    \ of the parentheses\n    for index, char := range paren_string {\n        if\
    \ char == '(' {\n            if current_level == 0 {\n                nested_parens_start\
    \ = index\n            }\n            current_level += 1\n            if current_level\
    \ > max_level {\n                max_level = current_level\n            }\n  \
    \      } else if char == ')' {\n            current_level -= 1\n            if\
    \ current_level == 0 {\n                nested_parens_end = index\n          \
    \      nesting_levels = append(nesting_levels, max_level)\n                max_level\
    \ = 0\n            }\n        }\n    }\n    return nesting_levels\n}\n", "   \
    \ results := make([]int, 0)\n    paren_string = paren_string + \" \"\n    current_max\
    \ := 0\n    curr_count := 0\n    for _, c := range paren_string {\n        switch\
    \ string(c) {\n        case \"(\":\n            curr_count++\n            if curr_count\
    \ > current_max {\n                current_max = curr_count\n            }\n \
    \       case \")\":\n            curr_count--\n        case \" \":\n         \
    \   results = append(results, current_max)\n            current_max = 0\n    \
    \        curr_count = 0\n        }\n    }\n    return results\n}\n", "    var\
    \ num_parens = make([]int, 0)\n    var paren_count int = 0\n    var new_paren_count\
    \ int = 0\n    var max_count int = 0\n    for _, char := range paren_string {\n\
    \        if char == '(' {\n            paren_count += 1\n        } else if char\
    \ == ')' {\n            paren_count -= 1\n        } else if char == ' ' {\n  \
    \          if paren_count > max_count {\n                max_count = paren_count\n\
    \            }\n            new_paren_count = 0\n        }\n        new_paren_count\
    \ += 1\n    }\n    if paren_count > max_count {\n        max_count = paren_count\n\
    \    }\n    num_parens = append(num_parens, max_count)\n    paren_string = paren_string[new_paren_count\
    \ + 1:]\n    return append(num_parens, parse_nested_parens(paren_string)...)\n\
    }\n", "    if paren_string == \"\" {\n        return nil\n    }\n    max_level\
    \ := make([]int, 0)\n    current_level := 0\n    for _, char := range paren_string\
    \ {\n        if char == '(' {\n            current_level += 1\n        } else\
    \ if char == ')' {\n            max_level = append(max_level, current_level)\n\
    \            current_level -= 1\n        }\n    }\n    return max_level\n}\n",
  "    var result []int\n    var nesting_level int\n    var temp_result []int\n  \
    \  for _, c := range paren_string {\n        if c == '(' {\n            nesting_level\
    \ += 1\n        } else if c == ')' {\n            nesting_level -= 1\n       \
    \ } else if c == ' ' {\n            temp_result = append(temp_result, nesting_level)\n\
    \            nesting_level = 0\n        }\n    }\n    var max_nesting_level int\n\
    \    for _, nesting_level := range temp_result {\n        if nesting_level > max_nesting_level\
    \ {\n            max_nesting_level = nesting_level\n        }\n    }\n    for\
    \ _, nesting_level := range temp_result {\n        if nesting_level == max_nesting_level\
    \ {\n            result = append(result, nesting_level)\n        }\n    }\n  \
    \  return result\n}\n", "    depth := 0\n    result := make([]int, 0)\n    for\
    \ _, c := range paren_string {\n        switch c {\n        case '(':\n      \
    \      depth += 1\n        case ')':\n            depth -= 1\n        case ' ':\n\
    \            result = append(result, depth)\n        }\n    }\n    return result\n\
    }\n", "    levels := make([]int, 0)\n    level := 0\n    for _, c := range paren_string\
    \ {\n        switch c {\n        case '(':\n            level++\n        case\
    \ ')':\n            levels = append(levels, level)\n            level--\n    \
    \    }\n    }\n    return levels\n}\n", "    max_level := 0\n    cur_level :=\
    \ 0\n    var result []int\n    for _, s := range paren_string {\n        switch\
    \ string(s) {\n        case \"(\":\n            cur_level++\n            if cur_level\
    \ > max_level {\n                max_level = cur_level\n            }\n      \
    \  case \")\":\n            if cur_level == max_level {\n                result\
    \ = append(result, max_level)\n                max_level = 0\n            }\n\
    \            cur_level--\n        case \" \":\n            if cur_level == max_level\
    \ {\n                result = append(result, max_level)\n                max_level\
    \ = 0\n            }\n            cur_level = 0\n        }\n    }\n    return\
    \ result\n}\n", "    paren_list := []rune(paren_string)\n    paren_indices :=\
    \ []int{}\n    paren_cnt := 0\n    max_cnt := 0\n    for _, paren := range paren_list\
    \ {\n        if paren == '(' {\n            paren_cnt++\n            if paren_cnt\
    \ > max_cnt {\n                max_cnt = paren_cnt\n            }\n        } else\
    \ if paren == ')' {\n            paren_cnt--\n        } else if paren == ' ' {\n\
    \            paren_indices = append(paren_indices, max_cnt)\n            max_cnt\
    \ = 0\n        }\n    }\n    return paren_indices\n}\n", "    return []int{}\n\
    }\n", "    var stack []int\n    var res []int\n    for _, x := range paren_string\
    \ {\n        if string(x) == \"(\" {\n            stack = append(stack, 0)\n \
    \       } else if string(x) == \")\" {\n            var level int\n          \
    \  for i:=len(stack)-1; i>=0; i-- {\n                if stack[i] < 0 {\n     \
    \               stack = stack[:i]\n                    break\n               \
    \ }\n                level += stack[i]\n            }\n            stack = append(stack,\
    \ -1)\n            res = append(res, level)\n        } else if string(x) == \"\
    \ \" {\n            for i:=len(stack)-1; i>=0; i-- {\n                if stack[i]\
    \ < 0 {\n                    stack = stack[:i]\n                    break\n  \
    \              }\n                stack[i]++\n            }\n        }\n    }\n\
    \    return res\n}\n", "    var stack []int\n    var deep int\n    var result\
    \ []int\n    var parsing bool\n\n    for _, char := range paren_string {\n   \
    \     if char == '(' {\n            parsing = true\n            deep += 1\n  \
    \          stack = append(stack, deep)\n        } else if char == ')' {\n    \
    \        if parsing {\n                result = append(result, stack[len(stack)-1])\n\
    \                stack = stack[:len(stack)-1]\n                deep -= 1\n   \
    \         }\n        } else {\n            if parsing {\n                parsing\
    \ = false\n                deep = 0\n            }\n        }\n    }\n    return\
    \ result\n}\n", "    result := make([]int, 0)\n    for _, str := range(Split(paren_string,\
    \ \" \")) {\n        if len(str) == 0 {\n            continue\n        }\n   \
    \     if str[0] != '(' || str[len(str) - 1] != ')' {\n            panic(\"Malformed\
    \ paren string\")\n        }\n        result = append(result, parse_nested_parens_internal(str,\
    \ 0, 1))\n    }\n    return result\n}\n", "    max_levels := []int{}\n    level\
    \ := 0\n    current_group := \"\"\n    for _, c := range paren_string {\n    \
    \    current_group += string(c)\n        if c == '(' {\n            level += 1\n\
    \        } else if c == ')' {\n            level -= 1\n        } else if c ==\
    \ ' ' {\n            max_levels = append(max_levels, level)\n            level\
    \ = 0\n            current_group = \"\"\n        }\n    }\n    return max_levels\n\
    }\n", "    max_level := 0\n    current_level := 0\n    result := make([]int, 0)\n\
    \    for _, char := range paren_string {\n        if char == '(' {\n         \
    \   current_level += 1\n            if current_level > max_level {\n         \
    \       max_level = current_level\n            }\n        } else if char == ')'\
    \ {\n            if current_level == max_level {\n                result = append(result,\
    \ max_level)\n                max_level = 0\n                current_level = 0\n\
    \            } else {\n                current_level -= 1\n            }\n   \
    \     }\n    }\n    return result\n}\n", "    var result []int\n    start := 0\n\
    \    level := 0\n    for i, c := range paren_string {\n        if c == '(' {\n\
    \            level++\n        } else if c == ')' {\n            level--\n    \
    \    } else if c == ' ' {\n            if level > 0 {\n                level--\n\
    \            } else {\n                result = append(result, level - start)\n\
    \                start = level\n            }\n        }\n        if i == len(paren_string)\
    \ - 1 {\n            result = append(result, level - start)\n        }\n    }\n\
    \    return result\n}\n", "    var current_level int = 0\n    var max_level []int\
    \ = make([]int, 0)\n    var current_group []int = make([]int, 0)\n    for _, c\
    \ := range paren_string {\n        if c == '(' {\n            current_level +=\
    \ 1\n            current_group = append(current_group, current_level)\n      \
    \  } else if c == ')' {\n            current_level -= 1\n            current_group\
    \ = append(current_group, current_level)\n        } else if c == ' ' {\n     \
    \       max_level = append(max_level, current_group[len(current_group) - 1])\n\
    \            current_group = make([]int, 0)\n        }\n    }\n    return max_level\n\
    }\n", "    var result []int\n    var count int\n    var index int\n    var i int\n\
    \    for ; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n\
    \            count++\n        } else if paren_string[i] == ')' {\n           \
    \ count--\n        } else if paren_string[i] == ' ' {\n            result = append(result,\
    \ count)\n            count = 0\n            index++\n        }\n    }\n    result\
    \ = append(result, count)\n    return result\n}\n", "    var stack []int\n   \
    \ for _, c := range paren_string {\n        if c == '(' {\n            stack =\
    \ append(stack, 0)\n        } else if c == ')' {\n            depth := 0\n   \
    \         for i := len(stack) - 1; i >= 0; i-- {\n                if stack[i]\
    \ == 0 {\n                    depth = len(stack) - i\n                    break\n\
    \                }\n            }\n            stack = append(stack, depth)\n\
    \        }\n    }\n    return stack\n}\n", "    paren_array := []int{}\n    paren_group\
    \ := \"\"\n    for _, char := range paren_string {\n        switch char {\n  \
    \      case '(':\n            paren_group += \"(\"\n        case ')':\n      \
    \      paren_group += \")\"\n        case ' ':\n            paren_array = append(paren_array,\
    \ parse_nested_parens_core(paren_group))\n            paren_group = \"\"\n   \
    \     }\n    }\n    return paren_array\n}\n", "    count_levels := func(input\
    \ string) int {\n        var level int\n        max_level := 0\n        for _,\
    \ c := range input {\n            if c == '(' {\n                level++\n   \
    \         } else if c == ')' {\n                level--\n            } else {\n\
    \                panic(\"Invalid input!\")\n            }\n            if level\
    \ > max_level {\n                max_level = level\n            }\n        }\n\
    \        return max_level\n    }\n\n    var result []int\n    for _, paren :=\
    \ range paren_string {\n        if paren == ' ' {\n            continue\n    \
    \    }\n        fmt.Println(paren)\n        level := count_levels(string(paren))\n\
    \        result = append(result, level)\n    }\n    return result\n}\n", "   \
    \ var result []int\n    var paren_counter int\n    var deepest_nesting int\n \
    \   for _, char := range paren_string {\n        if string(char) == \"(\" {\n\
    \            paren_counter++\n            if paren_counter > deepest_nesting {\n\
    \                deepest_nesting = paren_counter\n            }\n        } else\
    \ if string(char) == \")\" {\n            paren_counter--\n        } else if string(char)\
    \ == \" \" {\n            result = append(result, deepest_nesting)\n         \
    \   deepest_nesting = 0\n        }\n    }\n    result = append(result, deepest_nesting)\n\
    \    return result\n}\n", "    var result []int\n    current_level := 0\n    max_level\
    \ := 0\n    for _, char := range paren_string {\n        if char == '(' {\n  \
    \          current_level++\n            if current_level > max_level {\n     \
    \           max_level = current_level\n            }\n        } else if char ==\
    \ ')' {\n            current_level--\n        } else if char == ' ' {\n      \
    \      result = append(result, max_level)\n            max_level = 0\n       \
    \     current_level = 0\n        }\n    }\n    result = append(result, max_level)\n\
    \    return result\n}\n", "    max_count := 0\n    counts := []int{}\n    for\
    \ _, word := range split_words(paren_string) {\n        for _, char := range word\
    \ {\n            if char == '(' {\n                max_count += 1\n          \
    \  } else if char == ')' {\n                max_count -= 1\n            }\n  \
    \      }\n        counts = append(counts, max_count)\n        max_count = 0\n\
    \    }\n    return counts\n}\n", "    var deepest_nesting = []int{}\n    var cur_paren_group\
    \ = \"\"\n    var cur_deepest_nesting = 0\n    var cur_nesting = 0\n    for _,\
    \ paren := range paren_string {\n        if string(paren) == \" \" {\n       \
    \     deepest_nesting = append(deepest_nesting, cur_deepest_nesting)\n       \
    \     cur_paren_group = \"\"\n            cur_deepest_nesting = 0\n          \
    \  cur_nesting = 0\n        } else {\n            cur_paren_group += string(paren)\n\
    \            if string(paren) == \"(\" {\n                cur_nesting += 1\n \
    \               if cur_nesting > cur_deepest_nesting {\n                    cur_deepest_nesting\
    \ = cur_nesting\n                }\n            } else {\n                cur_nesting\
    \ -= 1\n            }\n        }\n    }\n    deepest_nesting = append(deepest_nesting,\
    \ cur_deepest_nesting)\n    return deepest_nesting\n}\n", "    levels := make([]int,\
    \ 0)\n    paren_level := 0\n    for _, c := range paren_string {\n        if c\
    \ == '(' {\n            paren_level++\n        } else if c == ')' {\n        \
    \    levels = append(levels, paren_level)\n            paren_level--\n       \
    \ }\n    }\n    return levels\n}\n", "    depths := make([]int, 0)\n    max_depth\
    \ := 0\n    depth := 0\n    open_paren := '('\n    close_paren := ')'\n    lparen_count\
    \ := 0\n    rparen_count := 0\n    for _, char := range paren_string {\n     \
    \   if char == open_paren {\n            lparen_count += 1\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == close_paren {\n            rparen_count\
    \ += 1\n            depth -= 1\n        } else if char == ' ' {\n            if\
    \ lparen_count == rparen_count {\n                depths = append(depths, max_depth)\n\
    \                max_depth = 0\n                depth = 0\n                lparen_count\
    \ = 0\n                rparen_count = 0\n            }\n        }\n    }\n   \
    \ return depths\n}\n", "    var current_level int\n    var result []int\n    for\
    \ _, v := range paren_string {\n        // fmt.Println(v)\n        if v == '('\
    \ {\n            current_level += 1\n        } else if v == ')' {\n          \
    \  current_level -= 1\n        } else if v == ' ' {\n            result = append(result,\
    \ current_level)\n            current_level = 0\n        }\n    }\n    return\
    \ result\n}\n", "    if paren_string == \"\" {\n        return []int{}\n    }\n\
    \    stack := make([]int, 0)\n    max := make([]int, 0)\n    for _, ch := range\
    \ paren_string {\n        if ch == '(' {\n            stack = append(stack, 0)\n\
    \        } else if ch == ')' {\n            if len(stack) > 0 {\n            \
    \    stack[len(stack)-1]++\n                if len(stack) > len(max) {\n     \
    \               max = stack\n                }\n            }\n        } else\
    \ if ch == ' ' {\n            stack = stack[:0]\n        }\n    }\n    return\
    \ max\n}\n", "    var paren_levels []int\n    var current_level int = 0\n    var\
    \ max_level int = 0\n    var char string\n    for _, char = range paren_string\
    \ {\n        switch char {\n        case '(':\n            current_level += 1\n\
    \            if current_level > max_level {\n                max_level = current_level\n\
    \            }\n        case ')':\n            current_level -= 1\n        case\
    \ ' ':\n            paren_levels = append(paren_levels, max_level)\n         \
    \   max_level = 0\n            current_level = 0\n        }\n    }\n    paren_levels\
    \ = append(paren_levels, max_level)\n    return paren_levels\n}\n", "    var results\
    \ []int\n    return results\n}\n", "    parens := []rune(paren_string)\n    res\
    \ := make([]int, 0)\n    max := 0\n    for _, c := range parens {\n        if\
    \ c == '(' {\n            max += 1\n        } else if c == ')' {\n           \
    \ max -= 1\n        } else {\n            res = append(res, max)\n           \
    \ max = 0\n        }\n    }\n    res = append(res, max)\n    return res\n}\n",
  "    depths := make([]int, 0)\n    cur_depth := 0\n    max_depth := 0\n    for _,\
    \ c := range paren_string {\n        if c == '(' {\n            cur_depth++\n\
    \            if cur_depth > max_depth {\n                max_depth = cur_depth\n\
    \            }\n        } else if c == ')' {\n            if cur_depth > 0 {\n\
    \                cur_depth--\n            }\n        } else if c == ' ' {\n  \
    \          depths = append(depths, max_depth)\n            max_depth = 0\n   \
    \         cur_depth = 0\n        }\n    }\n    depths = append(depths, max_depth)\n\
    \    return depths\n}\n", "    levels := make([]int, 0)\n    depth := 0\n    max_depth\
    \ := 0\n    for _, c := range paren_string {\n        switch c {\n        case\
    \ '(':\n            depth += 1\n            max_depth = max(max_depth, depth)\n\
    \        case ')':\n            depth -= 1\n        case ' ':\n            if\
    \ depth == 0 {\n                levels = append(levels, max_depth)\n         \
    \       max_depth = 0\n            }\n        }\n    }\n    levels = append(levels,\
    \ max_depth)\n    return levels\n}\n", "    var current_level int = 0\n    var\
    \ max_levels []int\n    for _, current_paren := range paren_string {\n       \
    \ if current_paren == '(' {\n            current_level++\n        } else if current_paren\
    \ == ')' {\n            current_level--\n        } else if current_paren == '\
    \ ' {\n            max_levels = append(max_levels, current_level)\n          \
    \  current_level = 0\n        }\n    }\n    return max_levels\n}\n", "    var\
    \ max_depth int = 0\n    var depth_stack []int\n    var depth_list []int\n   \
    \ for _, ch := range paren_string {\n        if ch == '(' {\n            depth_stack\
    \ = append(depth_stack, 0)\n        } else if ch == ')' {\n            depth_stack\
    \ = depth_stack[:len(depth_stack)-1]\n        } else if ch == ' ' {\n        \
    \    if len(depth_stack) > max_depth {\n                max_depth = len(depth_stack)\n\
    \            }\n            depth_list = append(depth_list, max_depth)\n     \
    \       max_depth = 0\n        }\n    }\n    return depth_list\n}\n", "    parens\
    \ := []int{}\n    cur := 0\n    for _, r := range paren_string {\n        switch\
    \ r {\n        case '(':\n            cur++\n        case ')':\n            cur--\n\
    \        case ' ':\n            parens = append(parens, cur)\n            cur\
    \ = 0\n        }\n    }\n    return parens\n}\n", "    var ret []int\n    var\
    \ max_count int = 0\n    var count int = 0\n    for _, char := range paren_string\
    \ {\n        if char == '(' {\n            count += 1\n        } else if char\
    \ == ')' {\n            count -= 1\n        }\n        max_count = max(max_count,\
    \ count)\n        if char == ' ' {\n            ret = append(ret, max_count)\n\
    \            max_count = 0\n            count = 0\n        }\n    }\n    return\
    \ ret\n}\n", "    prev_level := 0 // Keep track of current level of nesting\n\
    \    max_level := 0 // Keep track of max level of nesting\n    result := []int{}\
    \ // Store result for each group\n    for _, char := range paren_string {\n  \
    \      if string(char) == \"(\" {\n            prev_level += 1\n            if\
    \ prev_level > max_level {\n                max_level = prev_level\n         \
    \   }\n        } else if string(char) == \")\" {\n            prev_level -= 1\n\
    \        } else if string(char) == \" \" {\n            result = append(result,\
    \ max_level)\n            max_level = 0\n            prev_level = 0\n        }\n\
    \    }\n    result = append(result, max_level)\n    return result\n}\n", "   \
    \ result := make([]int, 0)\n    start_pos := 0\n    cur_level := 0\n    max_level\
    \ := 0\n    for pos, char := range paren_string {\n        if char == '(' {\n\
    \            cur_level += 1\n            if cur_level > max_level {\n        \
    \        max_level = cur_level\n            }\n        } else if char == ')' {\n\
    \            cur_level -= 1\n        } else if char == ' ' {\n            result\
    \ = append(result, max_level)\n            start_pos = pos + 1\n            cur_level\
    \ = 0\n            max_level = 0\n        }\n    }\n    result = append(result,\
    \ max_level)\n    return result\n}\n", "    var nested_parens []int\n    var current_level\
    \ int = 0\n    var max_level int = 0\n    for _, char := range paren_string {\n\
    \        if char == '(' {\n            current_level++\n            if current_level\
    \ > max_level {\n                max_level = current_level\n            }\n  \
    \      } else if char == ')' {\n            current_level--\n        } else if\
    \ char == ' ' {\n            nested_parens = append(nested_parens, max_level)\n\
    \            max_level = 0\n            current_level = 0\n        }\n    }\n\
    \    return nested_parens\n}\n", "    paren_array := []int{}\n    paren_count\
    \ := 0\n    for _, char := range paren_string {\n        switch char {\n     \
    \   case '(':\n            paren_count++\n        case ')':\n            paren_count--\n\
    \        case ' ':\n            paren_array = append(paren_array, paren_count)\n\
    \            paren_count = 0\n        }\n    }\n    return paren_array\n}\n",
  "    max_levels := make([]int, 0)\n    current_level := 0\n    current_max := 0\n\
    \    // This is to indicate if there is any dangling left or right parenthesis,\
    \ which means the string is not valid.\n    left_dangling := false\n    right_dangling\
    \ := false\n    for _, char := range paren_string {\n        switch char {\n \
    \       case '(':\n            current_level += 1\n            if current_level\
    \ > current_max {\n                current_max = current_level\n            }\n\
    \        case ')':\n            if current_level == 0 {\n                right_dangling\
    \ = true\n            } else {\n                current_level -= 1\n         \
    \   }\n        case ' ':\n            if current_level != 0 {\n              \
    \  left_dangling = true\n            }\n            max_levels = append(max_levels,\
    \ current_max)\n            current_max = 0\n            current_level = 0\n \
    \       }\n    }\n    if current_level != 0 {\n        left_dangling = true\n\
    \    }\n    max_levels = append(max_levels, current_max)\n    if left_dangling\
    \ || right_dangling {\n        return nil\n    }\n    return max_levels\n}\n",
  "    // returns the index of the matched parenthesis.\n    match_paren := func(paren_string\
    \ string, start_index int) int {\n        stack := make([]int, 0)\n\n        for\
    \ i, char := range paren_string {\n            if char == '(' {\n            \
    \    stack = append(stack, i)\n            } else if char == ')' {\n         \
    \       if len(stack) == 0 {\n                    return -1\n                }\
    \ else {\n                    stack = stack[:len(stack)-1]\n                }\n\
    \            }\n        }\n\n        return -1\n    }\n\n    // returns the nesting\
    \ level of the parentheses.\n    get_level := func(paren_string string) int {\n\
    \        level := 0\n        for _, char := range paren_string {\n           \
    \ if char == '(' {\n                level++\n            } else if char == ')'\
    \ {\n                level--\n            }\n        }\n        return level\n\
    \    }\n\n    res := make([]int, 0)\n    for i := 0; i < len(paren_string); {\n\
    \        if paren_string[i] == ' ' {\n            i++\n            continue\n\
    \        }\n        j := match_paren(paren_string[i:], 0)\n        if j != -1\
    \ {\n            res = append(res, get_level(paren_string[i:i+j+1]))\n       \
    \     i += j + 1\n        } else {\n            res = append(res, 0)\n       \
    \     i++\n        }\n    }\n\n    return res\n}\n", "    parens := make([]int,\
    \ 0)\n    count := 0\n    for _, c := range paren_string {\n        if c == '('\
    \ {\n            count += 1\n        } else if c == ')' {\n            count -=\
    \ 1\n        }\n        if c == ' ' {\n            parens = append(parens, count)\n\
    \            count = 0\n        }\n    }\n    parens = append(parens, count)\n\
    \    return parens\n}\n", "    var prev_level int = 0\n    var ans []int = make([]int,\
    \ 0)\n    var level int = 0\n    for _, paren := range paren_string {\n      \
    \  if string(paren) == \"(\" {\n            level += 1\n        } else if string(paren)\
    \ == \")\" {\n            level -= 1\n        } else if string(paren) == \" \"\
    \ {\n            ans = append(ans, level)\n            level = 0\n        }\n\
    \    }\n    return ans\n}\n", "    // TODO\n    return []int{}\n}\n", "    max_nesting\
    \ := 0\n    cur_nesting := 0\n    max_nesting_lst := []int{}\n    for _, paren\
    \ := range paren_string {\n        if paren == '(' {\n            cur_nesting\
    \ += 1\n        } else if paren == ')' {\n            cur_nesting -= 1\n     \
    \   } else if paren == ' ' {\n            max_nesting_lst = append(max_nesting_lst,\
    \ max_nesting)\n            max_nesting = 0\n            cur_nesting = 0\n   \
    \     }\n        if cur_nesting > max_nesting {\n            max_nesting = cur_nesting\n\
    \        }\n    }\n    max_nesting_lst = append(max_nesting_lst, max_nesting)\n\
    \    return max_nesting_lst\n}\n", "    var stack []int\n\n    // Maximum number\
    \ of groups are 4:\n    parsed_nesting_levels := make([]int, 4)\n    nesting_level\
    \ := 0\n    group_count := 0\n\n    for i := 0; i < len(paren_string); i++ {\n\
    \        switch paren_string[i] {\n        case '(':\n            stack = append(stack,\
    \ 0)\n            nesting_level++\n        case ')':\n            if nesting_level\
    \ == 0 {\n                return nil\n            }\n            stack = stack[:len(stack)-1]\n\
    \            nesting_level--\n        case ' ':\n            if nesting_level\
    \ != 0 {\n                return nil\n            }\n            parsed_nesting_levels[group_count]\
    \ = len(stack)\n            group_count++\n        }\n    }\n\n    if len(stack)\
    \ != 0 {\n        return nil\n    }\n\n    return parsed_nesting_levels\n}\n",
  "    var output []int\n    var depth int\n    var depth_max int\n    var paren_open\
    \ = rune('(')\n    var paren_close = rune(')')\n    paren_string_runes := []rune(paren_string)\n\
    \    for _, v := range paren_string_runes {\n        if v == paren_open {\n  \
    \          depth++\n            if depth > depth_max {\n                depth_max\
    \ = depth\n            }\n        } else if v == paren_close {\n            output\
    \ = append(output, depth_max)\n            depth_max = 0\n            depth--\n\
    \        }\n    }\n    return output\n}\n", "    var max_level_list []int\n  \
    \  var paren_count, paren_max_count int\n\n    for index, char := range paren_string\
    \ {\n        if char == '(' {\n            paren_count++\n            paren_max_count\
    \ = Max(paren_max_count, paren_count)\n        } else if char == ')' {\n     \
    \       paren_count--\n        } else if char == ' ' {\n            max_level_list\
    \ = append(max_level_list, paren_max_count)\n            paren_count, paren_max_count\
    \ = 0, 0\n        }\n        if index == len(paren_string) - 1 {\n           \
    \ max_level_list = append(max_level_list, paren_max_count)\n        }\n    }\n\
    \    return max_level_list\n}\n", "    var groups []string = make([]string, 0)\n\
    \    var empty_string string = \"\"\n    for _, char := range paren_string {\n\
    \        if char == ' ' {\n            if empty_string != \"\" {\n           \
    \     groups = append(groups, empty_string)\n                empty_string = \"\
    \"\n            }\n        } else {\n            empty_string += string(char)\n\
    \        }\n    }\n    if empty_string != \"\" {\n        groups = append(groups,\
    \ empty_string)\n    }\n    var result []int = make([]int, len(groups))\n    for\
    \ i, group := range groups {\n        var current_level int = 0\n        var max_level\
    \ int = 0\n        for _, char := range group {\n            if char == '(' {\n\
    \                current_level += 1\n            } else if char == ')' {\n   \
    \             current_level -= 1\n            }\n            if current_level\
    \ > max_level {\n                max_level = current_level\n            }\n  \
    \      }\n        result[i] = max_level\n    }\n    return result\n}\n", "   \
    \ results := make([]int, 0)\n    parens := []rune(paren_string)\n    result, consumed\
    \ := get_nested_parens(parens)\n    if consumed < len(parens) {\n        fmt.Println(\"\
    Unconsumed Inputs: \", parens[consumed:])\n    }\n    results = append(results,\
    \ result)\n    return results\n}\n", "    stack := []int{}\n    results := []int{}\n\
    \    for _, paren := range paren_string {\n        switch paren {\n        case\
    \ '(':\n            stack = append(stack, 1)\n        case ')':\n            if\
    \ len(stack) == 0 {\n                // Invalid input\n                stack =\
    \ append(stack, 0)\n            } else {\n                res := 0\n         \
    \       for _, p := range stack {\n                    res += p\n            \
    \    }\n                results = append(results, res)\n                stack\
    \ = stack[:len(stack)-1]\n            }\n        case ' ':\n            if len(stack)\
    \ > 0 {\n                res := 0\n                for _, p := range stack {\n\
    \                    res += p\n                }\n                results = append(results,\
    \ res)\n            }\n            stack = []int{}\n        }\n    }\n    return\
    \ results\n}\n", "    if len(paren_string) == 0 {\n        return []int{}\n  \
    \  }\n    // Use a stack to parse string\n    stack := []int{}\n    max_level\
    \ := []int{}\n    current_level := 0\n    for _, v := range paren_string {\n \
    \       if v == '(' {\n            stack = append(stack, 1)\n            current_level++\n\
    \        } else if v == ')' {\n            stack = stack[:len(stack)-1]\n    \
    \        current_level--\n        } else if v == ' ' {\n            max_level\
    \ = append(max_level, current_level)\n        }\n    }\n    max_level = append(max_level,\
    \ current_level)\n    return max_level\n}\n", "    output := make([]int, 0)\n\
    \    level := 0\n    for _, c := range paren_string {\n        if c == '(' {\n\
    \            level += 1\n        } else if c == ')' {\n            output = append(output,\
    \ level)\n            level -= 1\n        }\n    }\n    return output\n}\n", " \
    \   // TODO - Add your code here\n    return nil\n}\n", "    var nested_levels\
    \ []int\n    var current_level int = 0\n    var max_level int = 0\n    var paren_string_array\
    \ []rune = []rune(paren_string)\n    for _, current_rune := range paren_string_array\
    \ {\n        switch current_rune {\n        case '(':\n            current_level\
    \ += 1\n            if max_level < current_level {\n                max_level\
    \ = current_level\n            }\n        case ')':\n            if current_level\
    \ == 0 {\n                // error\n                panic(\"Invalid input string:\
    \ extra closing parenthesis.\")\n            }\n            current_level -= 1\n\
    \        case ' ':\n            if current_level != 0 {\n                // error\n\
    \                panic(\"Invalid input string: unexpected space in the middle\
    \ of a level.\")\n            }\n            nested_levels = append(nested_levels,\
    \ max_level)\n            max_level = 0\n        default:\n            // error\n\
    \            panic(\"Invalid input string: unexpected character.\")\n        }\n\
    \    }\n    // Add the last nested_level\n    nested_levels = append(nested_levels,\
    \ max_level)\n    return nested_levels\n}\n", "    // Space separated groups of\
    \ parens\n    paren_groups := []string{}\n    start := 0\n    for i, ch := range\
    \ paren_string {\n        if ch == ' ' {\n            paren_groups = append(paren_groups,\
    \ paren_string[start:i])\n            start = i + 1\n        }\n    }\n    if\
    \ start < len(paren_string) {\n        paren_groups = append(paren_groups, paren_string[start:])\n\
    \    }\n\n    // For each paren group, calculate the max level of nesting\n  \
    \  max_level := []int{}\n    for _, s := range paren_groups {\n        tmp :=\
    \ 0\n        max := 0\n        for _, ch := range s {\n            if ch == '('\
    \ {\n                tmp += 1\n            } else if ch == ')' {\n           \
    \     tmp -= 1\n            }\n            if tmp > max {\n                max\
    \ = tmp\n            }\n        }\n        max_level = append(max_level, max)\n\
    \    }\n    return max_level\n}\n", "    depth := 0\n    depth_list := make([]int,\
    \ 0)\n    for _, c := range paren_string {\n        switch c {\n        case '(':\n\
    \            depth++\n        case ')':\n            depth_list = append(depth_list,\
    \ depth)\n            depth--\n        case ' ':\n            // skip this\n \
    \       default:\n            fmt.Printf(\"Error: unexpected character %v in input\
    \ string.\\n\", c)\n        }\n    }\n    return depth_list\n}\n", "    levels\
    \ := make([]int, 0)\n    current_level := 0\n    for _, c := range paren_string\
    \ {\n        switch c {\n        case '(':\n            current_level++\n    \
    \    case ')':\n            current_level--\n        default:\n            levels\
    \ = append(levels, current_level)\n            current_level = 0\n        }\n\
    \    }\n    return levels\n}\n", "    results := make([]int, 0)\n    nest_level\
    \ := 0\n    for _, char := range paren_string {\n        if char == '(' {\n  \
    \          nest_level += 1\n        } else if char == ')' {\n            nest_level\
    \ -= 1\n        } else if char == ' ' {\n            results = append(results,\
    \ nest_level)\n            nest_level = 0\n        }\n    }\n    results = append(results,\
    \ nest_level)\n    return results\n}\n", "    var nested_levels []int\n    var\
    \ current_level int\n    var max_level int\n    for _, c := range paren_string\
    \ {\n        if c == '(' {\n            current_level++\n            if current_level\
    \ > max_level {\n                max_level = current_level\n            }\n  \
    \      } else if c == ')' {\n            current_level--\n        } else if c\
    \ == ' ' {\n            nested_levels = append(nested_levels, max_level)\n   \
    \         max_level = 0\n            current_level = 0\n        }\n    }\n   \
    \ nested_levels = append(nested_levels, max_level)\n    return nested_levels\n\
    }\n", "    result := make([]int, 0)\n    current_level := 0\n    current_group\
    \ := 0\n    var i int\n    for i = 0; i < len(paren_string); i++ {\n        if\
    \ paren_string[i] == '(' {\n            current_level += 1\n        } else if\
    \ paren_string[i] == ')' {\n            current_level -= 1\n        } else if\
    \ paren_string[i] == ' ' {\n            result = append(result, current_level)\n\
    \            current_level = 0\n            current_group += 1\n        }\n  \
    \  }\n    result = append(result, current_level)\n    return result\n}\n", " \
    \   output := make([]int, 0)\n    token := \"\"\n    for _, char := range paren_string\
    \ {\n        if char == ' ' {\n            if token != \"\" {\n              \
    \  output = append(output, parse_single_group(token))\n                token =\
    \ \"\"\n            }\n        } else {\n            token += string(char)\n \
    \       }\n    }\n    if token != \"\" {\n        output = append(output, parse_single_group(token))\n\
    \    }\n    return output\n}\n", "    // The algorithm is to iterate through the\
    \ string, for each character\n    //   if it is '(', increment the level by 1\n\
    \    //   if it is ')', decrement the level by 1\n    //   if it is ' ', check\
    \ if it is the deepest level of nesting, update the max if it is\n    //\n   \
    \ // The state we keep is the number of levels of nesting we have seen so far.\n\
    \    //\n    // Another tricky part is that we do not know how many parentheses\
    \ group we have in the input string.\n    // We need to make sure we reset the\
    \ level to 0 whenever we see a space.\n    //\n    // If a parentheses is unmatched,\
    \ the level would go below 0. It is also possible that it never goes back to 0.\n\
    \    //\n    // If we go past the end of the string and level is not 0, it is\
    \ an error.\n\n    max_levels := []int{}\n    level := 0\n    max_level := 0\n\
    \    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i] == '('\
    \ {\n            level += 1\n        } else if paren_string[i] == ')' {\n    \
    \        level -= 1\n        } else if paren_string[i] == ' ' {\n            if\
    \ level > max_level {\n                max_level = level\n            }\n    \
    \        max_levels = append(max_levels, max_level)\n            max_level = 0\n\
    \            level = 0\n        }\n    }\n    if level > max_level {\n       \
    \ max_level = level\n    }\n    max_levels = append(max_levels, max_level)\n \
    \   if level != 0 {\n        fmt.Println(\"Error, string not balanced\")\n   \
    \ }\n    return max_levels\n}\n", "    left_paren_counter := 0\n    right_paren_counter\
    \ := 0\n    output := []int{}\n    for _, char := range paren_string {\n     \
    \   // fmt.Println(char)\n        if char == '(' {\n            left_paren_counter\
    \ += 1\n        } else if char == ')' {\n            right_paren_counter += 1\n\
    \        } else if char == ' ' {\n            // fmt.Println(\"appending \", left_paren_counter,\
    \ right_paren_counter)\n            output = append(output, left_paren_counter)\n\
    \            left_paren_counter = 0\n            right_paren_counter = 0\n   \
    \     }\n    }\n    output = append(output, left_paren_counter)\n    return output\n\
    }\n", "    paren_groups := paren_string[1:len(paren_string) - 1]\n    paren_group_array\
    \ := make([]string, 0)\n    index := 0\n    for i := 0; i < len(paren_groups);\
    \ i++ {\n        if paren_groups[i] == '(' {\n            index = i\n        }\
    \ else if paren_groups[i] == ')' {\n            paren_group_array = append(paren_group_array,\
    \ paren_groups[index:i + 1])\n        }\n    }\n    max_nesting_level := make([]int,\
    \ len(paren_group_array))\n    for i := 0; i < len(paren_group_array); i++ {\n\
    \        max_nesting_level[i] = parse_max_nesting_level(paren_group_array[i])\n\
    \    }\n    return max_nesting_level\n}\n", "    var max_depth []int\n    var\
    \ num_left int\n    for _, char := range paren_string {\n        if string(char)\
    \ == \"(\" {\n            num_left += 1\n        } else if string(char) == \"\
    )\" {\n            num_left -= 1\n        } else if string(char) == \" \" {\n\
    \            max_depth = append(max_depth, num_left)\n            num_left = 0\n\
    \        }\n    }\n    return max_depth\n}\n", "    var res []int\n    num :=\
    \ 0\n    for _, ch := range paren_string {\n        if ch == '(' {\n         \
    \   num++\n        } else if ch == ')' {\n            res = append(res, num)\n\
    \            num--\n        }\n    }\n    return res\n}\n", "    paren_levels\
    \ := make([]int, 0)\n    level := 0\n    for _, c := range paren_string {\n  \
    \      if c == '(' {\n            level += 1\n        } else if c == ')' {\n \
    \           level -= 1\n        } else if c == ' ' {\n            paren_levels\
    \ = append(paren_levels, level)\n            level = 0\n        }\n    }\n   \
    \ return paren_levels\n}\n", "    max_levels := make([]int, 0)\n    max_level\
    \ := 0\n    level := 0\n    for _, paren := range paren_string {\n        if paren\
    \ == '(' {\n            level += 1\n            if level > max_level {\n     \
    \           max_level = level\n            }\n        } else if paren == ')' {\n\
    \            level -= 1\n            if level == 0 {\n                max_levels\
    \ = append(max_levels, max_level)\n                max_level = 0\n           \
    \ }\n        }\n    }\n    return max_levels\n}\n", "    results := make([]int,\
    \ 0)\n    if len(paren_string) == 0 {\n        return results\n    }\n    left_paren_count\
    \ := 0\n    right_paren_count := 0\n    max_depth := 0\n    for _, ch := range\
    \ paren_string {\n        switch ch {\n        case '(':\n            left_paren_count++\n\
    \            max_depth = max(max_depth, left_paren_count)\n        case ')':\n\
    \            right_paren_count++\n            max_depth = max(max_depth, right_paren_count)\n\
    \        case ' ':\n            // Do nothing\n        default:\n            return\
    \ []int{}\n        }\n        if left_paren_count == right_paren_count {\n   \
    \         results = append(results, max_depth)\n            max_depth = 0\n  \
    \          left_paren_count = 0\n            right_paren_count = 0\n        }\n\
    \    }\n    return results\n}\n", "    nest_depth := 0\n    max_nest_depth :=\
    \ 0\n    nest_depth_list := []int{}\n    for i := 0; i < len(paren_string); i++\
    \ {\n        c := paren_string[i]\n        if c == '(' {\n            nest_depth++\n\
    \            if nest_depth > max_nest_depth {\n                max_nest_depth\
    \ = nest_depth\n            }\n        } else if c == ')' {\n            nest_depth--\n\
    \        } else if c == ' ' {\n            nest_depth_list = append(nest_depth_list,\
    \ max_nest_depth)\n            max_nest_depth = 0\n            nest_depth = 0\n\
    \        }\n    }\n    nest_depth_list = append(nest_depth_list, max_nest_depth)\n\
    \    return nest_depth_list\n}\n", "    var results []int\n    var i int\n   \
    \ var deepest_level int\n    var count int\n\n    for i = 0; i < len(paren_string);\
    \ i++ {\n        if paren_string[i] == '(' {\n            count++\n          \
    \  if count > deepest_level {\n                deepest_level = count\n       \
    \     }\n        } else if paren_string[i] == ')' {\n            count--\n   \
    \     } else if paren_string[i] == ' ' {\n            results = append(results,\
    \ deepest_level)\n            deepest_level = 0\n            count = 0\n     \
    \   }\n    }\n    results = append(results, deepest_level)\n    return results\n\
    }\n", "    var result []int\n    var current_level int = 0\n    var max_level\
    \ int = 0\n    for _, paren := range paren_string {\n        if paren == '(' {\n\
    \            current_level += 1\n            if current_level > max_level {\n\
    \                max_level = current_level\n            }\n        } else if paren\
    \ == ')' {\n            result = append(result, max_level)\n            current_level\
    \ -= 1\n            max_level = current_level\n        }\n    }\n    return result\n\
    }\n", "    arr := make([]int, len(paren_string))\n    max_l := 0\n    max_r :=\
    \ 0\n    cnt := 0\n    for i, c := range paren_string {\n        //fmt.Println(i,\
    \ c)\n        if c == '(' {\n            if cnt == 0 {\n                max_l\
    \ = i\n            }\n            cnt++\n        } else if c == ')' {\n      \
    \      if cnt == 1 {\n                max_r = i\n                arr[i] = max_r\
    \ - max_l + 1\n            }\n            cnt--\n        }\n    }\n    //fmt.Println(arr)\n\
    \    return arr\n}\n", "    if len(paren_string) == 0 {\n        return []int{}\n\
    \    }\n    var max_nesting_levels []int = make([]int, 0)\n    var paren_stack\
    \ []int = make([]int, 0)\n    for _, c := range paren_string {\n        if c ==\
    \ '(' {\n            paren_stack = append(paren_stack, 0)\n        } else if c\
    \ == ')' {\n            if len(paren_stack) > 0 {\n                popped_val\
    \ := paren_stack[len(paren_stack) - 1]\n                paren_stack = paren_stack[:len(paren_stack)\
    \ - 1]\n                if len(paren_stack) > 0 {\n                    paren_stack[len(paren_stack)\
    \ - 1] += popped_val + 1\n                } else {\n                    max_nesting_levels\
    \ = append(max_nesting_levels, popped_val + 1)\n                }\n          \
    \  }\n        } else if c == ' ' {\n            // Do nothing\n        } else\
    \ {\n            panic(fmt.Sprintf(\"Unrecognized character %s\", string(c)))\n\
    \        }\n    }\n    return max_nesting_levels\n}\n", "    group_open_close_levels\
    \ := make([]int, 0)\n    group_open_close_cnt := 0\n    max_open_close_level :=\
    \ 0\n    for _, char := range paren_string {\n        if char == '(' {\n     \
    \       group_open_close_cnt++\n            if group_open_close_cnt > max_open_close_level\
    \ {\n                max_open_close_level = group_open_close_cnt\n           \
    \ }\n        } else if char == ')' {\n            group_open_close_cnt--\n   \
    \     } else if char == ' ' {\n            group_open_close_levels = append(group_open_close_levels,\
    \ max_open_close_level)\n            max_open_close_level = 0\n            group_open_close_cnt\
    \ = 0\n        }\n    }\n    group_open_close_levels = append(group_open_close_levels,\
    \ max_open_close_level)\n    return group_open_close_levels\n}\n", "    // TODO:\
    \ Implement this\n    return []int{}\n}\n", "    var result []int\n    var open_stack\
    \ []int\n\n    for _, c := range paren_string {\n        if c == '(' {\n     \
    \       open_stack = append(open_stack, 0)\n        } else if c == ')' {\n   \
    \         if len(open_stack) == 0 {\n                result = append(result, 0)\n\
    \            } else {\n                var tmp int\n                for i := 0;\
    \ i < len(open_stack); i++ {\n                    tmp += open_stack[i]\n     \
    \           }\n                result = append(result, tmp)\n                open_stack\
    \ = open_stack[:len(open_stack)-1]\n            }\n        } else if c == ' '\
    \ {\n            if len(open_stack) == 0 {\n                result = append(result,\
    \ 0)\n            } else {\n                var tmp int\n                for i\
    \ := 0; i < len(open_stack); i++ {\n                    tmp += open_stack[i]\n\
    \                }\n                open_stack = open_stack[:len(open_stack)-1]\n\
    \                open_stack = append(open_stack, tmp)\n            }\n       \
    \ }\n    }\n\n    return result\n}\n", "    max_level := 0\n    cur_level := 0\n\
    \    var ret []int\n    for _, c := range paren_string {\n        switch string(c)\
    \ {\n        case \"(\":\n            cur_level += 1\n            if cur_level\
    \ > max_level {\n                max_level = cur_level\n            }\n      \
    \  case \")\":\n            if cur_level == max_level {\n                ret =\
    \ append(ret, max_level)\n                max_level = 0\n                cur_level\
    \ = 0\n            } else {\n                cur_level -= 1\n            }\n \
    \       }\n    }\n    return ret\n}\n", "    depth := 0\n    max_depths := []int{}\n\
    \    for _, curr_paren := range paren_string {\n        if curr_paren == '(' {\n\
    \            depth += 1\n        } else if curr_paren == ')' {\n            depth\
    \ -= 1\n        } else if curr_paren == ' ' {\n            max_depths = append(max_depths,\
    \ depth)\n            depth = 0\n        }\n    }\n    max_depths = append(max_depths,\
    \ depth)\n    return max_depths\n}\n", "    all_nesting_levels := make([]int,\
    \ 0)\n    for _, paren_substring := range (paren_string) {\n        max_level\
    \ := 0\n        current_level := 0\n        for _, paren := range (paren_substring)\
    \ {\n            switch paren {\n            case '(':\n                current_level\
    \ += 1\n            case ')':\n                current_level -= 1\n          \
    \  }\n            if current_level > max_level {\n                max_level =\
    \ current_level\n            }\n        }\n        all_nesting_levels = append(all_nesting_levels,\
    \ max_level)\n    }\n    return all_nesting_levels\n}\n", "    result := make([]int,\
    \ 0)\n    n := len(paren_string)\n    lc := 0\n    rc := 0\n    level := 0\n \
    \   for i := 0; i < n; i++ {\n        c := string(paren_string[i])\n        if\
    \ c == \"(\" {\n            lc++\n            level++\n        } else if c ==\
    \ \")\" {\n            rc++\n            level--\n        } else if c == \" \"\
    \ {\n            result = append(result, level)\n            lc = 0\n        \
    \    rc = 0\n            level = 0\n        }\n    }\n    result = append(result,\
    \ level)\n    return result\n}\n", "    var count []int\n    if (paren_string\
    \ == \"\") {\n        return count\n    }\n    for _, paren_group := range paren_string\
    \ {\n        if (paren_group == '(') {\n            count = append(count, 1)\n\
    \        } else if (paren_group == ')') {\n            count = append(count, -1)\n\
    \        }\n    }\n    return count\n}\n", "    var paren_string_split []string\
    \ = strings.Split(paren_string, \" \")\n    var max_level []int\n    for i :=\
    \ 0; i < len(paren_string_split); i++ {\n        var max_level_i int = 0\n   \
    \     var num_left_paren int = 0\n        var num_right_paren int = 0\n      \
    \  for j := 0; j < len(paren_string_split[i]); j++ {\n            if paren_string_split[i][j]\
    \ == '(' {\n                num_left_paren += 1\n                if num_left_paren\
    \ > max_level_i {\n                    max_level_i = num_left_paren\n        \
    \        }\n            } else if paren_string_split[i][j] == ')' {\n        \
    \        num_right_paren += 1\n                if num_right_paren > num_left_paren\
    \ {\n                    max_level_i = 0\n                    break\n        \
    \        }\n            }\n        }\n        max_level = append(max_level, max_level_i)\n\
    \    }\n    return max_level\n}\n", "    paren_levels := make([]int, 0)\n    paren_level\
    \ := 0\n    for _, r := range paren_string {\n        switch r {\n        case\
    \ '(':\n            paren_level += 1\n        case ')':\n            paren_level\
    \ -= 1\n        case ' ':\n            paren_levels = append(paren_levels, paren_level)\n\
    \            paren_level = 0\n        }\n    }\n    return paren_levels\n}\n",
  "    return nil\n}\n", "    var nested_parens []int\n    paren_counts := make(map[rune]int)\n\
    \    for _, r := range paren_string {\n        if r == '(' {\n            paren_counts[r]\
    \ += 1\n        } else if r == ')' {\n            paren_counts[r] += 1\n     \
    \   }\n    }\n    return nested_parens\n}\n", "    result := make([]int, 0)\n\
    \    start := 0\n    end := 0\n    current_level := 0\n    max_level := 0\n  \
    \  for end < len(paren_string) {\n        //fmt.Println(start, end, max_level,\
    \ current_level)\n        if paren_string[end] == '(' {\n            current_level\
    \ += 1\n            if current_level > max_level {\n                max_level\
    \ = current_level\n            }\n        } else if paren_string[end] == ')' {\n\
    \            current_level -= 1\n        } else if paren_string[end] == ' ' {\n\
    \            result = append(result, max_level)\n            current_level = 0\n\
    \            max_level = 0\n            start = end + 1\n        }\n        end\
    \ += 1\n    }\n    result = append(result, max_level)\n    return result\n}\n",
  "    depth := 0\n    max_depth := 0\n    depth_arr := []int{}\n    for i := 0; i\
    \ < len(paren_string); i++ {\n        switch string(paren_string[i]) {\n     \
    \   case \"(\":\n            depth += 1\n            if depth > max_depth {\n\
    \                max_depth = depth\n            }\n        case \")\":\n     \
    \       depth -= 1\n        case \" \":\n            if depth == 0 {\n       \
    \         depth_arr = append(depth_arr, max_depth)\n                max_depth\
    \ = 0\n            }\n        }\n    }\n    depth_arr = append(depth_arr, max_depth)\n\
    \    return depth_arr\n}\n", "    var stack []int\n    var max_stack []int\n \
    \   var deepest_level []int\n    for i := 0; i < len(paren_string); i++ {\n  \
    \      if paren_string[i] == '(' {\n            stack = append(stack, 1)\n   \
    \     } else if paren_string[i] == ')' {\n            if len(stack) > 0 {\n  \
    \              stack = stack[0:len(stack)-1]\n            }\n        } else if\
    \ paren_string[i] == ' ' {\n            max_stack = append(max_stack, len(stack))\n\
    \        }\n    }\n    max_stack = append(max_stack, len(stack))\n    var max\
    \ int\n    for i := 0; i < len(max_stack); i++ {\n        if max_stack[i] > max\
    \ {\n            max = max_stack[i]\n        }\n    }\n    for i := 0; i < len(max_stack);\
    \ i++ {\n        if max_stack[i] == max {\n            deepest_level = append(deepest_level,\
    \ max)\n        } else {\n            deepest_level = append(deepest_level, max_stack[i])\n\
    \        }\n    }\n    return deepest_level\n}\n", "    open_count := 0\n    depths\
    \ := []int{}\n    for _, c := range paren_string {\n        switch c {\n     \
    \   case '(':\n            open_count++\n        case ')':\n            depths\
    \ = append(depths, open_count)\n            open_count--\n        }\n    }\n \
    \   return depths\n}\n", "    var result []int\n    var paren_stack []rune\n \
    \   paren_string += \" \"\n    var counter int\n    for _, rune_value := range\
    \ paren_string {\n        if rune_value == '(' {\n            paren_stack = append(paren_stack,\
    \ rune_value)\n        } else if rune_value == ')' {\n            paren_stack\
    \ = paren_stack[:len(paren_stack)-1]\n            counter += 1\n        } else\
    \ if rune_value == ' ' {\n            result = append(result, counter)\n     \
    \       counter = 0\n        }\n    }\n    return result\n}\n", "    var paren_count\
    \ []int = make([]int, 0)\n    var temp_count int = 0\n    for _, v := range paren_string\
    \ {\n        if v == '(' {\n            temp_count += 1\n        } else if v ==\
    \ ')' {\n            paren_count = append(paren_count, temp_count)\n         \
    \   temp_count = 0\n        }\n    }\n    return paren_count\n}\n", "    result\
    \ := make([]int, 0)\n    for _, paren := range paren_string {\n        max_nesting\
    \ := -1\n        var last byte\n        nesting := 0\n        for _, c := range\
    \ paren {\n            if c == '(' {\n                if last == ')' {\n     \
    \               nesting = 1\n                } else {\n                    nesting++\n\
    \                }\n            } else if c == ')' {\n                nesting--\n\
    \            }\n\n            if nesting > max_nesting {\n                max_nesting\
    \ = nesting\n            }\n            last = byte(c)\n        }\n        result\
    \ = append(result, max_nesting)\n    }\n    return result\n}\n", "    paren_strings\
    \ := strings.Split(paren_string, \" \")\n    max_nested_level := make([]int, len(paren_strings))\n\
    \    for i, paren_str := range paren_strings {\n        depth := 0\n        max_depth\
    \ := 0\n        for _, char := range paren_str {\n            if char == '(' {\n\
    \                depth += 1\n            } else if char == ')' {\n           \
    \     depth -= 1\n            }\n            if depth > max_depth {\n        \
    \        max_depth = depth\n            }\n        }\n        max_nested_level[i]\
    \ = max_depth\n    }\n    return max_nested_level\n}\n", "    max_depth := make([]int,\
    \ 0)\n    stack := make([]int, 0)\n    for _, character := range paren_string\
    \ {\n        if character == '(' {\n            stack = append(stack, 0)\n   \
    \     } else if character == ')' {\n            if len(stack) > 0 {\n        \
    \        temp := stack[len(stack)-1]\n                stack = stack[:len(stack)-1]\n\
    \                if len(stack) > 0 {\n                    stack[len(stack)-1]\
    \ += temp + 1\n                } else {\n                    max_depth = append(max_depth,\
    \ temp + 1)\n                }\n            }\n        }\n    }\n    return max_depth\n\
    }\n", "    result := make([]int, 0)\n    depth := 0\n    group_depth := 0\n  \
    \  var c rune\n    for _, c = range paren_string {\n        switch c {\n     \
    \   case '(':\n            depth += 1\n            if depth > group_depth {\n\
    \                group_depth = depth\n            }\n        case ')':\n     \
    \       depth -= 1\n        case ' ':\n            if depth == 0 {\n         \
    \       result = append(result, group_depth)\n                group_depth = 0\n\
    \            }\n        }\n    }\n    result = append(result, group_depth)\n \
    \   return result\n}\n", "    max_levels := make([]int, 0)\n    cur_max := 0\n\
    \    cur_level := 0\n    for _, ch := range paren_string {\n        if ch == '('\
    \ {\n            cur_level += 1\n            if cur_level > cur_max {\n      \
    \          cur_max = cur_level\n            }\n        } else if ch == ')' {\n\
    \            cur_level -= 1\n        } else if ch == ' ' {\n            max_levels\
    \ = append(max_levels, cur_max)\n            cur_max = 0\n            cur_level\
    \ = 0\n        }\n    }\n    max_levels = append(max_levels, cur_max)\n    return\
    \ max_levels\n}\n", "    max_depth := 0\n    current_depth := 0\n    depths :=\
    \ []int{}\n    for _, paren := range paren_string {\n        switch paren {\n\
    \        case '(':\n            current_depth += 1\n            if current_depth\
    \ > max_depth {\n                max_depth = current_depth\n            }\n  \
    \      case ')':\n            if current_depth == 0 {\n                panic(\"\
    Mismatched parentheses\")\n            }\n            if current_depth == max_depth\
    \ {\n                depths = append(depths, max_depth)\n                max_depth\
    \ = 0\n            }\n            current_depth -= 1\n        case ' ':\n    \
    \        continue\n        default:\n            panic(\"Only parentheses and\
    \ spaces allowed\")\n        }\n    }\n    if current_depth != 0 {\n        panic(\"\
    Mismatched parentheses\")\n    }\n    return depths\n}\n", "    max_level_list\
    \ := make([]int, 0)\n    current_level := 0\n    max_level := 0\n    for _, ch\
    \ := range paren_string {\n        if ch == '(' {\n            current_level++\n\
    \            if current_level > max_level {\n                max_level = current_level\n\
    \            }\n        } else if ch == ')' {\n            current_level--\n \
    \       } else if ch == ' ' {\n            max_level_list = append(max_level_list,\
    \ max_level)\n            max_level = 0\n            current_level = 0\n     \
    \   }\n    }\n    return max_level_list\n}\n", "    var counter int = 0\n    var\
    \ deepest_level []int = make([]int, 0)\n    for i := 0; i < len(paren_string);\
    \ i++ {\n        if string(paren_string[i]) == \"(\" {\n            counter++\n\
    \        } else if string(paren_string[i]) == \")\" {\n            counter--\n\
    \        } else if string(paren_string[i]) == \" \" {\n            deepest_level\
    \ = append(deepest_level, counter)\n            counter = 0\n        }\n    }\n\
    \    deepest_level = append(deepest_level, counter)\n    return deepest_level\n\
    }\n", "    var prev_level, level int\n    paren_levels := make([]int, 0)\n   \
    \ for _, v := range paren_string {\n        if v == '(' {\n            level++\n\
    \        } else if v == ')' {\n            if level == 0 {\n                panic(\"\
    Extra parentheses\")\n            }\n            if level == prev_level {\n  \
    \              paren_levels = append(paren_levels, level)\n            }\n   \
    \         prev_level = level\n            level--\n        }\n    }\n    if level\
    \ != 0 {\n        panic(\"Extra parentheses\")\n    }\n    return paren_levels\n\
    }\n", "    var stack []byte\n    var result []int\n    level := 0\n    for i :=\
    \ 0; i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n     \
    \       level++\n            stack = append(stack, '(')\n        } else if paren_string[i]\
    \ == ')' {\n            level--\n            stack = stack[:len(stack)-1]\n  \
    \      } else if paren_string[i] == ' ' {\n            result = append(result,\
    \ level)\n            level = 0\n        }\n    }\n    return result\n}\n", " \
    \   var result []int\n    var current_count int\n    for _, char := range paren_string\
    \ {\n        if char == '(' {\n            current_count += 1\n        } else\
    \ if char == ')' {\n            result = append(result, current_count)\n     \
    \       current_count -= 1\n        }\n    }\n    return result\n}\n", "    nest_stack\
    \ := []int{}\n    nest_max := []int{}\n    for _, paren := range paren_string\
    \ {\n        if paren == '(' {\n            nest_stack = append(nest_stack, 0)\n\
    \        } else if paren == ')' {\n            if len(nest_stack) > 0 {\n    \
    \            nest_max = append(nest_max, nest_stack[len(nest_stack)-1]+1)\n  \
    \              nest_stack = nest_stack[:len(nest_stack)-1]\n            }\n  \
    \      } else if paren == ' ' {\n            continue\n        } else {\n    \
    \        fmt.Println(\"Unexpected character:\", paren)\n        }\n    }\n   \
    \ return nest_max\n}\n", "    var result []int\n    current := 0\n    max := 0\n\
    \    for _, ch := range paren_string {\n        if ch == '(' {\n            current\
    \ += 1\n            if current > max {\n                max = current\n      \
    \      }\n        } else if ch == ')' {\n            current -= 1\n        } else\
    \ if ch == ' ' {\n            result = append(result, max)\n            max =\
    \ 0\n            current = 0\n        }\n    }\n    result = append(result, max)\n\
    \    return result\n}\n", "    str_arr := strings.Split(paren_string, \" \")\n\
    \    levels := make([]int, len(str_arr))\n    for i, str := range str_arr {\n\
    \        if len(str) == 0 {\n            levels[i] = 0\n            continue\n\
    \        }\n        level := 0\n        max := 0\n        for _, ch := range str\
    \ {\n            if ch == '(' {\n                level++\n            } else if\
    \ ch == ')' {\n                level--\n            }\n            if level >\
    \ max {\n                max = level\n            }\n        }\n        levels[i]\
    \ = max\n    }\n    return levels\n}\n", "    // This stack is used to store the\
    \ deepest level of nesting so far.\n    curr_max_nesting := make([]int, 0)\n \
    \   // This stack is used to keep track of the current level of nesting.\n   \
    \ curr_nesting := make([]int, 0)\n    // This stack is used to keep track of the\
    \ number of open parentheses.\n    open_paren_num := make([]int, 0)\n    for _,\
    \ c := range paren_string {\n        if c == '(' {\n            // Push an open\
    \ paren to the stack.\n            open_paren_num = append(open_paren_num, 1)\n\
    \            // Update the current level of nesting.\n            curr_nesting\
    \ = append(curr_nesting, open_paren_num[len(open_paren_num)-1])\n            //\
    \ Update the deepest level of nesting so far.\n            if len(curr_max_nesting)\
    \ == 0 {\n                curr_max_nesting = append(curr_max_nesting, curr_nesting[len(curr_nesting)-1])\n\
    \            } else {\n                curr_max_nesting = append(curr_max_nesting,\n\
    \                    max(curr_max_nesting[len(curr_max_nesting)-1], curr_nesting[len(curr_nesting)-1]))\n\
    \            }\n        } else if c == ')' {\n            // Pop the stack of\
    \ open parens.\n            open_paren_num = open_paren_num[:len(open_paren_num)-1]\n\
    \            // Pop the stack of current nesting.\n            curr_nesting =\
    \ curr_nesting[:len(curr_nesting)-1]\n            // Pop the stack of deepest\
    \ nesting so far.\n            curr_max_nesting = curr_max_nesting[:len(curr_max_nesting)-1]\n\
    \        } else if c == ' ' {\n            // If we meet a space, we should push\
    \ the deepest level of nesting so far to the final result.\n            curr_nesting\
    \ = make([]int, 0)\n            curr_max_nesting = append(curr", "    max_levels\
    \ := []int{}\n    max_level := 0\n    bracket_count := 0\n    for i := 0; i <\
    \ len(paren_string); i++ {\n        ch := paren_string[i]\n        if ch == '('\
    \ {\n            bracket_count++\n            if bracket_count > max_level {\n\
    \                max_level = bracket_count\n            }\n        } else if ch\
    \ == ')' {\n            bracket_count--\n        } else if ch == ' ' {\n     \
    \       max_levels = append(max_levels, max_level)\n            max_level = 0\n\
    \            bracket_count = 0\n        }\n    }\n    if max_level > 0 {\n   \
    \     max_levels = append(max_levels, max_level)\n    }\n    return max_levels\n\
    }\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
