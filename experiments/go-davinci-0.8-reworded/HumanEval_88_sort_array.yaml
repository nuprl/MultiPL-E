name: HumanEval_88_sort_array
language: go_test.go
prompt: "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // Given a list of non-negative integers, return a cogo of the given list after\
  \ sorting,\n// you will sort the given list in ascending order if the sum( first\
  \ index value, last index value) is odd,\n// or sort it in descending order if the\
  \ sum( first index value, last index value) is even.\n// Note:\n// * don't change\
  \ the given list.\n// Examples:\n// >>> sort_array(string{})\n// PATCH list\n//\
  \ >>> sort_array([]int{5})\n// []int{5}\n// >>> sort_array([]int{2, 4, 3, 0, 1,\
  \ 5})\n// []int{0, 1, 2, 3, 4, 5}\n// >>> sort_array([]int{2, 4, 3, 0, 1, 5, 6})\n\
  // []int{6, 5, 4, 3, 2, 1, 0}\nfunc sort_array(array []int) []int {\n"
tests: "func TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
  \ candidate([]int{5}), expected: []int{5} },\n     { actual: candidate([]int{2,\
  \ 4, 3, 0, 1, 5}), expected: []int{0, 1, 2, 3, 4, 5} },\n     { actual: candidate([]int{2,\
  \ 4, 3, 0, 1, 5, 6}), expected: []int{6, 5, 4, 3, 2, 1, 0} },\n     { actual: candidate([]int{2,\
  \ 1}), expected: []int{1, 2} },\n     { actual: candidate([]int{15, 42, 87, 32,\
  \ 11, 0}), expected: []int{0, 11, 15, 32, 42, 87} },\n     { actual: candidate([]int{21,\
  \ 14, 23, 11}), expected: []int{23, 21, 14, 11} },\n   }\n\n\tfor i, tc := range\
  \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\
  \tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
  \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    if len(array) < 2 {\n        return array\n    }\n    switch (array[0]\
    \ + array[len(array) - 1]) % 2 {\n    case 0:\n        return sort_array_desc(array)\n\
    \    default:\n        return sort_array_asc(array)\n    }\n}\n", "    length\
    \ := len(array)\n    if length < 1 {\n        return array\n    }\n    if length\
    \ == 1 {\n        return array\n    }\n    if length == 2 {\n        return array\n\
    \    }\n    if (array[0] + array[length - 1]) % 2 == 0 {\n        return reverse_array(array)\n\
    \    }\n    return array\n}\n", "    arrayLen := len(array)\n    if arrayLen ==\
    \ 0 {\n        return array\n    }\n    flag := (array[0] + array[arrayLen - 1])\
    \ % 2 == 0\n    // fmt.Println(flag)\n    for i := 0; i < arrayLen; i++ {\n  \
    \      for j := 0; j < arrayLen - i - 1; j++ {\n            if flag {\n      \
    \          if array[j] < array[j + 1] {\n                    array[j], array[j\
    \ + 1] = array[j + 1], array[j]\n                }\n            } else {\n   \
    \             if array[j] > array[j + 1] {\n                    array[j], array[j\
    \ + 1] = array[j + 1], array[j]\n                }\n            }\n        }\n\
    \    }\n    return array\n}\n", "    var sum int\n    for i, value := range array\
    \ {\n        sum += value\n        if i == 0 {\n            continue\n       \
    \ }\n        if array[i] > array[i-1] {\n            continue\n        }\n   \
    \     array[i], array[i-1] = array[i-1], array[i]\n    }\n    if sum % 2 == 0\
    \ {\n        for i := 0; i < len(array)/2; i++ {\n            array[i], array[len(array)-1-i]\
    \ = array[len(array)-1-i], array[i]\n        }\n    }\n    return array\n}\n",
  "    // TODO: Implement this method\n    return array\n}\n", "    var sum int\n\
    \    for i, v := range array {\n        sum += v\n        if i == 0 {\n      \
    \      continue\n        }\n        if v < array[i-1] {\n            tmp := array[i-1]\n\
    \            array[i-1] = v\n            array[i] = tmp\n        }\n    }\n  \
    \  for i, v := range array {\n        if i == 0 {\n            continue\n    \
    \    }\n        if v < array[i-1] {\n            tmp := array[i-1]\n         \
    \   array[i-1] = v\n            array[i] = tmp\n        }\n    }\n    if sum %\
    \ 2 == 0 {\n        for i, v := range array {\n            array[i] = v\n    \
    \    }\n    }\n    return array\n}\n", "    var odd_part []int\n    var even_part\
    \ []int\n    var odd_part_sorted []int\n    var even_part_sorted []int\n    var\
    \ result []int\n    var n int\n    for i := 0; i < len(array); i++ {\n       \
    \ if array[i] % 2 == 0 {\n            even_part = append(even_part, array[i])\n\
    \        } else {\n            odd_part = append(odd_part, array[i])\n       \
    \ }\n    }\n    odd_part_sorted = odd_part\n    even_part_sorted = even_part\n\
    \    for i := 0; i < len(odd_part_sorted) - 1; i++ {\n        for j := i + 1;\
    \ j < len(odd_part_sorted); j++ {\n            if odd_part_sorted[i] > odd_part_sorted[j]\
    \ {\n                n = odd_part_sorted[i]\n                odd_part_sorted[i]\
    \ = odd_part_sorted[j]\n                odd_part_sorted[j] = n\n            }\n\
    \        }\n    }\n    for i := 0; i < len(even_part_sorted) - 1; i++ {\n    \
    \    for j := i + 1; j < len(even_part_sorted); j++ {\n            if even_part_sorted[i]\
    \ < even_part_sorted[j] {\n                n = even_part_sorted[i]\n         \
    \       even_part_sorted[i] = even_part_sorted[j]\n                even_part_sorted[j]\
    \ = n\n            }\n        }\n    }\n    for i := 0; i < len(odd_part_sorted);\
    \ i++ {\n        result = append(result, odd_part_sorted[i])\n    }\n    for i\
    \ := 0; i < len(even_part_sorted); i++ {\n        result = append(result, even_part_sorted[i])\n\
    \    }\n    return result\n}\n", "    fmt.Println(\"array:\", array)\n    length\
    \ := len(array)\n    if length == 0 {\n        return array\n    }\n\n    // max\
    \ number: 5, 4\n    // or: 5, 4, 3\n    // or: 5, 4, 3, 2\n    // or: 5, 4, 3,\
    \ 2, 1\n    // or: 5, 4, 3, 2, 1, 0\n    if length == 1 {\n        return array\n\
    \    }\n\n    // max number: 4, 3, 5\n    // or: 4, 3, 2, 5\n    // or: 4, 3,\
    \ 2, 1, 5\n    // or: 4, 3, 2, 1, 0, 5\n    if length == 2 {\n        if array[0]\
    \ > array[1] {\n            return []int{array[1], array[0]}\n        }\n    \
    \    return array\n    }\n\n    // max number: 3, 2, 4, 5\n    // or: 3, 2, 1,\
    \ 4, 5\n    // or: 3, 2, 1, 0, 4, 5\n    if length == 3 {\n        if array[0]\
    \ > array[1] {\n            array[0], array[1] = array[1], array[0]\n        }\n\
    \        if array[1] > array[2] {\n            array[1], array[2] = array[2],\
    \ array[1]\n        }\n        if array[0] > array[1] {\n            array[0],\
    \ array[1] = array[1], array[0]\n        }\n        return array\n    }\n\n  \
    \  // max number: 2, 1, 3, 4, 5\n    // or: 2, 1, 0, 3, 4, 5\n    if length ==\
    \ 4 {\n        // max number: 3, 4, 5\n        if array[0] > array[1] {\n    \
    \        array[0], array[1] = array[1], array[0]\n        }\n        if array[2]\
    \ > array[3] {\n            array[2], array[3] = array[3], array[2]\n        }\n\
    \        if array[0] > array[2] {\n            array[0], array[2] = array", " \
    \   arrayLen := len(array)\n    if arrayLen == 0 {\n        fmt.Println(\"PATCH\
    \ list\")\n        return array\n    }\n\n    if arrayLen == 1 {\n        return\
    \ array\n    }\n\n    if array[0] % 2 == array[arrayLen - 1] % 2 {\n        //\
    \ odd\n        return sortArrayInAscendingOrder(array)\n    } else {\n       \
    \ // even\n        return sortArrayInDescendingOrder(array)\n    }\n}\n", "  \
    \  n := len(array)\n    if n <= 1 {\n        return array\n    }\n    if (array[0]\
    \ + array[n-1]) & 1 == 0 {\n        k := n - 1\n        for i := 0; i < n/2; i++\
    \ {\n            array[i], array[k-i] = array[k-i], array[i]\n        }\n    }\n\
    \    k := n / 2\n    for i := 0; i < k; i++ {\n        for j := k; j < n-1; j++\
    \ {\n            if array[j] < array[j+1] {\n                array[j], array[j+1]\
    \ = array[j+1], array[j]\n            }\n        }\n    }\n    return array\n\
    }\n", "    if len(array) < 2 {\n        return array\n    }\n    if (array[0]\
    \ + array[len(array) - 1]) % 2 == 0 {\n        return reverse_array(array)\n \
    \   }\n    sorted := array\n    for i := 0; i < len(sorted) - 1; i++ {\n     \
    \   for j := i + 1; j < len(sorted); j++ {\n            if sorted[i] > sorted[j]\
    \ {\n                sorted[i], sorted[j] = sorted[j], sorted[i]\n           \
    \ }\n        }\n    }\n    return sorted\n}\n", "    arrayLen := len(array)\n\
    \    var f_v, l_v int\n    var sum int\n    if arrayLen != 0 {\n        f_v =\
    \ array[0]\n        l_v = array[arrayLen-1]\n        sum = f_v + l_v\n    } else\
    \ {\n        return nil\n    }\n    sort_array := make([]int, arrayLen)\n    start_index\
    \ := 0\n    end_index := arrayLen - 1\n    if sum % 2 == 0 {\n        for _, v\
    \ := range array {\n            if v % 2 == 0 {\n                sort_array[start_index]\
    \ = v\n                start_index++\n            } else {\n                sort_array[end_index]\
    \ = v\n                end_index--\n            }\n        }\n    } else {\n \
    \       for _, v := range array {\n            if v % 2 == 0 {\n             \
    \   sort_array[end_index] = v\n                end_index--\n            } else\
    \ {\n                sort_array[start_index] = v\n                start_index++\n\
    \            }\n        }\n    }\n    return sort_array\n}\n", "    n := len(array)\n\
    \    if n <= 1 {\n        return array\n    }\n    if (array[0] + array[n-1])\
    \ & 1 == 0 {\n        for i := 0; i < n/2; i++ {\n            array[i], array[n-1-i]\
    \ = array[n-1-i], array[i]\n        }\n    }\n    return array\n}\n", "    first\
    \ := array[0]\n    last := array[len(array) - 1]\n    if (first + last) % 2 ==\
    \ 0 {\n        fmt.Println(\"odd\")\n        for j := 0; j < len(array); j++ {\n\
    \            for i := 0; i < len(array) - 1; i++ {\n                if array[i]\
    \ < array[i + 1] {\n                    temp := array[i]\n                   \
    \ array[i] = array[i + 1]\n                    array[i + 1] = temp\n         \
    \       }\n            }\n        }\n    } else {\n        fmt.Println(\"even\"\
    )\n        for j := 0; j < len(array); j++ {\n            for i := 0; i < len(array)\
    \ - 1; i++ {\n                if array[i] > array[i + 1] {\n                 \
    \   temp := array[i]\n                    array[i] = array[i + 1]\n          \
    \          array[i + 1] = temp\n                }\n            }\n        }\n\
    \    }\n    return array\n}\n", "    var (\n        a, b int\n        size = len(array)\n\
    \    )\n    for i, j := 0, size - 1; i < j; {\n        a, b = array[i], array[j]\n\
    \        sum := a + b\n        if sum & 1 == 0 {\n            array[i], array[j]\
    \ = b, a\n        }\n        i++\n        j--\n    }\n    return array\n}\n",
  "    left := array[0]\n    right := array[len(array) - 1]\n    if (left + right)\
    \ % 2 == 0 {\n        // sort in descending order\n        for i := 0; i < len(array)\
    \ - 1; i++ {\n            for j := 0; j < len(array) - 1 - i; j++ {\n        \
    \        if array[j] < array[j + 1] {\n                    tmp := array[j]\n \
    \                   array[j] = array[j + 1]\n                    array[j + 1]\
    \ = tmp\n                }\n            }\n        }\n    } else {\n        //\
    \ sort in ascending order\n        for i := 0; i < len(array) - 1; i++ {\n   \
    \         for j := 0; j < len(array) - 1 - i; j++ {\n                if array[j]\
    \ > array[j + 1] {\n                    tmp := array[j]\n                    array[j]\
    \ = array[j + 1]\n                    array[j + 1] = tmp\n                }\n\
    \            }\n        }\n    }\n    return array\n}\n", "    if len(array) <\
    \ 2 {\n        return array\n    }\n    var tmp int\n    for i:= 0; i < len(array)\
    \ - 1; i++ {\n        for j := i + 1; j < len(array); j++ {\n            if (array[i]\
    \ + array[len(array) - 1 - i]) % 2 != 0 {\n                if array[i] > array[j]\
    \ {\n                    tmp = array[i]\n                    array[i] = array[j]\n\
    \                    array[j] = tmp\n                }\n            } else {\n\
    \                if array[i] < array[j] {\n                    tmp = array[i]\n\
    \                    array[i] = array[j]\n                    array[j] = tmp\n\
    \                }\n            }\n        }\n    }\n    return array\n}\n", " \
    \   if len(array) == 0 {\n        panic(\"PATCH list\")\n    }\n    var sum int\n\
    \    for k, v := range array {\n        sum += v\n        if k == len(array) -\
    \ 1 {\n            break\n        }\n    }\n    if sum % 2 == 0 {\n        for\
    \ i := 0; i < len(array) / 2; i++ {\n            array[i], array[len(array) -\
    \ 1 - i] = array[len(array) - 1 - i], array[i]\n        }\n    }\n    return array\n\
    }\n", "    if len(array) == 0 {\n        return nil\n    }\n    if len(array)\
    \ == 1 {\n        return array\n    }\n    var (\n        array_left = []int{}\n\
    \        array_right = []int{}\n        start = 0\n        end = len(array) -\
    \ 1\n        last_compare = array[start]\n        index = start + 1\n    )\n \
    \   for {\n        if index > end {\n            break\n        }\n        if\
    \ array[index] > last_compare {\n            array_left = append(array_left, array[index])\n\
    \        } else {\n            array_right = append(array_right, array[index])\n\
    \        }\n        index++\n    }\n    array_left = sort_array(array_left)\n\
    \    array_right = sort_array(array_right)\n    return append(append(array_left,\
    \ last_compare), array_right...)\n}\n", "    if len(array) == 0 {\n        return\
    \ nil\n    }\n    first, last := array[0], array[len(array)-1]\n    if (first\
    \ + last) % 2 == 0 {\n        sort_array_desc(array)\n    } else {\n        sort_array_asc(array)\n\
    \    }\n    return array\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
