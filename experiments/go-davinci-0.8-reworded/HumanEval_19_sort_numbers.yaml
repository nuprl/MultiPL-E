name: HumanEval_19_sort_numbers
language: go_test.go
prompt: "package sort_numbers_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid\
  \ choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight'\
  \ and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n\
  // >>> sort_numbers(\"three one five\")\n// \"one three five\"\nfunc sort_numbers(numbers\
  \ string) string {\n"
tests: "func TestSort_Numbers(t *testing.T) {\n  candidate := sort_numbers\n\ttype\
  \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
  \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
  \ candidate(\"three\"), expected: \"three\" },\n     { actual: candidate(\"three\
  \ five nine\"), expected: \"three five nine\" },\n     { actual: candidate(\"five\
  \ zero four seven nine eight\"), expected: \"zero four five seven eight nine\" },\n\
  \     { actual: candidate(\"six five four three two one zero\"), expected: \"zero\
  \ one two three four five six\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    // Your code here\n    return \"\"\n}\n", "    // do your thing\n\
    \    return \"\"\n}\n", "    var sortedArray []int\n\n    numeralMap := map[string]int{\n\
    \        \"zero\":  0,\n        \"one\":   1,\n        \"two\":   2,\n       \
    \ \"three\": 3,\n        \"four\":  4,\n        \"five\":  5,\n        \"six\"\
    :   6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\":  9,\n\
    \    }\n\n    for _, numeral := range numbers {\n        if numeral == ' ' {\n\
    \            continue\n        }\n        value, ok := numeralMap[string(numeral)]\n\
    \        if !ok {\n            // this will throw an exception and fail the test\n\
    \            fmt.Errorf(\"Invalid numeral %v\", numeral)\n        }\n\n      \
    \  // binary search\n        index := sort.Search(len(sortedArray), func(i int)\
    \ bool { return sortedArray[i] >= value })\n        // insert the new value\n\
    \        sortedArray = append(sortedArray, 0)\n        copy(sortedArray[index+1:],\
    \ sortedArray[index:])\n        sortedArray[index] = value\n    }\n\n    return\
    \ strings.Join(sortedArray, \" \")\n}\n", "    return numbers\n}\n", "    numMap\
    \ := map[string]int{\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\"\
    : 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n    \
    \    \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\"\
    : 9,\n    }\n    words := make([]string, 10)\n    var numeral string\n    var\
    \ number int\n    var index int\n    for i := 0; i < len(numbers); i++ {\n   \
    \     if numbers[i] == ' ' {\n            number = numMap[numeral]\n         \
    \   index = 0\n            for ; index < len(words) && words[index] != \"\"; index++\
    \ {\n                if number < numMap[words[index]] {\n                    break\n\
    \                }\n            }\n            for j := len(words) - 1; j > index;\
    \ j-- {\n                words[j] = words[j - 1]\n            }\n            words[index]\
    \ = numeral\n            numeral = \"\"\n        } else {\n            numeral\
    \ += string(numbers[i])\n        }\n    }\n    number = numMap[numeral]\n    index\
    \ = 0\n    for ; index < len(words) && words[index] != \"\"; index++ {\n     \
    \   if number < numMap[words[index]] {\n            break\n        }\n    }\n\
    \    for j := len(words) - 1; j > index; j-- {\n        words[j] = words[j - 1]\n\
    \    }\n    words[index] = numeral\n    return strings.Join(words, \" \")\n}\n",
  "    return numbers\n}\n", "    words := map[string]int{\n        \"zero\": 0,\n\
    \        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\"\
    : 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n     \
    \   \"eight\": 8,\n        \"nine\": 9,\n    }\n    if words == nil {\n      \
    \  return \"\"\n    }\n    return \"\"\n}\n", "    // get the indexes for the\
    \ numbers in the string\n    indexMap := make(map[int]int)\n\n    // zero one\
    \ two three four five six seven eight nine\n    words := []string{\"zero\", \"\
    one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\
    \ \"nine\"}\n    for i, word := range words {\n        indexMap[i] = index_of(numbers,\
    \ word)\n    }\n\n    fmt.Println(indexMap)\n\n    smallestNumber := find_smallest_number(indexMap)\n\
    \    fmt.Println(smallestNumber)\n\n    return \"\"\n}\n", "    numeralValues\
    \ := map[string]int{\n        \"zero\": 0,\n        \"one\": 1,\n        \"two\"\
    : 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\": 5,\n    \
    \    \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n        \"nine\"\
    : 9,\n    }\n\n    numeralOrder := []string{\n        \"zero\",\n        \"one\"\
    ,\n        \"two\",\n        \"three\",\n        \"four\",\n        \"five\",\n\
    \        \"six\",\n        \"seven\",\n        \"eight\",\n        \"nine\",\n\
    \    }\n\n    sortedNumerals := []string{}\n    maxValue := -1\n    for _, numeral\
    \ := range strings.Split(numbers, \" \") {\n        numeralValue := numeralValues[numeral]\n\
    \        if numeralValue > maxValue {\n            sortedNumerals = append(sortedNumerals,\
    \ numeral)\n            maxValue = numeralValue\n        } else {\n          \
    \  for index, sortedNumeral := range sortedNumerals {\n                if numeralValue\
    \ < numeralValues[sortedNumeral] {\n                    sortedNumerals = append(sortedNumerals[:index],\
    \ append([]string{numeral}, sortedNumerals[index:]...)...)\n                 \
    \   break\n                }\n            }\n        }\n    }\n\n    return strings.Join(sortedNumerals,\
    \ \" \")\n}\n", "    numeralToInt := map[string]int {\n        \"zero\": 0,\n\
    \        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\"\
    : 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n     \
    \   \"eight\": 8,\n        \"nine\": 9,\n    }\n\n    // convert string to array\
    \ of ints\n    splitNum := splitString(numbers)\n    ints := stringsToInts(splitNum,\
    \ numeralToInt)\n\n    // sort array of ints\n    sortedInts := mergeSort(ints)\n\
    \n    // convert array of ints to sorted array of strings\n    sortedStrings :=\
    \ intsToStrings(sortedInts, numeralToInt)\n\n    // convert array of strings to\
    \ string\n    sortedString := joinString(sortedStrings)\n\n    return sortedString\n\
    }\n", "    const (\n        zero = \"zero\"\n        one = \"one\"\n        two\
    \ = \"two\"\n        three = \"three\"\n        four = \"four\"\n        five\
    \ = \"five\"\n        six = \"six\"\n        seven = \"seven\"\n        eight\
    \ = \"eight\"\n        nine = \"nine\"\n    )\n    var nums []string\n    ns :=\
    \ make(map[string]int)\n    ns[zero] = 0\n    ns[one] = 1\n    ns[two] = 2\n \
    \   ns[three] = 3\n    ns[four] = 4\n    ns[five] = 5\n    ns[six] = 6\n    ns[seven]\
    \ = 7\n    ns[eight] = 8\n    ns[nine] = 9\n    for _,s := range(strings.Split(numbers,\
    \ \" \")) {\n        if n, exists := ns[s]; exists {\n            nums = append(nums,\
    \ n)\n        }\n    }\n    sort.Ints(nums)\n    return \"\"\n}\n", "    var result\
    \ []string\n\n    // Split the input string into a slice\n    number_list := strings.Split(numbers,\
    \ \" \")\n\n    for _, word := range number_list {\n        switch word {\n  \
    \      case \"zero\":\n            result = append(result, word)\n        case\
    \ \"one\":\n            result = append(result, word)\n        case \"two\":\n\
    \            result = append(result, word)\n        case \"three\":\n        \
    \    result = append(result, word)\n        case \"four\":\n            result\
    \ = append(result, word)\n        case \"five\":\n            result = append(result,\
    \ word)\n        case \"six\":\n            result = append(result, word)\n  \
    \      case \"seven\":\n            result = append(result, word)\n        case\
    \ \"eight\":\n            result = append(result, word)\n        case \"nine\"\
    :\n            result = append(result, word)\n        }\n    }\n\n    return strings.Join(result,\
    \ \" \")\n}\n", "    nums := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n    words :=\
    \ []string{\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\"\
    , \"seven\", \"eight\", \"nine\"}\n    word_nums := make(map[string]int)\n   \
    \ for i, word := range words {\n        word_nums[word] = nums[i]\n    }\n   \
    \ num_words := make(map[int]string)\n    for word, num := range word_nums {\n\
    \        num_words[num] = word\n    }\n    w := make([]string, len(words))\n \
    \   for i, num := range nums {\n        w[i] = num_words[num]\n    }\n    for\
    \ i, word := range words {\n        fmt.Printf(\"%d: %s\\n\", i, word)\n    }\n\
    \    for i, num := range nums {\n        fmt.Printf(\"%d: %d\\n\", i, num)\n \
    \   }\n    for i, word := range w {\n        fmt.Printf(\"%d: %s\\n\", i, word)\n\
    \    }\n    return \"\"\n}\n", "    words := map[string]int {\n        \"zero\"\
    : 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n      \
    \  \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\"\
    : 7,\n        \"eight\": 8,\n        \"nine\": 9,\n    }\n    words_in := map[int]string\
    \ {\n        0: \"zero\",\n        1: \"one\",\n        2: \"two\",\n        3:\
    \ \"three\",\n        4: \"four\",\n        5: \"five\",\n        6: \"six\",\n\
    \        7: \"seven\",\n        8: \"eight\",\n        9: \"nine\",\n    }\n \
    \   var nums []int\n    var num_string string\n    for _, v := range numbers {\n\
    \        if string(v) == \" \" {\n            v_int, ok := words[num_string]\n\
    \            if ok {\n                nums = append(nums, v_int)\n           \
    \ }\n            num_string = \"\"\n        } else {\n            num_string +=\
    \ string(v)\n        }\n    }\n    v_int, ok := words[num_string]\n    if ok {\n\
    \        nums = append(nums, v_int)\n    }\n    for i := 0; i < len(nums) - 1;\
    \ i++ {\n        for j := i + 1; j < len(nums); j++ {\n            if nums[i]\
    \ > nums[j] {\n                tmp := nums[i]\n                nums[i] = nums[j]\n\
    \                nums[j] = tmp\n            }\n        }\n    }\n    var ret string\n\
    \    for _, v := range nums {\n        ret += words_in[v] + \" \"\n    }\n   \
    \ ret = ret[:len(ret) - 1]\n    return ret\n}\n", "    num_map := map[string]int{\n\
    \        \"zero\": 0,\n        \"one\": 1,\n        \"two\": 2,\n        \"three\"\
    : 3,\n        \"four\": 4,\n        \"five\": 5,\n        \"six\": 6,\n      \
    \  \"seven\": 7,\n        \"eight\": 8,\n        \"nine\": 9,\n    }\n    num_array\
    \ := []int{}\n    for _, number := range strings.Split(numbers, \" \") {\n   \
    \     if _, ok := num_map[number]; ok {\n            num_array = append(num_array,\
    \ num_map[number])\n        }\n    }\n    sort.Ints(num_array)\n    number_string\
    \ := \"\"\n    for _, number := range num_array {\n        number_string += strconv.Itoa(number)\
    \ + \" \"\n    }\n    return number_string[:len(number_string)-1]\n}\n", "   \
    \ var numberMap = map[string]int{\n        \"zero\": 0,\n        \"one\": 1,\n\
    \        \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"\
    five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n\
    \        \"nine\": 9,\n    }\n    numberals := split_to_words(numbers)\n    var\
    \ numberSlice []int\n    for _, numberal := range numberals {\n        numberSlice\
    \ = append(numberSlice, numberMap[numberal])\n    }\n    sort_ints(numberSlice)\n\
    \    var result = \"\"\n    for i, number := range numberSlice {\n        if i\
    \ > 0 {\n            result += \" \"\n        }\n        for numberal, num :=\
    \ range numberMap {\n            if num == number {\n                result +=\
    \ numberal\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n", "    nums := []string{\"zero\", \"one\", \"two\", \"three\", \"\
    four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"}\n    words := []string{}\n\
    \    output := []string{}\n    greater := false\n    result := \"\"\n\n    //\
    \ split the given string\n    for _, w := range numbers {\n        if w == ' '\
    \ {\n            continue\n        }\n        words = append(words, string(w))\n\
    \    }\n\n    // find the smallest number and place it in the output array\n \
    \   for _, n := range nums {\n        for _, w := range words {\n            if\
    \ n == w {\n                output = append(output, n)\n                break\n\
    \            }\n        }\n    }\n\n    // sort the output array and return it\n\
    \    if len(output) == 1 {\n        return output[0]\n    }\n    for j := 0; j\
    \ < len(output); j++ {\n        for i := 0; i < len(output)-1; i++ {\n       \
    \     if output[i] > output[i+1] {\n                output[i], output[i+1] = output[i+1],\
    \ output[i]\n                greater = true\n            }\n        }\n      \
    \  if !greater {\n            break\n        }\n    }\n    for _, o := range output\
    \ {\n        result += o + \" \"\n    }\n    return result[:len(result)-1]\n}\n",
  "    var numMap = map[string]int{\n        \"zero\": 0,\n        \"one\": 1,\n \
    \       \"two\": 2,\n        \"three\": 3,\n        \"four\": 4,\n        \"five\"\
    : 5,\n        \"six\": 6,\n        \"seven\": 7,\n        \"eight\": 8,\n    \
    \    \"nine\": 9,\n    }\n    ns := make([]int, 0)\n    for _, n := range numbers\
    \ {\n        if n != ' ' {\n            ns = append(ns, numMap[string(n)])\n \
    \       }\n    }\n    fmt.Println(ns)\n    return \"\"\n}\n", "    // TODO: implement\n\
    \    return \"\"\n}\n", "    m := map[string]int{\n        \"zero\": 0,\n    \
    \    \"one\": 1,\n        \"two\": 2,\n        \"three\": 3,\n        \"four\"\
    : 4,\n        \"five\": 5,\n        \"six\": 6,\n        \"seven\": 7,\n     \
    \   \"eight\": 8,\n        \"nine\": 9,\n    }\n    var numbers_int []int\n  \
    \  for _, number := range(strings.Split(numbers, \" \")) {\n        numbers_int\
    \ = append(numbers_int, m[number])\n    }\n    sort.Ints(numbers_int)\n    var\
    \ result string\n    for _, number := range(numbers_int) {\n        result +=\
    \ strconv.Itoa(number) + \" \"\n    }\n    return result\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
