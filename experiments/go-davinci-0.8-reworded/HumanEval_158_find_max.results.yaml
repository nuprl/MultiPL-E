language: go_test.go
name: HumanEval_158_find_max
results:
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max string\n \
    \   max_unique := 0\n    for _, word := range words {\n        unique := make(map[rune]bool)\n\
    \        for _, ch := range word {\n            unique[ch] = true\n        }\n\
    \        if len(unique) > max_unique {\n            max = word\n            max_unique\
    \ = len(unique)\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp69f5diyr_test.go:56: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmp69f5diyr_test.go:56: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074363
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Write your code\
    \ here\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpp8swkqal_test.go:45: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpp8swkqal_test.go:45: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpp8swkqal_test.go:45:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpp8swkqal_test.go:45: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpp8swkqal_test.go:45: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpp8swkqal_test.go:45: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpp8swkqal_test.go:45:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpp8swkqal_test.go:45: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpp8swkqal_test.go:45: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpp8swkqal_test.go:45: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074363
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_words []string\n\
    \    max_chars := 0\n    for _, word := range words {\n        if num_unique_chars(word)\
    \ > max_chars {\n            max_chars = num_unique_chars(word)\n            max_words\
    \ = []string{word}\n        } else if num_unique_chars(word) == max_chars {\n\
    \            max_words = append(max_words, word)\n        }\n    }\n    min_word\
    \ := min_word(max_words)\n    return min_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxd613ke7_test.go:22:12: undefined: num_unique_chars

    /tmp/tmpxd613ke7_test.go:23:25: undefined: num_unique_chars

    /tmp/tmpxd613ke7_test.go:25:19: undefined: num_unique_chars

    /tmp/tmpxd613ke7_test.go:29:17: undefined: min_word

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074362
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // TODO - Add your\
    \ code here\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpcojyw852_test.go:45: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpcojyw852_test.go:45: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpcojyw852_test.go:45:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpcojyw852_test.go:45: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpcojyw852_test.go:45: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpcojyw852_test.go:45: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpcojyw852_test.go:45:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpcojyw852_test.go:45: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpcojyw852_test.go:45: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpcojyw852_test.go:45: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074363
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    word := \"\"\n   \
    \ max := 0\n    for _, v := range words {\n        if len(v) > max {\n       \
    \     word = v\n            max = len(v)\n        }\n    }\n    return word\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpqgw1use__test.go:52: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074363
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_num int\n\
    \    var result string\n    for _, word := range words {\n        if max_num <\
    \ len(get_unique_chars(word)) {\n            max_num = len(get_unique_chars(word))\n\
    \            result = word\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsn36z_xr_test.go:22:26: undefined: get_unique_chars

    /tmp/tmpsn36z_xr_test.go:23:27: undefined: get_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074362
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    maxWord := \"\"\n\
    \    maxLength := 0\n    for _, word := range words {\n        if len(word) >\
    \ maxLength {\n            maxWord = word\n            maxLength = len(word)\n\
    \        }\n    }\n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpx63dggvj_test.go:52: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074363
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_uniq_len := 0\n    uniq_map := make(map[rune]bool)\n    for _, word :=\
    \ range words {\n        // uniq_map := make(map[rune]bool)\n        for _, c\
    \ := range word {\n            uniq_map[c] = true\n        }\n        uniq_len\
    \ := len(uniq_map)\n        if uniq_len > max_uniq_len {\n            max_uniq_len\
    \ = uniq_len\n            max_word = word\n        }\n        if uniq_len == max_uniq_len\
    \ && word < max_word {\n            max_word = word\n        }\n        // fmt.Println(uniq_map)\n\
    \        // clear map\n        for k := range uniq_map {\n            delete(uniq_map,\
    \ k)\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074363
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    result\
    \ := \"\"\n    for _, word := range words {\n        if len(remove_duplicates(word))\
    \ > max {\n            max = len(remove_duplicates(word))\n            result\
    \ = word\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp31j8ah7p_test.go:22:16: undefined: remove_duplicates

    /tmp/tmp31j8ah7p_test.go:23:23: undefined: remove_duplicates

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074362
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // TODO: implement\n\
    \n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp21uoq_el_test.go:46: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp21uoq_el_test.go:46: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmp21uoq_el_test.go:46:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmp21uoq_el_test.go:46: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmp21uoq_el_test.go:46: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmp21uoq_el_test.go:46: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp21uoq_el_test.go:46:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmp21uoq_el_test.go:46: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmp21uoq_el_test.go:46: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmp21uoq_el_test.go:46: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074363
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max int\n    var\
    \ ans string\n    for _, word := range words {\n        count := make(map[rune]int)\n\
    \        for _, char := range word {\n            count[char]++\n        }\n \
    \       len := len(count)\n        if len > max {\n            max = len\n   \
    \         ans = word\n        } else if len == max {\n            if word < ans\
    \ {\n                ans = word\n            }\n        }\n    }\n    return ans\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074363
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := \"\"\n    maxCount\
    \ := 0\n    for _, v := range words {\n        m := make(map[rune]int)\n     \
    \   for _, vv := range v {\n            m[vv]++\n        }\n        if len(m)\
    \ > maxCount {\n            max = v\n            maxCount = len(m)\n        }\n\
    \    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpbf0g6xcl_test.go:56: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpbf0g6xcl_test.go:56: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074363
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_uniq := 0\n    for _, word := range words {\n        uniq := len(get_uniq_chars(word))\n\
    \        if uniq > max_uniq {\n            max_uniq = uniq\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3isokccr_test.go:22:21: undefined: get_uniq_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074362
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    max_word := words[0]\n    max_count :=\
    \ map_count(max_word)\n\n    for _, word := range words[1:] {\n        word_count\
    \ := map_count(word)\n        if word_count > max_count {\n            max_word\
    \ = word\n            max_count = word_count\n        } else if word_count ==\
    \ max_count {\n            if word < max_word {\n                max_word = word\n\
    \            }\n        }\n    }\n\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn3e2okb7_test.go:24:18: undefined: map_count

    /tmp/tmpn3e2okb7_test.go:27:23: undefined: map_count

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074362
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    var max_word string\n    var max_length\
    \ int\n\n    for _, word := range words {\n        if len(word) > max_length {\n\
    \            max_word = word\n            max_length = len(word)\n        }\n\
    \    }\n\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpcz5sm42g_test.go:58: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074363
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    uniq_counts := map[string]int{}\n\
    \    for _, word := range words {\n        uniq_counts[word] = count_uniq_chars(word)\n\
    \    }\n    return find_max_len(uniq_counts)\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzt2er9p4_test.go:21:29: undefined: count_uniq_chars

    /tmp/tmpzt2er9p4_test.go:23:12: undefined: find_max_len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074362
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    max_str := words[0]\n    max_count := unique_chars(max_str)\n\
    \    for _, word := range words[1:] {\n        count := unique_chars(word)\n \
    \       if count > max_count {\n            max_str = word\n            max_count\
    \ = count\n        } else if count == max_count && word < max_str {\n        \
    \    max_str = word\n        }\n    }\n    return max_str\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps2l8hh85_test.go:23:18: undefined: unique_chars

    /tmp/tmps2l8hh85_test.go:25:18: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074362
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_word string\n\
    \    var max_chars = 0\n    for _, w := range words {\n        chars := map[rune]bool{}\n\
    \        for _, c := range w {\n            chars[c] = true\n        }\n     \
    \   n := len(chars)\n        if n > max_chars {\n            max_chars = n\n \
    \           max_word = w\n        } else if n == max_chars && w < max_word {\n\
    \            max_word = w\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074363
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    var\
    \ maxStr string\n    for _, w := range words {\n        m := len(unique(w))\n\
    \        if m > max {\n            max = m\n            maxStr = w\n        }\n\
    \    }\n    return maxStr\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpywjh714b_test.go:22:18: undefined: unique

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074362
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_length := 0\n    for _, word := range words {\n        unique_chars :=\
    \ make(map[rune]int)\n        for _, char := range word {\n            unique_chars[char]\
    \ = 1\n        }\n        if len(unique_chars) > max_length {\n            max_length\
    \ = len(unique_chars)\n            max_word = word\n        }\n    }\n    return\
    \ max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmprjlw3223_test.go:56: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmprjlw3223_test.go:56: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074363
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_unique_char := 0\n    for _, word := range words {\n        if max_unique_char\
    \ < len(get_unique_chars(word)) {\n            max_unique_char = len(get_unique_chars(word))\n\
    \            max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq61dldkn_test.go:22:34: undefined: get_unique_chars

    /tmp/tmpq61dldkn_test.go:23:35: undefined: get_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074362
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_word string\n\
    \    var max_count int\n    for _, w := range words {\n        count := unique_char_count(w)\n\
    \        if count > max_count {\n            max_count = count\n            max_word\
    \ = w\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0x1v3n2i_test.go:22:18: undefined: unique_char_count

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074362
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    if len(words) == 1 {\n        return words[0]\n\
    \    }\n\n    maxCount := 0\n    maxWord := \"\"\n    for _, word := range words\
    \ {\n        wordMap := make(map[string]bool)\n        for _, letter := range\
    \ word {\n            if _, ok := wordMap[string(letter)]; !ok {\n           \
    \     wordMap[string(letter)] = true\n            }\n        }\n\n        count\
    \ := len(wordMap)\n        if count > maxCount {\n            maxCount = count\n\
    \            maxWord = word\n        } else if count == maxCount {\n         \
    \   if word < maxWord {\n                maxWord = word\n            }\n     \
    \   }\n    }\n\n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n \
    \ candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074363
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) < 1\
    \ {\n        return \"\"\n    }\n    cur_max := words[0]\n    max_len := len(cur_max)\n\
    \    for _, word := range words {\n        if len(word) > max_len {\n        \
    \    cur_max = word\n            max_len = len(word)\n        }\n    }\n    return\
    \ cur_max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmprzvb8n1v_test.go:55: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074364
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Initialize a map\
    \ to store the number of unique characters in each word.\n    n_uniq_map := make(map[string]int)\n\
    \    // Initialize slice to store the strings with maximum number of unique characters.\n\
    \    max_uniq_words := make([]string, 0)\n    // Initialize count of unique characters.\n\
    \    max_uniq_count := 0\n    // Iterate through each word in the list.\n    for\
    \ _, word := range words {\n        // Initialize a map to store the number of\
    \ occurrences of each character.\n        char_map := make(map[string]int)\n \
    \       // Iterate through each character in the word.\n        for _, char :=\
    \ range word {\n            // Convert character to string.\n            char_str\
    \ := string(char)\n            // Increment count of the character in the map.\n\
    \            if _, ok := char_map[char_str]; ok {\n                char_map[char_str]\
    \ += 1\n            } else {\n                char_map[char_str] = 1\n       \
    \     }\n        }\n        // Initialize a count of unique characters in the\
    \ word.\n        uniq_count := 0\n        // Iterate through all the characters\
    \ in the map.\n        for _, char_count := range char_map {\n            // If\
    \ the character occurs only once, increment the count of unique characters.\n\
    \            if char_count == 1 {\n                uniq_count += 1\n         \
    \   }\n        }\n        // Store the count of unique characters for the word\
    \ in the map.\n        n_uniq_map[word] = uniq_count\n        // If the count\
    \ of unique characters in the word is greater than the max, reset\n        //\
    \ the max count and clear the slice of words with max unique characters.\n   \
    \     if uniq_count > max_uniq_count {\n            max_uniq_count = uniq_count\n\
    \            max_uniq_words = make([]string, 0)\n        }\n        // If the\
    \ count of unique characters in the word is equal to the max, append the\n   \
    \     // word to the slice of words with max unique characters.\n        if uniq_count\
    \ == max_uniq_count {\n            max_uniq_words = append(max_\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc_xjhye8_test.go:60:41: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074364
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    if len(words) == 1 {\n        return words[0]\n\
    \    }\n    max_index := 0\n    max_length := len(get_unique_chars(words[0]))\n\
    \    for i := 1; i < len(words); i++ {\n        length := len(get_unique_chars(words[i]))\n\
    \        if length > max_length {\n            max_index = i\n            max_length\
    \ = length\n        }\n    }\n    return words[max_index]\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3q8aqqn3_test.go:26:23: undefined: get_unique_chars

    /tmp/tmp3q8aqqn3_test.go:28:23: undefined: get_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074364
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max *string =\
    \ nil\n    for _, word := range words {\n        if max == nil || *max < word\
    \ {\n            max = &word\n        }\n    }\n    return *max\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpa3qabsre_test.go:50: expected 'enam', got 'game'\n    ---\
    \ FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpa3qabsre_test.go:50: expected\
    \ 'aaaaaaa', got 'cc'\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n      \
    \  tmpa3qabsre_test.go:50: expected 'abc', got 'cba'\n    --- FAIL: TestFind_Max/test_num__5\
    \ (0.00s)\n        tmpa3qabsre_test.go:50: expected 'gonna', got 'rock'\n    ---\
    \ FAIL: TestFind_Max/test_num__7 (0.00s)\n        tmpa3qabsre_test.go:50: expected\
    \ 'this', got 'prrk'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074364
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_len, max_pos\
    \ int\n    var max_word string\n    for i, word := range words {\n        uc :=\
    \ unique_chars(word)\n        if len(uc) > max_len {\n            max_len = len(uc)\n\
    \            max_pos = i\n        }\n    }\n    if max_pos >= 0 {\n        max_word\
    \ = words[max_pos]\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpie047z4i_test.go:22:15: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074364
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    maxStr := \"\"\n \
    \   maxNum := 0\n    for _, str := range words {\n        chars := make(map[rune]bool)\n\
    \        for _, char := range str {\n            chars[char] = true\n        }\n\
    \        num := len(chars)\n        if num > maxNum {\n            maxNum = num\n\
    \            maxStr = str\n        } else if num == maxNum && str < maxStr {\n\
    \            maxStr = str\n        }\n    }\n    return maxStr\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074364
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    if len(words) == 1 {\n        return words[0]\n\
    \    }\n    n := len(words)\n    max := 0\n    max_word := \"\"\n    for i :=\
    \ 0; i < n; i++ {\n        m := make(map[rune]bool)\n        for _, c := range\
    \ words[i] {\n            m[c] = true\n        }\n        if len(m) > max {\n\
    \            max = len(m)\n            max_word = words[i]\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpln7rp4w3_test.go:63: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpln7rp4w3_test.go:63: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074364
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    max_word := words[0]\n    max_len := len(unique_chars(words[0]))\n\
    \    for _, word := range words[1:] {\n        unique_len := len(unique_chars(word))\n\
    \        if unique_len > max_len {\n            max_word = word\n            max_len\
    \ = unique_len\n        } else if unique_len == max_len {\n            if word\
    \ < max_word {\n                max_word = word\n            }\n        }\n  \
    \  }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxu2pz5xx_test.go:24:20: undefined: unique_chars

    /tmp/tmpxu2pz5xx_test.go:26:27: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074364
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    maxUnique := 0\n \
    \   maxWord := \"\"\n    for _, word := range words {\n        m := make(map[rune]int)\n\
    \        count := 0\n        for _, r := range word {\n            if _, ok :=\
    \ m[r]; !ok {\n                count++\n                m[r] = 1\n           \
    \ }\n        }\n        if count > maxUnique {\n            maxUnique = count\n\
    \            maxWord = word\n        } else if count == maxUnique {\n        \
    \    if word < maxWord {\n                maxWord = word\n            }\n    \
    \    }\n    }\n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074364
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := \"\"\n    var\
    \ maxUniqueChars int\n    for _, word := range words {\n        uc := findUniqueChars(word)\n\
    \        if len(uc) > maxUniqueChars {\n            maxUniqueChars = len(uc)\n\
    \            max = word\n        } else if len(uc) == maxUniqueChars {\n     \
    \       if word < max {\n                max = word\n            }\n        }\n\
    \    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyx5rjxv6_test.go:22:15: undefined: findUniqueChars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074364
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    var word string\n    var max_uniq = 0\n\
    \    for _, w := range words {\n        uniq := 0\n        m := make(map[string]bool)\n\
    \        for _, c := range w {\n            if !m[string(c)] {\n             \
    \   m[string(c)] = true\n                uniq += 1\n            }\n        }\n\
    \        if uniq > max_uniq {\n            max_uniq = uniq\n            word =\
    \ w\n        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmptm0b6hbo_test.go:64: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmptm0b6hbo_test.go:64: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074365
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max string\n \
    \   for _, word := range words {\n        if len(unique_chars(word)) > len(unique_chars(max))\
    \ {\n            max = word\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzt5ope6x_test.go:21:16: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074365
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_count int\n\
    \    var max_word string\n    for _, word := range words {\n        if count :=\
    \ count_unique_chars(word); count > max_count {\n            max_count = count\n\
    \            max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt2z9g1em_test.go:22:21: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074365
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    max_word\
    \ := \"\"\n    for _, word := range words {\n        m := make(map[byte]int)\n\
    \        for i := 0; i < len(word); i++ {\n            m[word[i]]++\n        }\n\
    \        if len(m) > max {\n            max = len(m)\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp2bdikno8_test.go:56: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmp2bdikno8_test.go:56: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074365
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max, max_word := 0,\
    \ \"\"\n    for _, word := range words {\n        if len(word) > max {\n     \
    \       max = len(word)\n            max_word = word\n        }\n    }\n    return\
    \ max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpfqfjxqgy_test.go:51: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074365
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_len int\n\
    \    var max_word string\n    for _, word := range words {\n        set := make(map[rune]bool)\n\
    \        for _, ch := range word {\n            set[ch] = true\n        }\n  \
    \      if len(set) > max_len {\n            max_len = len(set)\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp5ttisp4d_test.go:56: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmp5ttisp4d_test.go:56: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074365
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    bestWord := \"\"\n\
    \    bestCount := 0\n    for _, word := range words {\n        // we can reuse\
    \ this map to count the number of unique\n        // letters in each word\n  \
    \      countMap := make(map[rune]bool)\n        for _, letter := range word {\n\
    \            countMap[letter] = true\n        }\n        if len(countMap) > bestCount\
    \ {\n            bestCount = len(countMap)\n            bestWord = word\n    \
    \    }\n    }\n    return bestWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n \
    \ candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp0mmn0fmq_test.go:58: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmp0mmn0fmq_test.go:58: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074365
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_word, tmp_word\
    \ string\n    var max_len int\n    for _, word := range words {\n        if len(word)\
    \ > max_len {\n            max_len = len(word)\n            max_word = word\n\
    \        } else if len(word) == max_len {\n            tmp_word = max_word\n \
    \           for index, char := range word {\n                if index >= len(tmp_word)\
    \ {\n                    break\n                }\n                if rune(tmp_word[index])\
    \ > char {\n                    max_word = word\n                    break\n \
    \               } else if rune(tmp_word[index]) < char {\n                   \
    \ break\n                }\n            }\n        }\n    }\n    return max_word\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__7\
    \ (0.00s)\n        tmpyqf7yp8l_test.go:65: expected 'this', got 'prrk'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074365
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_word string\n\
    \    var max_unique_count int\n    for _, word := range words {\n        if len(word)\
    \ == 0 {\n            continue\n        }\n        var unique_count int\n    \
    \    var unique = make(map[byte]int)\n        for i := 0; i < len(word); i++ {\n\
    \            unique[word[i]]++\n        }\n        for _, v := range unique {\n\
    \            if v == 1 {\n                unique_count++\n            }\n    \
    \    }\n        if max_unique_count < unique_count {\n            max_unique_count\
    \ = unique_count\n            max_word = word\n        } else if max_unique_count\
    \ == unique_count {\n            if max_word > word {\n                max_word\
    \ = word\n            }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__2\
    \ (0.00s)\n        tmpyncjs5_z_test.go:69: expected 'aaaaaaa', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpyncjs5_z_test.go:69: expected\
    \ 'footbott', got 'game'\n    --- FAIL: TestFind_Max/test_num__5 (0.00s)\n   \
    \     tmpyncjs5_z_test.go:69: expected 'gonna', got 'rock'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074365
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    max := words[0]\n    for _, s := range words\
    \ {\n        if len(s) > len(max) {\n            max = s\n        }\n    }\n \
    \   return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp3z3rafrz_test.go:53: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074365
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_uniq_chars := 0\n    for _, word := range words {\n        unique_chars\
    \ := 0\n        for i := 0; i < len(word); i++ {\n            unique := true\n\
    \            for j := 0; j < len(word); j++ {\n                if i != j && word[i]\
    \ == word[j] {\n                    unique = false\n                    break\n\
    \                }\n            }\n            if unique {\n                unique_chars++\n\
    \            }\n        }\n        if unique_chars > max_uniq_chars {\n      \
    \      max_uniq_chars = unique_chars\n            max_word = word\n        } else\
    \ if unique_chars == max_uniq_chars && word < max_word {\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__2\
    \ (0.00s)\n        tmp0tc1bzxr_test.go:67: expected 'aaaaaaa', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmp0tc1bzxr_test.go:67: expected\
    \ 'footbott', got 'game'\n    --- FAIL: TestFind_Max/test_num__5 (0.00s)\n   \
    \     tmp0tc1bzxr_test.go:67: expected 'gonna', got 'rock'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074365
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max string = \"\
    \"\n    var maxCount int = 0\n    for _, str := range words {\n        if len(str)\
    \ > len(max) {\n            max = str\n            maxCount = len(map[rune]bool{})\n\
    \        } else if len(str) == len(max) {\n            if len(map[rune]bool{})\
    \ > maxCount {\n                max = str\n                maxCount = len(map[rune]bool{})\n\
    \            }\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp0mx68rzu_test.go:57: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074365
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    max_word\
    \ := \"\"\n    for _, word := range words {\n        l := len(find_unique_chars(word))\n\
    \        if l > max {\n            max = l\n            max_word = word\n    \
    \    }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n \
    \ candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpauou4nje_test.go:22:18: undefined: find_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074365
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    if len(words) == 1 {\n        return words[0]\n\
    \    }\n    maxUniqueChars := 0\n    maxString := \"\"\n    maxWordIdx := 0\n\
    \    for idx, word := range words {\n        chSet := make(map[rune]int)\n   \
    \     for _, ch := range word {\n            chSet[ch]++\n        }\n        if\
    \ len(chSet) > maxUniqueChars {\n            maxUniqueChars = len(chSet)\n   \
    \         maxString = word\n            maxWordIdx = idx\n        }\n    }\n \
    \   return maxString\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu1fpmk79_test.go:27:5: maxWordIdx declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074365
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_count := 0\n    for _, word := range words {\n        unique_chars :=\
    \ map[rune]bool{}\n        for _, char := range word {\n            unique_chars[char]\
    \ = true\n        }\n        if len(unique_chars) > max_count {\n            max_count\
    \ = len(unique_chars)\n            max_word = word\n        }\n    }\n    return\
    \ max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpk40gfpz6_test.go:56: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpk40gfpz6_test.go:56: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074367
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // your code here\n\
    \    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp0ne92qii_test.go:45: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp0ne92qii_test.go:45: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmp0ne92qii_test.go:45:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmp0ne92qii_test.go:45: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmp0ne92qii_test.go:45: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmp0ne92qii_test.go:45: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp0ne92qii_test.go:45:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmp0ne92qii_test.go:45: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmp0ne92qii_test.go:45: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmp0ne92qii_test.go:45: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074367
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    unique\
    \ := []string{}\n    for _, word := range words {\n        if len(word) > max\
    \ {\n            max = len(word)\n            unique = []string{word}\n      \
    \  } else if len(word) == max {\n            unique = append(unique, word)\n \
    \       }\n    }\n    fmt.Println(unique)\n    for i, word := range unique {\n\
    \        if i == 0 {\n            continue\n        }\n        if word < unique[i-1]\
    \ {\n            unique[i], unique[i-1] = unique[i-1], word\n        }\n    }\n\
    \    return unique[0]\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "[string]\n[name enam game]\n[aaaaaaa]\n[abc cba]\n[footbott]\n[gonna]\n\
    [nation]\n[this prrk]\n[b]\n[play play play]\n--- FAIL: TestFind_Max (0.00s)\n\
    \    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n        tmpktoejusl_test.go:63:\
    \ expected 'this', got 'prrk'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074367
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_count := 0\n    for _, word := range words {\n        unique_count :=\
    \ len(get_unique_chars(word))\n        if unique_count > max_count {\n       \
    \     max_count = unique_count\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzykghpp0_test.go:22:29: undefined: get_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074366
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max string\n \
    \   max_size := 0\n    for _, word := range words {\n        word_freq := make(map[rune]int)\n\
    \        for _, c := range word {\n            word_freq[c] += 1\n        }\n\
    \        if len(word_freq) > max_size {\n            max = word\n            max_size\
    \ = len(word_freq)\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpuwq875iq_test.go:56: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpuwq875iq_test.go:56: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074367
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    unique_max := 0\n    for _, word := range words {\n        unique := 0\n\
    \        unique_map := make(map[string]bool)\n        for _, char := range word\
    \ {\n            if !unique_map[string(char)] {\n                unique++\n  \
    \              unique_map[string(char)] = true\n            }\n        }\n   \
    \     if unique > unique_max {\n            unique_max = unique\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmptgip6gix_test.go:60: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmptgip6gix_test.go:60: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074367
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_count := 0\n \
    \   max_word := \"\"\n    for _, w := range words {\n        var m = make(map[string]bool)\n\
    \        for _, ch := range w {\n            m[string(ch)] = true\n        }\n\
    \        unique_count := len(m)\n        if unique_count > max_count {\n     \
    \       max_count = unique_count\n            max_word = w\n        } else if\
    \ unique_count == max_count {\n            if w < max_word {\n               \
    \ max_word = w\n            }\n        }\n    }\n    return max_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074367
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var maxString string\n\
    \    var maxLength int\n    for _, word := range words {\n        if maxLength\
    \ < len(word) {\n            maxLength = len(word)\n            maxString = word\n\
    \        }\n    }\n    return maxString\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmph78t5uye_test.go:52: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074367
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var current_word string\n\
    \    var current_word_characters []string\n    var current_word_character_set\
    \ map[string]bool\n    var num_current_word_characters int\n    var current_word_is_max\
    \ bool\n    var max_word string\n    var max_word_characters []string\n    var\
    \ max_word_character_set map[string]bool\n    var num_max_word_characters int\n\
    \n    max_word = words[0]\n    max_word_characters = get_characters(max_word)\n\
    \    max_word_character_set = get_character_set(max_word_characters)\n    num_max_word_characters\
    \ = len(max_word_character_set)\n\n    for _, word := range words {\n        current_word\
    \ = word\n        current_word_characters = get_characters(current_word)\n   \
    \     current_word_character_set = get_character_set(current_word_characters)\n\
    \        num_current_word_characters = len(current_word_character_set)\n\n   \
    \     if num_current_word_characters == num_max_word_characters {\n          \
    \  current_word_is_max = false\n            // if there are multiple strings with\
    \ the same number of unique\n            // characters, return the one which comes\
    \ first in lexicographical\n            // order.\n            if current_word\
    \ < max_word {\n                max_word = current_word\n            }\n     \
    \   } else if num_current_word_characters > num_max_word_characters {\n      \
    \      max_word = current_word\n            max_word_characters = current_word_characters\n\
    \            max_word_character_set = current_word_character_set\n           \
    \ num_max_word_characters = num_current_word_characters\n        }\n    }\n\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1eyokkg5_test.go:23:9: current_word_is_max declared but not used

    /tmp/tmp1eyokkg5_test.go:30:27: undefined: get_characters

    /tmp/tmp1eyokkg5_test.go:31:30: undefined: get_character_set

    /tmp/tmp1eyokkg5_test.go:36:35: undefined: get_characters

    /tmp/tmp1eyokkg5_test.go:37:38: undefined: get_character_set

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074367
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := words[0]\n\
    \    for _, w := range words[1:] {\n        if len(w) > len(max) {\n         \
    \   max = w\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpwv0vhop3_test.go:50: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074367
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_length := 0\n\
    \    max_word := \"\"\n    for _, word := range words {\n        length := len(unique_chars(word))\n\
    \        if length > max_length {\n            max_length = length\n         \
    \   max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0bjfwtp5_test.go:22:23: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074367
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_so_far := \"\"\
    \n    max_num_unique := 0\n    for _, word := range words {\n        num_unique\
    \ := 0\n        for i := 0; i < len(word); i++ {\n            if i == 0 {\n  \
    \              num_unique++\n            } else {\n                is_unique :=\
    \ true\n                for j := 0; j < i; j++ {\n                    if word[i]\
    \ == word[j] {\n                        is_unique = false\n                  \
    \      break\n                    }\n                }\n                if is_unique\
    \ {\n                    num_unique++\n                }\n            }\n    \
    \    }\n        if num_unique > max_num_unique {\n            max_so_far = word\n\
    \            max_num_unique = num_unique\n        } else if num_unique == max_num_unique\
    \ {\n            if word < max_so_far {\n                max_so_far = word\n \
    \           }\n        }\n    }\n    return max_so_far\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074367
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    if len(words) == 1 {\n        return words[0]\n\
    \    }\n    uniqueWords := make(map[string]int)\n    for _, word := range words\
    \ {\n        uniqueWords[word] = uniqueCharCount(word)\n    }\n    maxUnique :=\
    \ -1\n    var maxWord string\n    for word, unique := range uniqueWords {\n  \
    \      if unique > maxUnique {\n            maxUnique = unique\n            maxWord\
    \ = word\n        }\n    }\n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxh_ubyk0_test.go:27:29: undefined: uniqueCharCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074367
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count := make(map[string]int)\n\
    \    max := 0\n    word := \"\"\n    for _, w := range words {\n        count[w]\
    \ = len(unique(w))\n        if count[w] > max {\n            max = count[w]\n\
    \            word = w\n        }\n    }\n    return word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt0hhx366_test.go:23:24: undefined: unique

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074367
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    dict := make(map[string]int)\n\
    \    nums := []int{}\n    for _, word := range words {\n        num := 0\n   \
    \     for _, b := range word {\n            if _, ok := dict[string(b)]; !ok {\n\
    \                dict[string(b)] = 1\n                num += 1\n            }\n\
    \        }\n        nums = append(nums, num)\n    }\n    fmt.Println(nums)\n \
    \   max := 0\n    for i, j := range nums {\n        if j > max {\n           \
    \ max = j\n        }\n    }\n    for i, j := range nums {\n        if j == max\
    \ {\n            return words[i]\n        }\n    }\n    return \"\"\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyru6nol9_test.go:33:9: i declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074367
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_chars = 0\n\
    \    var max_word = \"\"\n    for _, word := range words {\n        map_chars\
    \ := make(map[string]bool)\n        for _, char := range word {\n            map_chars[string(char)]\
    \ = true\n        }\n        n_chars := len(map_chars)\n        if n_chars > max_chars\
    \ {\n            max_chars = n_chars\n            max_word = word\n        } else\
    \ if n_chars == max_chars {\n            if word < max_word {\n              \
    \  max_word = word\n            }\n        }\n    }\n    return max_word\n}\n\n\
    func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // TODO: Implement\n\
    \    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpq6f4qxgv_test.go:45: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpq6f4qxgv_test.go:45: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpq6f4qxgv_test.go:45:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpq6f4qxgv_test.go:45: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpq6f4qxgv_test.go:45: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpq6f4qxgv_test.go:45: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpq6f4qxgv_test.go:45:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpq6f4qxgv_test.go:45: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpq6f4qxgv_test.go:45: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpq6f4qxgv_test.go:45: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074368
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := words[0]\n\
    \    for _, w := range words[1:] {\n        if uniqueCount(w) > uniqueCount(max)\
    \ {\n            max = w\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptr0nl4nv_test.go:21:12: undefined: uniqueCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074367
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var result string\n\
    \    var result_len int\n    for _, word := range words {\n        l := len(unique_chars(word))\n\
    \        if l > result_len {\n            result = word\n            result_len\
    \ = l\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmwx6vjc6_test.go:22:18: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074367
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // your code here\n\
    \    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmp0ne92qii_test.go:45: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmp0ne92qii_test.go:45: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmp0ne92qii_test.go:45:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmp0ne92qii_test.go:45: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmp0ne92qii_test.go:45: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmp0ne92qii_test.go:45: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmp0ne92qii_test.go:45:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmp0ne92qii_test.go:45: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmp0ne92qii_test.go:45: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmp0ne92qii_test.go:45: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074367
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    var max_count int = 0\n    var max_word string\
    \ = \"\"\n    for _, word := range words {\n        if len(word) == 0 {\n    \
    \        continue\n        }\n        var temp_count int = 0\n        var chars\
    \ map[rune]bool = make(map[rune]bool)\n        for _, char := range word {\n \
    \           if _, ok := chars[char]; !ok {\n                temp_count += 1\n\
    \                chars[char] = true\n            }\n        }\n        if temp_count\
    \ > max_count {\n            max_count = temp_count\n            max_word = word\n\
    \        } else if temp_count == max_count {\n            if word < max_word {\n\
    \                max_word = word\n            }\n        }\n    }\n    return\
    \ max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    maxWord := \"\"\n\
    \    for _, word := range words {\n        if len(maxWord) == 0 || len(word) >\
    \ len(maxWord) {\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmps_yl6h4i_test.go:50: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_w := \"\"\n  \
    \  max_c := 0\n    for _, w := range words {\n        c := 0\n        for i :=\
    \ 0; i < len(w); i++ {\n            c++\n            j := i + 1\n            for\
    \ ; j < len(w); j++ {\n                if w[i] == w[j] {\n                   \
    \ break\n                }\n            }\n            i = j - 1\n        }\n\
    \        if c > max_c {\n            max_c = c\n            max_w = w\n      \
    \  } else if c == max_c && w < max_w {\n            max_w = w\n        }\n   \
    \ }\n    return max_w\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpuanra8u7_test.go:65: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpuanra8u7_test.go:65:\
    \ expected 'gonna', got 'are'\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpuanra8u7_test.go:65: expected 'this', got 'a'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074368
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    maxCount := 0\n  \
    \  maxWord := \"\"\n    for _, word := range words {\n        count := countUniqueCharacters(word)\n\
    \        if count > maxCount {\n            maxCount = count\n            maxWord\
    \ = word\n        } else if count == maxCount && word < maxWord {\n          \
    \  maxWord = word\n        }\n    }\n    return maxWord\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_pbv_r9r_test.go:22:18: undefined: countUniqueCharacters

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074368
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max string\n \
    \   for _, word := range words {\n        if len(word) > len(max) {\n        \
    \    max = word\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp3hn16p4h_test.go:50: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074369
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := \"\"\n    maxUniqueChars\
    \ := 0\n    for _, word := range words {\n        uniqueChars := countUniqueChars(word)\n\
    \        if maxUniqueChars < uniqueChars {\n            maxUniqueChars = uniqueChars\n\
    \            max = word\n        } else if maxUniqueChars == uniqueChars {\n \
    \           if max > word {\n                max = word\n            }\n     \
    \   }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwal4hntm_test.go:22:24: undefined: countUniqueChars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074369
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_word string\n\
    \    var max_letters_map map[string]bool\n    max_letters_len := 0\n    for _,\
    \ word := range words {\n        if len(word) > max_letters_len {\n          \
    \  max_letters_len = len(word)\n            max_word = word\n            max_letters_map\
    \ = get_letters_map(word)\n        } else if len(word) == max_letters_len {\n\
    \            letters_map := get_letters_map(word)\n            if len(letters_map)\
    \ > len(max_letters_map) {\n                max_letters_map = letters_map\n  \
    \              max_word = word\n            } else if len(letters_map) == len(max_letters_map)\
    \ {\n                if word < max_word {\n                    max_word = word\n\
    \                }\n            }\n        }\n    }\n    return max_word\n}\n\n\
    func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppf069y_i_test.go:26:31: undefined: get_letters_map

    /tmp/tmppf069y_i_test.go:28:28: undefined: get_letters_map

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074369
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_word string\n\
    \    max_count := 0\n    for _,word := range words {\n        max_count = find_count(word,\
    \ max_count, &max_word)\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjh7w788f_test.go:22:21: undefined: find_count

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074369
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count_map := make(map[string]int)\n\
    \    max_count := 0\n    ans := \"\"\n    for _, word := range words {\n     \
    \   if _, ok := count_map[word]; !ok {\n            count_map[word] = len(unique_chars(word))\n\
    \        }\n        if count_map[word] > max_count {\n            max_count =\
    \ count_map[word]\n            ans = word\n        }\n    }\n    return ans\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_6x39i_s_test.go:24:35: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074369
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    unique_char_words\
    \ := map[string]map[rune]bool{}\n    max_unique_char_count := 0\n    max_unique_char_word\
    \ := \"\"\n    for _, word := range words {\n        unique_char_words[word] =\
    \ map[rune]bool{}\n        for _, char := range word {\n            unique_char_words[word][char]\
    \ = true\n        }\n        unique_char_count := len(unique_char_words[word])\n\
    \        if unique_char_count > max_unique_char_count {\n            max_unique_char_count\
    \ = unique_char_count\n            max_unique_char_word = word\n        } else\
    \ if unique_char_count == max_unique_char_count {\n            // if we have a\
    \ tie on the number of unique characters, return the one\n            // which\
    \ comes first in lexicographical order\n            if word < max_unique_char_word\
    \ {\n                max_unique_char_word = word\n            }\n        }\n \
    \   }\n    return max_unique_char_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074369
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // TODO - Add your\
    \ code here\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpcojyw852_test.go:45: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpcojyw852_test.go:45: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpcojyw852_test.go:45:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpcojyw852_test.go:45: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpcojyw852_test.go:45: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpcojyw852_test.go:45: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpcojyw852_test.go:45:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpcojyw852_test.go:45: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpcojyw852_test.go:45: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpcojyw852_test.go:45: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074363
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max = \"\"\n \
    \   var count = 0\n    var maxCount = 0\n    for _, word := range words {\n  \
    \      if len(word) > len(max) {\n            max = word\n        }\n        for\
    \ index, value := range word {\n            if index == 0 {\n                count++\n\
    \            } else {\n                if string(value) != string(word[index-1])\
    \ {\n                    count++\n                }\n            }\n        }\n\
    \        if count > maxCount {\n            maxCount = count\n            max\
    \ = word\n        }\n        count = 0\n    }\n    return max\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpw5jvys3j_test.go:66: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074370
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := \"\"\n    max_count\
    \ := 0\n    for _, word := range words {\n        if max_count < len(find_unique_letters(word))\
    \ {\n            max = word\n            max_count = len(find_unique_letters(word))\n\
    \        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_sucpbfp_test.go:22:28: undefined: find_unique_letters

    /tmp/tmp_sucpbfp_test.go:24:29: undefined: find_unique_letters

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074369
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    max := words[0]\n    for _, word := range\
    \ words {\n        if len(word) > len(max) {\n            max = word\n       \
    \ }\n    }\n\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp7ts25ljj_test.go:55: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074370
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    word := words[0]\n    best := make(map[rune]bool)\n\
    \    for _, c := range word {\n        best[c] = true\n    }\n\n    for _, w :=\
    \ range words[1:] {\n        if len(w) > len(word) {\n            word = w\n \
    \           best = make(map[rune]bool)\n            for _, c := range word {\n\
    \                best[c] = true\n            }\n        } else if len(w) == len(word)\
    \ {\n            score := make(map[rune]bool)\n            for _, c := range w\
    \ {\n                score[c] = true\n            }\n            if len(score)\
    \ > len(best) {\n                word = w\n                best = score\n    \
    \        }\n        }\n    }\n\n    return word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpby11irxt_test.go:73: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074369
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    var maxWord string\n    maxCount := 0\n \
    \   for _, word := range words {\n        count := 0\n        for _, ch := range\
    \ word {\n            if strings.Count(word, string(ch)) == 1 {\n            \
    \    count += 1\n            }\n        }\n        if count > maxCount {\n   \
    \         maxCount = count\n            maxWord = word\n        }\n    }\n   \
    \ return maxWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbcj4uxv1_test.go:27:16: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074369
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_str := \"\"\n\
    \    max_count := 0\n    for _, word := range words {\n        unique_count :=\
    \ 0\n        for _, letter := range word {\n            if !is_seen(word, letter)\
    \ {\n                unique_count++\n            }\n        }\n        if max_count\
    \ < unique_count {\n            max_count = unique_count\n            max_str\
    \ = word\n        }\n    }\n    return max_str\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1t_gwtzs_test.go:24:17: undefined: is_seen

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074369
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_word string\n\
    \    max_count := 0\n    for _, word := range words {\n        chars := map[rune]bool{}\n\
    \        for _, c := range word {\n            chars[c] = true\n        }\n  \
    \      count := len(chars)\n        if count > max_count {\n            max_count\
    \ = count\n            max_word = word\n        } else if count == max_count &&\
    \ word < max_word {\n            max_word = word\n        }\n    }\n    return\
    \ max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074370
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    // maximum number of unique characters\n\
    \    // max_len := len(words[0])\n    // max_word := words[0]\n    // for _, word\
    \ := range words[1:] {\n    //     unique_char := make(map[rune]int)\n    // \
    \    for _, char := range word {\n    //         unique_char[char] = 0\n    //\
    \     }\n    //     if len(unique_char) > max_len {\n    //         max_len =\
    \ len(unique_char)\n    //         max_word = word\n    //     }\n    // }\n \
    \   // return max_word\n\n    // modified code\n    max_len := len(words[0])\n\
    \    max_word := words[0]\n    for _, word := range words[1:] {\n        unique_char\
    \ := make(map[rune]int)\n        for _, char := range word {\n            unique_char[char]\
    \ = 0\n        }\n        // if len(unique_char) > max_len {\n        //     max_len\
    \ = len(unique_char)\n        //     max_word = word\n        // }\n        //\
    \ if len(unique_char) == max_len {\n        //     if word < max_word {\n    \
    \    //         max_word = word\n        //     }\n        // }\n        if len(unique_char)\
    \ > max_len || (len(unique_char) == max_len && word < max_word) {\n          \
    \  max_len = len(unique_char)\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074370
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_count int\n\
    \    var max_word string\n    for _, word := range words {\n        count := count_unique_chars(word)\n\
    \        if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo1lo6yp6_test.go:22:18: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074369
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max, word := 0, \"\
    \"\n    for _, v := range words {\n        if len(unique(v)) > max {\n       \
    \     max = len(unique(v))\n            word = v\n        }\n    }\n    return\
    \ word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6bxhc5av_test.go:21:16: undefined: unique

    /tmp/tmp6bxhc5av_test.go:22:23: undefined: unique

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074369
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    maxWord\
    \ := \"\"\n    for _, word := range words {\n        m := make(map[rune]int)\n\
    \        for _, w := range word {\n            m[w] = m[w] + 1\n        }\n  \
    \      if len(m) > max {\n            max = len(m)\n            maxWord = word\n\
    \        }\n    }\n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpd0n0zqja_test.go:56: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpd0n0zqja_test.go:56: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074370
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    var\
    \ max_string string\n    for _, word := range words {\n        max_char := find_max_char(word)\n\
    \        // fmt.Println(max_char)\n        if max_char > max {\n            max\
    \ = max_char\n            max_string = word\n        }\n    }\n    return max_string\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm2wep9g2_test.go:22:21: undefined: find_max_char

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074370
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_len := 0\n    for _, w := range words {\n        uniq_char_map := make(map[rune]bool)\n\
    \        for _, c := range w {\n            uniq_char_map[c] = true\n        }\n\
    \        l := len(uniq_char_map)\n        if l > max_len {\n            max_len\
    \ = l\n            max_word = w\n        } else if l == max_len && w < max_word\
    \ {\n            max_word = w\n        }\n    }\n    return max_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074370
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_count := 0\n \
    \   max_word := \"\"\n    for _, word := range words {\n        count := count_distinct_characters(word)\n\
    \        if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfveqz17x_test.go:22:18: undefined: count_distinct_characters

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074370
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_unique_count\
    \ int\n    var max_unique_word string\n    for _, w := range words {\n       \
    \ m := make(map[rune]bool)\n        count := 0\n        for _, r := range w {\n\
    \            if _, ok := m[r]; !ok {\n                m[r] = true\n          \
    \      count++\n            }\n        }\n        if count > max_unique_count\
    \ {\n            max_unique_count = count\n            max_unique_word = w\n \
    \       } else if count == max_unique_count {\n            if w < max_unique_word\
    \ {\n                max_unique_word = w\n            }\n        }\n    }\n  \
    \  return max_unique_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074370
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_count := 0\n    for _, word := range words {\n        count := count_unique_chars(word)\n\
    \        if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpru9fhwaa_test.go:22:18: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074195
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_len := 0\n   \
    \ var res string\n    for _, w := range words {\n        set := make(map[rune]bool)\n\
    \        for _, c := range w {\n            set[c] = true\n        }\n       \
    \ if len(set) > max_len {\n            max_len = len(set)\n            res = w\n\
    \        }\n    }\n    return res\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpsa70sx93_test.go:56: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpsa70sx93_test.go:56: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074370
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    max_word\
    \ := \"\"\n    for _, word := range words {\n        if len(unique_characters(word))\
    \ > max {\n            max = len(unique_characters(word))\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0nhcoxlw_test.go:22:16: undefined: unique_characters

    /tmp/tmp0nhcoxlw_test.go:23:23: undefined: unique_characters

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074370
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    unique := make(map[string]int)\n\
    \    for _, word := range words {\n        m := make(map[rune]bool)\n        for\
    \ _, r := range word {\n            m[r] = true\n        }\n        unique[word]\
    \ = len(m)\n    }\n    var maxWord string\n    var maxCount int\n    for w, u\
    \ := range unique {\n        if u > maxCount {\n            maxWord = w\n    \
    \        maxCount = u\n        }\n    }\n    return maxWord\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpskq2_s0z_test.go:60: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpskq2_s0z_test.go:60: expected\
    \ 'aaaaaaa', got 'bb'\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n      \
    \  tmpskq2_s0z_test.go:60: expected 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max, index := len(words[0]),\
    \ 0\n    for i, w := range words {\n        if len(w) > max {\n            max,\
    \ index = len(w), i\n        }\n    }\n    return words[index]\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp9ayiixew_test.go:50: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_count := 0\n \
    \   max_word := \"\"\n    for _, word := range words {\n        if len(word) <\
    \ max_count {\n            continue\n        }\n        if len(word) == max_count\
    \ {\n            if word < max_word {\n                continue\n            }\n\
    \        }\n        set := make(map[rune]bool)\n        for _, char := range word\
    \ {\n            set[char] = true\n        }\n        if len(set) > max_count\
    \ {\n            max_count = len(set)\n            max_word = word\n        }\n\
    \    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpampr3n9v_test.go:64: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpampr3n9v_test.go:64: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074371
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    chars := make(map[string]int)\n\
    \    max := make(map[string]int)\n    for _,word := range words {\n        chars[word]\
    \ = 0\n        chars[word] = count_unique_chars(word)\n        fmt.Println(chars)\n\
    \    }\n    for word,num := range chars {\n        max[word] = num\n    }\n  \
    \  // find word with max unique characters\n    for word,num := range chars {\n\
    \        for word2,num2 := range chars {\n            if num < num2 {\n      \
    \          max[word] = num2\n            }\n        }\n    }\n    // determine\
    \ the lexicographically first word\n    for word,num := range max {\n        for\
    \ word2,num2 := range max {\n            if num == num2 && word > word2 {\n  \
    \              max[word] = num2\n            }\n        }\n    }\n    for word,_\
    \ := range max {\n        return word\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp50ywj2re_test.go:23:23: undefined: count_unique_chars

    /tmp/tmp50ywj2re_test.go:31:13: word2 declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    len_count := make(map[int]int)\n\
    \    var list []string\n    for _, w := range words {\n        if _, ok := len_count[len(w)];\
    \ !ok {\n            len_count[len(w)] = 1\n            list = append(list, w)\n\
    \        } else {\n            len_count[len(w)] += 1\n        }\n    }\n    if\
    \ len(list) == 1 {\n        return list[0]\n    }\n    max := 0\n    for i :=\
    \ 0; i < len(list); i++ {\n        if len_count[len(list[i])] > max {\n      \
    \      max = len_count[len(list[i])]\n        }\n    }\n    var res []string\n\
    \    for _, w := range list {\n        if len_count[len(w)] == max {\n       \
    \     res = append(res, w)\n        }\n    }\n    var smaller string\n    smaller\
    \ = res[0]\n    for _, w := range res {\n        if w < smaller {\n          \
    \  smaller = w\n        }\n    }\n    return smaller\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpgeqrvrrm_test.go:76: expected 'string', got 'name'\n   \
    \ --- FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpgeqrvrrm_test.go:76:\
    \ expected 'enam', got 'name'\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n\
    \        tmpgeqrvrrm_test.go:76: expected 'aaaaaaa', got 'bb'\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpgeqrvrrm_test.go:76: expected 'footbott', got 'play'\n \
    \   --- FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpgeqrvrrm_test.go:76:\
    \ expected 'gonna', got 'are'\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n\
    \        tmpgeqrvrrm_test.go:76: expected 'nation', got 'are'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074371
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    for _, w := range words {\n        if len(w) > len(max_word) {\n        \
    \    max_word = w\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp2fbxfbrk_test.go:50: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074372
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_len := 0\n   \
    \ unique_str := \"\"\n    for _, word := range words {\n        unique_len :=\
    \ len(get_unique_chars(word))\n        if unique_len > max_len {\n           \
    \ max_len = unique_len\n            unique_str = word\n        }\n    }\n    return\
    \ unique_str\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkx4cqq_f_test.go:22:27: undefined: get_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var maxWord string\n\
    \    var maxCount int\n    for _, word := range words {\n        charCount :=\
    \ getCharCount(word)\n        if len(charCount) > maxCount {\n            maxCount\
    \ = len(charCount)\n            maxWord = word\n        }\n    }\n    return maxWord\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5l0nmxcy_test.go:22:22: undefined: getCharCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_word string\n\
    \    max_count := 0\n    for _, word := range words {\n        word_count := len(unique_chars(word))\n\
    \        if word_count > max_count {\n            max_count = word_count\n   \
    \         max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_m0sg0ur_test.go:22:27: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074371
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    max_count := 0\n    max_word := \"\"\n  \
    \  for _, word := range words {\n        count := make(map[rune]int)\n       \
    \ for _, c := range word {\n            if _, ok := count[c]; !ok {\n        \
    \        count[c] = 1\n            }\n        }\n        if len(count) > max_count\
    \ {\n            max_count = len(count)\n            max_word = word\n       \
    \ } else if len(count) == max_count {\n            if word < max_word {\n    \
    \            max_word = word\n            }\n        }\n    }\n    return max_word\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074372
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    word_map := make(map[string]int)\n\
    \    max_val := 0\n    max_idx := 0\n    for idx, word := range words {\n    \
    \    uniq_count := 0\n        for _, ch := range word {\n            if _, ok\
    \ := word_map[string(ch)]; !ok {\n                uniq_count += 1\n          \
    \      word_map[string(ch)] = 1\n            }\n        }\n        if uniq_count\
    \ > max_val {\n            max_val = uniq_count\n            max_idx = idx\n \
    \       }\n    }\n    return words[max_idx]\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpck70bciv_test.go:60: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpck70bciv_test.go:60: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074372
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    maxUniqueWord := words[0]\n    maxUniqueChars\
    \ := len(get_unique_chars(words[0]))\n\n    for _, w := range words[1:] {\n  \
    \      u := len(get_unique_chars(w))\n        if u > maxUniqueChars {\n      \
    \      maxUniqueChars = u\n            maxUniqueWord = w\n        } else if u\
    \ == maxUniqueChars && w < maxUniqueWord {\n            maxUniqueWord = w\n  \
    \      }\n    }\n\n    return maxUniqueWord\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprxw93jzm_test.go:24:27: undefined: get_unique_chars

    /tmp/tmprxw93jzm_test.go:27:18: undefined: get_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074372
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count, word := 0,\
    \ \"\"\n    for _, w := range words {\n        if len(w) > count {\n         \
    \   count = len(w)\n            word = w\n        }\n    }\n    return word\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp8n89wgdi_test.go:51: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074372
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_count := 0\n \
    \   max_word := \"\"\n    for _, v := range words {\n        if len(unique_chars(v))\
    \ > max_count {\n            max_count = len(unique_chars(v))\n            max_word\
    \ = v\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpycxuyz5v_test.go:22:16: undefined: unique_chars

    /tmp/tmpycxuyz5v_test.go:23:29: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074372
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var result string\n\
    \    var max int\n    for _, word := range words {\n        var count int\n  \
    \      var m = make(map[rune]int)\n        for _, s := range word {\n        \
    \    m[s] = 1\n        }\n        for _, v := range m {\n            count +=\
    \ v\n        }\n        if count > max {\n            max = count\n          \
    \  result = word\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpvlecm72n_test.go:60: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpvlecm72n_test.go:60: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    max_word\
    \ := \"\"\n    for _,word := range words {\n        // build map\n        my_map\
    \ := make(map[string]int)\n        for _,ch := range word {\n            my_map[string(ch)]\
    \ = 1\n        }\n        if len(my_map) > max {\n            max = len(my_map)\n\
    \            max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpln0r3okm_test.go:57: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpln0r3okm_test.go:57: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074373
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_uniq_chars := 0\n    for _, word := range words {\n        if len(word)\
    \ > len(max_word) {\n            max_word = word\n            max_uniq_chars =\
    \ len(uniq_chars(word))\n        } else if len(word) == len(max_word) {\n    \
    \        uniq_chars := len(uniq_chars(word))\n            if uniq_chars > max_uniq_chars\
    \ {\n                max_word = word\n                max_uniq_chars = uniq_chars\n\
    \            }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqcuqwbyb_test.go:24:34: undefined: uniq_chars

    /tmp/tmpqcuqwbyb_test.go:26:31: undefined: uniq_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074372
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var maxWord string\n\
    \    var maxCount int\n\n    for _, word := range words {\n        wordCount :=\
    \ countUniqueChars(word)\n        if wordCount > maxCount {\n            maxCount\
    \ = wordCount\n            maxWord = word\n        }\n    }\n\n    return maxWord\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1niltlqi_test.go:23:22: undefined: countUniqueChars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074372
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var m = make(map[rune]int)\n\
    \    var max = 0\n    var result string\n    for _, w := range words {\n     \
    \   m = make(map[rune]int)\n        for _, c := range w {\n            m[c] +=\
    \ 1\n        }\n        if len(m) > max {\n            max = len(m)\n        \
    \    result = w\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpo8_8_mwb_test.go:57: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpo8_8_mwb_test.go:57: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074373
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    if len(words) == 1 {\n        return words[0]\n\
    \    }\n    max := len(words[0])\n    max_word := words[0]\n    cur_word := \"\
    \"\n    cur_len := 0\n    for _, v := range words {\n        if len(v) > max {\n\
    \            max = len(v)\n            max_word = v\n        }\n        cur_word\
    \ = \"\"\n        cur_len = 0\n        for _, s := range v {\n            if !contains(cur_word,\
    \ s) {\n                cur_word += string(s)\n                cur_len++\n   \
    \         }\n        }\n        if cur_len > max {\n            max = cur_len\n\
    \            max_word = v\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx4ovpiz9_test.go:37:17: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074372
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := \"\"\n    max_unique\
    \ := 0\n    for _, word := range words {\n        unique := make(map[rune]bool)\n\
    \        for _, char := range word {\n            if _, ok := unique[char]; !ok\
    \ {\n                unique[char] = true\n            }\n        }\n        if\
    \ len(unique) > max_unique {\n            max = word\n            max_unique =\
    \ len(unique)\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp_w4a9_62_test.go:58: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmp_w4a9_62_test.go:58: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074373
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_index := 0\n \
    \   max_count := 0\n    for i, word := range words {\n        count := unique_char_count(word)\n\
    \        if count > max_count {\n            max_count = count\n            max_index\
    \ = i\n        }\n    }\n    return words[max_index]\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7uqk4oq5_test.go:22:18: undefined: unique_char_count

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var ret string = \"\
    \"\n    var max int = 0\n    for _, word := range words {\n        num := len(unique_chars(word))\n\
    \        if num > max {\n            max = num\n            ret = word\n     \
    \   }\n    }\n    return ret\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp16dt5x51_test.go:22:20: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074373
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := \"\"\n    for\
    \ _, word := range words {\n        if len(word) > len(max) {\n            max\
    \ = word\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpsuo3szd5_test.go:50: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074199
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    max_word\
    \ := \"\"\n    for _, word := range words {\n        map_word := make(map[rune]int)\n\
    \        for _, rune_word := range word {\n            map_word[rune_word] = 1\n\
    \        }\n        map_word_len := len(map_word)\n        if map_word_len > max\
    \ {\n            max = map_word_len\n            max_word = word\n        } else\
    \ if map_word_len == max {\n            if word < max_word {\n               \
    \ max_word = word\n            }\n        }\n    }\n    return max_word\n}\n\n\
    func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074374
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_word string\n\
    \    var max_num int\n    var char_map map[string]int\n    char_map = make(map[string]int)\n\
    \    for _, word := range words {\n        char_map[word] = len(unique_chars(word))\n\
    \        if char_map[word] > max_num {\n            max_num = char_map[word]\n\
    \            max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa0tvq7sx_test.go:24:30: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074374
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    count_word := 0\n\
    \    words_index := 0\n    var max_chars []string\n    var max_word string\n \
    \   word_copy := make([]string, len(words))\n    copy(word_copy, words)\n    for\
    \ _, word := range word_copy {\n        for i := 0; i < len(word); i++ {\n   \
    \         for j := i + 1; j < len(word); j++ {\n                if word[i] ==\
    \ word[j] {\n                    word = word[:j] + word[j+1:]\n              \
    \      j--\n                }\n            }\n        }\n        if len(word)\
    \ > count_word {\n            count_word = len(word)\n            max_chars =\
    \ []string{}\n            max_chars = append(max_chars, word)\n        } else\
    \ if len(word) == count_word {\n            max_chars = append(max_chars, word)\n\
    \        }\n    }\n    max_word = max_chars[0]\n    if len(max_chars) > 1 {\n\
    \        for i := 1; i < len(max_chars); i++ {\n            if max_chars[i] <\
    \ max_word {\n                max_word = max_chars[i]\n            }\n       \
    \ }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw1ojumf3_test.go:20:5: words_index declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074374
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    word_map := make(map[string]int)\n\
    \    max_word := \"\"\n    max_count := 0\n    for _, word := range words {\n\
    \        word_map[word] = count_unique_chars(word)\n        if word_map[word]\
    \ > max_count {\n            max_count = word_map[word]\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkz5blx8i_test.go:23:26: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074374
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_value string\
    \ = \"\"\n    var max_value_sum int = 0\n    for _, word := range words {\n  \
    \      var w_map = make(map[rune]int)\n        var current_sum int = 0\n     \
    \   for _, val := range word {\n            if _, ok := w_map[val]; !ok {\n  \
    \              w_map[val] = 1\n                current_sum++\n            }\n\
    \        }\n        if current_sum > max_value_sum {\n            max_value_sum\
    \ = current_sum\n            max_value = word\n        }\n    }\n    return max_value\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpbe2f9561_test.go:60: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpbe2f9561_test.go:60: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074374
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := \"\"\n    for\
    \ _, word := range words {\n        if len(word) > len(max) {\n            max\
    \ = word\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpsuo3szd5_test.go:50: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074199
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    max_word\
    \ := \"\"\n    for _, word := range words {\n        characters := map[string]bool{}\n\
    \        for _, character := range word {\n            characters[string(character)]\
    \ = true\n        }\n        if len(characters) > max {\n            max = len(characters)\n\
    \            max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpian22hwz_test.go:56: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpian22hwz_test.go:56: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074374
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_count := 0\n    word_map := make(map[string]int)\n    for _, word :=\
    \ range words {\n        word_map[word] = len(word)\n        count := len(word)\n\
    \        if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpl3629g79_test.go:55: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074374
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var m_word string\n\
    \    var m_len int\n    for _, word := range words {\n        unique_chars :=\
    \ make(map[byte]bool)\n        for i := 0; i < len(word); i++ {\n            unique_chars[word[i]]\
    \ = true\n        }\n        if len(unique_chars) > m_len {\n            m_len\
    \ = len(unique_chars)\n            m_word = word\n        }\n    }\n    return\
    \ m_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp8jdv002h_test.go:56: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmp8jdv002h_test.go:56: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074374
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_word string\n\
    \    max_unique := 0\n    for _, word := range words {\n        unique := map[rune]bool{}\n\
    \        for _, r := range word {\n            unique[r] = true\n        }\n \
    \       if len(unique) > max_unique {\n            max_unique = len(unique)\n\
    \            max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpvk68qh0m_test.go:56: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpvk68qh0m_test.go:56: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074374
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := 0\n    max_s\
    \ := \"\"\n    for _, w := range words {\n        uniques := 0\n        for _,\
    \ c := range w {\n            count := 0\n            for _, d := range w {\n\
    \                if c == d {\n                    count += 1\n               \
    \ }\n            }\n            if count == 1 {\n                uniques += 1\n\
    \            }\n        }\n        if uniques > max {\n            max = uniques\n\
    \            max_s = w\n        }\n    }\n    return max_s\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpzkcn5k44_test.go:64: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpzkcn5k44_test.go:64: expected\
    \ 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpzkcn5k44_test.go:64:\
    \ expected 'footbott', got 'play'\n    --- FAIL: TestFind_Max/test_num__5 (0.00s)\n\
    \        tmpzkcn5k44_test.go:64: expected 'gonna', got 'rock'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074374
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_num := 0\n    for _, word := range words {\n        num := len(get_unique_letters(word))\n\
    \        if num > max_num {\n            max_num = num\n            max_word =\
    \ word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiyjo8b1a_test.go:22:20: undefined: get_unique_letters

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074374
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    maxCount := 0\n  \
    \  ret := \"\"\n    for _, word := range words {\n        if count(word) > maxCount\
    \ {\n            maxCount = count(word)\n            ret = word\n        }\n \
    \   }\n    return ret\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_82cexuv_test.go:22:12: undefined: count

    /tmp/tmp_82cexuv_test.go:23:24: undefined: count

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074374
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_count := 0\n    for _, word := range words {\n        count := len(unique_chars(word))\n\
    \        if count > max_count {\n            max_count = count\n            max_word\
    \ = word\n        } else if count == max_count {\n            if word < max_word\
    \ {\n                max_word = word\n            }\n        }\n    }\n    return\
    \ max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfzcmg1o6_test.go:22:22: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074195
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    maxLen := 0\n    ret := \"\"\n    for _,\
    \ w := range words {\n        if len(w) > maxLen {\n            maxLen = len(w)\n\
    \            ret = w\n        }\n    }\n    return ret\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp_u9zfn78_test.go:55: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    for _, word := range words {\n        if len(word) > len(max_word) {\n  \
    \          max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpz45pah2j_test.go:50: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_word string\n\
    \    for i, w := range words {\n        if len(w) == 0 {\n            continue\n\
    \        }\n        for _, ww := range words[i+1:] {\n            if len(ww) ==\
    \ 0 {\n                continue\n            }\n            if len(w) > len(ww)\
    \ {\n                max_word = w\n            } else if len(w) < len(ww) {\n\
    \                max_word = ww\n            } else {\n                max_word\
    \ = w\n            }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__2\
    \ (0.00s)\n        tmpjzmi21hz_test.go:62: expected 'aaaaaaa', got 'bb'\n    ---\
    \ FAIL: TestFind_Max/test_num__7 (0.00s)\n        tmpjzmi21hz_test.go:62: expected\
    \ 'this', got 'prrk'\n    --- FAIL: TestFind_Max/test_num__8 (0.00s)\n       \
    \ tmpjzmi21hz_test.go:62: expected 'b', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var word_lengths []int\n\
    \    word_map := make(map[int]string)\n    for _, word := range words {\n    \
    \    word_lengths = append(word_lengths, len(word))\n        word_map[len(word)]\
    \ = word\n    }\n    max_length := 0\n    for _, value := range word_lengths {\n\
    \        if value > max_length {\n            max_length = value\n        }\n\
    \    }\n    return word_map[max_length]\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpvomt_lw6_test.go:56: expected 'enam', got 'game'\n    ---\
    \ FAIL: TestFind_Max/test_num__3 (0.00s)\n        tmpvomt_lw6_test.go:56: expected\
    \ 'abc', got 'cba'\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n        tmpvomt_lw6_test.go:56:\
    \ expected 'this', got 'prrk'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // Set max length\n\
    \    max_length := 0\n    max_word := \"\"\n    // Iterate over words\n    for\
    \ _, word := range words {\n        // Count number of unique characters in current\
    \ word\n        chars := map[rune]bool{}\n        for _, char := range word {\n\
    \            chars[char] = true\n        }\n        // Does word have more unique\
    \ characters than max_length?\n        if len(chars) > max_length {\n        \
    \    max_length = len(chars)\n            max_word = word\n        }\n    }\n\
    \    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpp0a29h76_test.go:60: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpp0a29h76_test.go:60: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var maxWord string\n\
    \    var maxLen int\n    for _, word := range words {\n        var letterMap =\
    \ make(map[string]int)\n        for _, letter := range word {\n            letterMap[string(letter)]\
    \ = 1\n        }\n        if len(letterMap) > maxLen {\n            maxLen = len(letterMap)\n\
    \            maxWord = word\n        }\n    }\n    return maxWord\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpafvx9l43_test.go:56: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpafvx9l43_test.go:56: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074375
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_len := 0\n    for _, word := range words {\n        cnt := count_unique_chars(word)\n\
    \        if cnt > max_len {\n            max_len = cnt\n            max_word =\
    \ word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2d83f2k1_test.go:22:16: undefined: count_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := \"\"\n    for\
    \ _, word := range words {\n        if len(word) > len(max) {\n            max\
    \ = word\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpsuo3szd5_test.go:50: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074199
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    if len(words) == 1 {\n        return words[0]\n\
    \    }\n\n    countMap := make(map[string]int)\n    maxKey := words[0]\n    for\
    \ _, word := range words {\n        if len(word) == 0 {\n            continue\n\
    \        }\n\n        if len(word) == 1 {\n            maxKey = word\n       \
    \     continue\n        }\n\n        _, ok := countMap[word]\n        if !ok {\n\
    \            // Generate the count map for the first time\n            characterMap\
    \ := make(map[rune]bool)\n            for _, char := range word {\n          \
    \      characterMap[char] = true\n            }\n            countMap[word] =\
    \ len(characterMap)\n        }\n\n        if countMap[word] > countMap[maxKey]\
    \ {\n            maxKey = word\n        } else if countMap[word] == countMap[maxKey]\
    \ {\n            if word < maxKey {\n                maxKey = word\n         \
    \   }\n        }\n    }\n\n    return maxKey\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__7\
    \ (0.00s)\n        tmp85iuwab7_test.go:83: expected 'this', got 'prrk'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074375
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    words_len := len(words)\n\
    \    max_map := make(map[string]int)\n    max_len := 0\n    max_word := \"\"\n\
    \    if words_len == 0 {\n        return \"\"\n    }\n    if words_len == 1 {\n\
    \        return words[0]\n    }\n    for _, word := range words {\n        word_len\
    \ := len(word)\n        if word_len == 0 {\n            continue\n        }\n\
    \        unique_map := make(map[rune]int)\n        unique_map_len := 0\n     \
    \   for _, r := range word {\n            if _, ok := unique_map[r]; !ok {\n \
    \               unique_map[r] = 1\n                unique_map_len++\n        \
    \    }\n        }\n        if max_len < unique_map_len {\n            max_len\
    \ = unique_map_len\n            max_map = make(map[string]int)\n            max_map[word]\
    \ = unique_map_len\n        } else if max_len == unique_map_len {\n          \
    \  max_map[word] = unique_map_len\n        }\n    }\n    for word, _ := range\
    \ max_map {\n        if max_word == \"\" {\n            max_word = word\n    \
    \    } else if max_word > word {\n            max_word = word\n        }\n   \
    \ }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074375
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max int\n    var\
    \ index int\n    for i, v := range words {\n        if i == 0 {\n            max\
    \ = len(wordToMap(v))\n            index = i\n        } else {\n            if\
    \ len(wordToMap(v)) > max {\n                max = len(wordToMap(v))\n       \
    \         index = i\n            }\n        }\n    }\n    return words[index]\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz7sre417_test.go:23:23: undefined: wordToMap

    /tmp/tmpz7sre417_test.go:26:20: undefined: wordToMap

    /tmp/tmpz7sre417_test.go:27:27: undefined: wordToMap

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    maxWord := \"\"\n\
    \    maxUniqueChars := 0\n    for _, word := range words {\n        uniqueChars\
    \ := unique_chars(word)\n        if uniqueChars > maxUniqueChars {\n         \
    \   maxUniqueChars = uniqueChars\n            maxWord = word\n        }\n    }\n\
    \    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3jlcawjg_test.go:22:24: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074375
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    unique_words := make(map[string]bool)\n\
    \    max_word := \"\"\n    for _, w := range words {\n        for _, l := range\
    \ w {\n            unique_words[string(l)] = true\n        }\n        if len(unique_words)\
    \ > len(max_word) {\n            max_word = w\n        }\n        unique_words\
    \ = make(map[string]bool)\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpaneq429m_test.go:55: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpaneq429m_test.go:55: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074376
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    currentMax := \"\"\
    \n    currentMaxUniqueChars := 0\n    for _, word := range words {\n        uniqueChars\
    \ := make(map[rune]bool)\n        for _, letter := range word {\n            uniqueChars[letter]\
    \ = true\n        }\n        if len(uniqueChars) > currentMaxUniqueChars {\n \
    \           currentMax = word\n            currentMaxUniqueChars = len(uniqueChars)\n\
    \        }\n    }\n    return currentMax\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpx30pnw1f_test.go:56: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpx30pnw1f_test.go:56: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074376
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    max_unique_chars_word := words[0]\n   \
    \ max_unique_chars := len(unique_chars(words[0]))\n\n    for _, word := range\
    \ words[1:] {\n        unique_chars := len(unique_chars(word))\n        if unique_chars\
    \ > max_unique_chars {\n            max_unique_chars = unique_chars\n        \
    \    max_unique_chars_word = word\n        } else if unique_chars == max_unique_chars\
    \ {\n            if word < max_unique_chars_word {\n                max_unique_chars_word\
    \ = word\n            }\n        }\n    }\n\n    return max_unique_chars_word\n\
    }\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnsbw7lk6_test.go:24:29: undefined: unique_chars

    /tmp/tmpnsbw7lk6_test.go:27:29: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074376
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    if len(words) == 1 {\n        return words[0]\n\
    \    }\n    var letterMap map[string]int\n    maxCount := 0\n    maxWord := \"\
    \"\n    for _, v := range words {\n        letterMap = make(map[string]int)\n\
    \        for _, v1 := range v {\n            letterMap[string(v1)] = 1\n     \
    \   }\n        count := len(letterMap)\n        if count > maxCount {\n      \
    \      maxCount = count\n            maxWord = v\n        } else if count == maxCount\
    \ {\n            if v < maxWord {\n                maxWord = v\n            }\n\
    \        }\n    }\n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074376
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_n := 0\n    for _, w := range words {\n        if n := len(unique_chars(w));\
    \ n > max_n {\n            max_n = n\n            max_word = w\n        }\n  \
    \  }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpskd616g0_test.go:22:21: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074376
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    if len(words) == 1 {\n        return words[0]\n\
    \    }\n    max_word := words[0]\n    max_chars := len(find_chars(words[0]))\n\
    \    for _, word := range words[1:] {\n        n := len(find_chars(word))\n  \
    \      if n > max_chars {\n            max_chars = n\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpry1rr9rc_test.go:26:22: undefined: find_chars

    /tmp/tmpry1rr9rc_test.go:28:18: undefined: find_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074376
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var bestWord string\n\
    \    var bestCount int\n\n    for _, w := range words {\n        c := uniqueCharCount(w)\n\
    \        if bestCount < c {\n            bestCount = c\n            bestWord =\
    \ w\n        }\n    }\n\n    return bestWord\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq6cp331__test.go:23:14: undefined: uniqueCharCount

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074376
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_word string\n\
    \    max_size := 0\n    for _, word := range words {\n        if len(word) > max_size\
    \ {\n            max_size = len(word)\n            max_word = word\n        }\n\
    \    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpwpcos82r_test.go:52: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074377
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_count := 0\n \
    \   max_word := \"\"\n    for _, word := range words {\n        unique_count :=\
    \ 0\n        chars := map[rune]bool{}\n        for _, char := range word {\n \
    \           if _, exists := chars[char]; !exists {\n                unique_count++\n\
    \                chars[char] = true\n            }\n        }\n        if unique_count\
    \ > max_count {\n            max_count = unique_count\n            max_word =\
    \ word\n        } else if unique_count == max_count && word < max_word {\n   \
    \         max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074377
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // TODO: return first\
    \ word as an example\n    if len(words) == 0 {\n        return \"\"\n    }\n\n\
    \    m := make(map[string]int)\n    for _, word := range words {\n        m[word]\
    \ = count_unique_characters(word)\n    }\n\n    max := 0\n    max_word := \"\"\
    \n    for k, v := range m {\n        if v > max {\n            max = v\n     \
    \       max_word = k\n        }\n    }\n\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp532eobam_test.go:26:19: undefined: count_unique_characters

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_count := 0\n    for _, word := range words {\n        if count := unique_chars(word);\
    \ count > max_count {\n            max_count = count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7mbxvh3f_test.go:22:21: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_string := \"\"\
    \n    max_unique_chars := 0\n    for _, word := range words {\n        unique_chars\
    \ := 0\n        m := make(map[rune]bool)\n        for _, c := range word {\n \
    \           if _, exists := m[c]; !exists {\n                m[c] = true\n   \
    \             unique_chars++\n            }\n        }\n        if max_unique_chars\
    \ < unique_chars {\n            max_unique_chars = unique_chars\n            max_string\
    \ = word\n        } else if max_unique_chars == unique_chars {\n            if\
    \ max_string > word {\n                max_string = word\n            }\n    \
    \    }\n    }\n    return max_string\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074377
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var word string\n\
    \    var maxlen int\n    for _, w := range words {\n        if wlen := len(unique(w));\
    \ wlen > maxlen {\n            maxlen = wlen\n            word = w\n        }\n\
    \    }\n    return word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8jxup8h0_test.go:22:24: undefined: unique

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_len := 0\n    for _, word := range words {\n        if len(word) > max_len\
    \ {\n            max_word = word\n            max_len = len(word)\n        }\n\
    \    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpahziv9bo_test.go:52: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074198
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_unique_chars :=\
    \ 0\n    max_unique_word := \"\"\n    for _, word := range words {\n        if\
    \ len(word) == 0 {\n            continue\n        }\n        if len(word) > max_unique_chars\
    \ {\n            max_unique_chars = len(word)\n            max_unique_word = word\n\
    \        }\n    }\n    return max_unique_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp9daihpx9_test.go:55: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074377
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var s string\n   \
    \ var max_unique int\n    for _, word := range words {\n        unique := get_unique_count(word)\n\
    \        if unique > max_unique {\n            max_unique = unique\n         \
    \   s = word\n        }\n    }\n    return s\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7d0_8659_test.go:22:19: undefined: get_unique_count

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    max_len := 0\n    max_word := \"\"\n  \
    \  for _, word := range words {\n        char_map := make(map[string]int)\n  \
    \      for _, c := range word {\n            char_map[string(c)] += 1\n      \
    \  }\n        if len(char_map) > max_len {\n            max_len = len(char_map)\n\
    \            max_word = word\n        } else if len(char_map) == max_len {\n \
    \           if word < max_word {\n                max_word = word\n          \
    \  }\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074377
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) < 1\
    \ {\n        return \"\"\n    }\n    mx := words[0]\n    mxc := unique_char_count(mx)\n\
    \    for _, w := range words[1:] {\n        if wc := unique_char_count(w); wc\
    \ > mxc {\n            mx = w\n            mxc = wc\n        }\n    }\n    return\
    \ mx\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzrottbp0_test.go:23:12: undefined: unique_char_count

    /tmp/tmpzrottbp0_test.go:25:18: undefined: unique_char_count

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_value := 0\n    for _, word := range words {\n        if len(word) <\
    \ 2 {\n            if len(word) > max_value {\n                max_word = word\n\
    \                max_value = len(word)\n            }\n            continue\n\
    \        }\n        chars := make(map[string]bool)\n        for _, c := range\
    \ word {\n            chars[string(c)] = true\n        }\n        if len(chars)\
    \ > max_value {\n            max_word = word\n            max_value = len(chars)\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpy1_difwy_test.go:63: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpy1_difwy_test.go:63: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074377
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    word_counts := make(map[string]int)\n\
    \    for _, word := range words {\n        count := 0\n        for _, c := range\
    \ word {\n            count += 1\n        }\n        word_counts[word] = count\n\
    \    }\n    max_count := 0\n    var max_word string\n    for word, count := range\
    \ word_counts {\n        if count > max_count {\n            max_count = count\n\
    \            max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmscq58a__test.go:22:16: c declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var result string\n\
    \    var max_len int\n    for _, str := range words {\n        cur_len := len(unique(str))\n\
    \        if cur_len > max_len {\n            max_len = cur_len\n            result\
    \ = str\n        }\n    }\n    return result\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3untonp6_test.go:22:24: undefined: unique

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_word, cur_word\
    \ string\n    //max_word_chars := make(map[rune]int)\n    max_uniq_chars := 0\n\
    \    for _, cur_word = range words {\n        cur_word_chars := make(map[rune]int)\n\
    \        cur_uniq_chars := 0\n        for _, char := range cur_word {\n      \
    \      cur_word_chars[char]++\n            if cur_word_chars[char] == 1 {\n  \
    \              cur_uniq_chars++\n            }\n        }\n        if cur_uniq_chars\
    \ > max_uniq_chars {\n            max_uniq_chars = cur_uniq_chars\n          \
    \  max_word = cur_word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp76fbyriv_test.go:61: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmp76fbyriv_test.go:61: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074378
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_word string\n\
    \    var max_count int\n    for _, word := range words {\n        if len(word)\
    \ > max_count {\n            unique_chars := make(map[rune]bool)\n           \
    \ for _, ch := range word {\n                unique_chars[ch] = true\n       \
    \     }\n            max_count = len(unique_chars)\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp3oslspu__test.go:56: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmp3oslspu__test.go:56: expected\
    \ 'aaaaaaa', got 'cc'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074378
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    m, max_word := make(map[string]int),\
    \ \"\"\n    for _, w := range words {\n        m[w] = len(unique_char(w))\n  \
    \      if m[w] > m[max_word] {\n            max_word = w\n        }\n    }\n \
    \   return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpka66htgm_test.go:21:20: undefined: unique_char

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074377
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    _, word := 0, \"\"\
    \n    for _, w := range words {\n        curr := 0\n        char := make(map[rune]int)\n\
    \        for _, c := range w {\n            if _, ok := char[c]; !ok {\n     \
    \           curr++\n                char[c] = 1\n            }\n        }\n  \
    \      if curr > len(word) {\n            word = w\n        }\n    }\n    return\
    \ word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"}),\
    \ expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmphenk6cop_test.go:58: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmphenk6cop_test.go:58: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074378
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    var max string\n    for _, word := range\
    \ words {\n        if len(word) > len(max) {\n            max = word\n       \
    \ }\n    }\n\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpcbxgbe8k_test.go:55: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max int\n    var\
    \ max_word string\n    for _, word := range words {\n        if len(word) > max\
    \ {\n            max = len(word)\n            max_word = word\n        }\n   \
    \ }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpzs1pzedb_test.go:52: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074379
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    max := words[0]\n    maxcount := count(max)\n\
    \    for _, word := range words[1:] {\n        if count(word) > maxcount {\n \
    \           max = word\n            maxcount = count(word)\n        }\n    }\n\
    \    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8925hb2o_test.go:23:17: undefined: count

    /tmp/tmp8925hb2o_test.go:25:12: undefined: count

    /tmp/tmp8925hb2o_test.go:27:24: undefined: count

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074378
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    max := words[0]\n    for _, word := range\
    \ words {\n        if len(word) > len(max) {\n            max = word\n       \
    \ }\n    }\n\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp7ts25ljj_test.go:55: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074370
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_len := 0\n    unique_set := make(map[rune]\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn2pcu9ht_test.go:21:33: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074378
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // First, make sure\
    \ the list is sorted\n    for i := 0; i < len(words) - 1; i++ {\n        for j\
    \ := i + 1; j < len(words); j++ {\n            if words[i] > words[j] {\n    \
    \            temp := words[i]\n                words[i] = words[j]\n         \
    \       words[j] = temp\n            }\n        }\n    }\n\n    // Then, find\
    \ all the words with maximum number of unique characters\n    max_unique_count\
    \ := 0\n    for _, word := range words {\n        word_char_count := map[string]int{}\n\
    \        for _, c := range word {\n            word_char_count[string(c)] += 1\n\
    \        }\n        unique_count := 0\n        for _, count := range word_char_count\
    \ {\n            if count == 1 {\n                unique_count += 1\n        \
    \    }\n        }\n        if unique_count > max_unique_count {\n            max_unique_count\
    \ = unique_count\n        }\n    }\n\n    // Return the first word with maximum\
    \ number of unique characters\n    for _, word := range words {\n        word_char_count\
    \ := map[string]int{}\n        for _, c := range word {\n            word_char_count[string(c)]\
    \ += 1\n        }\n        unique_count := 0\n        for _, count := range word_char_count\
    \ {\n            if count == 1 {\n                unique_count += 1\n        \
    \    }\n        }\n        if unique_count == max_unique_count {\n           \
    \ return word\n        }\n    }\n\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmp53x6fnsx_test.go:90: expected 'footbott', got 'game'\n \
    \   --- FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmp53x6fnsx_test.go:90:\
    \ expected 'gonna', got 'rock'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074379
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    if len(words) == 1 {\n        return words[0]\n\
    \    }\n    maxLen := len(words[0])\n    maxUnique := \"\"\n    for _, word :=\
    \ range words {\n        if len(word) == maxLen {\n            maxUnique = min(maxUnique,\
    \ word)\n        } else if len(word) > maxLen {\n            maxLen = len(word)\n\
    \            maxUnique = word\n        }\n    }\n    return maxUnique\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcw6ofd5x_test.go:29:25: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074378
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    max := words[0]\n    maxlen := len(unique_chars(max))\n\
    \    for _, word := range words[1:] {\n        if len(unique_chars(word)) > maxlen\
    \ {\n            max = word\n            maxlen = len(unique_chars(word))\n  \
    \      }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbrav0z7s_test.go:24:19: undefined: unique_chars

    /tmp/tmpbrav0z7s_test.go:26:16: undefined: unique_chars

    /tmp/tmpbrav0z7s_test.go:28:26: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074378
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_word string\n\
    \    max_chars := 0\n    for _, word := range words {\n        chars := make(map[rune]int)\n\
    \        for _, char := range word {\n            chars[char] = 1\n        }\n\
    \        if len(chars) > max_chars {\n            max_chars = len(chars)\n   \
    \         max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp26wnzknu_test.go:56: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmp26wnzknu_test.go:56: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074379
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max = make(map[string]int)\n\
    \    var max_string string\n    var num int\n    for _, v := range words {\n \
    \       num = find_unique_char(v)\n        if _, ok := max[v]; !ok {\n       \
    \     max[v] = num\n        }\n    }\n    for k, v := range max {\n        if\
    \ num < v {\n            num = v\n            max_string = k\n        }\n    }\n\
    \    return max_string\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate :=\
    \ find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfo94rvr8_test.go:23:15: undefined: find_unique_char

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := len(words[0])\n\
    \    maxWord := words[0]\n    for _, word := range words {\n        if len(word)\
    \ > max {\n            max = len(word)\n            maxWord = word\n        }\n\
    \    }\n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpkeu6e79x_test.go:52: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max int\n    for\
    \ _, word := range words {\n        if len(word) > max {\n            max = len(word)\n\
    \        }\n    }\n    for _, word := range words {\n        if len(word) == max\
    \ {\n            return word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmph1mhtapp_test.go:55: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074379
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    max_word := words[0]\n    max_count := count_unique_characters(max_word)\n\
    \    for _, word := range words[1:] {\n        count := count_unique_characters(word)\n\
    \        if count > max_count {\n            max_word = word\n            max_count\
    \ = count\n        } else if count == max_count && word < max_word {\n       \
    \     max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpovt2d7gf_test.go:23:18: undefined: count_unique_characters

    /tmp/tmpovt2d7gf_test.go:25:18: undefined: count_unique_characters

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var uniques map[string]int\
    \ = make(map[string]int)\n    for _, word := range words {\n        for _, char\
    \ := range word {\n            uniques[string(char)] = 1\n        }\n        if\
    \ len(uniques) > max {\n            max = len(uniques)\n            max_unique\
    \ = word\n        }\n        uniques = make(map[string]int)\n    }\n    return\
    \ max_unique\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfnm33qzx_test.go:24:27: undefined: max

    /tmp/tmpfnm33qzx_test.go:25:13: undefined: max

    /tmp/tmpfnm33qzx_test.go:26:13: undefined: max_unique

    /tmp/tmpfnm33qzx_test.go:30:12: undefined: max_unique

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    // TODO - Add your\
    \ code here\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate\
    \ := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\",\
    \ \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__0\
    \ (0.00s)\n        tmpcojyw852_test.go:45: expected 'string', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__1 (0.00s)\n        tmpcojyw852_test.go:45: expected\
    \ 'enam', got ''\n    --- FAIL: TestFind_Max/test_num__2 (0.00s)\n        tmpcojyw852_test.go:45:\
    \ expected 'aaaaaaa', got ''\n    --- FAIL: TestFind_Max/test_num__3 (0.00s)\n\
    \        tmpcojyw852_test.go:45: expected 'abc', got ''\n    --- FAIL: TestFind_Max/test_num__4\
    \ (0.00s)\n        tmpcojyw852_test.go:45: expected 'footbott', got ''\n    ---\
    \ FAIL: TestFind_Max/test_num__5 (0.00s)\n        tmpcojyw852_test.go:45: expected\
    \ 'gonna', got ''\n    --- FAIL: TestFind_Max/test_num__6 (0.00s)\n        tmpcojyw852_test.go:45:\
    \ expected 'nation', got ''\n    --- FAIL: TestFind_Max/test_num__7 (0.00s)\n\
    \        tmpcojyw852_test.go:45: expected 'this', got ''\n    --- FAIL: TestFind_Max/test_num__8\
    \ (0.00s)\n        tmpcojyw852_test.go:45: expected 'b', got ''\n    --- FAIL:\
    \ TestFind_Max/test_num__9 (0.00s)\n        tmpcojyw852_test.go:45: expected 'play',\
    \ got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074363
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    var max_word string\n    max_uniq := 0\n\
    \    for _, word := range words {\n        uniq := 0\n        for _, char := range\
    \ word {\n            if unicode.IsDigit(char) {\n                uniq++\n   \
    \         }\n        }\n        if uniq > max_uniq {\n            max_uniq = uniq\n\
    \            max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc\
    \ TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnnhv673m_test.go:28:16: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_unique_count :=\
    \ 0\n    max_unique_word := \"\"\n    for _, word := range words {\n        unique_count\
    \ := 0\n        m := make(map[rune]int)\n        for _, ch := range word {\n \
    \           if _, ok := m[ch]; !ok {\n                unique_count++\n       \
    \         m[ch] = 1\n            }\n        }\n        if unique_count > max_unique_count\
    \ {\n            max_unique_count = unique_count\n            max_unique_word\
    \ = word\n        } else if unique_count == max_unique_count {\n            if\
    \ word < max_unique_word {\n                max_unique_word = word\n         \
    \   }\n        }\n    }\n    return max_unique_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max_word := \"\"\n\
    \    max_unique_chars := 0\n    for _, word := range words {\n        if len(word)\
    \ < max_unique_chars {\n            continue\n        }\n        unique_chars\
    \ := make(map[string]bool)\n        for _, char := range word {\n            unique_chars[string(char)]\
    \ = true\n        }\n        if len(unique_chars) > max_unique_chars {\n     \
    \       max_unique_chars = len(unique_chars)\n            max_word = word\n  \
    \      }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpeqlwelwj_test.go:59: expected 'enam', got 'name'\n    ---\
    \ FAIL: TestFind_Max/test_num__4 (0.00s)\n        tmpeqlwelwj_test.go:59: expected\
    \ 'footbott', got 'play'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074379
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    maxWord := words[0]\n    maxLetterCount\
    \ := len(mapLetters(maxWord))\n\n    for _, word := range words[1:] {\n      \
    \  count := len(mapLetters(word))\n        if count > maxLetterCount {\n     \
    \       maxWord = word\n            maxLetterCount = count\n        }\n    }\n\
    \n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T) {\n  candidate := find_max\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{\"name\", \"of\", \"string\"\
    }), expected: \"string\" },\n     { actual: candidate([]string{\"name\", \"enam\"\
    , \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\"\
    , \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_c1y9n4f_test.go:24:27: undefined: mapLetters

    /tmp/tmp_c1y9n4f_test.go:27:22: undefined: mapLetters

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    if len(words) == 1 {\n        return words[0]\n\
    \    }\n    max_word := words[0]\n    max_count := count_distinct_chars(words[0])\n\
    \    for _, word := range words[1:] {\n        if count := count_distinct_chars(word);\
    \ count > max_count {\n            max_count = count\n            max_word = word\n\
    \        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t *testing.T) {\n\
    \  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmwkipgfw_test.go:26:18: undefined: count_distinct_chars

    /tmp/tmpmwkipgfw_test.go:28:21: undefined: count_distinct_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n    if len(words) == 1 {\n        return words[0]\n\
    \    }\n    word_map := make(map[string]int)\n    for _, word := range words {\n\
    \        word_map[word] = get_unique_chars(word)\n    }\n    max_unique_chars\
    \ := 0\n    for _, v := range word_map {\n        if v > max_unique_chars {\n\
    \            max_unique_chars = v\n        }\n    }\n    for _, word := range\
    \ words {\n        if word_map[word] == max_unique_chars {\n            return\
    \ word\n        }\n    }\n    return \"\"\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8ro9c31j_test.go:27:26: undefined: get_unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    uniqueMap := make(map[string]int)\n\
    \    // Initialize map\n    for _, word := range words {\n        uniques := make(map[rune]bool)\n\
    \        for _, letter := range word {\n            uniques[letter] = true\n \
    \       }\n        uniqueMap[word] = len(uniques)\n    }\n    // Find max and\
    \ return the one with lexicographical order\n    max := 0\n    maxWord := \"\"\
    \n    for word, value := range uniqueMap {\n        if value > max {\n       \
    \     max = value\n            maxWord = word\n        } else if value == max\
    \ {\n            if word < maxWord {\n                maxWord = word\n       \
    \     }\n        }\n    }\n    return maxWord\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074379
- exit_code: 0
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    maxUnique := 0\n \
    \   maxUniqueWord := \"\"\n    for _, word := range words {\n        tmp := make(map[byte]int)\n\
    \        for i := 0; i < len(word); i++ {\n            tmp[word[i]] = 0\n    \
    \    }\n        if len(tmp) > maxUnique {\n            maxUnique = len(tmp)\n\
    \            maxUniqueWord = word\n        } else if len(tmp) == maxUnique {\n\
    \            if word < maxUniqueWord {\n                maxUniqueWord = word\n\
    \            }\n        }\n    }\n    return maxUniqueWord\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max_word string\n\
    \    for _, word := range words {\n        if len(word) > len(max_word) {\n  \
    \          max_word = word\n        }\n    }\n    return max_word\n}\n\nfunc TestFind_Max(t\
    \ *testing.T) {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpsru1tl4g_test.go:50: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    if len(words) == 0\
    \ {\n        return \"\"\n    }\n\n    // To find the maximum number of unique\
    \ characters, we first need to\n    // find the number of unique characters for\
    \ each word.\n    // Then we can choose the word with the maximum number of unique\
    \ characters.\n    //\n    // For each word in the list, we'll need a slice to\
    \ keep track of the\n    // characters we've seen so far.\n    unique_chars :=\
    \ make([][]bool, len(words))\n    for idx, _ := range unique_chars {\n       \
    \ unique_chars[idx] = make([]bool, 26)\n    }\n\n    // Now we can iterate through\
    \ the list of words and populate the slices\n    // we just created.\n    for\
    \ word_idx, word := range words {\n        for char_idx, char := range word {\n\
    \            // We can use the ASCII value of the character as an index in\n \
    \           // the slice, converting each character to lower case for\n      \
    \      // case-insensitive comparisons.\n            unique_chars[word_idx][char\
    \ - 'a'] = true\n        }\n    }\n\n    // Now we'll find the word with the maximum\
    \ number of unique characters.\n    // To do this, we'll count the number of unique\
    \ characters for each word\n    // and keep track of the word with the maximum\
    \ number of unique characters.\n    //\n    // We'll start by getting a slice\
    \ of the unique character counts.\n    unique_char_counts := make([]int, len(words))\n\
    \    for word_idx, char_list := range unique_chars {\n        for _, char := range\
    \ char_list {\n            if char {\n                unique_char_counts[word_idx]++\n\
    \            }\n        }\n    }\n\n    // Now that we have the counts, we can\
    \ find the maximum number of unique\n    // characters and the index of the word\
    \ that has that number of unique\n    // characters.\n    max_num_unique_chars\
    \ := 0\n    max_char_idx := 0\n    for word_idx, count := range unique_char_counts\
    \ {\n        if count > max_num_unique_chars {\n            max_num_unique_chars\n\
    func TestFind_Max(t *testing.T) {\n  candidate := find_max\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{\"name\", \"of\", \"string\"}), expected: \"\
    string\" },\n     { actual: candidate([]string{\"name\", \"enam\", \"game\"}),\
    \ expected: \"enam\" },\n     { actual: candidate([]string{\"aaaaaaa\", \"bb\"\
    , \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"abc\"\
    , \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi5rqdbtn_test.go:67:6: expected ''('', found TestFind_Max

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    max := \"\"\n    for\
    \ _, word := range words {\n        if len(word) > len(max) {\n            max\
    \ = word\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmpsuo3szd5_test.go:50: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074199
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max string\n \
    \   var max_count int\n    for _, v := range words {\n        length := len(find_unique(v))\n\
    \        if length > max_count {\n            max = v\n            max_count =\
    \ length\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxz5y_xxy_test.go:22:23: undefined: find_unique

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 2
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max string\n \
    \   var count int\n    for _, word := range words {\n        unique := unique_chars(word)\n\
    \        if len(unique) > count {\n            max = word\n            count =\
    \ len(unique)\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkkdpajud_test.go:22:19: undefined: unique_chars

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074379
- exit_code: 1
  program: "package find_max_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Write a function that accepts a list of strings.\n// The list contains different\
    \ words. Return the word with maximum number\n// of unique characters. If multiple\
    \ strings have maximum number of unique\n// characters, return the one which comes\
    \ first in lexicographical order.\n// >>> find_max([]string{\"name\", \"of\",\
    \ \"string\"})\n// \"string\"\n// >>> find_max([]string{\"name\", \"enam\", \"\
    game\"})\n// \"enam\"\n// >>> find_max([]string{\"aaaaaaa\", \"bb\", \"cc\"})\n\
    // \"aaaaaaa\"\nfunc find_max(words []string) string {\n    var max string\n \
    \   for _, word := range words {\n        if len(word) > len(max) {\n        \
    \    max = word\n        }\n    }\n    return max\n}\n\nfunc TestFind_Max(t *testing.T)\
    \ {\n  candidate := find_max\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{\"\
    name\", \"of\", \"string\"}), expected: \"string\" },\n     { actual: candidate([]string{\"\
    name\", \"enam\", \"game\"}), expected: \"enam\" },\n     { actual: candidate([]string{\"\
    aaaaaaa\", \"bb\", \"cc\"}), expected: \"aaaaaaa\" },\n     { actual: candidate([]string{\"\
    abc\", \"cba\"}), expected: \"abc\" },\n     { actual: candidate([]string{\"play\"\
    , \"this\", \"game\", \"of\", \"footbott\"}), expected: \"footbott\" },\n    \
    \ { actual: candidate([]string{\"we\", \"are\", \"gonna\", \"rock\"}), expected:\
    \ \"gonna\" },\n     { actual: candidate([]string{\"we\", \"are\", \"a\", \"mad\"\
    , \"nation\"}), expected: \"nation\" },\n     { actual: candidate([]string{\"\
    this\", \"is\", \"a\", \"prrk\"}), expected: \"this\" },\n     { actual: candidate([]string{\"\
    b\"}), expected: \"b\" },\n     { actual: candidate([]string{\"play\", \"play\"\
    , \"play\"}), expected: \"play\" },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestFind_Max (0.00s)\n    --- FAIL: TestFind_Max/test_num__1\
    \ (0.00s)\n        tmp3hn16p4h_test.go:50: expected 'enam', got 'name'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074369
