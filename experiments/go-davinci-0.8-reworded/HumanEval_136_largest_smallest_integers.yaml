name: HumanEval_136_largest_smallest_integers
language: go_test.go
prompt: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n   \
  \ \"fmt\"\n)\n\n// Create a function that returns a list (a, b), where 'a' is\n\
  // the largest of negative integers, and 'b' is the smallest\n// of positive integers\
  \ in a list.\n// If there is no negative or positive integers, return them as nil.\n\
  // Examples:\n// >>> largest_smallest_integers([]int{2, 4, 1, 3, 5, 7})\n// []interface{}{None,\
  \ 1}\n// >>> largest_smallest_integers(int{})\n// []interface{}{None, None}\n//\
  \ >>> largest_smallest_integers([]int{0})\n// []interface{}{None, None}\nfunc largest_smallest_integers(lst\
  \ []int) []interface{} {\n"
tests: "func TestLargest_Smallest_Integers(t *testing.T) {\n  candidate := largest_smallest_integers\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected:\
  \ []interface{}{None, 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}),\
  \ expected: []interface{}{None, 1} },\n     { actual: candidate([]int{1, 3, 2, 4,\
  \ 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4,\
  \ 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7,\
  \ 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}),\
  \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{0}), expected:\
  \ []interface{}{None, None} },\n     { actual: candidate([]int{-1, -3, -5, -6}),\
  \ expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-1, -3, -5,\
  \ -6, 0}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-6,\
  \ -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6,\
  \ -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc\
  \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
  \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
  \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\
  \t}\n\t\t})\n\t}\n}\n"
completions: ["    // declare variables\n    var largestNeg int\n    var largestNegSet\
    \ bool\n    var smallestPos int\n    var smallestPosSet bool\n    // iterate over\
    \ the list\n    for _, x := range lst {\n        // if a negative integer, check\
    \ if it is largest\n        if x < 0 {\n            if !largestNegSet {\n    \
    \            largestNeg = x\n                largestNegSet = true\n          \
    \  } else if x > largestNeg {\n                largestNeg = x\n            }\n\
    \        } else if x > 0 {\n            // if a positive integer, check if it\
    \ is smallest\n            if !smallestPosSet {\n                smallestPos =\
    \ x\n                smallestPosSet = true\n            } else if x < smallestPos\
    \ {\n                smallestPos = x\n            }\n        }\n    }\n    //\
    \ generate return list\n    var out []interface{}\n    if largestNegSet {\n  \
    \      out = append(out, largestNeg)\n    } else {\n        out = append(out,\
    \ nil)\n    }\n    if smallestPosSet {\n        out = append(out, smallestPos)\n\
    \    } else {\n        out = append(out, nil)\n    }\n    return out\n}\n", " \
    \   var largestNegative int\n    var smallestPositive int\n    var smallestPositiveFound\
    \ bool\n    var largestNegativeFound bool\n    for _, n := range lst {\n     \
    \   if n >= 0 {\n            if !smallestPositiveFound {\n                smallestPositive\
    \ = n\n                smallestPositiveFound = true\n            } else if n <\
    \ smallestPositive {\n                smallestPositive = n\n            }\n  \
    \      } else {\n            if !largestNegativeFound {\n                largestNegative\
    \ = n\n                largestNegativeFound = true\n            } else if n >\
    \ largestNegative {\n                largestNegative = n\n            }\n    \
    \    }\n    }\n    if !largestNegativeFound {\n        largestNegative = 0\n \
    \   }\n    if !smallestPositiveFound {\n        smallestPositive = 0\n    }\n\
    \    return []interface{}{largestNegative, smallestPositive}\n}\n", "    return\
    \ []interface{}{0, 0}\n}\n", "    var largestsmallest []interface{}\n    if len(lst)\
    \ == 0 {\n        largestsmallest = append(largestsmallest, nil, nil)\n      \
    \  return largestsmallest\n    }\n    largest := lst[0]\n    smallest := lst[0]\n\
    \    for _, v := range lst {\n        if v > largest {\n            largest =\
    \ v\n        }\n        if v < smallest {\n            smallest = v\n        }\n\
    \    }\n    largestsmallest = append(largestsmallest, largest, smallest)\n   \
    \ return largestsmallest\n}\n", "    // Find the largest negative and smallest\
    \ positive integer in the list.\n    var maxNegativeInt int\n    var minPositiveInt\
    \ int\n    for _, v := range lst {\n        if v < 0 {\n            if v > maxNegativeInt\
    \ {\n                maxNegativeInt = v\n            }\n        } else {\n   \
    \         if v < minPositiveInt {\n                minPositiveInt = v\n      \
    \      }\n        }\n    }\n    return []interface{}{maxNegativeInt, minPositiveInt}\n\
    }\n", "    var negatives, positives []int\n    for _, x := range lst {\n     \
    \   if x < 0 {\n            negatives = append(negatives, x)\n        } else if\
    \ x > 0 {\n            positives = append(positives, x)\n        }\n    }\n  \
    \  return []interface{}{max_of_slice(negatives), min_of_slice(positives)}\n}\n",
  "    var a, b int\n    var c, d interface{}\n    c = nil\n    d = nil\n    for _,\
    \ n := range lst {\n        if n < 0 {\n            if a < n {\n             \
    \   a = n\n                c = a\n            }\n        } else {\n          \
    \  if b == 0 {\n                b = n\n                d = b\n            } else\
    \ if b > n {\n                b = n\n                d = b\n            }\n  \
    \      }\n    }\n    return []interface{}{c, d}\n}\n", "    if len(lst) == 0 {\n\
    \        return []interface{}{nil, nil}\n    }\n    largestNeg, smallestPos :=\
    \ 0, 0\n    for _, v := range lst {\n        if v > 0 {\n            if smallestPos\
    \ == 0 {\n                smallestPos = v\n            } else if v < smallestPos\
    \ {\n                smallestPos = v\n            }\n        } else if v < 0 {\n\
    \            if largestNeg == 0 {\n                largestNeg = v\n          \
    \  } else if v > largestNeg {\n                largestNeg = v\n            }\n\
    \        }\n    }\n    return []interface{}{largestNeg, smallestPos}\n}\n", " \
    \   if len(lst) == 0 {\n        return []interface{}{nil, nil}\n    }\n    largest_negative\
    \ := nil\n    smallest_positive := nil\n    for _, n := range lst {\n        if\
    \ n < 0 {\n            if largest_negative == nil || n > largest_negative {\n\
    \                largest_negative = n\n            }\n        } else if n > 0\
    \ {\n            if smallest_positive == nil || n < smallest_positive {\n    \
    \            smallest_positive = n\n            }\n        }\n    }\n    return\
    \ []interface{}{largest_negative, smallest_positive}\n}\n", "    // Your code\
    \ here\n    var res []interface{}\n    return res\n}\n", "    neg, pos := -1,\
    \ -1\n    for _, e := range lst {\n        if e > 0 {\n            if pos == -1\
    \ || e < pos {\n                pos = e\n            }\n        } else if e <\
    \ 0 {\n            if neg == -1 || e > neg {\n                neg = e\n      \
    \      }\n        }\n    }\n    return []interface{}{neg, pos}\n}\n", "    var\
    \ res []interface{}\n    var a, b int\n\n    for _, v := range lst {\n       \
    \ if v < 0 {\n            if v > a {\n                a = v\n            }\n \
    \       } else {\n            if v < b {\n                b = v\n            }\n\
    \        }\n    }\n\n    if a == 0 {\n        res = append(res, nil)\n    } else\
    \ {\n        res = append(res, a)\n    }\n\n    if b == 0 {\n        res = append(res,\
    \ nil)\n    } else {\n        res = append(res, b)\n    }\n\n    return res\n\
    }\n", "    return nil\n}\n", "    len_lst := len(lst)\n    if len_lst == 0 {\n\
    \        return []interface{}{nil, nil}\n    }\n    smallest_pos := lst[0]\n \
    \   largest_neg := lst[0]\n    for i := 0; i < len_lst; i++ {\n        if lst[i]\
    \ < 0 {\n            if lst[i] > largest_neg {\n                largest_neg =\
    \ lst[i]\n            }\n        } else {\n            if lst[i] < smallest_pos\
    \ {\n                smallest_pos = lst[i]\n            }\n        }\n    }\n\
    \    return []interface{}{largest_neg, smallest_pos}\n}\n", "    return []interface{}{nil,\
    \ nil}\n}\n", "    var (\n        largestNegative, smallestPositive int\n    \
    \    isSet bool\n    )\n    for _, i := range lst {\n        if i < 0 {\n    \
    \        if !isSet {\n                largestNegative = i\n                isSet\
    \ = true\n            } else if i > largestNegative {\n                largestNegative\
    \ = i\n            }\n        } else if i > 0 {\n            if !isSet {\n   \
    \             smallestPositive = i\n                isSet = true\n           \
    \ } else if i < smallestPositive {\n                smallestPositive = i\n   \
    \         }\n        }\n    }\n    return []interface{}{largestNegative, smallestPositive}\n\
    }\n", "    var a, b int = 0, 0\n    var a_exists, b_exists bool = false, false\n\
    \    for _, num := range lst {\n        if num > 0 {\n            if b_exists\
    \ {\n                if num < b {\n                    b = num\n             \
    \   }\n            } else {\n                b = num\n                b_exists\
    \ = true\n            }\n        } else if num < 0 {\n            if a_exists\
    \ {\n                if num > a {\n                    a = num\n             \
    \   }\n            } else {\n                a = num\n                a_exists\
    \ = true\n            }\n        }\n    }\n    if !a_exists {\n        a = 0\n\
    \    }\n    if !b_exists {\n        b = 0\n    }\n    return []interface{}{a,\
    \ b}\n}\n", "    var max, min int\n    var is_max, is_min bool\n\n    for _, e\
    \ := range lst {\n        if e < 0 {\n            if !is_max || e > max {\n  \
    \              max = e\n                is_max = true\n            }\n       \
    \ } else if e > 0 {\n            if !is_min || e < min {\n                min\
    \ = e\n                is_min = true\n            }\n        }\n    }\n\n    return\
    \ []interface{}{max, min}\n}\n", "    var largestNegative, smallestPositive int\n\
    \    var largestNegativeFound, smallestPositiveFound bool\n\n    for _, i := range\
    \ lst {\n        if i < 0 {\n            if !largestNegativeFound {\n        \
    \        largestNegative = i\n                largestNegativeFound = true\n  \
    \          } else if i > largestNegative {\n                largestNegative =\
    \ i\n            }\n        } else if i > 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = i\n                smallestPositiveFound\
    \ = true\n            } else if i < smallestPositive {\n                smallestPositive\
    \ = i\n            }\n        }\n    }\n\n    return []interface{}{largestNegative,\
    \ smallestPositive}\n}\n", "    if lst == nil {\n        return []interface{}{nil,\
    \ nil}\n    }\n\n    var a, b interface{}\n    var smallest, largest int\n\n \
    \   // Finds the largest negative int\n    largest = -101\n    for _, val := range\
    \ lst {\n        if val < 0 && val > largest {\n            largest = val\n  \
    \      }\n    }\n    a = largest\n\n    // Finds the smallest positive int\n \
    \   smallest = 101\n    for _, val := range lst {\n        if val > 0 && val <\
    \ smallest {\n            smallest = val\n        }\n    }\n    b = smallest\n\
    \n    if largest == -101 && smallest == 101 {\n        return []interface{}{nil,\
    \ nil}\n    } else if largest == -101 {\n        return []interface{}{nil, smallest}\n\
    \    } else if smallest == 101 {\n        return []interface{}{largest, nil}\n\
    \    }\n\n    return []interface{}{largest, smallest}\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
