name: HumanEval_136_largest_smallest_integers
language: go_test.go
prompt: "package largest_smallest_integers_test\n\nimport (\n    \"testing\"\n   \
  \ \"fmt\"\n)\n\n// Create a function that returns a list (a, b), where 'a' is\n\
  // the largest of negative integers, and 'b' is the smallest\n// of positive integers\
  \ in a list.\n// If there is no negative or positive integers, return them as nil.\n\
  // Examples:\n// >>> largest_smallest_integers([]int{2, 4, 1, 3, 5, 7})\n// []interface{}{None,\
  \ 1}\n// >>> largest_smallest_integers(int{})\n// []interface{}{None, None}\n//\
  \ >>> largest_smallest_integers([]int{0})\n// []interface{}{None, None}\nfunc largest_smallest_integers(lst\
  \ []int) []interface{} {\n"
tests: "func TestLargest_Smallest_Integers(t *testing.T) {\n  candidate := largest_smallest_integers\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7}), expected:\
  \ []interface{}{None, 1} },\n     { actual: candidate([]int{2, 4, 1, 3, 5, 7, 0}),\
  \ expected: []interface{}{None, 1} },\n     { actual: candidate([]int{1, 3, 2, 4,\
  \ 5, 6, -2}), expected: []interface{}{-2, 1} },\n     { actual: candidate([]int{4,\
  \ 5, 3, 6, 2, 7, -7}), expected: []interface{}{-7, 2} },\n     { actual: candidate([]int{7,\
  \ 3, 8, 4, 9, 2, 5, -9}), expected: []interface{}{-9, 2} },\n     { actual: candidate([]int{}),\
  \ expected: []interface{}{None, None} },\n     { actual: candidate([]int{0}), expected:\
  \ []interface{}{None, None} },\n     { actual: candidate([]int{-1, -3, -5, -6}),\
  \ expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-1, -3, -5,\
  \ -6, 0}), expected: []interface{}{-1, None} },\n     { actual: candidate([]int{-6,\
  \ -4, -4, -3, 1}), expected: []interface{}{-3, 1} },\n     { actual: candidate([]int{-6,\
  \ -4, -4, -3, -100, 1}), expected: []interface{}{-3, 1} },\n   }\n\n\tfor i, tc\
  \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
  \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
  \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\
  \t}\n\t\t})\n\t}\n}\n"
completions: ["    // declare variables\n    var largestNeg int\n    var largestNegSet\
    \ bool\n    var smallestPos int\n    var smallestPosSet bool\n    // iterate over\
    \ the list\n    for _, x := range lst {\n        // if a negative integer, check\
    \ if it is largest\n        if x < 0 {\n            if !largestNegSet {\n    \
    \            largestNeg = x\n                largestNegSet = true\n          \
    \  } else if x > largestNeg {\n                largestNeg = x\n            }\n\
    \        } else if x > 0 {\n            // if a positive integer, check if it\
    \ is smallest\n            if !smallestPosSet {\n                smallestPos =\
    \ x\n                smallestPosSet = true\n            } else if x < smallestPos\
    \ {\n                smallestPos = x\n            }\n        }\n    }\n    //\
    \ generate return list\n    var out []interface{}\n    if largestNegSet {\n  \
    \      out = append(out, largestNeg)\n    } else {\n        out = append(out,\
    \ nil)\n    }\n    if smallestPosSet {\n        out = append(out, smallestPos)\n\
    \    } else {\n        out = append(out, nil)\n    }\n    return out\n}\n", " \
    \   var largestNegative int\n    var smallestPositive int\n    var smallestPositiveFound\
    \ bool\n    var largestNegativeFound bool\n    for _, n := range lst {\n     \
    \   if n >= 0 {\n            if !smallestPositiveFound {\n                smallestPositive\
    \ = n\n                smallestPositiveFound = true\n            } else if n <\
    \ smallestPositive {\n                smallestPositive = n\n            }\n  \
    \      } else {\n            if !largestNegativeFound {\n                largestNegative\
    \ = n\n                largestNegativeFound = true\n            } else if n >\
    \ largestNegative {\n                largestNegative = n\n            }\n    \
    \    }\n    }\n    if !largestNegativeFound {\n        largestNegative = 0\n \
    \   }\n    if !smallestPositiveFound {\n        smallestPositive = 0\n    }\n\
    \    return []interface{}{largestNegative, smallestPositive}\n}\n", "    return\
    \ []interface{}{0, 0}\n}\n", "    var largestsmallest []interface{}\n    if len(lst)\
    \ == 0 {\n        largestsmallest = append(largestsmallest, nil, nil)\n      \
    \  return largestsmallest\n    }\n    largest := lst[0]\n    smallest := lst[0]\n\
    \    for _, v := range lst {\n        if v > largest {\n            largest =\
    \ v\n        }\n        if v < smallest {\n            smallest = v\n        }\n\
    \    }\n    largestsmallest = append(largestsmallest, largest, smallest)\n   \
    \ return largestsmallest\n}\n", "    // Find the largest negative and smallest\
    \ positive integer in the list.\n    var maxNegativeInt int\n    var minPositiveInt\
    \ int\n    for _, v := range lst {\n        if v < 0 {\n            if v > maxNegativeInt\
    \ {\n                maxNegativeInt = v\n            }\n        } else {\n   \
    \         if v < minPositiveInt {\n                minPositiveInt = v\n      \
    \      }\n        }\n    }\n    return []interface{}{maxNegativeInt, minPositiveInt}\n\
    }\n", "    var negatives, positives []int\n    for _, x := range lst {\n     \
    \   if x < 0 {\n            negatives = append(negatives, x)\n        } else if\
    \ x > 0 {\n            positives = append(positives, x)\n        }\n    }\n  \
    \  return []interface{}{max_of_slice(negatives), min_of_slice(positives)}\n}\n",
  "    var a, b int\n    var c, d interface{}\n    c = nil\n    d = nil\n    for _,\
    \ n := range lst {\n        if n < 0 {\n            if a < n {\n             \
    \   a = n\n                c = a\n            }\n        } else {\n          \
    \  if b == 0 {\n                b = n\n                d = b\n            } else\
    \ if b > n {\n                b = n\n                d = b\n            }\n  \
    \      }\n    }\n    return []interface{}{c, d}\n}\n", "    if len(lst) == 0 {\n\
    \        return []interface{}{nil, nil}\n    }\n    largestNeg, smallestPos :=\
    \ 0, 0\n    for _, v := range lst {\n        if v > 0 {\n            if smallestPos\
    \ == 0 {\n                smallestPos = v\n            } else if v < smallestPos\
    \ {\n                smallestPos = v\n            }\n        } else if v < 0 {\n\
    \            if largestNeg == 0 {\n                largestNeg = v\n          \
    \  } else if v > largestNeg {\n                largestNeg = v\n            }\n\
    \        }\n    }\n    return []interface{}{largestNeg, smallestPos}\n}\n", " \
    \   if len(lst) == 0 {\n        return []interface{}{nil, nil}\n    }\n    largest_negative\
    \ := nil\n    smallest_positive := nil\n    for _, n := range lst {\n        if\
    \ n < 0 {\n            if largest_negative == nil || n > largest_negative {\n\
    \                largest_negative = n\n            }\n        } else if n > 0\
    \ {\n            if smallest_positive == nil || n < smallest_positive {\n    \
    \            smallest_positive = n\n            }\n        }\n    }\n    return\
    \ []interface{}{largest_negative, smallest_positive}\n}\n", "    // Your code\
    \ here\n    var res []interface{}\n    return res\n}\n", "    neg, pos := -1,\
    \ -1\n    for _, e := range lst {\n        if e > 0 {\n            if pos == -1\
    \ || e < pos {\n                pos = e\n            }\n        } else if e <\
    \ 0 {\n            if neg == -1 || e > neg {\n                neg = e\n      \
    \      }\n        }\n    }\n    return []interface{}{neg, pos}\n}\n", "    var\
    \ res []interface{}\n    var a, b int\n\n    for _, v := range lst {\n       \
    \ if v < 0 {\n            if v > a {\n                a = v\n            }\n \
    \       } else {\n            if v < b {\n                b = v\n            }\n\
    \        }\n    }\n\n    if a == 0 {\n        res = append(res, nil)\n    } else\
    \ {\n        res = append(res, a)\n    }\n\n    if b == 0 {\n        res = append(res,\
    \ nil)\n    } else {\n        res = append(res, b)\n    }\n\n    return res\n\
    }\n", "    return nil\n}\n", "    len_lst := len(lst)\n    if len_lst == 0 {\n\
    \        return []interface{}{nil, nil}\n    }\n    smallest_pos := lst[0]\n \
    \   largest_neg := lst[0]\n    for i := 0; i < len_lst; i++ {\n        if lst[i]\
    \ < 0 {\n            if lst[i] > largest_neg {\n                largest_neg =\
    \ lst[i]\n            }\n        } else {\n            if lst[i] < smallest_pos\
    \ {\n                smallest_pos = lst[i]\n            }\n        }\n    }\n\
    \    return []interface{}{largest_neg, smallest_pos}\n}\n", "    return []interface{}{nil,\
    \ nil}\n}\n", "    var (\n        largestNegative, smallestPositive int\n    \
    \    isSet bool\n    )\n    for _, i := range lst {\n        if i < 0 {\n    \
    \        if !isSet {\n                largestNegative = i\n                isSet\
    \ = true\n            } else if i > largestNegative {\n                largestNegative\
    \ = i\n            }\n        } else if i > 0 {\n            if !isSet {\n   \
    \             smallestPositive = i\n                isSet = true\n           \
    \ } else if i < smallestPositive {\n                smallestPositive = i\n   \
    \         }\n        }\n    }\n    return []interface{}{largestNegative, smallestPositive}\n\
    }\n", "    var a, b int = 0, 0\n    var a_exists, b_exists bool = false, false\n\
    \    for _, num := range lst {\n        if num > 0 {\n            if b_exists\
    \ {\n                if num < b {\n                    b = num\n             \
    \   }\n            } else {\n                b = num\n                b_exists\
    \ = true\n            }\n        } else if num < 0 {\n            if a_exists\
    \ {\n                if num > a {\n                    a = num\n             \
    \   }\n            } else {\n                a = num\n                a_exists\
    \ = true\n            }\n        }\n    }\n    if !a_exists {\n        a = 0\n\
    \    }\n    if !b_exists {\n        b = 0\n    }\n    return []interface{}{a,\
    \ b}\n}\n", "    var max, min int\n    var is_max, is_min bool\n\n    for _, e\
    \ := range lst {\n        if e < 0 {\n            if !is_max || e > max {\n  \
    \              max = e\n                is_max = true\n            }\n       \
    \ } else if e > 0 {\n            if !is_min || e < min {\n                min\
    \ = e\n                is_min = true\n            }\n        }\n    }\n\n    return\
    \ []interface{}{max, min}\n}\n", "    var largestNegative, smallestPositive int\n\
    \    var largestNegativeFound, smallestPositiveFound bool\n\n    for _, i := range\
    \ lst {\n        if i < 0 {\n            if !largestNegativeFound {\n        \
    \        largestNegative = i\n                largestNegativeFound = true\n  \
    \          } else if i > largestNegative {\n                largestNegative =\
    \ i\n            }\n        } else if i > 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = i\n                smallestPositiveFound\
    \ = true\n            } else if i < smallestPositive {\n                smallestPositive\
    \ = i\n            }\n        }\n    }\n\n    return []interface{}{largestNegative,\
    \ smallestPositive}\n}\n", "    if lst == nil {\n        return []interface{}{nil,\
    \ nil}\n    }\n\n    var a, b interface{}\n    var smallest, largest int\n\n \
    \   // Finds the largest negative int\n    largest = -101\n    for _, val := range\
    \ lst {\n        if val < 0 && val > largest {\n            largest = val\n  \
    \      }\n    }\n    a = largest\n\n    // Finds the smallest positive int\n \
    \   smallest = 101\n    for _, val := range lst {\n        if val > 0 && val <\
    \ smallest {\n            smallest = val\n        }\n    }\n    b = smallest\n\
    \n    if largest == -101 && smallest == 101 {\n        return []interface{}{nil,\
    \ nil}\n    } else if largest == -101 {\n        return []interface{}{nil, smallest}\n\
    \    } else if smallest == 101 {\n        return []interface{}{largest, nil}\n\
    \    }\n\n    return []interface{}{largest, smallest}\n}\n", "    var largest,\
    \ smallest int\n    count_negatives, count_positives := 0, 0\n    for _, num :=\
    \ range lst {\n        if num < 0 {\n            count_negatives++\n         \
    \   if largest < num {\n                largest = num\n            }\n       \
    \ } else if num > 0 {\n            count_positives++\n            if smallest\
    \ == 0 || smallest > num {\n                smallest = num\n            }\n  \
    \      }\n    }\n    if count_negatives == 0 {\n        largest = 0\n    }\n \
    \   if count_positives == 0 {\n        smallest = 0\n    }\n    return []interface{}{largest,\
    \ smallest}\n}\n", "    var largest_negative int\n    var smallest_positive int\n\
    \    has_negative := false\n    has_positive := false\n    for _, n := range lst\
    \ {\n        if n < 0 {\n            if !has_negative || n > largest_negative\
    \ {\n                largest_negative = n\n            }\n            has_negative\
    \ = true\n        } else if n > 0 {\n            if !has_positive || n < smallest_positive\
    \ {\n                smallest_positive = n\n            }\n            has_positive\
    \ = true\n        }\n    }\n    if !has_negative {\n        largest_negative =\
    \ nil\n    }\n    if !has_positive {\n        smallest_positive = nil\n    }\n\
    \    return []interface{}{largest_negative, smallest_positive}\n}\n", "    return\
    \ []interface{}{}\n}\n", "    var largestNegative, smallestPositive int = 0, 0\n\
    \    var largestNegativeFound, smallestPositiveFound bool = false, false\n   \
    \ for _, i := range lst {\n        if i < 0 {\n            if largestNegativeFound\
    \ == false {\n                largestNegative = i\n                largestNegativeFound\
    \ = true\n            } else if i > largestNegative {\n                largestNegative\
    \ = i\n            }\n        } else if i > 0 {\n            if smallestPositiveFound\
    \ == false {\n                smallestPositive = i\n                smallestPositiveFound\
    \ = true\n            } else if i < smallestPositive {\n                smallestPositive\
    \ = i\n            }\n        }\n    }\n    var l, s interface{}\n    if largestNegativeFound\
    \ {\n        l = largestNegative\n    } else {\n        l = nil\n    }\n    if\
    \ smallestPositiveFound {\n        s = smallestPositive\n    } else {\n      \
    \  s = nil\n    }\n    return []interface{}{l, s}\n}\n", "    if len(lst) == 0\
    \ {\n        return []interface{}{nil, nil}\n    }\n    pos := nil\n    neg :=\
    \ nil\n    for _, i := range lst {\n        if i > 0 {\n            if pos ==\
    \ nil || i < pos {\n                pos = i\n            }\n        } else if\
    \ i < 0 {\n            if neg == nil || i > neg {\n                neg = i\n \
    \           }\n        }\n    }\n    return []interface{}{neg, pos}\n}\n", " \
    \   var largestNegative, smallestPositive int\n    var largestNegativeSet, smallestPositiveSet\
    \ bool\n    var result []interface{}\n\n    for _, i := range lst {\n        if\
    \ i < 0 {\n            if largestNegativeSet == false {\n                largestNegative\
    \ = i\n                largestNegativeSet = true\n            } else if i > largestNegative\
    \ {\n                largestNegative = i\n            }\n        } else if i >\
    \ 0 {\n            if smallestPositiveSet == false {\n                smallestPositive\
    \ = i\n                smallestPositiveSet = true\n            } else if i < smallestPositive\
    \ {\n                smallestPositive = i\n            }\n        }\n    }\n\n\
    \    if largestNegativeSet == false {\n        result = append(result, nil)\n\
    \    } else {\n        result = append(result, largestNegative)\n    }\n\n   \
    \ if smallestPositiveSet == false {\n        result = append(result, nil)\n  \
    \  } else {\n        result = append(result, smallestPositive)\n    }\n\n    return\
    \ result\n}\n", "    var n_largest, n_smallest int\n    var p_largest, p_smallest\
    \ int\n    var n_init, p_init bool\n    var result []interface{}\n\n    for _,\
    \ x := range lst {\n        if x < 0 {\n            if !n_init {\n           \
    \     n_largest = x\n                n_smallest = x\n                n_init =\
    \ true\n            } else {\n                if x > n_largest {\n           \
    \         n_largest = x\n                } else if x < n_smallest {\n        \
    \            n_smallest = x\n                }\n            }\n        } else\
    \ if x > 0 {\n            if !p_init {\n                p_largest = x\n      \
    \          p_smallest = x\n                p_init = true\n            } else {\n\
    \                if x > p_largest {\n                    p_largest = x\n     \
    \           } else if x < p_smallest {\n                    p_smallest = x\n \
    \               }\n            }\n        }\n    }\n\n    if n_init {\n      \
    \  result = append(result, n_largest)\n    } else {\n        result = append(result,\
    \ nil)\n    }\n\n    if p_init {\n        result = append(result, p_smallest)\n\
    \    } else {\n        result = append(result, nil)\n    }\n\n    return result\n\
    }\n", "    var largestNeg int\n    var smallestPos int\n    var largestNegFound\
    \ bool\n    var smallestPosFound bool\n    largestNegFound = false\n    smallestPosFound\
    \ = false\n    for _, v := range lst {\n        if v < 0 {\n            if !largestNegFound\
    \ {\n                largestNeg = v\n                largestNegFound = true\n\
    \            } else if v > largestNeg {\n                largestNeg = v\n    \
    \        }\n        } else if v > 0 {\n            if !smallestPosFound {\n  \
    \              smallestPos = v\n                smallestPosFound = true\n    \
    \        } else if v < smallestPos {\n                smallestPos = v\n      \
    \      }\n        }\n    }\n    if !largestNegFound {\n        largestNeg = 0\n\
    \    }\n    if !smallestPosFound {\n        smallestPos = 0\n    }\n    return\
    \ []interface{}{largestNeg, smallestPos}\n}\n", "    var min, max *int\n    for\
    \ _, i := range lst {\n        if i >= 0 {\n            if min == nil || i < *min\
    \ {\n                min = &i\n            }\n        } else {\n            if\
    \ max == nil || i > *max {\n                max = &i\n            }\n        }\n\
    \    }\n    return []interface{}{max, min}\n}\n", "\treturn []interface{}{1, 1}\n\
    }\n", "    return []interface{}{\n        nil,\n        nil,\n    }\n}\n", " \
    \   var rt []interface{}\n    var largestNg int\n    var smallestPt int\n    for\
    \ _, e := range lst {\n        if e < 0 {\n            if largestNg == 0 {\n \
    \               largestNg = e\n            } else if e > largestNg {\n       \
    \         largestNg = e\n            }\n        } else if e > 0 {\n          \
    \  if smallestPt == 0 {\n                smallestPt = e\n            } else if\
    \ e < smallestPt {\n                smallestPt = e\n            }\n        }\n\
    \    }\n    if largestNg == 0 {\n        rt = append(rt, nil)\n    } else {\n\
    \        rt = append(rt, largestNg)\n    }\n    if smallestPt == 0 {\n       \
    \ rt = append(rt, nil)\n    } else {\n        rt = append(rt, smallestPt)\n  \
    \  }\n    return rt\n}\n", "    // first, we will take care of the trivial cases\n\
    \    if lst == nil || len(lst) == 0 {\n        return []interface{}{nil, nil}\n\
    \    }\n\n    // now, we need to find the largest and smallest integers\n    largest_neg\
    \ := nil\n    smallest_pos := nil\n    for _, v := range lst {\n        // find\
    \ the largest negative integer\n        if v < 0 {\n            if largest_neg\
    \ == nil {\n                largest_neg = v\n            } else if v > largest_neg\
    \ {\n                largest_neg = v\n            }\n        }\n\n        // find\
    \ the smallest positive integer\n        if v > 0 {\n            if smallest_pos\
    \ == nil {\n                smallest_pos = v\n            } else if v < smallest_pos\
    \ {\n                smallest_pos = v\n            }\n        }\n    }\n\n   \
    \ return []interface{}{largest_neg, smallest_pos}\n}\n", "    var largestNegative\
    \ int = 0\n    var smallestPositive int = 0\n    var largestNegativeExists bool\
    \ = false\n    var smallestPositiveExists bool = false\n    for _, v := range\
    \ lst {\n        if v < 0 {\n            if !largestNegativeExists {\n       \
    \         largestNegative = v\n                largestNegativeExists = true\n\
    \            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else if v > 0 {\n            if !smallestPositiveExists\
    \ {\n                smallestPositive = v\n                smallestPositiveExists\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        }\n    }\n    var largest interface{}\n    var smallest\
    \ interface{}\n    if largestNegativeExists {\n        largest = largestNegative\n\
    \    } else {\n        largest = nil\n    }\n    if smallestPositiveExists {\n\
    \        smallest = smallestPositive\n    } else {\n        smallest = nil\n \
    \   }\n    return []interface{}{largest, smallest}\n}\n", "    var neg, pos []int\n\
    \    for _, v := range lst {\n        if v < 0 {\n            neg = append(neg,\
    \ v)\n        } else if v > 0 {\n            pos = append(pos, v)\n        }\n\
    \    }\n    if len(neg) == 0 {\n        neg = append(neg, 0)\n    }\n    if len(pos)\
    \ == 0 {\n        pos = append(pos, 0)\n    }\n    return []interface{}{largest(neg),\
    \ smallest(pos)}\n}\n", "    fmt.Println(lst)\n    a := 0\n    b := 0\n    max\
    \ := false\n    min := false\n    var temp []interface{}\n    for _, n := range\
    \ lst {\n        if n > 0 {\n            min = true\n            if b == 0 {\n\
    \                b = n\n            } else if n < b {\n                b = n\n\
    \            }\n        } else if n < 0 {\n            max = true\n          \
    \  if a == 0 {\n                a = n\n            } else if n > a {\n       \
    \         a = n\n            }\n        }\n    }\n    if !max {\n        a = 0\n\
    \    }\n    if !min {\n        b = 0\n    }\n    temp = append(temp, a, b)\n \
    \   return temp\n}\n", "    var negatives []int\n    var positives []int\n   \
    \ var answer []interface{}\n    for _, num := range lst {\n        if num < 0\
    \ {\n            negatives = append(negatives, num)\n        } else if num > 0\
    \ {\n            positives = append(positives, num)\n        }\n    }\n    if\
    \ len(negatives) == 0 {\n        answer = append(answer, nil)\n    } else {\n\
    \        answer = append(answer, negativeMax(negatives))\n    }\n    if len(positives)\
    \ == 0 {\n        answer = append(answer, nil)\n    } else {\n        answer =\
    \ append(answer, positiveMin(positives))\n    }\n    return answer\n}\n", "  \
    \  var min_positive int = -1\n    var max_negative int = 1\n    // The purpose\
    \ of result is to reduce the number of\n    // comparisons.\n    var result =\
    \ []interface{}{nil, nil}\n    for _, val := range lst {\n        if val < 0 {\n\
    \            if val > max_negative {\n                max_negative = val\n   \
    \             result[0] = val\n            }\n        } else if val > 0 {\n  \
    \          if min_positive == -1 || val < min_positive {\n                min_positive\
    \ = val\n                result[1] = val\n            }\n        }\n    }\n  \
    \  return result\n}\n", "    largestNegative := make([]int, 0)\n    smallestPositive\
    \ := make([]int, 0)\n    for _, v := range lst {\n        if v < 0 {\n       \
    \     largestNegative = append(largestNegative, v)\n        } else if v > 0 {\n\
    \            smallestPositive = append(smallestPositive, v)\n        }\n    }\n\
    \    if len(largestNegative) == 0 {\n        largestNegative = append(largestNegative,\
    \ nil)\n    } else {\n        largestNegative = append(largestNegative, largestNegative[0])\n\
    \        for _, n := range largestNegative {\n            if n > largestNegative[0]\
    \ {\n                largestNegative[0] = n\n            }\n        }\n    }\n\
    \    if len(smallestPositive) == 0 {\n        smallestPositive = append(smallestPositive,\
    \ nil)\n    } else {\n        smallestPositive = append(smallestPositive, smallestPositive[0])\n\
    \        for _, n := range smallestPositive {\n            if n < smallestPositive[0]\
    \ {\n                smallestPositive[0] = n\n            }\n        }\n    }\n\
    \    return []interface{}{largestNegative[0], smallestPositive[0]}\n}\n", "\t\
    if len(lst) == 0 {\n\t\treturn []interface{}{nil, nil}\n\t}\n\tmaxNeg := 0\n\t\
    minPos := 0\n\tfor _, v := range lst {\n\t\tif v < 0 {\n\t\t\tif v > maxNeg {\n\
    \t\t\t\tmaxNeg = v\n\t\t\t}\n\t\t} else if v >= 0 {\n\t\t\tif minPos == 0 {\n\t\
    \t\t\tminPos = v\n\t\t\t} else if v < minPos {\n\t\t\t\tminPos = v\n\t\t\t}\n\t\
    \t}\n\t}\n\tif maxNeg == 0 {\n\t\tmaxNeg = nil\n\t}\n\tif minPos == 0 {\n\t\t\
    minPos = nil\n\t}\n\treturn []interface{}{maxNeg, minPos}\n}\n", "    max, min\
    \ := 0, 0\n    foundMax, foundMin := false, false\n    for _, num := range lst\
    \ {\n        if num < 0 {\n            if !foundMax {\n                max = num\n\
    \                foundMax = true\n            } else if num > max {\n        \
    \        max = num\n            }\n        } else if num > 0 {\n            if\
    \ !foundMin {\n                min = num\n                foundMin = true\n  \
    \          } else if num < min {\n                min = num\n            }\n \
    \       }\n    }\n    return []interface{}{max, min}\n}\n", "    var maxNegative\
    \ int\n    var minPositive int\n    hasPositive := false\n    hasNegative := false\n\
    \    var retVal []interface{}\n\n    // iterate through the list\n    for _, l\
    \ := range lst {\n        // if it's a positive number\n        if l > 0 {\n \
    \           // if we haven't seen a positive number yet\n            if !hasPositive\
    \ {\n                // then set the first number we've seen as the smallest positive\n\
    \                minPositive = l\n                hasPositive = true\n       \
    \     } else {\n                // otherwise, test the number against the smallest\
    \ positive we've seen\n                if l < minPositive {\n                \
    \    minPositive = l\n                }\n            }\n        } else if l <\
    \ 0 {\n            // if we haven't seen a negative number yet\n            if\
    \ !hasNegative {\n                // then set the first number we've seen as the\
    \ largest negative\n                maxNegative = l\n                hasNegative\
    \ = true\n            } else {\n                // otherwise, test the number\
    \ against the largest negative we've seen\n                if l > maxNegative\
    \ {\n                    maxNegative = l\n                }\n            }\n \
    \       }\n    }\n\n    // if we didn't see any positive numbers\n    if !hasPositive\
    \ {\n        // then set the smallest positive to nil\n        minPositive = nil\n\
    \    }\n\n    // if we didn't see any negative numbers\n    if !hasNegative {\n\
    \        // then set the largest negative to nil\n        maxNegative = nil\n\
    \    }\n\n    // append the results to the return list\n    retVal = append(retVal,\
    \ maxNegative)\n    retVal = append(retVal, minPositive)\n\n    return retVal\n\
    }\n", "    return nil\n}\n", "    var largestNegative int\n    var smallestPositive\
    \ int\n    var largestNegativeExists bool\n    var smallestPositiveExists bool\n\
    \    largestNegativeExists = false\n    smallestPositiveExists = false\n    for\
    \ _, i := range lst {\n        if i > 0 {\n            if !smallestPositiveExists\
    \ {\n                smallestPositive = i\n                smallestPositiveExists\
    \ = true\n            } else if i < smallestPositive {\n                smallestPositive\
    \ = i\n            }\n        } else if i < 0 {\n            if !largestNegativeExists\
    \ {\n                largestNegative = i\n                largestNegativeExists\
    \ = true\n            } else if i > largestNegative {\n                largestNegative\
    \ = i\n            }\n        }\n    }\n    if largestNegativeExists && smallestPositiveExists\
    \ {\n        return []interface{}{largestNegative, smallestPositive}\n    } else\
    \ if largestNegativeExists {\n        return []interface{}{largestNegative, nil}\n\
    \    } else if smallestPositiveExists {\n        return []interface{}{nil, smallestPositive}\n\
    \    } else {\n        return []interface{}{nil, nil}\n    }\n}\n", "    var p1,\
    \ p2, p3 int\n    var arr []interface{}\n    var pos, neg bool\n    for _, a :=\
    \ range lst {\n        if a > 0 {\n            p2 = a\n            pos = true\n\
    \        }\n        if a < 0 {\n            p1 = a\n            neg = true\n \
    \       }\n    }\n    if pos {\n        p3 = p2\n        for _, a := range lst\
    \ {\n            if a > 0 && a < p3 {\n                p3 = a\n            }\n\
    \        }\n    }\n    if neg {\n        p3 = p1\n        for _, a := range lst\
    \ {\n            if a < 0 && a > p3 {\n                p3 = a\n            }\n\
    \        }\n    }\n    if pos {\n        arr = append(arr, p3)\n    } else {\n\
    \        arr = append(arr, nil)\n    }\n    if neg {\n        arr = append(arr,\
    \ p2)\n    } else {\n        arr = append(arr, nil)\n    }\n    return arr\n}\n",
  "\tlargestNegative, smallestPositive := 0, 0\n\thaveLargestNegative, haveSmallestPositive\
    \ := false, false\n\tfor _, value := range lst {\n\t\tif value < 0 {\n\t\t\tif\
    \ !haveLargestNegative || value > largestNegative {\n\t\t\t\tlargestNegative =\
    \ value\n\t\t\t\thaveLargestNegative = true\n\t\t\t}\n\t\t} else if value > 0\
    \ {\n\t\t\tif !haveSmallestPositive || value < smallestPositive {\n\t\t\t\tsmallestPositive\
    \ = value\n\t\t\t\thaveSmallestPositive = true\n\t\t\t}\n\t\t}\n\t}\n\tif !haveLargestNegative\
    \ {\n\t\tlargestNegative = nil\n\t}\n\tif !haveSmallestPositive {\n\t\tsmallestPositive\
    \ = nil\n\t}\n\treturn []interface{}{largestNegative, smallestPositive}\n}\n",
  "    // TODO: Implement me!\n    fmt.Println(\"Testing Largest/Smallest Integers\"\
    )\n    return []interface{}{nil, nil}\n}\n", "    var negative, positive int\n\
    \    for _, v := range lst {\n        if v > 0 {\n            if positive == 0\
    \ || v < positive {\n                positive = v\n            }\n        } else\
    \ if v < 0 {\n            if negative == 0 || v > negative {\n               \
    \ negative = v\n            }\n        }\n    }\n    return []interface{}{negative,\
    \ positive}\n}\n", "    return []interface{}{nil, nil}\n}\n", "    max_n, min_p\
    \ := 0, 0\n    for _, value := range lst {\n        if value < 0 {\n         \
    \   if value > max_n {\n                max_n = value\n            }\n       \
    \ } else if value > 0 {\n            if value < min_p {\n                min_p\
    \ = value\n            }\n        }\n    }\n    if max_n == 0 {\n        max_n\
    \ = nil\n    }\n    if min_p == 0 {\n        min_p = nil\n    }\n    return []interface{}{max_n,\
    \ min_p}\n}\n", "    var largest_negative_int interface{} = nil\n    var smallest_positive_int\
    \ interface{} = nil\n    for _, v := range lst {\n        switch {\n        case\
    \ v < 0 && largest_negative_int == nil:\n            largest_negative_int = v\n\
    \        case v < 0 && largest_negative_int != nil && v > largest_negative_int.(int):\n\
    \            largest_negative_int = v\n        case v > 0 && smallest_positive_int\
    \ == nil:\n            smallest_positive_int = v\n        case v > 0 && smallest_positive_int\
    \ != nil && v < smallest_positive_int.(int):\n            smallest_positive_int\
    \ = v\n        }\n    }\n    return []interface{}{largest_negative_int, smallest_positive_int}\n\
    }\n", "    var positive, negative []int\n    for _, v := range lst {\n       \
    \ if v < 0 {\n            negative = append(negative, v)\n        } else if v\
    \ > 0 {\n            positive = append(positive, v)\n        }\n    }\n    return\
    \ []interface{}{min(negative), max(positive)}\n}\n", "    var smallest, largest\
    \ interface{}\n    for _, v := range lst {\n        if v > 0 {\n            if\
    \ smallest == nil {\n                smallest = v\n            } else if v < smallest.(int)\
    \ {\n                smallest = v\n            }\n        } else if v < 0 {\n\
    \            if largest == nil {\n                largest = v\n            } else\
    \ if v > largest.(int) {\n                largest = v\n            }\n       \
    \ }\n    }\n    return []interface{}{largest, smallest}\n}\n", "    var result\
    \ []interface{}\n    if len(lst) == 0 {\n        result = append(result, nil,\
    \ nil)\n        return result\n    }\n    positiveList := make([]int, 0)\n   \
    \ negativeList := make([]int, 0)\n    for _, value := range lst {\n        if\
    \ value > 0 {\n            positiveList = append(positiveList, value)\n      \
    \  } else if value < 0 {\n            negativeList = append(negativeList, value)\n\
    \        }\n    }\n    if len(positiveList) == 0 {\n        result = append(result,\
    \ nil, nil)\n        return result\n    }\n    if len(negativeList) == 0 {\n \
    \       result = append(result, nil, positiveList[0])\n        return result\n\
    \    }\n    negativeMin := negativeList[0]\n    negativeMax := negativeList[0]\n\
    \    for _, value := range negativeList {\n        if value < negativeMin {\n\
    \            negativeMin = value\n        }\n        if value > negativeMax {\n\
    \            negativeMax = value\n        }\n    }\n    positiveMin := positiveList[0]\n\
    \    for _, value := range positiveList {\n        if value < positiveMin {\n\
    \            positiveMin = value\n        }\n    }\n    result = append(result,\
    \ negativeMax, positiveMin)\n    return result\n}\n", "    largest_negative :=\
    \ None{}\n    smallest_positive := None{}\n    for _, value := range lst {\n \
    \       if value < 0 {\n            if largest_negative.(None) == None{\n    \
    \            largest_negative = value\n            }\n            if value > largest_negative.(int)\
    \ {\n                largest_negative = value\n            }\n        } else if\
    \ value > 0 {\n            if smallest_positive.(None) == None{\n            \
    \    smallest_positive = value\n            }\n            if value < smallest_positive.(int)\
    \ {\n                smallest_positive = value\n            }\n        }\n   \
    \ }\n    return []interface{}{largest_negative, smallest_positive}\n}\n\ntype\
    \ None ", "\tneg := []int{}\n\tpos := []int{}\n\tfor _, v := range lst {\n\t\t\
    if v < 0 {\n\t\t\tneg = append(neg, v)\n\t\t} else if v > 0 {\n\t\t\tpos = append(pos,\
    \ v)\n\t\t}\n\t}\n\tvar maxNeg, minPos interface{}\n\tif len(neg) > 0 {\n\t\t\
    maxNeg = neg[0]\n\t\tfor _, v := range neg {\n\t\t\tif v > maxNeg.(int) {\n\t\t\
    \t\tmaxNeg = v\n\t\t\t}\n\t\t}\n\t}\n\tif len(pos) > 0 {\n\t\tminPos = pos[0]\n\
    \t\tfor _, v := range pos {\n\t\t\tif v < minPos.(int) {\n\t\t\t\tminPos = v\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn []interface{}{maxNeg, minPos}\n}\n", "    var (\n\
    \        negative_max = -10000\n        positive_min = 10000\n    )\n    ret :=\
    \ []interface{}{nil, nil}\n    for _, v := range lst {\n        if v < 0 {\n \
    \           if v > negative_max {\n                negative_max = v\n        \
    \    }\n        } else if v > 0 {\n            if v < positive_min {\n       \
    \         positive_min = v\n            }\n        }\n    }\n    if negative_max\
    \ != -10000 {\n        ret[0] = negative_max\n    }\n    if positive_min != 10000\
    \ {\n        ret[1] = positive_min\n    }\n    return ret\n}\n", "    largest_negative,\
    \ smallest_positive := 0, 0\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if v > largest_negative {\n                largest_negative = v\n\
    \            }\n        } else {\n            if v < smallest_positive {\n   \
    \             smallest_positive = v\n            }\n        }\n    }\n    return\
    \ []interface{}{largest_negative, smallest_positive}\n}\n", "    fmt.Println(lst)\n\
    \    if len(lst) == 0 {\n        return []interface{}{nil, nil}\n    }\n    leastNegative\
    \ := 0\n    foundLeastNegative := false\n    largestPositive := 0\n    foundLargestPositive\
    \ := false\n    for _, v := range lst {\n        if v < 0 {\n            if !foundLeastNegative\
    \ {\n                leastNegative = v\n                foundLeastNegative = true\n\
    \            } else if v > leastNegative {\n                leastNegative = v\n\
    \            }\n        } else if v > 0 {\n            if !foundLargestPositive\
    \ {\n                largestPositive = v\n                foundLargestPositive\
    \ = true\n            } else if v < largestPositive {\n                largestPositive\
    \ = v\n            }\n        }\n    }\n    if !foundLeastNegative {\n       \
    \ leastNegative = nil\n    }\n    if !foundLargestPositive {\n        largestPositive\
    \ = nil\n    }\n    return []interface{}{leastNegative, largestPositive}\n}\n",
  "    var minPositive int = 0;\n    var maxNegative int = 0;\n    var maxNegativeFound\
    \ bool = false;\n    var minPositiveFound bool = false;\n    var i int = 0;\n\
    \    var curValue int = 0;\n    if len(lst) == 0 {\n        return []interface{}{nil,\
    \ nil};\n    }\n    for i < len(lst) {\n        curValue = lst[i];\n        if\
    \ curValue > 0 {\n            if !minPositiveFound {\n                minPositive\
    \ = curValue;\n                minPositiveFound = true;\n            } else if\
    \ curValue < minPositive {\n                minPositive = curValue;\n        \
    \    }\n        } else if curValue < 0 {\n            if !maxNegativeFound {\n\
    \                maxNegative = curValue;\n                maxNegativeFound = true;\n\
    \            } else if curValue > maxNegative {\n                maxNegative =\
    \ curValue;\n            }\n        }\n        i++;\n    }\n    if !maxNegativeFound\
    \ {\n        maxNegative = nil;\n    }\n    if !minPositiveFound {\n        minPositive\
    \ = nil;\n    }\n    return []interface{}{maxNegative, minPositive};\n}\n", " \
    \   var largest_int *int\n    var smallest_int *int\n    for _, v := range lst\
    \ {\n        if v < 0 {\n            if largest_int == nil || *largest_int < v\
    \ {\n                largest_int = &v\n            }\n        } else if v > 0\
    \ {\n            if smallest_int == nil || *smallest_int > v {\n             \
    \   smallest_int = &v\n            }\n        }\n    }\n    return []interface{}{largest_int,\
    \ smallest_int}\n}\n", "    // Your code here\n    return []interface{}{nil, nil}\n\
    }\n", "    // refactor to use inbuilt func max & min.\n    return []interface{}{nil,\
    \ nil}\n}\n", "    lst_res := []interface{}{}\n    if len(lst) == 0 {\n      \
    \  lst_res = append(lst_res, nil, nil)\n        return lst_res\n    }\n    lst_pos\
    \ := []int{}\n    lst_neg := []int{}\n    for _, n := range lst {\n        if\
    \ n > 0 {\n            lst_pos = append(lst_pos, n)\n        } else if n < 0 {\n\
    \            lst_neg = append(lst_neg, n)\n        }\n    }\n    var max_neg int\n\
    \    var min_pos int\n    if len(lst_neg) == 0 {\n        max_neg = nil\n    }\
    \ else {\n        max_neg = lst_neg[0]\n        for _, n := range lst_neg {\n\
    \            if n > max_neg {\n                max_neg = n\n            }\n  \
    \      }\n    }\n    if len(lst_pos) == 0 {\n        min_pos = nil\n    } else\
    \ {\n        min_pos = lst_pos[0]\n        for _, n := range lst_pos {\n     \
    \       if n < min_pos {\n                min_pos = n\n            }\n       \
    \ }\n    }\n    lst_res = append(lst_res, max_neg, min_pos)\n    return lst_res\n\
    }\n", "    return nil\n}\n", "    if len(lst) == 0 {\n        return []interface{}{nil,\
    \ nil}\n    }\n    max, min := lst[0], lst[0]\n    for _, e := range lst {\n \
    \       if e < 0 && e > max {\n            max = e\n        }\n        if e >\
    \ 0 && e < min {\n            min = e\n        }\n    }\n    return []interface{}{max,\
    \ min}\n}\n", "    min := lst[0]\n    max := lst[0]\n    largest_smallest_int\
    \ := []interface{}{}\n    if len(lst) > 0 {\n        for _, v := range lst {\n\
    \            if v > max {\n                max = v\n            }\n          \
    \  if v < min {\n                min = v\n            }\n        }\n        largest_smallest_int\
    \ = append(largest_smallest_int, max, min)\n    } else {\n        largest_smallest_int\
    \ = append(largest_smallest_int, nil, nil)\n    }\n    return largest_smallest_int\n\
    }\n", "    var lst_pos, lst_neg []int\n    for _, v := range lst {\n        if\
    \ v > 0 {\n            lst_pos = append(lst_pos, v)\n        } else if v < 0 {\n\
    \            lst_neg = append(lst_neg, v)\n        }\n    }\n    if len(lst_pos)\
    \ == 0 && len(lst_neg) == 0 {\n        return []interface{}{nil, nil}\n    }\n\
    \    return []interface{}{max(lst_neg), min(lst_pos)}\n}\n", "    var min, max\
    \ int\n    min = lst[0]\n    max = lst[0]\n    for _, i := range lst {\n     \
    \   if i < min {\n            min = i\n        }\n        if i > max {\n     \
    \       max = i\n        }\n    }\n    return []interface{}{max, min}\n}\n", " \
    \   var largest, smallest int\n    var largest_found, smallest_found bool\n  \
    \  for _, x := range lst {\n        if x > 0 {\n            if !smallest_found\
    \ || x < smallest {\n                smallest = x\n                smallest_found\
    \ = true\n            }\n        } else if x < 0 {\n            if !largest_found\
    \ || x > largest {\n                largest = x\n                largest_found\
    \ = true\n            }\n        }\n    }\n    if largest_found {\n        if\
    \ smallest_found {\n            return []interface{}{largest, smallest}\n    \
    \    } else {\n            return []interface{}{largest, nil}\n        }\n   \
    \ } else {\n        if smallest_found {\n            return []interface{}{nil,\
    \ smallest}\n        } else {\n            return []interface{}{nil, nil}\n  \
    \      }\n    }\n}\n", "    var largestNegative, smallestPositive int\n    var\
    \ largestNegativeFound, smallestPositiveFound bool\n    for _, value := range\
    \ lst {\n        if value >= 0 {\n            if smallestPositiveFound {\n   \
    \             if value < smallestPositive {\n                    smallestPositive\
    \ = value\n                }\n            } else {\n                smallestPositive\
    \ = value\n                smallestPositiveFound = true\n            }\n     \
    \   } else {\n            if largestNegativeFound {\n                if value\
    \ > largestNegative {\n                    largestNegative = value\n         \
    \       }\n            } else {\n                largestNegative = value\n   \
    \             largestNegativeFound = true\n            }\n        }\n    }\n \
    \   if largestNegativeFound {\n        if smallestPositiveFound {\n          \
    \  return []interface{}{largestNegative, smallestPositive}\n        } else {\n\
    \            return []interface{}{largestNegative, nil}\n        }\n    } else\
    \ {\n        if smallestPositiveFound {\n            return []interface{}{nil,\
    \ smallestPositive}\n        } else {\n            return []interface{}{nil, nil}\n\
    \        }\n    }\n}\n", "    var pos, neg int\n    var posFound, negFound bool\n\
    \    for _, e := range lst {\n        if e > 0 {\n            if !posFound {\n\
    \                pos = e\n                posFound = true\n            } else\
    \ if e < pos {\n                pos = e\n            }\n        } else if e <\
    \ 0 {\n            if !negFound {\n                neg = e\n                negFound\
    \ = true\n            } else if e > neg {\n                neg = e\n         \
    \   }\n        }\n    }\n    if !posFound {\n        pos = 0\n    }\n    if !negFound\
    \ {\n        neg = 0\n    }\n    return []interface{}{neg, pos}\n}\n", "    var\
    \ a, b int\n    var flag bool\n    // This algorithm is O(n) in time and O(1)\
    \ in space complexity.\n    for _, x := range lst {\n        if x > 0 {\n    \
    \        if !flag {\n                b = x\n                flag = true\n    \
    \        } else if x < b {\n                b = x\n            }\n        } else\
    \ if x < 0 {\n            if x > a {\n                a = x\n            }\n \
    \       }\n    }\n    if a == 0 && b == 0 {\n        return []interface{}{nil,\
    \ nil}\n    }\n    if a == 0 {\n        return []interface{}{nil, b}\n    }\n\
    \    if b == 0 {\n        return []interface{}{a, nil}\n    }\n    return []interface{}{a,\
    \ b}\n}\n", "    if len(lst) == 0 {\n        return []interface{}{nil, nil}\n\
    \    }\n    if len(lst) == 1 {\n        if lst[0] > 0 {\n            return []interface{}{nil,\
    \ lst[0]}\n        } else if lst[0] < 0 {\n            return []interface{}{lst[0],\
    \ nil}\n        } else {\n            return []interface{}{nil, nil}\n       \
    \ }\n    }\n    largestNeg, smallestPos := 0, 0\n    largestNegIdx, smallestPosIdx\
    \ := -1, -1\n    for i, v := range lst {\n        if v > 0 {\n            if smallestPosIdx\
    \ == -1 {\n                smallestPosIdx = i\n                smallestPos = v\n\
    \            } else if v < smallestPos {\n                smallestPosIdx = i\n\
    \                smallestPos = v\n            }\n        } else if v < 0 {\n \
    \           if largestNegIdx == -1 {\n                largestNegIdx = i\n    \
    \            largestNeg = v\n            } else if v > largestNeg {\n        \
    \        largestNegIdx = i\n                largestNeg = v\n            }\n  \
    \      }\n    }\n    if largestNegIdx == -1 {\n        largestNeg = nil\n    }\n\
    \    if smallestPosIdx == -1 {\n        smallestPos = nil\n    }\n    return []interface{}{largestNeg,\
    \ smallestPos}\n}\n", "    var a, b interface{}\n    var pos, neg bool\n    for\
    \ _, val := range lst {\n        if val > 0 {\n            if !pos {\n       \
    \         b = val\n                pos = true\n            } else if val < b.(int)\
    \ {\n                b = val\n            }\n        } else if val < 0 {\n   \
    \         if !neg {\n                a = val\n                neg = true\n   \
    \         } else if val > a.(int) {\n                a = val\n            }\n\
    \        }\n    }\n    return []interface{}{a, b}\n}\n", "    var a, b int\n \
    \   first_pos, first_neg := false, false\n    for _, v := range lst {\n      \
    \  if v < 0 {\n            if !first_neg {\n                a = v\n          \
    \      first_neg = true\n            } else if v > a {\n                a = v\n\
    \            }\n        } else if v > 0 {\n            if !first_pos {\n     \
    \           b = v\n                first_pos = true\n            } else if v <\
    \ b {\n                b = v\n            }\n        }\n    }\n    if !first_pos\
    \ {\n        b = nil\n    }\n    if !first_neg {\n        a = nil\n    }\n   \
    \ return []interface{}{a, b}\n}\n", "    var negativeLargest, positiveSmallest\
    \ int\n    isNegative := false\n    isPositive := false\n    for _, value := range\
    \ lst {\n        if value < 0 {\n            if !isNegative {\n              \
    \  negativeLargest = value\n                isNegative = true\n            } else\
    \ if value > negativeLargest {\n                negativeLargest = value\n    \
    \        }\n        } else if value > 0 {\n            if !isPositive {\n    \
    \            positiveSmallest = value\n                isPositive = true\n   \
    \         } else if value < positiveSmallest {\n                positiveSmallest\
    \ = value\n            }\n        }\n    }\n    return []interface{}{ negativeLargest,\
    \ positiveSmallest }\n}\n", "    var largestNegative int\n    var smallestPositive\
    \ int\n    isNegative := false\n    isPositive := false\n    for _, v := range\
    \ lst {\n        if v > 0 {\n            if isPositive {\n                if v\
    \ < smallestPositive {\n                    smallestPositive = v\n           \
    \     }\n            } else {\n                smallestPositive = v\n        \
    \        isPositive = true\n            }\n        } else if v < 0 {\n       \
    \     if isNegative {\n                if v > largestNegative {\n            \
    \        largestNegative = v\n                }\n            } else {\n      \
    \          largestNegative = v\n                isNegative = true\n          \
    \  }\n        }\n    }\n    ret := []interface{}{largestNegative, smallestPositive}\n\
    \    return ret\n}\n", "    // Your code here\n    return []interface{}{nil, nil}\n\
    }\n", "    var largest, smallest int\n    var largestSet, smallestSet bool\n\n\
    \    for _, n := range lst {\n        if !largestSet && n < 0 {\n            largest\
    \ = n\n            largestSet = true\n        }\n        if !smallestSet && n\
    \ > 0 {\n            smallest = n\n            smallestSet = true\n        }\n\
    \        if largestSet && n < largest {\n            largest = n\n        }\n\
    \        if smallestSet && n < smallest {\n            smallest = n\n        }\n\
    \    }\n\n    return []interface{}{largest, smallest}\n}\n", "    a, b := largestNegative(lst),\
    \ smallestPositive(lst)\n    if a == nil {\n        a = nil\n    }\n    if b ==\
    \ nil {\n        b = nil\n    }\n    return []interface{}{a, b}\n}\n", "    negative,\
    \ positive := lst[0], lst[0]\n    for _, x := range lst {\n        if x < 0 &&\
    \ x > negative {\n            negative = x\n        }\n        if x > 0 && x <\
    \ positive {\n            positive = x\n        }\n    }\n    return []interface{}{negative,\
    \ positive}\n}\n", "    var largestNegative, smallestPositive int\n    var largestNegativeIsSet,\
    \ smallestPositiveIsSet bool\n    largestNegative = 0\n    smallestPositive =\
    \ 0\n    largestNegativeIsSet = false\n    smallestPositiveIsSet = false\n   \
    \ for _, item := range lst {\n        if item < 0 {\n            if !largestNegativeIsSet\
    \ {\n                largestNegative = item\n                largestNegativeIsSet\
    \ = true\n            } else if item > largestNegative {\n                largestNegative\
    \ = item\n            }\n        } else if item > 0 {\n            if !smallestPositiveIsSet\
    \ {\n                smallestPositive = item\n                smallestPositiveIsSet\
    \ = true\n            } else if item < smallestPositive {\n                smallestPositive\
    \ = item\n            }\n        }\n    }\n    return []interface{}{largestNegative,\
    \ smallestPositive}\n}\n", "    if len(lst) == 0 {\n        return []interface{}{nil,\
    \ nil}\n    }\n    largest := 0\n    smallest := 0\n    for _, val := range lst\
    \ {\n        if val > largest {\n            largest = val\n        }\n      \
    \  if val < smallest {\n            smallest = val\n        }\n    }\n    return\
    \ []interface{}{largest, smallest}\n}\n", "    var negs []int\n    var poss []int\n\
    \    for _, i := range lst {\n        if i < 0 {\n            negs = append(negs,\
    \ i)\n        } else if i > 0 {\n            poss = append(poss, i)\n        }\n\
    \    }\n    a := min_max(negs)\n    b := min_max(poss)\n    return []interface{}{a,\
    \ b}\n}\n", "    var smallestPos int\n    var largestNeg int\n    var largestNegInit\
    \ bool\n    var smallestPosInit bool\n    for _, v := range lst {\n        if\
    \ v > 0 {\n            if !smallestPosInit {\n                smallestPos = v\n\
    \                smallestPosInit = true\n            } else if v < smallestPos\
    \ {\n                smallestPos = v\n            }\n        } else if v < 0 {\n\
    \            if !largestNegInit {\n                largestNeg = v\n          \
    \      largestNegInit = true\n            } else if v > largestNeg {\n       \
    \         largestNeg = v\n            }\n        }\n    }\n    var result []interface{}\n\
    \    if largestNegInit {\n        result = append(result, largestNeg)\n    } else\
    \ {\n        result = append(result, nil)\n    }\n    if smallestPosInit {\n \
    \       result = append(result, smallestPos)\n    } else {\n        result = append(result,\
    \ nil)\n    }\n    return result\n}\n", "    smallest := float64(0)\n    largest\
    \ := float64(0)\n    first := float64(0)\n    foundFirst := false\n    for _,\
    \ x := range lst {\n        if float64(x) > 0 {\n            if !foundFirst {\n\
    \                first = float64(x)\n                foundFirst = true\n     \
    \       }\n            if float64(x) < first {\n                smallest = float64(x)\n\
    \            }\n        } else if float64(x) < 0 {\n            if !foundFirst\
    \ {\n                first = float64(x)\n                foundFirst = true\n \
    \           }\n            if float64(x) > first {\n                largest =\
    \ float64(x)\n            }\n        }\n    }\n    ret := []interface{}{largest,\
    \ smallest}\n    if largest == 0 {\n        ret[0] = nil\n    }\n    if smallest\
    \ == 0 {\n        ret[1] = nil\n    }\n    return ret\n}\n", "    if len(lst)\
    \ == 0 {\n        return []interface{}{nil, nil}\n    }\n    pos := make([]int,\
    \ 0)\n    neg := make([]int, 0)\n    for _, num := range lst {\n        if num\
    \ > 0 {\n            pos = append(pos, num)\n        } else if num < 0 {\n   \
    \         neg = append(neg, num)\n        }\n    }\n    if len(pos) == 0 || len(neg)\
    \ == 0 {\n        return []interface{}{nil, nil}\n    }\n    return []interface{}{max(neg),\
    \ min(pos)}\n}\n", "    return nil\n}\n", "    return []interface{}{}\n}\n", " \
    \   var negatives []int\n    var positives []int\n    var negativesMax int\n \
    \   var positivesMin int\n    var result []interface{}\n\n    for _, val := range\
    \ lst {\n        if val < 0 {\n            negatives = append(negatives, val)\n\
    \        } else if val > 0 {\n            positives = append(positives, val)\n\
    \        }\n    }\n\n    if len(negatives) == 0 {\n        negativesMax = 0\n\
    \    } else {\n        negativesMax = negatives[0]\n        for _, val := range\
    \ negatives {\n            if val > negativesMax {\n                negativesMax\
    \ = val\n            }\n        }\n    }\n\n    if len(positives) == 0 {\n   \
    \     positivesMin = 0\n    } else {\n        positivesMin = positives[0]\n  \
    \      for _, val := range positives {\n            if val < positivesMin {\n\
    \                positivesMin = val\n            }\n        }\n    }\n\n    result\
    \ = append(result, negativesMax)\n    result = append(result, positivesMin)\n\n\
    \    return result\n}\n", "    small_pos, large_neg := nil, nil\n    for _, x\
    \ := range lst {\n        if x > 0 {\n            if small_pos == nil || x < small_pos\
    \ {\n                small_pos = x\n            }\n        } else if x < 0 {\n\
    \            if large_neg == nil || x > large_neg {\n                large_neg\
    \ = x\n            }\n        }\n    }\n    return []interface{}{large_neg, small_pos}\n\
    }\n", "    return nil\n}\n", "    var a, b interface{} = nil, nil\n    for _,\
    \ i := range lst {\n        if i < 0 {\n            if a == nil {\n          \
    \      a = i\n            } else if i > a.(int) {\n                a = i\n   \
    \         }\n        } else if i > 0 {\n            if b == nil {\n          \
    \      b = i\n            } else if i < b.(int) {\n                b = i\n   \
    \         }\n        }\n    }\n    return []interface{}{a, b}\n}\n", "    if len(lst)\
    \ == 0 {\n        return []interface{}{nil, nil}\n    }\n    negatives := make([]int,\
    \ 0)\n    positives := make([]int, 0)\n    for _, v := range lst {\n        if\
    \ v < 0 {\n            negatives = append(negatives, v)\n        } else if v >\
    \ 0 {\n            positives = append(positives, v)\n        }\n    }\n    a :=\
    \ max(negatives)\n    b := min(positives)\n    if len(negatives) == 0 {\n    \
    \    a = nil\n    }\n    if len(positives) == 0 {\n        b = nil\n    }\n  \
    \  return []interface{}{a, b}\n}\n", "    var smallest, largest int\n    var sflag,\
    \ lflag bool\n    var res []interface{}\n    for _, v := range lst {\n       \
    \ if v > 0 {\n            if !sflag {\n                smallest = v\n        \
    \        sflag = true\n            } else if v < smallest {\n                smallest\
    \ = v\n            }\n        } else if v < 0 {\n            if !lflag {\n   \
    \             largest = v\n                lflag = true\n            } else if\
    \ v > largest {\n                largest = v\n            }\n        }\n    }\n\
    \    if sflag {\n        res = append(res, smallest)\n    } else {\n        res\
    \ = append(res, nil)\n    }\n    if lflag {\n        res = append(res, largest)\n\
    \    } else {\n        res = append(res, nil)\n    }\n    return res\n}\n", " \
    \   min := 0\n    max := 0\n    has_min := false\n    has_max := false\n    for\
    \ _, item := range lst {\n        if item > 0 {\n            if !has_min || item\
    \ < min {\n                min = item\n                has_min = true\n      \
    \      }\n        } else if item < 0 {\n            if !has_max || item > max\
    \ {\n                max = item\n                has_max = true\n            }\n\
    \        }\n    }\n    if !has_min {\n        min = nil\n    }\n    if !has_max\
    \ {\n        max = nil\n    }\n    return []interface{}{max, min}\n}\n", "   \
    \ minpos := 0\n    maxneg := 0\n    for _, number := range lst {\n        if number\
    \ > 0 {\n            if minpos == 0 {\n                minpos = number\n     \
    \       } else if number < minpos {\n                minpos = number\n       \
    \     }\n        } else if number < 0 {\n            if maxneg == 0 {\n      \
    \          maxneg = number\n            } else if number > maxneg {\n        \
    \        maxneg = number\n            }\n        }\n    }\n    return []interface{}{maxneg,\
    \ minpos}\n}\n", "    largest := 2 << 32 - 1\n    smallest := 1 << 32 - 1\n  \
    \  for _, i := range lst {\n        if i < 0 && i > largest {\n            largest\
    \ = i\n        }\n        if i > 0 && i < smallest {\n            smallest = i\n\
    \        }\n    }\n    if largest == 2 << 32 - 1 {\n        largest = nil\n  \
    \  }\n    if smallest == 1 << 32 - 1 {\n        smallest = nil\n    }\n    return\
    \ []interface{}{largest, smallest}\n}\n", "    var largestNeg int = nil\n    var\
    \ smallestPos int = nil\n    for _, n := range lst {\n        if n < 0 {\n   \
    \         if largestNeg == nil || n > largestNeg {\n                largestNeg\
    \ = n\n            }\n        } else if n > 0 {\n            if smallestPos ==\
    \ nil || n < smallestPos {\n                smallestPos = n\n            }\n \
    \       }\n    }\n    return []interface{}{largestNeg, smallestPos}\n}\n", " \
    \   var pos, neg int\n    first := true\n    for _, i := range lst {\n       \
    \ if i > 0 {\n            if first {\n                pos = i\n              \
    \  first = false\n            } else if i < pos {\n                pos = i\n \
    \           }\n        } else if i < 0 {\n            if first {\n           \
    \     neg = i\n                first = false\n            } else if i > neg {\n\
    \                neg = i\n            }\n        }\n    }\n    if first {\n  \
    \      return []interface{}{nil, nil}\n    }\n    return []interface{}{neg, pos}\n\
    }\n", "    // The defaults are the opposite of what we want to return.\n    largest\
    \ := lst[0]\n    smallest := lst[0]\n    var result []interface{}\n    for _,\
    \ value := range lst {\n        if value > largest {\n            largest = value\n\
    \        }\n        if value < smallest {\n            smallest = value\n    \
    \    }\n    }\n    result = append(result, smallest, largest)\n    return result\n\
    }\n", "    nilList := []interface{}{nil, nil}\n    if len(lst) == 0 {\n      \
    \  return nilList\n    }\n    negatives := []int{}\n    positives := []int{}\n\
    \    for _, v := range lst {\n        if v < 0 {\n            negatives = append(negatives,\
    \ v)\n        } else if v > 0 {\n            positives = append(positives, v)\n\
    \        }\n    }\n    if len(negatives) == 0 {\n        return append(nilList[:0],\
    \ append(nilList[0:], nilList[1:]...)...)\n    }\n    if len(positives) == 0 {\n\
    \        return append(nilList[:0], append(nilList[0:], nilList[1:]...)...)\n\
    \    }\n    return []interface{}{max(negatives), min(positives)}\n}\n", "    var\
    \ largestNeg int = 0\n    var smallestPos int = 0\n    var largestNegFound bool\
    \ = false\n    var smallestPosFound bool = false\n    for _, num := range lst\
    \ {\n        if num > 0 && (num < smallestPos || !smallestPosFound) {\n      \
    \      smallestPos = num\n            smallestPosFound = true\n        } else\
    \ if num < 0 && (num > largestNeg || !largestNegFound) {\n            largestNeg\
    \ = num\n            largestNegFound = true\n        }\n    }\n    if !largestNegFound\
    \ {\n        largestNeg = 0\n    }\n    if !smallestPosFound {\n        smallestPos\
    \ = 0\n    }\n    return []interface{}{largestNeg, smallestPos}\n}\n", "    var\
    \ maxNeg, minPos int\n    isNegative, isPositive := false, false\n    for _, num\
    \ := range lst {\n        if num < 0 {\n            if !isNegative {\n       \
    \         maxNeg = num\n                isNegative = true\n            } else\
    \ if num > maxNeg {\n                maxNeg = num\n            }\n        } else\
    \ if num > 0 {\n            if !isPositive {\n                minPos = num\n \
    \               isPositive = true\n            } else if num < minPos {\n    \
    \            minPos = num\n            }\n        }\n    }\n    if !isNegative\
    \ {\n        maxNeg = 0\n    }\n    if !isPositive {\n        minPos = 0\n   \
    \ }\n    return []interface{}{maxNeg, minPos}\n}\n", "    l := len(lst)\n    if\
    \ l == 0 {\n        return []interface{}{nil, nil}\n    }\n    var largestNeg\
    \ int\n    var smallestPos int\n    foundSmallestPos := false\n    foundLargestNeg\
    \ := false\n    for _, i := range lst {\n        if i < 0 {\n            if !foundLargestNeg\
    \ {\n                largestNeg = i\n                foundLargestNeg = true\n\
    \            } else if i > largestNeg {\n                largestNeg = i\n    \
    \        }\n        } else if i > 0 {\n            if !foundSmallestPos {\n  \
    \              smallestPos = i\n                foundSmallestPos = true\n    \
    \        } else if i < smallestPos {\n                smallestPos = i\n      \
    \      }\n        }\n    }\n    if !foundLargestNeg {\n        largestNeg = nil\n\
    \    }\n    if !foundSmallestPos {\n        smallestPos = nil\n    }\n    return\
    \ []interface{}{largestNeg, smallestPos}\n}\n", "    var largest_negative_int\
    \ int\n    var smallest_positive_int int\n    largest_negative_int_found := false\n\
    \    smallest_positive_int_found := false\n    for _, elem := range lst {\n  \
    \      if elem < 0 {\n            if largest_negative_int_found == false {\n \
    \               largest_negative_int = elem\n                largest_negative_int_found\
    \ = true\n            } else if elem > largest_negative_int {\n              \
    \  largest_negative_int = elem\n            }\n        } else if elem > 0 {\n\
    \            if smallest_positive_int_found == false {\n                smallest_positive_int\
    \ = elem\n                smallest_positive_int_found = true\n            } else\
    \ if elem < smallest_positive_int {\n                smallest_positive_int = elem\n\
    \            }\n        }\n    }\n    var largest_negative_int_interface interface{}\n\
    \    var smallest_positive_int_interface interface{}\n    if largest_negative_int_found\
    \ {\n        largest_negative_int_interface = largest_negative_int\n    } else\
    \ {\n        largest_negative_int_interface = nil\n    }\n    if smallest_positive_int_found\
    \ {\n        smallest_positive_int_interface = smallest_positive_int\n    } else\
    \ {\n        smallest_positive_int_interface = nil\n    }\n    return []interface{}{largest_negative_int_interface,\
    \ smallest_positive_int_interface}\n}\n", "    if lst == nil {\n        return\
    \ []interface{}{nil, nil}\n    }\n    if len(lst) == 0 {\n        return []interface{}{nil,\
    \ nil}\n    }\n    for i, _ := range lst {\n        if lst[i] == 0 {\n       \
    \     return []interface{}{nil, nil}\n        }\n    }\n    return []interface{}{lst[len(lst)-1],\
    \ lst[0]}\n}\n", "\tvar largest, smallest interface{}\n\tvar positives, negatives\
    \ []int\n\tif len(lst) == 0 {\n\t\treturn []interface{}{largest, smallest}\n\t\
    }\n\n\tfor _, value := range lst {\n\t\tif value > 0 {\n\t\t\tpositives = append(positives,\
    \ value)\n\t\t} else if value < 0 {\n\t\t\tnegatives = append(negatives, value)\n\
    \t\t}\n\t}\n\n\tif len(positives) > 0 {\n\t\tsort.Ints(positives)\n\t\tsmallest\
    \ = positives[0]\n\t}\n\n\tif len(negatives) > 0 {\n\t\tsort.Ints(negatives)\n\
    \t\tlargest = negatives[len(negatives)-1]\n\t}\n\n\treturn []interface{}{largest,\
    \ smallest}\n}\n", "    min_pos := nil\n    max_neg := nil\n    for _, i := range\
    \ lst {\n        if i > 0 {\n            if min_pos == nil || i < min_pos {\n\
    \                min_pos = i\n            }\n        } else if i < 0 {\n     \
    \       if max_neg == nil || i > max_neg {\n                max_neg = i\n    \
    \        }\n        }\n    }\n    return []interface{}{max_neg, min_pos}\n}\n",
  "    var largestNegative int\n    var smallestPositive int\n    var result []interface{}\n\
    \n    largestNegative = 0\n    smallestPositive = 0\n\n    for _, val := range\
    \ lst {\n        if val < 0 {\n            if val > largestNegative {\n      \
    \          largestNegative = val\n            }\n        } else if val > 0 {\n\
    \            if smallestPositive == 0 {\n                smallestPositive = val\n\
    \            } else if val < smallestPositive {\n                smallestPositive\
    \ = val\n            }\n        }\n    }\n\n    result = append(result, largestNegative)\n\
    \    result = append(result, smallestPositive)\n\n    return result\n}\n", " \
    \   var largest, smallest int\n    for _, v := range lst {\n        if v < 0 {\n\
    \            if largest == 0 || v > largest {\n                largest = v\n \
    \           }\n        } else {\n            if smallest == 0 || v < smallest\
    \ {\n                smallest = v\n            }\n        }\n    }\n    var result\
    \ []interface{}\n    result = append(result, largest)\n    result = append(result,\
    \ smallest)\n    return result\n}\n", "\tlargest_n, smallest_p := nil, nil\n\t\
    for _, n := range lst {\n\t\tif n > 0 {\n\t\t\tif smallest_p == nil || n < smallest_p\
    \ {\n\t\t\t\tsmallest_p = n\n\t\t\t}\n\t\t} else if n < 0 {\n\t\t\tif largest_n\
    \ == nil || n > largest_n {\n\t\t\t\tlargest_n = n\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ []interface{}{largest_n, smallest_p}\n}\n", "    largest := make(chan int)\n\
    \    smallest := make(chan int)\n    nlargest := make(chan int)\n    nsmallest\
    \ := make(chan int)\n    go find_largest(lst, largest)\n    go find_smallest(lst,\
    \ smallest)\n    go find_largest_negative(lst, nlargest)\n    go find_smallest_positive(lst,\
    \ nsmallest)\n    l, s, nl, ns := <-largest, <-smallest, <-nlargest, <-nsmallest\n\
    \    res := []interface{}{}\n    if nl == 0 {\n        res = append(res, nil)\n\
    \    } else {\n        res = append(res, nl)\n    }\n    if ns == 0 {\n      \
    \  res = append(res, nil)\n    } else {\n        res = append(res, ns)\n    }\n\
    \    return res\n}\n", "    a, b := nil, nil\n    for _, v := range lst {\n  \
    \      if v > 0 {\n            if b == nil || v < b {\n                b = v\n\
    \            }\n        } else if v < 0 {\n            if a == nil || v > a {\n\
    \                a = v\n            }\n        }\n    }\n    return []interface{}{a,\
    \ b}\n}\n", "    // TODO: Implement function\n    return nil\n}\n", "    var a\
    \ int\n    var b int\n    var c int\n    c = 0\n    // find smallest positive\
    \ integer\n    for _, value := range lst {\n        if value > 0 {\n         \
    \   if c == 0 {\n                b = value\n                c = 1\n          \
    \  } else if value < b {\n                b = value\n            }\n        }\n\
    \    }\n    c = 0\n    // find largest negative integer\n    for _, value := range\
    \ lst {\n        if value < 0 {\n            if c == 0 {\n                a =\
    \ value\n                c = 1\n            } else if value > a {\n          \
    \      a = value\n            }\n        }\n    }\n    var x []interface{}\n \
    \   if c == 0 {\n        x = append(x, nil)\n    } else {\n        x = append(x,\
    \ a)\n    }\n    if c == 0 {\n        x = append(x, nil)\n    } else {\n     \
    \   x = append(x, b)\n    }\n    return x\n}\n", "    var maxNeg int\n    var\
    \ minPos int\n    var hasNeg bool\n    var hasPos bool\n    for _, v := range\
    \ lst {\n        if v < 0 {\n            if !hasNeg || v > maxNeg {\n        \
    \        maxNeg = v\n            }\n            hasNeg = true\n        } else\
    \ if v > 0 {\n            if !hasPos || v < minPos {\n                minPos =\
    \ v\n            }\n            hasPos = true\n        }\n    }\n    var maxNegNull,\
    \ minPosNull interface{}\n    if !hasNeg {\n        maxNegNull = nil\n    } else\
    \ {\n        maxNegNull = maxNeg\n    }\n    if !hasPos {\n        minPosNull\
    \ = nil\n    } else {\n        minPosNull = minPos\n    }\n    return []interface{}{maxNegNull,\
    \ minPosNull}\n}\n", "\tvar ret = []interface{}{nil, nil}\n\tfor _, num := range\
    \ lst {\n\t\tif num > 0 {\n\t\t\tif ret[1] == nil || num < ret[1].(int) {\n\t\t\
    \t\tret[1] = num\n\t\t\t}\n\t\t} else if num < 0 {\n\t\t\tif ret[0] == nil ||\
    \ num > ret[0].(int) {\n\t\t\t\tret[0] = num\n\t\t\t}\n\t\t}\n\t}\n\treturn ret\n\
    }\n", "    var largestNeg, smallestPos int\n    largestNegInitialized := false\n\
    \    smallestPosInitialized := false\n    for _, e := range lst {\n        if\
    \ e > 0 {\n            if !smallestPosInitialized {\n                smallestPos\
    \ = e\n                smallestPosInitialized = true\n            } else if e\
    \ < smallestPos {\n                smallestPos = e\n            }\n        } else\
    \ if e < 0 {\n            if !largestNegInitialized {\n                largestNeg\
    \ = e\n                largestNegInitialized = true\n            } else if e >\
    \ largestNeg {\n                largestNeg = e\n            }\n        }\n   \
    \ }\n    if largestNegInitialized {\n        if smallestPosInitialized {\n   \
    \         return []interface{}{largestNeg, smallestPos}\n        } else {\n  \
    \          return []interface{}{largestNeg, nil}\n        }\n    } else {\n  \
    \      if smallestPosInitialized {\n            return []interface{}{nil, smallestPos}\n\
    \        } else {\n            return []interface{}{nil, nil}\n        }\n   \
    \ }\n}\n", "    var largestNegative int\n    var smallestPositive int\n    var\
    \ largestNegativeFound bool\n    var smallestPositiveFound bool\n    for _, num\
    \ := range lst {\n        if num >= 0 {\n            if !smallestPositiveFound\
    \ {\n                smallestPositive = num\n                smallestPositiveFound\
    \ = true\n            } else if num < smallestPositive {\n                smallestPositive\
    \ = num\n            }\n        } else {\n            if !largestNegativeFound\
    \ {\n                largestNegative = num\n                largestNegativeFound\
    \ = true\n            } else if num > largestNegative {\n                largestNegative\
    \ = num\n            }\n        }\n    }\n    if !largestNegativeFound {\n   \
    \     largestNegative = nil\n    }\n    if !smallestPositiveFound {\n        smallestPositive\
    \ = nil\n    }\n    return []interface{}{largestNegative, smallestPositive}\n\
    }\n", "    var res []interface{}\n\n    var largestNeg, smallestPos int\n    largestNeg\
    \ = 0\n    smallestPos = 0\n    for _, num := range lst {\n        if num > 0\
    \ {\n            if smallestPos == 0 {\n                smallestPos = num\n  \
    \          } else if num < smallestPos {\n                smallestPos = num\n\
    \            }\n        } else if num < 0 {\n            if largestNeg == 0 {\n\
    \                largestNeg = num\n            } else if num > largestNeg {\n\
    \                largestNeg = num\n            }\n        }\n    }\n\n    res\
    \ = append(res, largestNeg)\n    res = append(res, smallestPos)\n    return res\n\
    }\n", "    var largest_neg int\n    var smallest_pos int\n    smallest_pos_set\
    \ := false\n    largest_neg_set := false\n    for _, v := range lst {\n      \
    \  if v > 0 {\n            if smallest_pos_set == false {\n                smallest_pos\
    \ = v\n                smallest_pos_set = true\n            } else if v < smallest_pos\
    \ {\n                smallest_pos = v\n            }\n        } else if v < 0\
    \ {\n            if largest_neg_set == false {\n                largest_neg =\
    \ v\n                largest_neg_set = true\n            } else if v > largest_neg\
    \ {\n                largest_neg = v\n            }\n        }\n    }\n    if\
    \ largest_neg_set == false {\n        largest_neg = 0\n    }\n    if smallest_pos_set\
    \ == false {\n        smallest_pos = 0\n    }\n    return []interface{}{largest_neg,\
    \ smallest_pos}\n}\n", "    largest, smallest := 0, 0\n    for _, i := range lst\
    \ {\n        if i > largest {\n            largest = i\n        }\n        if\
    \ i < smallest {\n            smallest = i\n        }\n    }\n    return []interface{}{largest,\
    \ smallest}\n}\n", "    if len(lst) == 0 {\n        return []interface{}{nil,\
    \ nil}\n    }\n    var biggest int\n    var smallest int\n    for _, v := range\
    \ lst {\n        if v < 0 {\n            if biggest < v {\n                biggest\
    \ = v\n            }\n        } else {\n            if smallest == 0 {\n     \
    \           smallest = v\n            } else if smallest > v {\n             \
    \   smallest = v\n            }\n        }\n    }\n    return []interface{}{biggest,\
    \ smallest}\n}\n", "    var largest_negative int\n    var smallest_positive int\n\
    \    var has_positive bool\n    var has_negative bool\n    for _, v := range lst\
    \ {\n        if v > 0 {\n            if !has_positive || v < smallest_positive\
    \ {\n                smallest_positive = v\n            }\n            has_positive\
    \ = true\n        } else if v < 0 {\n            if !has_negative || v > largest_negative\
    \ {\n                largest_negative = v\n            }\n            has_negative\
    \ = true\n        }\n    }\n    if !has_positive {\n        smallest_positive\
    \ = nil\n    }\n    if !has_negative {\n        largest_negative = nil\n    }\n\
    \    return []interface{}{largest_negative, smallest_positive}\n}\n", "    var\
    \ largestNegativeInt int\n    var smallestPositiveInt int\n    var largestNegativeIndex\
    \ int\n    var smallestPositiveIndex int\n    largestNegativeInt = 0\n    smallestPositiveInt\
    \ = 0\n    largestNegativeIndex = -1\n    smallestPositiveIndex = -1\n    for\
    \ index, val := range lst {\n        if val < 0 {\n            if largestNegativeIndex\
    \ == -1 {\n                largestNegativeInt = val\n                largestNegativeIndex\
    \ = index\n            } else if val > largestNegativeInt {\n                largestNegativeInt\
    \ = val\n                largestNegativeIndex = index\n            }\n       \
    \ } else if val > 0 {\n            if smallestPositiveIndex == -1 {\n        \
    \        smallestPositiveInt = val\n                smallestPositiveIndex = index\n\
    \            } else if val < smallestPositiveInt {\n                smallestPositiveInt\
    \ = val\n                smallestPositiveIndex = index\n            }\n      \
    \  }\n    }\n    fmt.Println(largestNegativeInt, smallestPositiveInt)\n    return\
    \ []interface{}{largestNegativeInt, smallestPositiveInt}\n}\n", "    largest_negative,\
    \ smallest_positive := 0, 0\n    for i := 0; i < len(lst); i++ {\n        if lst[i]\
    \ < 0 {\n            if largest_negative < lst[i] {\n                largest_negative\
    \ = lst[i]\n            }\n        } else if lst[i] > 0 {\n            if smallest_positive\
    \ == 0 {\n                smallest_positive = lst[i]\n            } else if smallest_positive\
    \ > lst[i] {\n                smallest_positive = lst[i]\n            }\n    \
    \    }\n    }\n    if largest_negative == 0 {\n        largest_negative = nil\n\
    \    }\n    if smallest_positive == 0 {\n        smallest_positive = nil\n   \
    \ }\n    return []interface{}{largest_negative, smallest_positive}\n}\n", "  \
    \  return nil\n}\n", "\tvar smallest *int\n\tvar largest *int\n\tfor _, n := range\
    \ lst {\n\t\tif n > 0 {\n\t\t\tif smallest == nil || n < *smallest {\n\t\t\t\t\
    smallest = &n\n\t\t\t}\n\t\t} else if n < 0 {\n\t\t\tif largest == nil || n >\
    \ *largest {\n\t\t\t\tlargest = &n\n\t\t\t}\n\t\t}\n\t}\n\tif smallest == nil\
    \ {\n\t\tsmallest = nil\n\t}\n\tif largest == nil {\n\t\tlargest = nil\n\t}\n\t\
    return []interface{}{largest, smallest}\n}\n", "    var (\n        smallestPositive\
    \ int = 0\n        largestNegative int = 0\n        hasPositive bool = false\n\
    \        hasNegative bool = false\n    )\n\n    for _, e := range lst {\n    \
    \    if e > 0 {\n            hasPositive = true\n            if smallestPositive\
    \ == 0 || e < smallestPositive {\n                smallestPositive = e\n     \
    \       }\n        } else if e < 0 {\n            hasNegative = true\n       \
    \     if largestNegative == 0 || e > largestNegative {\n                largestNegative\
    \ = e\n            }\n        }\n    }\n\n    return []interface{}{largestNegative,\
    \ smallestPositive}\n}\n", "    return []interface{}{nil, nil}\n}\n", "    var\
    \ largeNegative, smallPositive int = -1, -1\n    pos := false\n    neg := false\n\
    \    for _, n := range lst {\n        if n > 0 {\n            pos = true\n   \
    \         if smallPositive == -1 || n < smallPositive {\n                smallPositive\
    \ = n\n            }\n        } else if n < 0 {\n            neg = true\n    \
    \        if largeNegative == -1 || n > largeNegative {\n                largeNegative\
    \ = n\n            }\n        }\n    }\n    if !pos {\n        smallPositive =\
    \ -1\n    }\n    if !neg {\n        largeNegative = -1\n    }\n    return []interface{}{largeNegative,\
    \ smallPositive}\n}\n", "    // your code here\n    return nil\n}\n", "    var\
    \ a, b int\n    var neg, pos bool\n\n    for _, n := range lst {\n        if n\
    \ < 0 {\n            if !neg || n > a {\n                a = n\n            }\n\
    \            neg = true\n        } else if n > 0 {\n            if !pos || n <\
    \ b {\n                b = n\n            }\n            pos = true\n        }\n\
    \    }\n\n    var out []interface{}\n    out = append(out, a)\n    out = append(out,\
    \ b)\n    return out\n}\n", "    var a, b interface{} = nil, nil\n    for _, v\
    \ := range lst {\n        if v > 0 {\n            if b == nil || v < b {\n   \
    \             b = v\n            }\n        } else if v < 0 {\n            if\
    \ a == nil || v > a {\n                a = v\n            }\n        }\n    }\n\
    \    return []interface{}{a, b}\n}\n", "    var negaInt, posiInt interface{}\n\
    \    for _, v := range lst {\n        if v < 0 {\n            if negaInt == nil\
    \ {\n                negaInt = v\n            } else if v > negaInt.(int) {\n\
    \                negaInt = v\n            }\n        } else if v > 0 {\n     \
    \       if posiInt == nil {\n                posiInt = v\n            } else if\
    \ v < posiInt.(int) {\n                posiInt = v\n            }\n        }\n\
    \    }\n    return []interface{}{negaInt, posiInt}\n}\n", "    // initialize output\
    \ values\n    largestNegative := -1 * int(^uint(0) >> 1) - 1\n    smallestPositive\
    \ := int(^uint(0) >> 1)\n    maxInt := int(^uint(0) >> 1)\n    minInt := -1 *\
    \ int(^uint(0) >> 1) - 1\n\n    // initialize output list\n    // NOTE: we initialize\
    \ the output list as a list of pointers\n    // because of how interfaces get\
    \ initialized in Golang, if\n    // we initialize the list as a list of interfaces,\
    \ we'd need\n    // to convert the values when we assign them to the list\n  \
    \  // (e.g. lst[0] = &largestNegative, instead of\n    // lst[0] = largestNegative).\
    \ When we return the list, we'll\n    // need to initialize a new list to store\
    \ the values pointed\n    // to by the list's elements and then return that list\
    \ instead\n    // (e.g. retLst := []interface{}{*lst[0], *lst[1]})\n    lst2 :=\
    \ []*interface{}{&largestNegative, &smallestPositive}\n\n    // initialize boolean\
    \ variables to check if largestNegative\n    // and smallestPositive have been\
    \ updated\n    largestNegativeUpdated := false\n    smallestPositiveUpdated :=\
    \ false\n\n    // iterate through list of integers\n    for _, n := range lst\
    \ {\n        // check if current number is negative\n        if n < 0 {\n    \
    \        // check if current number is larger than largestNegative\n         \
    \   if n > largestNegative {\n                // set largestNegative to current\
    \ number\n                lst2[0] = &n\n                // set largestNegativeUpdated\
    \ to true\n                largestNegativeUpdated = true\n            }\n    \
    \    } else if n > 0 {\n            // check if current number is smaller than\
    \ smallestPositive\n            if n < smallestPositive {\n                //\
    \ set smallestPositive to current number\n                lst2[1] = &n\n     \
    \           // set smallestPositiveUpdated to true\n                smallestPositiveUpdated\
    \ = true\n            }\n        }\n    }\n\n    // check if largestNegative was\
    \ not updated\n    if !largestNegativeUpdated {\n        // set largestNegative\
    \ to None\n", "    smallest_positive := 0\n    largest_negative := 0\n    first_positive\
    \ := false\n    first_negative := false\n    var result []interface{}\n    for\
    \ _, v := range lst {\n        if v >= 0 {\n            if !first_positive {\n\
    \                smallest_positive = v\n                first_positive = true\n\
    \            } else if v < smallest_positive {\n                smallest_positive\
    \ = v\n            }\n        } else {\n            if !first_negative {\n   \
    \             largest_negative = v\n                first_negative = true\n  \
    \          } else if v > largest_negative {\n                largest_negative\
    \ = v\n            }\n        }\n    }\n    if first_positive {\n        result\
    \ = append(result, nil)\n        result = append(result, smallest_positive)\n\
    \    } else {\n        result = append(result, nil)\n        result = append(result,\
    \ nil)\n    }\n    if first_negative {\n        result = append(result, largest_negative)\n\
    \        result = append(result, nil)\n    } else {\n        result = append(result,\
    \ nil)\n        result = append(result, nil)\n    }\n    return result\n}\n",
  "    var neg_num int\n    var pos_num int\n    if lst == nil {\n        return []interface{}{nil,\
    \ nil}\n    } else {\n        for _, num := range lst {\n            if num <\
    \ 0 {\n                if neg_num < num {\n                    neg_num = num\n\
    \                }\n            } else if num > 0 {\n                if pos_num\
    \ == 0 {\n                    pos_num = num\n                } else if pos_num\
    \ > num {\n                    pos_num = num\n                }\n            }\n\
    \        }\n        return []interface{}{neg_num, pos_num}\n    }\n}\n", "   \
    \ max_neg := new(int)\n    min_pos := new(int)\n    *max_neg = 0\n    *min_pos\
    \ = 0\n    for _, value := range lst {\n        if value < 0 {\n            if\
    \ value > *max_neg {\n                *max_neg = value\n            }\n      \
    \  } else if value > 0 {\n            if value < *min_pos {\n                *min_pos\
    \ = value\n            }\n        }\n    }\n    if *max_neg == 0 && *min_pos ==\
    \ 0 {\n        return []interface{}{nil, nil}\n    } else if *max_neg == 0 {\n\
    \        return []interface{}{nil, *min_pos}\n    } else if *min_pos == 0 {\n\
    \        return []interface{}{*max_neg, nil}\n    } else {\n        return []interface{}{*max_neg,\
    \ *min_pos}\n    }\n}\n", "    var a, b interface{} = nil, nil\n    var lst_a,\
    \ lst_b []int\n    for _, x := range lst {\n        if x > 0 {\n            lst_b\
    \ = append(lst_b, x)\n        } else if x < 0 {\n            lst_a = append(lst_a,\
    \ x)\n        }\n    }\n    if len(lst_a) > 0 {\n        a = lst_a[0]\n      \
    \  for _, x := range lst_a {\n            if x > a.(int) {\n                a\
    \ = x\n            }\n        }\n    }\n    if len(lst_b) > 0 {\n        b = lst_b[0]\n\
    \        for _, x := range lst_b {\n            if x < b.(int) {\n           \
    \     b = x\n            }\n        }\n    }\n    return []interface{}{a, b}\n\
    }\n", "    var ls []interface{}\n\n    var highest, lowest int\n\n    for _, v\
    \ := range lst {\n        if v < 0 {\n            if v > highest {\n         \
    \       highest = v\n            }\n        } else if v > 0 {\n            if\
    \ v < lowest {\n                lowest = v\n            }\n        }\n    }\n\n\
    \    ls = append(ls, highest, lowest)\n\n    return ls\n}\n", "    var max, min\
    \ int\n    max, min = 0, 0\n    lstLen := len(lst)\n    if lstLen == 0 {\n   \
    \     return []interface{}{nil, nil}\n    }\n\n    maxFound := false\n    minFound\
    \ := false\n    for i := 0; i < lstLen; i++ {\n        if lst[i] > 0 {\n     \
    \       if !minFound {\n                min = lst[i]\n                minFound\
    \ = true\n            } else if lst[i] < min {\n                min = lst[i]\n\
    \            }\n        } else if lst[i] < 0 {\n            if !maxFound {\n \
    \               max = lst[i]\n                maxFound = true\n            } else\
    \ if lst[i] > max {\n                max = lst[i]\n            }\n        }\n\
    \    }\n\n    if maxFound {\n        return []interface{}{max, min}\n    } else\
    \ {\n        return []interface{}{nil, min}\n    }\n}\n", "    if len(lst) ==\
    \ 0 {\n        return []interface{}{nil, nil}\n    }\n    var smallest int\n \
    \   var largest int\n    for _, v := range lst {\n        if v > 0 {\n       \
    \     if smallest == 0 {\n                smallest = v\n            } else if\
    \ v < smallest {\n                smallest = v\n            }\n        } else\
    \ if v < 0 {\n            if largest == 0 {\n                largest = v\n   \
    \         } else if v > largest {\n                largest = v\n            }\n\
    \        }\n    }\n    return []interface{}{largest, smallest}\n}\n", "    var\
    \ a, b interface{}\n    var has_positives, has_negatives bool\n\n    for _, item\
    \ := range lst {\n        if item > 0 {\n            if !has_positives {\n   \
    \             b = item\n                has_positives = true\n            }\n\
    \            if item < b.(int) {\n                b = item\n            }\n  \
    \      } else if item < 0 {\n            if !has_negatives {\n               \
    \ a = item\n                has_negatives = true\n            }\n            if\
    \ item > a.(int) {\n                a = item\n            }\n        }\n    }\n\
    \n    if !has_positives {\n        b = nil\n    }\n    if !has_negatives {\n \
    \       a = nil\n    }\n\n    return []interface{}{a, b}\n}\n", "    var pos_lst\
    \ []int\n    var neg_lst []int\n    for _, val := range lst {\n        if val\
    \ > 0 {\n            pos_lst = append(pos_lst, val)\n        } else if val < 0\
    \ {\n            neg_lst = append(neg_lst, val)\n        }\n    }\n    if len(pos_lst)\
    \ == 0 {\n        pos_lst = append(pos_lst, 0)\n    }\n    if len(neg_lst) ==\
    \ 0 {\n        neg_lst = append(neg_lst, 0)\n    }\n    pos_num := min(pos_lst)\n\
    \    neg_num := max(neg_lst)\n    return []interface{}{neg_num, pos_num}\n}\n",
  "    if len(lst) < 1 {\n        return []interface{}{nil, nil}\n    }\n    var largestNegative\
    \ int\n    var smallestPositive int\n    for _, n := range lst {\n        if n\
    \ < 0 {\n            if largestNegative < n {\n                largestNegative\
    \ = n\n            }\n        } else {\n            if smallestPositive == 0 ||\
    \ smallestPositive > n {\n                smallestPositive = n\n            }\n\
    \        }\n    }\n    return []interface{}{largestNegative, smallestPositive}\n\
    }\n", "    var a, b int\n    var positive, negative bool\n    negative = false\n\
    \    positive = false\n    for _, value := range lst {\n        if value > 0 {\n\
    \            if !positive {\n                positive = true\n               \
    \ b = value\n            } else if value < b {\n                b = value\n  \
    \          }\n        } else if value < 0 {\n            if !negative {\n    \
    \            negative = true\n                a = value\n            } else if\
    \ value > a {\n                a = value\n            }\n        }\n    }\n  \
    \  if !positive {\n        b = nil\n    }\n    if !negative {\n        a = nil\n\
    \    }\n    return []interface{}{a, b}\n}\n", "    var positive []int\n    var\
    \ negative []int\n    for _, v := range lst {\n        if v < 0 {\n          \
    \  negative = append(negative, v)\n        } else if v > 0 {\n            positive\
    \ = append(positive, v)\n        }\n    }\n    var result []interface{}\n    if\
    \ len(negative) > 0 {\n        result = append(result, largest_element(negative))\n\
    \    } else {\n        result = append(result, nil)\n    }\n    if len(positive)\
    \ > 0 {\n        result = append(result, smallest_element(positive))\n    } else\
    \ {\n        result = append(result, nil)\n    }\n    return result\n}\n", " \
    \   if lst == nil {\n        return []interface{}{nil, nil}\n    }\n    var positive_arr\
    \ []int\n    var negative_arr []int\n    for _, v := range lst {\n        if v\
    \ > 0 {\n            positive_arr = append(positive_arr, v)\n        } else if\
    \ v < 0 {\n            negative_arr = append(negative_arr, v)\n        }\n   \
    \ }\n    return []interface{}{max(negative_arr), min(positive_arr)}\n}\n", " \
    \   // Get max and min of ints in a slice\n    var largest_negative int\n    var\
    \ smallest_positive int\n    for _, num := range lst {\n        if num < 0 {\n\
    \            if largest_negative < num {\n                largest_negative = num\n\
    \            }\n        } else {\n            if smallest_positive > num || smallest_positive\
    \ == 0 {\n                smallest_positive = num\n            }\n        }\n\
    \    }\n    // Use nil if there are none\n    if largest_negative == 0 {\n   \
    \     largest_negative = nil\n    }\n    if smallest_positive == 0 {\n       \
    \ smallest_positive = nil\n    }\n    // Return as slice\n    return []interface{}{largest_negative,\
    \ smallest_positive}\n}\n", "    largest, smallest := -1, 1\n    flag_largest,\
    \ flag_smallest := false, false\n    for _, v := range lst {\n        if v < 0\
    \ {\n            flag_largest = true\n            if v > largest {\n         \
    \       largest = v\n            }\n        } else if v > 0 {\n            flag_smallest\
    \ = true\n            if v < smallest {\n                smallest = v\n      \
    \      }\n        }\n    }\n    if !flag_largest {\n        largest = 0\n    }\n\
    \    if !flag_smallest {\n        smallest = 0\n    }\n    return []interface{}{largest,\
    \ smallest}\n}\n", "\treturn nil\n}\n", "    var pmin, pmax int\n    var nmin,\
    \ nmax int\n    pmin = 0\n    pmax = 0\n    nmin = 0\n    nmax = 0\n    isNegative\
    \ := false\n    isPositive := false\n    // find largest and smallest positive\n\
    \    for _, v := range lst {\n        if v < 0 {\n            isNegative = true\n\
    \            if nmin == 0 || v < nmin {\n                nmin = v\n          \
    \  }\n            if nmax == 0 || v > nmax {\n                nmax = v\n     \
    \       }\n        } else if v > 0 {\n            isPositive = true\n        \
    \    if pmin == 0 || v < pmin {\n                pmin = v\n            }\n   \
    \         if pmax == 0 || v > pmax {\n                pmax = v\n            }\n\
    \        }\n    }\n    if !isNegative {\n        nmin = 0\n        nmax = 0\n\
    \    }\n    if !isPositive {\n        pmin = 0\n        pmax = 0\n    }\n    return\
    \ []interface{}{nmax, pmin}\n}\n", "    var a, b int\n    for _, n := range lst\
    \ {\n        if n > 0 {\n            if n < b || b == 0 {\n                b =\
    \ n\n            }\n        } else if n < 0 {\n            if n > a || a == 0\
    \ {\n                a = n\n            }\n        }\n    }\n    return []interface{}{a,\
    \ b}\n}\n", "    var largestNegative, smallestPositive int\n    var largestNegativeFlag,\
    \ smallestPositiveFlag bool\n    for _, n := range lst {\n        if n < 0 {\n\
    \            if !largestNegativeFlag {\n                largestNegative = n\n\
    \                largestNegativeFlag = true\n            } else if n > largestNegative\
    \ {\n                largestNegative = n\n            }\n        } else if n >\
    \ 0 {\n            if !smallestPositiveFlag {\n                smallestPositive\
    \ = n\n                smallestPositiveFlag = true\n            } else if n <\
    \ smallestPositive {\n                smallestPositive = n\n            }\n  \
    \      }\n    }\n    var result = []interface{}{}\n    if largestNegativeFlag\
    \ {\n        result = append(result, largestNegative)\n    } else {\n        result\
    \ = append(result, nil)\n    }\n    if smallestPositiveFlag {\n        result\
    \ = append(result, smallestPositive)\n    } else {\n        result = append(result,\
    \ nil)\n    }\n    return result\n}\n", "    var largestNeg int\n    var smallestPos\
    \ int\n    var nagtiveExist bool\n    var postiveExist bool\n    for _, v := range\
    \ lst {\n        if v < 0 {\n            if !nagtiveExist {\n                largestNeg\
    \ = v\n                nagtiveExist = true\n            } else if v > largestNeg\
    \ {\n                largestNeg = v\n            }\n        } else if v > 0 {\n\
    \            if !postiveExist {\n                smallestPos = v\n           \
    \     postiveExist = true\n            } else if v < smallestPos {\n         \
    \       smallestPos = v\n            }\n        }\n    }\n    if !nagtiveExist\
    \ {\n        largestNeg = nil\n    }\n    if !postiveExist {\n        smallestPos\
    \ = nil\n    }\n    return []interface{}{largestNeg, smallestPos}\n}\n", "   \
    \ nn := 0\n    n := 0\n    p := 0\n    pp := 0\n    for _, v := range lst {\n\
    \        if v < 0 {\n            if v < nn {\n                nn = v\n       \
    \     }\n            n = nn\n        } else if v > 0 {\n            if v > pp\
    \ {\n                pp = v\n            }\n            p = pp\n        }\n  \
    \  }\n    if n == 0 {\n        n = nil\n    }\n    if p == 0 {\n        p = nil\n\
    \    }\n    return []interface{}{n, p}\n}\n", "    return lst\n}\n", "    return\
    \ []interface{}{nil, nil}\n}\n", "    if len(lst) == 0 {\n        return []interface{}{nil,\
    \ nil}\n    }\n    var largestNegative, smallestPositive int = 0, 0\n    isLargestNegativeFound,\
    \ isSmallestPositiveFound := false, false\n    for _, val := range lst {\n   \
    \     if val < 0 {\n            if isLargestNegativeFound {\n                if\
    \ val > largestNegative {\n                    largestNegative = val\n       \
    \         }\n            } else {\n                largestNegative = val\n   \
    \             isLargestNegativeFound = true\n            }\n        } else if\
    \ val > 0 {\n            if isSmallestPositiveFound {\n                if val\
    \ < smallestPositive {\n                    smallestPositive = val\n         \
    \       }\n            } else {\n                smallestPositive = val\n    \
    \            isSmallestPositiveFound = true\n            }\n        }\n    }\n\
    \    if !isLargestNegativeFound {\n        largestNegative = nil\n    }\n    if\
    \ !isSmallestPositiveFound {\n        smallestPositive = nil\n    }\n    return\
    \ []interface{}{largestNegative, smallestPositive}\n}\n", "    var smallest, largest\
    \ int\n    var largestFound, smallestFound bool\n    for _, e := range lst {\n\
    \        if e > 0 {\n            if !smallestFound {\n                smallest\
    \ = e\n                smallestFound = true\n            } else if e < smallest\
    \ {\n                smallest = e\n            }\n        } else if e < 0 {\n\
    \            if !largestFound {\n                largest = e\n               \
    \ largestFound = true\n            } else if e > largest {\n                largest\
    \ = e\n            }\n        }\n    }\n    if !largestFound {\n        largest\
    \ = 0\n    }\n    if !smallestFound {\n        smallest = 0\n    }\n    return\
    \ []interface{}{largest, smallest}\n}\n", "    if len(lst) == 0 {\n        return\
    \ []interface{}{nil, nil}\n    }\n    neg := make([]int, 0)\n    pos := make([]int,\
    \ 0)\n    for _, v := range lst {\n        if v > 0 {\n            pos = append(pos,\
    \ v)\n        } else if v < 0 {\n            neg = append(neg, v)\n        }\n\
    \    }\n    if len(neg) == 0 {\n        neg = append(neg, nil)\n    } else {\n\
    \        tmp := neg[0]\n        for _, v := range neg {\n            if v > tmp\
    \ {\n                tmp = v\n            }\n        }\n        neg = []int{tmp}\n\
    \    }\n    if len(pos) == 0 {\n        pos = append(pos, nil)\n    } else {\n\
    \        tmp := pos[0]\n        for _, v := range pos {\n            if v < tmp\
    \ {\n                tmp = v\n            }\n        }\n        pos = []int{tmp}\n\
    \    }\n    return []interface{}{neg[0], pos[0]}\n}\n", "    largest_of_negative_integers\
    \ := -1\n    smallest_of_positive_integers := -1\n    for _, element := range\
    \ lst {\n        if element < 0 {\n            if element > largest_of_negative_integers\
    \ {\n                largest_of_negative_integers = element\n            }\n \
    \       } else if element > 0 {\n            if smallest_of_positive_integers\
    \ == -1 {\n                smallest_of_positive_integers = element\n         \
    \   } else if element < smallest_of_positive_integers {\n                smallest_of_positive_integers\
    \ = element\n            }\n        }\n    }\n    if largest_of_negative_integers\
    \ == -1 {\n        largest_of_negative_integers = nil\n    }\n    if smallest_of_positive_integers\
    \ == -1 {\n        smallest_of_positive_integers = nil\n    }\n    return []interface{}{largest_of_negative_integers,\
    \ smallest_of_positive_integers}\n}\n", "\tvar (\n\t\tlargestNeg int\n\t\tsmallestPos\
    \ int\n\t)\n\tlargestNeg = lst[0]\n\tsmallestPos = lst[0]\n\tfor i := 0; i < len(lst);\
    \ i++ {\n\t\tif lst[i] < 0 {\n\t\t\tif lst[i] > largestNeg {\n\t\t\t\tlargestNeg\
    \ = lst[i]\n\t\t\t}\n\t\t} else if lst[i] > 0 {\n\t\t\tif lst[i] < smallestPos\
    \ {\n\t\t\t\tsmallestPos = lst[i]\n\t\t\t}\n\t\t}\n\t}\n\treturn []interface{}{largestNeg,\
    \ smallestPos}\n}\n", "    var smallestPositive int\n    var largestNegative int\n\
    \    var existsNegative bool\n    var existsPositive bool\n    for _, element\
    \ := range lst {\n        if (element > 0) {\n            existsPositive = true\n\
    \            if (smallestPositive == 0 || element < smallestPositive) {\n    \
    \            smallestPositive = element\n            }\n        } else if (element\
    \ < 0) {\n            existsNegative = true\n            if (largestNegative ==\
    \ 0 || element > largestNegative) {\n                largestNegative = element\n\
    \            }\n        }\n    }\n    if (!existsNegative) {\n        largestNegative\
    \ = nil\n    }\n    if (!existsPositive) {\n        smallestPositive = nil\n \
    \   }\n    return []interface{}{largestNegative, smallestPositive}\n}\n", "  \
    \  var smallest int\n    var largest int\n    for _, i := range lst {\n      \
    \  if i > 0 {\n            if smallest == 0 {\n                smallest = i\n\
    \            } else if i < smallest {\n                smallest = i\n        \
    \    }\n        } else if i < 0 {\n            if largest == 0 {\n           \
    \     largest = i\n            } else if i > largest {\n                largest\
    \ = i\n            }\n        }\n    }\n    return []interface{}{largest, smallest}\n\
    }\n", "\t\n\tif len(lst) == 0 {\n\t\treturn []interface{}{ nil, nil }\n\t}\n\t\
    \n\t// Find smallest positive integer\n\tminPos := lst[0]\n\tfor _, num := range\
    \ lst {\n\t\tif num > 0 && num < minPos {\n\t\t\tminPos = num\n\t\t}\n\t}\n\t\n\
    \t// Find largest negative integer\n\tmaxNeg := lst[0]\n\tfor _, num := range\
    \ lst {\n\t\tif num < 0 && num > maxNeg {\n\t\t\tmaxNeg = num\n\t\t}\n\t}\n\t\n\
    \treturn []interface{}{maxNeg, minPos}\n}\n", "    var largest_negative, smallest_positive\
    \ int\n    var largest_negative_found, smallest_positive_found bool\n    for _,\
    \ n := range lst {\n        if n < 0 {\n            if largest_negative_found\
    \ {\n                if n > largest_negative {\n                    largest_negative\
    \ = n\n                }\n            } else {\n                largest_negative\
    \ = n\n                largest_negative_found = true\n            }\n        }\
    \ else if n > 0 {\n            if smallest_positive_found {\n                if\
    \ n < smallest_positive {\n                    smallest_positive = n\n       \
    \         }\n            } else {\n                smallest_positive = n\n   \
    \             smallest_positive_found = true\n            }\n        }\n    }\n\
    \    if !largest_negative_found {\n        largest_negative = 0\n    }\n    if\
    \ !smallest_positive_found {\n        smallest_positive = 0\n    }\n    return\
    \ []interface{}{largest_negative, smallest_positive}\n}\n", "    negLargest :=\
    \ -1\n    posSmallest := 1\n    foundNeg := false\n    foundPos := false\n   \
    \ for _, v := range lst {\n        if v < 0 {\n            if !foundNeg || v >\
    \ negLargest {\n                negLargest = v\n                foundNeg = true\n\
    \            }\n        } else if v > 0 {\n            if !foundPos || v < posSmallest\
    \ {\n                posSmallest = v\n                foundPos = true\n      \
    \      }\n        }\n    }\n    if !foundNeg {\n        negLargest = nil\n   \
    \ }\n    if !foundPos {\n        posSmallest = nil\n    }\n    return []interface{}{negLargest,\
    \ posSmallest}\n}\n", "    var negative, positive int\n    var isNegative, isPositive\
    \ bool\n    for _, num := range lst {\n        if num < 0 {\n            isNegative\
    \ = true\n            if num > negative {\n                negative = num\n  \
    \          }\n        } else if num > 0 {\n            isPositive = true\n   \
    \         if num < positive || positive == 0 {\n                positive = num\n\
    \            }\n        }\n    }\n    return []interface{}{negative, positive}\n\
    }\n", "    var largest_neg_int int\n    var smallest_pos_int int\n    var largest,\
    \ smallest interface{}\n    var pos_int, neg_int bool\n    var output []interface{}\n\
    \n    for _, num := range lst {\n        if num > 0 {\n            if !pos_int\
    \ {\n                smallest_pos_int = num\n                pos_int = true\n\
    \            } else if num < smallest_pos_int {\n                smallest_pos_int\
    \ = num\n            }\n        } else if num < 0 {\n            if !neg_int {\n\
    \                largest_neg_int = num\n                neg_int = true\n     \
    \       } else if num > largest_neg_int {\n                largest_neg_int = num\n\
    \            }\n        }\n    }\n\n    if pos_int {\n        smallest = smallest_pos_int\n\
    \    } else {\n        smallest = nil\n    }\n\n    if neg_int {\n        largest\
    \ = largest_neg_int\n    } else {\n        largest = nil\n    }\n\n    output\
    \ = append(output, largest, smallest)\n    return output\n}\n", "    var largestNegative,\
    \ smallestPositive int\n    largestNegativeInitialized := false\n    smallestPositiveInitialized\
    \ := false\n    for _, i := range lst {\n        if i < 0 {\n            if !largestNegativeInitialized\
    \ {\n                largestNegative = i\n                largestNegativeInitialized\
    \ = true\n            } else if i > largestNegative {\n                largestNegative\
    \ = i\n            }\n        } else if i > 0 {\n            if !smallestPositiveInitialized\
    \ {\n                smallestPositive = i\n                smallestPositiveInitialized\
    \ = true\n            } else if i < smallestPositive {\n                smallestPositive\
    \ = i\n            }\n        }\n    }\n    if !largestNegativeInitialized {\n\
    \        largestNegative = 0\n    }\n    if !smallestPositiveInitialized {\n \
    \       smallestPositive = 0\n    }\n    return []interface{}{largestNegative,\
    \ smallestPositive}\n}\n", "    var largestNegative, smallestPositive int = 0,\
    \ 0\n    var hasNegative, hasPositive bool = false, false\n    for _, v := range\
    \ lst {\n        if v < 0 {\n            if !hasNegative || largestNegative <\
    \ v {\n                largestNegative = v\n            }\n            hasNegative\
    \ = true\n        } else if v > 0 {\n            if !hasPositive || smallestPositive\
    \ > v {\n                smallestPositive = v\n            }\n            hasPositive\
    \ = true\n        }\n    }\n    var result []interface{}\n    if hasNegative {\n\
    \        result = append(result, largestNegative)\n    } else {\n        result\
    \ = append(result, nil)\n    }\n    if hasPositive {\n        result = append(result,\
    \ smallestPositive)\n    } else {\n        result = append(result, nil)\n    }\n\
    \    return result\n}\n", "    var lrgNeg, lstPos *int = nil, nil\n    for _,\
    \ x := range lst {\n        if x > 0 {\n            if lstPos == nil || x < *lstPos\
    \ {\n                lstPos = &x\n            }\n        } else if x < 0 {\n \
    \           if lrgNeg == nil || x > *lrgNeg {\n                lrgNeg = &x\n \
    \           }\n        }\n    }\n    return []interface{}{lrgNeg, lstPos}\n}\n",
  "    fmt.Println(lst)\n    return []interface{}{}\n}\n", "    var largestNegative\
    \ int = 0\n    var smallestPositive int = 0\n    for _, v := range lst {\n   \
    \     if v < 0 {\n            if v < largestNegative {\n                largestNegative\
    \ = v\n            }\n        } else {\n            if v > smallestPositive {\n\
    \                smallestPositive = v\n            }\n        }\n    }\n    if\
    \ largestNegative == 0 && smallestPositive == 0 {\n        return []interface{}{nil,\
    \ nil}\n    }\n    return []interface{}{largestNegative, smallestPositive}\n}\n",
  "    pos, neg := []int{}, []int{}\n    for _, v := range lst {\n        if v > 0\
    \ {\n            pos = append(pos, v)\n        } else if v < 0 {\n           \
    \ neg = append(neg, v)\n        }\n    }\n    if len(pos) == 0 {\n        pos\
    \ = append(pos, nil)\n    }\n    if len(neg) == 0 {\n        neg = append(neg,\
    \ nil)\n    }\n    return []interface{}{neg[0], pos[0]}\n}\n", "    var a interface{}\
    \ = nil\n    var b interface{} = nil\n    var hasNegative, hasPositive bool\n\
    \    for _, i := range lst {\n        if i < 0 {\n            hasNegative = true\n\
    \            if a == nil || i > a {\n                a = i\n            }\n  \
    \      } else if i > 0 {\n            hasPositive = true\n            if b ==\
    \ nil || i < b {\n                b = i\n            }\n        }\n    }\n   \
    \ if !hasNegative {\n        a = nil\n    }\n    if !hasPositive {\n        b\
    \ = nil\n    }\n    return []interface{}{a, b}\n}\n", "    // find largest and\
    \ smallest elements\n    var max, min int\n    for _, n := range lst {\n     \
    \   if n > max {\n            max = n\n        }\n        if n < min {\n     \
    \       min = n\n        }\n    }\n    // check if they are negative or positive\n\
    \    var result []interface{}\n    if max < 0 {\n        result = append(result,\
    \ max)\n    } else {\n        result = append(result, nil)\n    }\n    if min\
    \ > 0 {\n        result = append(result, min)\n    } else {\n        result =\
    \ append(result, nil)\n    }\n    return result\n}\n", "    return []interface{}{}\n\
    }\n", "    var largestNegative, smallestPositive int\n    var smallestPositiveInitialized\
    \ bool = false\n    var largestNegativeInitialized bool = false\n    for _, v\
    \ := range lst {\n        if v > 0 {\n            if smallestPositiveInitialized\
    \ == false {\n                smallestPositive = v\n                smallestPositiveInitialized\
    \ = true\n            } else if v < smallestPositive {\n                smallestPositive\
    \ = v\n            }\n        } else if v < 0 {\n            if largestNegativeInitialized\
    \ == false {\n                largestNegative = v\n                largestNegativeInitialized\
    \ = true\n            } else if v > largestNegative {\n                largestNegative\
    \ = v\n            }\n        }\n    }\n    if smallestPositiveInitialized ==\
    \ false {\n        smallestPositive = nil\n    }\n    if largestNegativeInitialized\
    \ == false {\n        largestNegative = nil\n    }\n    return []interface{}{largestNegative,\
    \ smallestPositive}\n}\n", "    var largest int\n    var smallest int\n    for\
    \ _, n := range lst {\n        if largest < n {\n            largest = n\n   \
    \     }\n        if smallest > n {\n            smallest = n\n        }\n    }\n\
    \    return []interface{}{largest, smallest}\n}\n", "    res := []interface{}{}\n\
    \    if len(lst) == 0 {\n        res = append(res, nil, nil)\n        return res\n\
    \    }\n    return find_extremes(lst)\n}\n", "    var largest_int int\n    var\
    \ smallest_int int\n    var largest_seen bool\n    var smallest_seen bool\n  \
    \  for _, value := range lst {\n        if value < 0 {\n            if !largest_seen\
    \ {\n                largest_int = value\n                largest_seen = true\n\
    \            } else if value > largest_int {\n                largest_int = value\n\
    \            }\n        } else if value > 0 {\n            if !smallest_seen {\n\
    \                smallest_int = value\n                smallest_seen = true\n\
    \            } else if value < smallest_int {\n                smallest_int =\
    \ value\n            }\n        }\n    }\n    fmt.Println(largest_int, smallest_int)\n\
    \    return []interface{}{largest_int, smallest_int}\n}\n", "    var largestNeg\
    \ int\n    var smallestPos int\n    var largestNegSet bool\n    var smallestPosSet\
    \ bool\n    for _, x := range lst {\n        if x > 0 {\n            if smallestPosSet\
    \ {\n                if x < smallestPos {\n                    smallestPos = x\n\
    \                }\n            } else {\n                smallestPos = x\n  \
    \              smallestPosSet = true\n            }\n        } else if x < 0 {\n\
    \            if largestNegSet {\n                if x > largestNeg {\n       \
    \             largestNeg = x\n                }\n            } else {\n      \
    \          largestNeg = x\n                largestNegSet = true\n            }\n\
    \        }\n    }\n    var a interface{}\n    var b interface{}\n    if largestNegSet\
    \ {\n        a = largestNeg\n    } else {\n        a = nil\n    }\n    if smallestPosSet\
    \ {\n        b = smallestPos\n    } else {\n        b = nil\n    }\n    return\
    \ []interface{}{a, b}\n}\n", "    a, b := None, None\n    negative := []int{}\n\
    \    positive := []int{}\n    for _, v := range lst {\n        if v < 0 {\n  \
    \          negative = append(negative, v)\n        } else if v > 0 {\n       \
    \     positive = append(positive, v)\n        }\n    }\n    if len(negative) >\
    \ 0 {\n        a = negative[0]\n        for _, v := range negative {\n       \
    \     if v > a {\n                a = v\n            }\n        }\n    }\n   \
    \ if len(positive) > 0 {\n        b = positive[0]\n        for _, v := range positive\
    \ {\n            if v < b {\n                b = v\n            }\n        }\n\
    \    }\n    return []interface{}{a, b}\n}\n\ntype TestData ", "    negative :=\
    \ make([]int, 0)\n    positive := make([]int, 0)\n    for _, i := range lst {\n\
    \        if i > 0 {\n            positive = append(positive, i)\n        } else\
    \ if i < 0 {\n            negative = append(negative, i)\n        }\n    }\n \
    \   var a, b int\n    if len(negative) > 0 {\n        a = negative[0]\n      \
    \  for _, i := range negative {\n            if i > a {\n                a = i\n\
    \            }\n        }\n    } else {\n        a = 0\n    }\n    if len(positive)\
    \ > 0 {\n        b = positive[0]\n        for _, i := range positive {\n     \
    \       if i < b {\n                b = i\n            }\n        }\n    } else\
    \ {\n        b = 0\n    }\n    return []interface{}{a, b}\n}\n", "    return []interface{}{nil,\
    \ nil}\n}\n", "    smallest, largest := 1, -1\n    for _, v := range lst {\n \
    \       if v > 0 && v < smallest {\n            smallest = v\n        } else if\
    \ v < 0 && v > largest {\n            largest = v\n        }\n    }\n    if smallest\
    \ == 1 && largest == -1 {\n        return []interface{}{nil, nil}\n    }\n   \
    \ return []interface{}{largest, smallest}\n}\n", "    if len(lst) < 1 {\n    \
    \    return []interface{}{nil, nil}\n    }\n    var maxNeg, minPos int\n    for\
    \ _, n := range lst {\n        if n < 0 {\n            if maxNeg < n {\n     \
    \           maxNeg = n\n            }\n        } else {\n            if minPos\
    \ > n || minPos == 0 {\n                minPos = n\n            }\n        }\n\
    \    }\n    return []interface{}{maxNeg, minPos}\n}\n", "    // Write your code\
    \ here\n    return []interface{}{nil, nil}\n}\n", "    var largest, smallest int\n\
    \    var largest_flag, smallest_flag bool\n\n    for _, v := range lst {\n   \
    \     if largest_flag == false && v < 0 {\n            largest = v\n         \
    \   largest_flag = true\n        } else if largest_flag == true && v < 0 && v\
    \ > largest {\n            largest = v\n        }\n\n        if smallest_flag\
    \ == false && v > 0 {\n            smallest = v\n            smallest_flag = true\n\
    \        } else if smallest_flag == true && v > 0 && v < smallest {\n        \
    \    smallest = v\n        }\n    }\n\n    if largest_flag {\n        return []interface{}{largest,\
    \ smallest}\n    } else {\n        return []interface{}{nil, nil}\n    }\n}\n",
  "    var largest, smallest int\n    var found_positives, found_negatives bool\n\
    \    for _, i := range lst {\n        if i > 0 {\n            if !found_positives\
    \ {\n                smallest = i\n                found_positives = true\n  \
    \          } else if i < smallest {\n                smallest = i\n          \
    \  }\n        } else if i < 0 {\n            if !found_negatives {\n         \
    \       largest = i\n                found_negatives = true\n            } else\
    \ if i > largest {\n                largest = i\n            }\n        }\n  \
    \  }\n    if !found_positives {\n        smallest = nil\n    }\n    if !found_negatives\
    \ {\n        largest = nil\n    }\n    return []interface{}{largest, smallest}\n\
    }\n", "    var a, b interface{} = nil, nil\n    for _, v := range lst {\n    \
    \    if v < 0 {\n            if a == nil {\n                a = v\n          \
    \  } else if v > a.(int) {\n                a = v\n            }\n        } else\
    \ if v > 0 {\n            if b == nil {\n                b = v\n            }\
    \ else if v < b.(int) {\n                b = v\n            }\n        }\n   \
    \ }\n    return []interface{}{a, b}\n}\n", "    var largestNegative int\n    var\
    \ smallestPositive int\n    if len(lst) == 0 {\n        return []interface{}{nil,\
    \ nil}\n    }\n    for _, v := range lst {\n        if v < 0 {\n            if\
    \ largestNegative == 0 {\n                largestNegative = v\n            } else\
    \ if v > largestNegative {\n                largestNegative = v\n            }\n\
    \        } else if v > 0 {\n            if smallestPositive == 0 {\n         \
    \       smallestPositive = v\n            } else if v < smallestPositive {\n \
    \               smallestPositive = v\n            }\n        }\n    }\n    if\
    \ largestNegative == 0 {\n        largestNegative = nil\n    }\n    if smallestPositive\
    \ == 0 {\n        smallestPositive = nil\n    }\n    return []interface{}{largestNegative,\
    \ smallestPositive}\n}\n", "    var a, b interface{}\n    a = nil\n    b = nil\n\
    \    for _, v := range lst {\n        if v > 0 {\n            if b == nil {\n\
    \                b = v\n            } else if v < b.(int) {\n                b\
    \ = v\n            }\n        } else if v < 0 {\n            if a == nil {\n \
    \               a = v\n            } else if v > a.(int) {\n                a\
    \ = v\n            }\n        }\n    }\n    return []interface{}{a, b}\n}\n",
  "    var largest, smallest int = 0, 0\n    if len(lst) > 0 {\n        largest =\
    \ lst[0]\n        smallest = lst[0]\n    }\n    for _, value := range lst {\n\
    \        if value < smallest {\n            smallest = value\n        }\n    \
    \    if value > largest {\n            largest = value\n        }\n    }\n   \
    \ if largest > 0 && smallest < 0 {\n        return []interface{}{largest, smallest}\n\
    \    }\n    return []interface{}{nil, nil}\n}\n", "    var l int\n    l = len(lst)\n\
    \    if l > 0 {\n        var smallest_int int\n        var largest_int int\n \
    \       smallest_int = lst[0]\n        largest_int = lst[0]\n        for i :=\
    \ 0; i < l; i++ {\n            if lst[i] < smallest_int {\n                smallest_int\
    \ = lst[i]\n            }\n            if lst[i] > largest_int {\n           \
    \     largest_int = lst[i]\n            }\n        }\n        if smallest_int\
    \ < 0 {\n            if largest_int > 0 {\n                return []interface{}{largest_int,\
    \ smallest_int}\n            } else {\n                return []interface{}{largest_int,\
    \ nil}\n            }\n        } else {\n            return []interface{}{nil,\
    \ smallest_int}\n        }\n    } else {\n        return []interface{}{nil, nil}\n\
    \    }\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
