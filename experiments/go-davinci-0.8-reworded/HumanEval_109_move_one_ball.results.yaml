language: go_test.go
name: HumanEval_109_move_one_ball
results:
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    if len(arr)\
    \ == 1 {\n        return true\n    }\n    min := arr[0]\n    max := arr[0]\n \
    \   for _, val := range arr {\n        if val < min {\n            min = val\n\
    \        }\n        if val > max {\n            max = val\n        }\n    }\n\
    \    if min == arr[0] {\n        return true\n    }\n    if max == arr[0] {\n\
    \        return true\n    }\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpb3aqtdqq_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpb3aqtdqq_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpb3aqtdqq_test.go:72: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpll54ljd8_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpll54ljd8_test.go:53:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) <= 1 {\n        return true\n    }\n    sorted\
    \ := arr[1:]\n    for i, _ := range sorted {\n        if sorted[i] < arr[i] {\n\
    \            return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp1rw8qttc_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp1rw8qttc_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // If a list has 1 element or is empty, it is trivially sorted.\n\
    \    if len(arr) <= 1 {\n        return true\n    }\n    // If a list has 2 elements,\
    \ it is sorted if they are in increasing order.\n    if len(arr) == 2 {\n    \
    \    return arr[0] <= arr[1]\n    }\n    // Identify the first element that is\
    \ not in increasing order. It will be\n    // the right most element that is not\
    \ in order.\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i-1]\
    \ {\n            break\n        }\n    }\n    // If there is no element that is\
    \ not in increasing order, then the list is\n    // already sorted.\n    if i\
    \ == 0 {\n        return true\n    }\n    // Identify the first element that is\
    \ less than the first element that was\n    // not in increasing order.\n    for\
    \ j := 0; j < i-1; j++ {\n        if arr[j] < arr[i] {\n            break\n  \
    \      }\n    }\n    // If this element is found, then we can sort the list by\
    \ a sequence of\n    // right shifts.\n    if j < i-1 {\n        return true\n\
    \    }\n    // We cannot sort the list.\n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm804t_a3_test.go:47:8: undefined: i

    /tmp/tmpm804t_a3_test.go:52:21: undefined: i

    /tmp/tmpm804t_a3_test.go:53:25: undefined: i

    /tmp/tmpm804t_a3_test.go:59:8: undefined: j

    /tmp/tmpm804t_a3_test.go:59:12: undefined: i

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpll54ljd8_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpll54ljd8_test.go:53:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // YOUR CODE HERE\n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpfgji9st1_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpfgji9st1_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpfgji9st1_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpjpr6dhu9_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpjpr6dhu9_test.go:50:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    length := len(arr)\n    if length == 0 {\n        return\
    \ true\n    }\n    if length == 1 {\n        return true\n    }\n    shift_till\
    \ := -1\n    for i := length - 1; i > 0; i-- {\n        if arr[i] < arr[i - 1]\
    \ {\n            shift_till = i\n            break\n        }\n    }\n    if shift_till\
    \ == -1 {\n        return true\n    } else {\n        for j := shift_till; j <\
    \ length; j++ {\n            if arr[j] > arr[shift_till - 1] {\n             \
    \   return false\n            }\n        }\n        return true\n    }\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp73j806a1_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp73j806a1_test.go:73:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    size := len(arr)\n    // if empty list, return true\n   \
    \ if size == 0 {\n        return true\n    }\n    // find the first element that\
    \ is not in sequence\n    start := -1\n    for i := 1; i < size; i++ {\n     \
    \   if arr[i] < arr[i-1] {\n            start = i\n            break\n       \
    \ }\n    }\n    // if list is in sequence, return true\n    if start == -1 {\n\
    \        return true\n    }\n    // set the starting point to -1\n    end := start\n\
    \    // find the end point that is out of sequence\n    for i := start + 1; i\
    \ < size; i++ {\n        if arr[i] < arr[i-1] {\n            end = i\n       \
    \ }\n    }\n    // loop through the section that is out of sequence\n    for i\
    \ := start; i <= end; i++ {\n        // if the left is greater than the right,\
    \ return false\n        if i > 0 && arr[i] < arr[i-1] {\n            return false\n\
    \        }\n        // if the right is less than the left, return false\n    \
    \    if i < size - 1 && arr[i] > arr[i+1] {\n            return false\n      \
    \  }\n    }\n    // else, return true\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpmipbofei_test.go:87: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpmipbofei_test.go:87:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Code goes here.\n    //return true\n    if len(arr) ==\
    \ 0 {\n        return true\n    }\n\n    return moveOneBallRecursive(arr, 0)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqk2a62yq_test.go:36:12: undefined: moveOneBallRecursive

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    n := len(arr)\n    if n == 0 {\n        return true\n   \
    \ }\n    shift_count := 0\n    for i := 0; i < n; i++ {\n        if arr[i] !=\
    \ i + 1 {\n            break\n        }\n        shift_count++\n    }\n    if\
    \ shift_count == n {\n        return true\n    }\n    for i := shift_count; i\
    \ < n; i++ {\n        if arr[i] == i + 1 {\n            return false\n       \
    \ }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpafi15ndo_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpafi15ndo_test.go:69:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 0
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    var min_idx\
    \ int = 0\n    for i, v := range arr {\n        if v < arr[min_idx] {\n      \
    \      min_idx = i\n        }\n    }\n    var sub_arr = make([]int, len(arr))\n\
    \    copy(sub_arr, arr[min_idx:])\n    copy(sub_arr[len(arr)-min_idx:], arr[:min_idx])\n\
    \    // fmt.Println(sub_arr)\n    arr = sub_arr\n    // fmt.Println(arr)\n   \
    \ if arr[0] > arr[len(arr)-1] {\n        return false\n    }\n    for i := 0;\
    \ i < len(arr)-1; i++ {\n        if arr[i] > arr[i+1] {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    var idx int\n    var isSorted bool\n    if len(arr) == 0\
    \ {\n        return true\n    }\n    isSorted = false\n    for !isSorted {\n \
    \       isSorted = true\n        for i := 0; i < len(arr) - 1; i++ {\n       \
    \     if arr[i] > arr[i + 1] {\n                arr[i], arr[i + 1] = arr[i + 1],\
    \ arr[i]\n                isSorted = false\n                if idx == 0 {\n  \
    \                  idx = i + 1\n                }\n            }\n        }\n\
    \    }\n    fmt.Println(arr)\n    fmt.Println(idx)\n    return idx == 1\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "[1 2 3 4 5]\n3\n[1 2 3 5 10]\n3\n[1 2 3 4]\n1\n[1 2 3 4 5]\n2\n--- FAIL:\
    \ TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0 (0.00s)\n\
    \        tmpta7fwqhm_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpta7fwqhm_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpta7fwqhm_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    // Find\
    \ the index of the minimum value\n    min_idx := 0\n    for i, x := range arr\
    \ {\n        if x < arr[min_idx] {\n            min_idx = i\n        }\n    }\n\
    \    // Check if the list is already sorted\n    for i := 1; i < len(arr); i++\
    \ {\n        if arr[i] < arr[i-1] {\n            return false\n        }\n   \
    \ }\n    // Check if the minimum value is at the right place\n    if min_idx ==\
    \ 0 {\n        return true\n    }\n    // Check if the rest of the list is sorted\n\
    \    for i := min_idx + 1; i < len(arr); i++ {\n        if arr[i] < arr[i-1] {\n\
    \            return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpcb05hdcs_test.go:76: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpcb05hdcs_test.go:76:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    minpos\
    \ := 0\n    min := arr[0]\n    for i, v := range arr {\n        if v < min {\n\
    \            min = v\n            minpos = i\n        }\n    }\n    // Find the\
    \ number of right shifts required to bring the minimum element \n    // (with\
    \ a minimum index) to the first position.\n    var shift_cnt int\n    if minpos\
    \ < len(arr) - 1 {\n        shift_cnt = len(arr) - 1 - minpos\n    }\n    if shift_cnt\
    \ > 1 {\n        return false\n    }\n    if shift_cnt == 1 {\n        for i :=\
    \ minpos + 1; i < len(arr); i++ {\n            if arr[i] < arr[i - 1] {\n    \
    \            return false\n            }\n        }\n    }\n    // We have shifted\
    \ the minimum element to the first position. Now let's\n    // check if the remaining\
    \ elements of the list are sorted or not.\n    for i := 1; i < len(arr); i++ {\n\
    \        if arr[i] < arr[i - 1] {\n            return false\n        }\n    }\n\
    \    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpaix1lfnd_test.go:84: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpaix1lfnd_test.go:84:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    n := len(arr)\n    if n == 0 {\n        return true\n   \
    \ }\n    for i := 0; i < n; i++ {\n        if (i == 0 && arr[i] > arr[i+1]) ||\
    \ (i == n-1 && arr[i] < arr[i-1]) || (i > 0 && i < n-1 && arr[i] > arr[i+1] &&\
    \ arr[i] < arr[i-1]) {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp5rgoq6yn_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp5rgoq6yn_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp5rgoq6yn_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp5rgoq6yn_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // find the number that is the lowest and that does not follow\
    \ the minimum\n    // of its previous numbers. If there is no such number, we're\
    \ sorted and\n    // return true. If there is such a number and it is the minimum,\
    \ we can\n    // shift the array to the right to make it the first number, thus\
    \ sorting\n    // the array. If there is such a number and it is not the minimum,\
    \ we're\n    // unsorted and return false.\n    var i, min int\n    var minNum\
    \ int = -1\n    var minNumNum int = -1\n    for i, min = range arr {\n       \
    \ if i > 0 && min < arr[i-1] {\n            minNum = i\n            minNumNum\
    \ = min\n            break\n        }\n    }\n    if minNum < 0 {\n        return\
    \ true\n    }\n    if minNumNum == arr[minNum-1] {\n        // shift to the right\n\
    \        arr = append(arr[minNum:], arr[:minNum]...)\n        return true\n  \
    \  }\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp19uxnaf8_test.go:74: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp19uxnaf8_test.go:74:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // check empty list\n    if len(arr) == 0 {\n        return\
    \ true\n    }\n    // check size one list\n    if len(arr) == 1 {\n        return\
    \ true\n    }\n    // check size two list\n    if len(arr) == 2 {\n        if\
    \ arr[0] <= arr[1] {\n            return true\n        } else {\n            return\
    \ false\n        }\n    }\n    // check list size three\n    if len(arr) == 3\
    \ {\n        if arr[0] <= arr[1] && arr[1] <= arr[2] {\n            return true\n\
    \        } else if arr[0] <= arr[2] && arr[2] <= arr[1] {\n            return\
    \ true\n        } else if arr[1] <= arr[0] && arr[0] <= arr[2] {\n           \
    \ return true\n        } else if arr[1] <= arr[2] && arr[2] <= arr[0] {\n    \
    \        return true\n        } else if arr[2] <= arr[0] && arr[0] <= arr[1] {\n\
    \            return true\n        } else if arr[2] <= arr[1] && arr[1] <= arr[0]\
    \ {\n            return true\n        } else {\n            return false\n   \
    \     }\n    }\n    // check list size 4 or more\n    var largest int\n    for\
    \ _, value := range arr {\n        if value > largest {\n            largest =\
    \ value\n        }\n    }\n    new_arr := make([]int, len(arr)-1)\n    if arr[0]\
    \ == largest {\n        var index int\n        for i, value := range arr {\n \
    \           if i == 0 {\n                continue\n            }\n           \
    \ new_arr[index] = value\n            index += 1\n        }\n        return move_one_ball(new_arr)\n\
    \    } else {\n        var index int\n        for i, value := range arr {\n  \
    \          if i == len(arr)-1 {\n                break\n            }\n      \
    \      new_arr[index] = value\n            index += 1\n        }\n        return\
    \ move_one_ball(new_arr)\n    }\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp9mgcdqqx_test.go:112: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp9mgcdqqx_test.go:112:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    start\
    \ := 0\n    end := len(arr) - 1\n    // find the first number in sorted order\n\
    \    for start < end {\n        mid := (start + end) / 2\n        if arr[mid]\
    \ > arr[end] {\n            start = mid + 1\n        } else {\n            end\
    \ = mid\n        }\n    }\n    // check if the next number is in increasing order\n\
    \    if arr[(start + 1) % len(arr)] > arr[start] {\n        return true\n    }\n\
    \    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp0qvavmex_test.go:68: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp0qvavmex_test.go:68:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    for i\
    \ := 0; i < len(arr) - 1; i++ {\n        if arr[i] > arr[i + 1] {\n          \
    \  return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp5ckxwq_6_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp5ckxwq_6_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Remove duplicates from arr.\n    cache := make(map[int]bool)\n\
    \    arr_prime := []int{}\n    for _, element := range arr {\n        if _, ok\
    \ := cache[element]; !ok {\n            cache[element] = true\n            arr_prime\
    \ = append(arr_prime, element)\n        }\n    }\n    // Sort arr_prime.\n   \
    \ for i := 0; i < len(arr_prime) - 1; i++ {\n        min := i\n        for j :=\
    \ i + 1; j < len(arr_prime); j++ {\n            if arr_prime[j] < arr_prime[min]\
    \ {\n                min = j\n            }\n        }\n        arr_prime[i],\
    \ arr_prime[min] = arr_prime[min], arr_prime[i]\n    }\n    // Compare arr and\
    \ arr_prime.\n    for i := 0; i < len(arr); i++ {\n        if arr[i] != arr_prime[i]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg3gq6_rl_test.go:75: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg3gq6_rl_test.go:75:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    if len(arr)\
    \ == 1 {\n        return true\n    }\n    for i := 1; i < len(arr); i++ {\n  \
    \      if arr[i] < arr[i-1] {\n            if i == 1 {\n                arr[0],\
    \ arr[1] = arr[1], arr[0]\n            } else {\n                return false\n\
    \            }\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpe9wbniu8_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpe9wbniu8_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpjpr6dhu9_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpjpr6dhu9_test.go:50:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    length := len(arr)\n    if length <= 1 {\n        return\
    \ true\n    }\n    smallest := arr[0]\n    largetest := arr[0]\n    maxIndex :=\
    \ 0\n    for i, v := range arr {\n        if smallest > v {\n            smallest\
    \ = v\n        }\n        if largetest < v {\n            largetest = v\n    \
    \        maxIndex = i\n        }\n    }\n    for i, v := range arr {\n       \
    \ if i == maxIndex {\n            continue\n        }\n        if v > smallest\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpfppye5ys_test.go:74: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpfppye5ys_test.go:74:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    m := make(map[int]int)\n    if len(arr) == 0 {\n        return\
    \ true\n    }\n    for _, v := range arr {\n        if _, ok := m[v]; ok {\n \
    \           return false\n        }\n        m[v] = 1\n    }\n    return true\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp_du3zhrq_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp_du3zhrq_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // fmt.Println(\"\\n\")\n    if len(arr) == 0 {\n       \
    \ return true\n    }\n    if len(arr) == 1 {\n        return true\n    }\n   \
    \ for idx, val := range arr {\n        if idx < len(arr) - 1 {\n            if\
    \ val > arr[idx + 1] {\n                return false\n            }\n        }\n\
    \    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpq1fiffoe_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpq1fiffoe_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    // TODO\
    \ - Add your code here\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp_ag15dyo_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp_ag15dyo_test.go:54:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074220
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    for _,\
    \ val := range arr {\n        if val < 1 || val > len(arr) {\n            return\
    \ false\n        }\n    }\n    arrMap := make(map[int]int)\n    for _, val :=\
    \ range arr {\n        arrMap[val] += 1\n    }\n    if len(arrMap) != len(arr)\
    \ {\n        return false\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__1\
    \ (0.00s)\n        tmpor32lxmx_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__2 (0.00s)\n        tmpor32lxmx_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestMove_One_Ball/test_num__3\
    \ (0.00s)\n        tmpor32lxmx_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074220
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    if len(arr)\
    \ == 1 {\n        return true\n    }\n    if len(arr) == 2 {\n        return true\n\
    \    }\n    ball := arr[0]\n    first_hole := -1\n    first_ball := -1\n    for\
    \ i, v := range arr {\n        if v < ball {\n            first_hole = i\n   \
    \         break\n        }\n    }\n    for i, v := range arr {\n        if v >\
    \ ball {\n            first_ball = i\n            break\n        }\n    }\n  \
    \  if first_hole == -1 || first_ball == -1 {\n        return true\n    }\n   \
    \ if first_hole < first_ball {\n        return false\n    }\n    arr[0] = arr[first_ball]\n\
    \    arr[first_ball] = ball\n    return move_one_ball(arr[1:])\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp6twz00h2_test.go:82: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp6twz00h2_test.go:82:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    if len(arr)\
    \ == 1 {\n        return true\n    }\n    if arr[0] < arr[1] {\n        return\
    \ move_one_ball(arr[1:])\n    }\n    if arr[0] > arr[1] {\n        temp := arr[0]\n\
    \        for i := 0; i < len(arr) - 1; i++ {\n            arr[i] = arr[i + 1]\n\
    \        }\n        arr[len(arr) - 1] = temp\n        return move_one_ball(arr)\n\
    \    }\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp26o3d58w_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp26o3d58w_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    sorted_arr\
    \ := make([]int, len(arr))\n    copy(sorted_arr, arr)\n    for i := 1; i < len(arr);\
    \ i++ {\n        if arr[i] < arr[i-1] {\n            return false\n        }\n\
    \    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmptn1sfkc8_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmptn1sfkc8_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    n := len(arr)\n    if n == 0 {\n        return true\n   \
    \ }\n    // Count the number of inversions.\n    inversions := 0\n    for i, j\
    \ := 0, 1; j < n; i, j = i+1, j+1 {\n        if arr[i] > arr[j] {\n          \
    \  inversions += 1\n        }\n    }\n    // The array is in non-decreasing order.\n\
    \    if inversions == 0 {\n        return true\n    }\n    // The array is in\
    \ strictly decreasing order.\n    if inversions == n-1 {\n        return false\n\
    \    }\n    // At most (n-1) inversions can be made by shifting.\n    return inversions\
    \ <= n-1\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp7ddsds23_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp7ddsds23_test.go:70:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpdsg7abp3_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 0
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    count,\
    \ prev := 0, arr[0]\n    for _, current := range arr {\n        if prev > current\
    \ {\n            count += 1\n        }\n        prev = current\n    }\n    return\
    \ count <= 1\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // >>> YOUR CODE GOES HERE <<<\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmppr0hq0nf_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmppr0hq0nf_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmppr0hq0nf_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    if len(arr)\
    \ == 1 {\n        return true\n    }\n    max := arr[0]\n    for i := 1; i < len(arr);\
    \ i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n    }\n\
    \    if max == arr[0] {\n        // We can assume that the list is sorted in non-decreasing\
    \ order\n        return true\n    }\n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpiwh6bpjb_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpiwh6bpjb_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpiwh6bpjb_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    max :=\
    \ arr[0]\n    min := arr[0]\n    for _, v := range arr {\n        if v > max {\n\
    \            max = v\n        }\n        if v < min {\n            min = v\n \
    \       }\n    }\n    diff := max - min\n    if diff == len(arr) - 1 {\n     \
    \   return true\n    }\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__1\
    \ (0.00s)\n        tmpdmxjxzdh_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__2 (0.00s)\n        tmpdmxjxzdh_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestMove_One_Ball/test_num__3\
    \ (0.00s)\n        tmpdmxjxzdh_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpjpr6dhu9_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpjpr6dhu9_test.go:50:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // YOUR CODE HERE\n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpfgji9st1_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpfgji9st1_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpfgji9st1_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // If given list is empty, return true\n    if len(arr) ==\
    \ 0 {\n        return true\n    }\n    // If given list is of length 1, return\
    \ true\n    if len(arr) == 1 {\n        return true\n    }\n    length := len(arr)\n\
    \    result := false\n    // Create a map to store the number of occurances of\
    \ each number in the list\n    occurance_map := make(map[int]int)\n    // Iterate\
    \ through the list and store the occurances\n    for _, v := range arr {\n   \
    \     occurance_map[v] += 1\n    }\n    // Variable to store the current minimum\
    \ value in the list\n    min := arr[0]\n    // Iterate through the list and find\
    \ the lowest number in the list\n    for _, v := range arr {\n        if v < min\
    \ {\n            min = v\n        }\n    }\n    // If occurance of minimum number\
    \ in the list is less than length of the list\n    // Then it is not possible\
    \ to get the list sorted.\n    if occurance_map[min] < length {\n        return\
    \ false\n    }\n    // Loop through the list\n    for i := 0; i < length; i++\
    \ {\n        // If last element in the list, set result to true and continue\n\
    \        if i == length - 1 {\n            result = true\n            continue\n\
    \        }\n        // If the current element is less than the next element, set\
    \ result to false\n        // and break out of the loop\n        if arr[i] > arr[i\
    \ + 1] {\n            result = false\n            break\n        }\n    }\n  \
    \  return result\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpgr0p7r4r_test.go:93: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpgr0p7r4r_test.go:93:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    if len(arr)\
    \ == 1 {\n        return true\n    }\n    for i := 0; i < len(arr); i++ {\n  \
    \      for j := i + 1; j < len(arr); j++ {\n            if arr[i] > arr[j] {\n\
    \                return false\n            }\n        }\n    }\n    return true\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpk23ic1j__test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpk23ic1j__test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) <= 1 {\n        return true\n    }\n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpcmfpblce_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpcmfpblce_test.go:53:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    for i\
    \ := 1; i < len(arr); i++ {\n        if arr[i-1] > arr[i] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmppyi756b2_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmppyi756b2_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    min :=\
    \ min_in_slice(arr)\n    for _, v := range arr {\n        if v != min {\n    \
    \        return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp6h0nm8g_test.go:33:12: undefined: min_in_slice

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074220
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    // max\
    \ index is len(arr) - 1\n    // min index is 0\n    max_index := len(arr) - 1\n\
    \    min_index := 0\n    // we're basically looking for some arrangement where\
    \ the max and min are\n    // both not in their own respective slots.\n    //\
    \ So we're looking for a slot to put the max_index, or a slot for the\n    //\
    \ min_index.\n    for i := 0; i < len(arr); i++ {\n        if arr[i] == max_index\
    \ {\n            max_index = i\n        }\n        if arr[i] == min_index {\n\
    \            min_index = i\n        }\n    }\n    if min_index != 0 || max_index\
    \ != len(arr) - 1 {\n        return true\n    }\n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__1\
    \ (0.00s)\n        tmps0p673gc_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO: Implement this function.\n    return false\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpdnjrbin__test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpdnjrbin__test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpdnjrbin__test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    for i, v := range arr {\n        arr[i] = v\n    }\n    if\
    \ len(arr) <= 1 {\n        return true\n    }\n    min := 0\n    for i, v := range\
    \ arr {\n        if v < arr[min] {\n            min = i\n        }\n    }\n  \
    \  _, max, idx := arr[0], arr[0], 0\n    for i, v := range arr {\n        if v\
    \ > max {\n            max = v\n            idx = i\n        }\n    }\n    if\
    \ idx == min {\n        return true\n    }\n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0cwus2cx_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0cwus2cx_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpdsg7abp3_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Implement this placeholder.\n    return true\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpw99lw8m1_test.go:51: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpw99lw8m1_test.go:51:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Write your code here.\n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmppe8ehasz_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmppe8ehasz_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmppe8ehasz_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // The solution is to find the smallest element and then\
    \ search to the\n    // right to find the place where the smallest element belongs.\n\
    \    // Our strategy is to find two elements. The first is the smallest element\n\
    \    // of the list. The second is the element that is to the right of the\n \
    \   // smallest element and smaller than the smallest element.\n    // We will\
    \ then search the remaining elements of the list to determine if\n    // they\
    \ are larger than the second smallest element and smaller than or\n    // equal\
    \ to the smallest element.\n    // If the list is sorted we can just return true.\n\
    \    var n int = len(arr)\n    if n == 0 {\n        return true\n    }\n    var\
    \ smallest, second_smallest int = arr[0], arr[0]\n    for _, value := range arr\
    \ {\n        if value < smallest {\n            smallest = value\n        }\n\
    \    }\n    // Now we need to find the second smallest element. It will be an\
    \ element\n    // that is to the right of the smallest element and smaller than\
    \ the\n    // smallest element.\n    var found_second_smallest bool = false\n\
    \    for i := 1; i < n; i++ {\n        if arr[i] < smallest {\n            second_smallest\
    \ = arr[i]\n            found_second_smallest = true\n            break\n    \
    \    }\n    }\n    if !found_second_smallest {\n        return true\n    }\n \
    \   // Check the remaining elements of the list to make sure that they are\n \
    \   // larger than the second smallest element and smaller than or equal to\n\
    \    // the smallest element.\n    var prev int = second_smallest\n    for i :=\
    \ 1; i < n; i++ {\n        if arr[i] > prev && arr[i] <= smallest {\n        \
    \    prev = arr[i]\n        } else {\n            return false\n        }\n  \
    \  }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpi9xvpqhk_test.go:94: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpi9xvpqhk_test.go:94:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) <= 1 {\n        return true\n    }\n    for i\
    \ := 1; i < len(arr); i++ {\n        if arr[i-1] > arr[i] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp3op28wcj_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp3op28wcj_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Brute force:\n    // We may use one ball to 'block' the\
    \ gap.\n    // We go through the list and find the first gap.\n    // Then we\
    \ move the ball to the gap and 'block' it.\n    // Then we shift the list to the\
    \ right.\n    // We start from index 1.\n    for i := 1; i < len(arr); i++ {\n\
    \        if arr[i-1] > arr[i] {\n            // We found the first gap.\n    \
    \        // We need to block it with ball.\n            // We move the ball to\
    \ the left.\n            // We start from index 1.\n            for j := 1; j\
    \ < i; j++ {\n                // We shift the list.\n                arr[j-1]\
    \ = arr[j]\n            }\n            // We put the ball to the end of the list.\n\
    \            arr[i-1] = arr[i]\n            // We shift the list by one.\n   \
    \         for j := i; j < len(arr) - 1; j++ {\n                arr[j] = arr[j+1]\n\
    \            }\n            // We put the ball in front of the gap.\n        \
    \    arr[i] = arr[i-1]\n            // We need to check again that the list is\
    \ sorted.\n            for k := 1; k < len(arr); k++ {\n                if arr[k-1]\
    \ > arr[k] {\n                    return false\n                }\n          \
    \  }\n            return true\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp8t7h4xc9_test.go:83: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp8t7h4xc9_test.go:83:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    var ball_pos = -1\n    for i, val := range arr {\n      \
    \  if ball_pos == -1 && (i == 0 || val < arr[i-1]) {\n            ball_pos = i\n\
    \        }\n    }\n    fmt.Println(ball_pos)\n    if ball_pos == -1 {\n      \
    \  return true\n    }\n    for i := ball_pos + 1; i < len(arr); i++ {\n      \
    \  if arr[i] > arr[ball_pos] {\n            return false\n        }\n    }\n \
    \   return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "0\n0\n0\n0\n-1\n--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmptpfsxt6x_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmptpfsxt6x_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmptpfsxt6x_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    var best\
    \ = make([]int, len(arr))\n    for i := 0; i < len(arr); i++ {\n        idx :=\
    \ arr[i] - 1;\n        best[idx] = i\n    }\n    var newBest = make([]int, len(arr))\n\
    \    max := -1\n    for i := 0; i < len(arr); i++ {\n        idx := (best[i] +\
    \ 1) % len(arr)\n        newBest[i] = best[idx]\n        if newBest[i] > max {\n\
    \            max = newBest[i]\n        }\n    }\n    return max == len(arr) -\
    \ 1\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [9] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [9] with length 5\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball({0xc0000c4618, 0x5, 0x4b3193?})\n\
    \t/tmp/tmp7ew3gk59_test.go:36 +0x105\ncommand-line-arguments_test.TestMove_One_Ball(0x0?)\n\
    \t/tmp/tmp7ew3gk59_test.go:58 +0x10b\ntesting.tRunner(0xc0001a01a0, 0x528f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074222
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    // We\
    \ will analyze two elements at a time, p and q.\n    // if p is greater than q,\
    \ then p must be last element after all right shifts.\n    // This is because\
    \ if we do 2 right shifts, we will have p at the end.\n    // If we do 1 more\
    \ right shift, the last number will become q. If we continue\n    // shifting,\
    \ the last number will never be larger than q.\n    min := arr[0]\n    for i :=\
    \ 1; i < len(arr); i++ {\n        if arr[i] < min {\n            return false\n\
    \        }\n        min = arr[i]\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpyrev7sqs_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpyrev7sqs_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    var i, n int\n    n = len(arr)\n    if n <= 1 {\n       \
    \ return true\n    }\n    for ;i < n - 1; i++ {\n        if arr[i] > arr[i + 1]\
    \ {\n            break\n        }\n    }\n    if i == n - 1 {\n        return\
    \ true\n    }\n    for ;i < n - 1; i++ {\n        if arr[i] <= arr[i + 1] {\n\
    \            return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpl5n9enuk_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpl5n9enuk_test.go:68:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpdsg7abp3_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpdsg7abp3_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    max_index\
    \ := 0\n    for i, v := range arr {\n        if v > arr[max_index] {\n       \
    \     max_index = i\n        }\n    }\n    if max_index == 0 {\n        return\
    \ true\n    }\n    new_arr := make([]int, len(arr))\n    copy(new_arr, arr[max_index:])\n\
    \    copy(new_arr[len(arr) - max_index:], arr[:max_index])\n    for i := 0; i\
    \ < len(arr) - 1; i++ {\n        if new_arr[i] > new_arr[i + 1] {\n          \
    \  return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmphyvnp3nj_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmphyvnp3nj_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmphyvnp3nj_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    size := len(arr)\n    if size == 0 {\n        return true\n\
    \    }\n\n    r_min := 1e8\n    for i := 0; i < size; i++ {\n        if arr[i]\
    \ < r_min {\n            r_min = arr[i]\n        }\n    }\n\n    size = 0\n  \
    \  for i := 0; i < len(arr); i++ {\n        if arr[i] == r_min {\n           \
    \ break\n        }\n        size++\n    }\n\n    fmt.Println(arr[:size], arr[size:])\n\
    \    for i := 0; i < size; i++ {\n        if arr[i] > arr[size] {\n          \
    \  return false\n        }\n    }\n\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb55cwg28_test.go:37:21: invalid operation: arr[i] < r_min (mismatched
    types int and float64)

    /tmp/tmpb55cwg28_test.go:38:21: cannot use arr[i] (variable of type int) as type
    float64 in assignment

    /tmp/tmpb55cwg28_test.go:44:22: invalid operation: arr[i] == r_min (mismatched
    types int and float64)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    max_val\
    \ := arr[0]\n    for i, val := range arr {\n        if val < max_val {\n     \
    \       return false\n        }\n        if val > max_val {\n            max_val\
    \ = val\n        }\n        if i < len(arr) - 1 && val > arr[i + 1] {\n      \
    \      return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpssk0aphr_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpssk0aphr_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    result\
    \ := false\n    // Just need to find the greatest value\n    max := arr[0]\n \
    \   for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max\
    \ = arr[i]\n        }\n    }\n    // Loop through the array and check if the greatest\
    \ value is in the right place\n    // If it is not in the right place then check\
    \ if it is in the first place\n    // If it is in the first place then that means\
    \ that it could be sorted by\n    // performing a single right shift\n    if arr[len(arr)\
    \ - 1] != max {\n        for i := 0; i < len(arr); i++ {\n            if arr[i]\
    \ == max {\n                if i == 0 {\n                    result = true\n \
    \               }\n                break\n            }\n        }\n    } else\
    \ {\n        result = true\n    }\n    return result\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp3qe5m3dx_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp3qe5m3dx_test.go:77:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp3qe5m3dx_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpdsg7abp3_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    var stack\
    \ []int\n    for _, v := range arr {\n        fmt.Println(stack)\n        if len(stack)\
    \ == 0 {\n            stack = append(stack, v)\n        } else {\n           \
    \ if stack[len(stack)-1] > v {\n                return false\n            } else\
    \ {\n                if len(stack) > 1 && stack[len(stack)-2] > v {\n        \
    \            stack = stack[:len(stack)-1]\n                }\n               \
    \ stack = append(stack, v)\n            }\n        }\n    }\n    return true\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "[]\n[3]\n[3 4]\n[3 4 5]\n[]\n[3]\n[3 5]\n[3 5 10]\n[]\n[4]\n[]\n[3]\n[3\
    \ 5]\n--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmptx3km1as_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmptx3km1as_test.go:69:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n\treturn true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpox9vrlb7_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpox9vrlb7_test.go:50:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    for i, num := range arr {\n        if num != i + 1 {\n  \
    \          return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpumc_b_by_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpumc_b_by_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Replace this comment with code in here.\n    return false\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmphu7xs78v_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmphu7xs78v_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmphu7xs78v_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    for i,v := range arr {\n        if v >= arr[len(arr)-1] {\n\
    \            j := i\n            for ; j < len(arr)-1; j++ {\n               \
    \ if arr[j] > arr[j+1] {\n                    return false\n                }\n\
    \            }\n            return true\n        }\n    }\n    return true\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpktz4x6m5_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpktz4x6m5_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    arrlen\
    \ := len(arr)\n    max := arr[0]\n    for i := 1; i < arrlen; i++ {\n        if\
    \ arr[i] < max {\n            return false\n        }\n        if arr[i] > max\
    \ {\n            max = arr[i]\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpujnxf8wd_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpujnxf8wd_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    ball\
    \ := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < ball {\n\
    \            return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp7w6ldve7_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp7w6ldve7_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    fmt.Println(\"arr is \", arr)\n    if len(arr) == 0 {\n \
    \       return true\n    }\n    // We are only allowed to perform right shift\
    \ operation. So, it's better to\n    // break the whole list into two sublists,\
    \ the first sublist is all element\n    // before the last element, and the second\
    \ sublist is the last element.\n    // We then check if the first sublist is in\
    \ non-decreasing order, and the\n    // last element is greater than the first\
    \ element.\n    for i := 0; i < len(arr) - 1; i++ {\n        if arr[i] > arr[i\
    \ + 1] {\n            return false\n        }\n    }\n    return arr[len(arr)\
    \ - 1] > arr[0]\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "arr is  [3 4 5 1 2]\narr is  [3 5 10 1 2]\narr is  [4 3 1 2]\narr is  [3\
    \ 5 4 1 2]\narr is  []\n--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0zdrf9vv_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0zdrf9vv_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    // scan\
    \ from the end of arr\n    for i := len(arr) - 1; i > 0; i-- {\n        // find\
    \ the first ball which is on the wrong position\n        if arr[i] < arr[i-1]\
    \ {\n            // find the rightmost ball which is less than the ball on the\
    \ wrong\n            // position\n            j := len(arr) - 1\n            for\
    \ j > i && arr[j] >= arr[i-1] {\n                j--\n            }\n        \
    \    // if there is no ball which is less than the ball on the wrong\n       \
    \     // position, then we can not make it sorted\n            if j == i {\n \
    \               return false\n            }\n            // right shift j-1 positions\n\
    \            arr = append(arr[j:], arr[:j]...)\n            // right shift i-1\
    \ positions\n            arr = append(arr[i:], arr[:i]...)\n            // all\
    \ balls are shifted, so we can make it sorted\n            return true\n     \
    \   }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n \
    \ candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpjn7q3i_2_test.go:76: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpjn7q3i_2_test.go:76:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    switch len(arr) {\n    case 0:\n        return true\n   \
    \ case 1:\n        return true\n    default:\n        temp := arr[len(arr)-1]\n\
    \        arr = arr[:len(arr)-1]\n        return check_sub_lists(temp, arr)\n \
    \   }\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpal7udb4e_test.go:38:16: undefined: check_sub_lists

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074223
- exit_code: 0
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    cnt := 0\n    if len(arr) == 0 {\n        return true\n \
    \   }\n    if len(arr) == 1 {\n        return true\n    }\n    for i := 0; i <\
    \ len(arr); i++ {\n        if i+1 < len(arr) && arr[i] > arr[i+1] {\n        \
    \    cnt += 1\n        }\n    }\n    if cnt == 1 {\n        return true\n    }\n\
    \    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    min_idx\
    \ := 0\n    for i, v := range arr {\n        if v < arr[min_idx] {\n         \
    \   min_idx = i\n        }\n    }\n    for i, v := range arr {\n        if v >\
    \ arr[min_idx] {\n            return false\n        }\n        if i == len(arr)\
    \ - 1 {\n            return true\n        }\n        if v > arr[i + 1] {\n   \
    \         return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpcebdeqdl_test.go:70: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpcebdeqdl_test.go:70:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    if len(arr)\
    \ == 1 {\n        return true\n    }\n    // Simulate the shifting process.\n\
    \    // And only when the list becomes non-decreasing, we return true.\n    min\
    \ := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < min {\n\
    \            min = arr[i]\n        }\n        // If the array is non-decreasing,\
    \ we return true.\n        if arr[i] >= arr[i-1] {\n            return true\n\
    \        }\n    }\n    // If the array is decreasing and 'min' is at the last\
    \ index,\n    // it is not possible to achieve non-decreasing order, so we return\
    \ false.\n    if arr[len(arr)-1] == min {\n        return false\n    }\n    //\
    \ If it is not possible to achieve non-decreasing order,\n    // we shift it and\
    \ return false.\n    arr = append(arr[1:], arr[0])\n    return move_one_ball(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp1dn14ipj_test.go:76: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp1dn14ipj_test.go:76:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpjpr6dhu9_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpjpr6dhu9_test.go:50:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) <= 1 {\n        return true\n    }\n    // Locate\
    \ the first occurrence of minimum value in the array\n    min_value, min_index\
    \ := arr[0], 0\n    for i, v := range arr {\n        if v < min_value {\n    \
    \        min_value, min_index = v, i\n        }\n    }\n    // Now shift all items\
    \ after min_index to the left so that the item\n    // at min_index is moved to\
    \ the beginning of the array\n    for i := min_index; i < len(arr) - 1; i++ {\n\
    \        arr[i] = arr[i + 1]\n    }\n    arr[len(arr) - 1] = min_value\n    //\
    \ Finally check if the new array is sorted\n    for i := 0; i < len(arr) - 1;\
    \ i++ {\n        if arr[i] > arr[i + 1] {\n            return false\n        }\n\
    \    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpxj4atyuu_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpxj4atyuu_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074223
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    for _, v := range arr {\n        if v == 1 {\n          \
    \  return true\n        }\n    }\n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp_isf_hek_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp_isf_hek_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp_isf_hek_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074224
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < arr[i-1]\
    \ {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp9wdbc9kz_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp9wdbc9kz_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp9wdbc9kz_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074224
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    var is_sorted\
    \ bool = true\n    for i := 0; i < len(arr) - 1; i++ {\n        if arr[i] > arr[i\
    \ + 1] {\n            is_sorted = false\n            break\n        }\n    }\n\
    \    if is_sorted {\n        return true\n    }\n    // if the last item is smaller\
    \ than the first item, we can move the last item\n    // to the first item.\n\
    \    if arr[len(arr) - 1] < arr[0] {\n        return true\n    }\n    // To get\
    \ the non-decreasing order list, we need to find the continuous\n    // sublist\
    \ with non-decreasing order.\n    // left and right is the start/end index of\
    \ the continuous sublist.\n    var left, right int = -1, -1\n    for i := 0; i\
    \ < len(arr) - 1; i++ {\n        if arr[i] > arr[i + 1] {\n            // arr[i]\
    \ > arr[i + 1] means the item at i+1 needs to be moved left.\n            if left\
    \ == -1 {\n                left = i + 1\n            }\n            right = i\
    \ + 1\n        }\n    }\n    if right == -1 {\n        return false\n    }\n \
    \   // Here we loop the list to find a item smaller than the item at left\n  \
    \  // position.\n    for i := right; i < len(arr); i++ {\n        if arr[i] <\
    \ arr[left] {\n            return true\n        }\n    }\n    // At this point,\
    \ we haven't found a item in the list smaller than the \n    // item at left position.\n\
    \    // We need to check if the item at left position is smaller than the item\n\
    \    // at the 0 position.\n    if arr[left] < arr[0] {\n        return true\n\
    \    }\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpj59ko5fo_test.go:98: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpj59ko5fo_test.go:98:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074224
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    var n = len(arr)\n    var sorted_arr = make([]int, n)\n \
    \   copy(sorted_arr, arr)\n    var left_to_right = make([]int, n)\n    var right_to_left\
    \ = make([]int, n)\n    var sorted_left_to_right = make([]int, n)\n    var sorted_right_to_left\
    \ = make([]int, n)\n    // initialize left_to_right\n    for i := 0; i < n; i++\
    \ {\n        left_to_right[i] = arr[i]\n        if i > 0 {\n            if left_to_right[i-1]\
    \ > left_to_right[i] {\n                left_to_right[i] = left_to_right[i-1]\n\
    \            }\n        }\n    }\n    // initialize right_to_left\n    for i :=\
    \ n-1; i >= 0; i-- {\n        right_to_left[i] = arr[i]\n        if i < n-1 {\n\
    \            if right_to_left[i+1] > right_to_left[i] {\n                right_to_left[i]\
    \ = right_to_left[i+1]\n            }\n        }\n    }\n    // sort sorted_arr\n\
    \    for i := 0; i < n; i++ {\n        for j := i; j < n; j++ {\n            if\
    \ sorted_arr[i] > sorted_arr[j] {\n                sorted_arr[i], sorted_arr[j]\
    \ = sorted_arr[j], sorted_arr[i]\n            }\n        }\n    }\n    // initialize\
    \ sorted_left_to_right\n    for i := 0; i < n; i++ {\n        sorted_left_to_right[i]\
    \ = sorted_arr[i]\n        if i > 0 {\n            if sorted_left_to_right[i-1]\
    \ > sorted_left_to_right[i] {\n                sorted_left_to_right[i] = sorted_left_to_right[i-1]\n\
    \            }\n        }\n    }\n    // initialize sorted_right_to_\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphn1bfbq8_test.go:73:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074224
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) <= 1 {\n        return true\n    }\n    for i,\
    \ num := range arr {\n        if (i+1) == num {\n            continue\n      \
    \  }\n        // find the right position\n        right_pos := num - 1\n     \
    \   if right_pos < 0 {\n            right_pos = len(arr) - 1\n        }\n    \
    \    if right_pos > len(arr) - 1 {\n            right_pos = 0\n        }\n   \
    \     if arr[right_pos] == num {\n            continue\n        }\n        //\
    \ swap\n        if i < right_pos {\n            for ; i < right_pos; i++ {\n \
    \               arr[i], arr[i+1] = arr[i+1], arr[i]\n            }\n        }\
    \ else {\n            for ; i > right_pos; i-- {\n                arr[i], arr[i-1]\
    \ = arr[i-1], arr[i]\n            }\n        }\n    }\n    fmt.Println(arr)\n\
    \    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "[1 2 4 3 5]\n[1 2 10 5 3]\n[1 2 3 4]\n[1 2 5 3 4]\n--- FAIL: TestMove_One_Ball\
    \ (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2 (0.00s)\n        tmplnvq92ze_test.go:80:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestMove_One_Ball/test_num__3\
    \ (0.00s)\n        tmplnvq92ze_test.go:80: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074225
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    arr_len := len(arr)\n    if arr_len == 0 {\n        return\
    \ true\n    }\n    // Make each element in a sliding window of length 3 whose\
    \ left and right\n    // boundaries are 'start' and 'end' to satisfy the following\
    \ condition:\n    // arr[i] < arr[i+1] for all i=start, start+1, ..., end-1\n\
    \    // Example: [3, 1, 4, 2, 5]\n    // The following operations will achieve\
    \ the goal:\n    //    1st iteration: [1, 3, 4, 2, 5]\n    //    2nd iteration:\
    \ [1, 2, 3, 4, 5]\n    start := 0\n    end := 0\n    if arr_len == 1 {\n     \
    \   return true\n    }\n    // If the array contains only two elements, swapping\
    \ them will be sufficient\n    // if they are not in non-decreasing order.\n \
    \   if arr_len == 2 {\n        if arr[0] > arr[1] {\n            arr[0], arr[1]\
    \ = arr[1], arr[0]\n        }\n        return true\n    }\n    for ; end < arr_len-1;\
    \ end++ {\n        if arr[end] > arr[end+1] {\n            // Find the next largest\
    \ element 'index' in the right boundary of\n            // the sliding window.\n\
    \            index := start\n            for i := start; i <= end; i++ {\n   \
    \             if arr[i] > arr[index] {\n                    index = i\n      \
    \          }\n            }\n            // Swap the element at 'end' and 'index'\
    \ in the sliding window.\n            arr[end], arr[index] = arr[index], arr[end]\n\
    \            start = end\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp8h29i8c6_test.go:89: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp8h29i8c6_test.go:89:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074225
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) <= 1 {\n        return true\n    }\n    var (\n\
    \        smallest = arr[0]\n        i = 1\n    )\n    for ; i < len(arr); i++\
    \ {\n        if arr[i] < smallest {\n            smallest = arr[i]\n        }\n\
    \    }\n    var pos = 0\n    for ; pos < len(arr); pos++ {\n        if arr[pos]\
    \ == smallest {\n            break\n        }\n    }\n    var j = pos\n    for\
    \ ; j < len(arr); j++ {\n        if arr[j] < arr[j - 1] {\n            return\
    \ false\n        }\n    }\n    for i = 0; i < pos; i++ {\n        if arr[i] <\
    \ arr[i + 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpwp8z59ys_test.go:79: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpwp8z59ys_test.go:79:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    var l int = len(arr)\n    if l == 0 {\n        return true\n\
    \    }\n    var curr, prev int = arr[0], arr[0]\n    for i := 1; i < l; i++ {\n\
    \        curr = arr[i]\n        if curr < prev {\n            return false\n \
    \       }\n        prev = curr\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmposq6rzq3_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmposq6rzq3_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    if len(arr)\
    \ == 1 {\n        return true\n    }\n    min := arr[0]\n    max := arr[0]\n \
    \   for _, v := range arr {\n        if v < min {\n            min = v\n     \
    \   }\n        if v > max {\n            max = v\n        }\n    }\n    min_index\
    \ := 0\n    max_index := 0\n    for i, v := range arr {\n        if v == min {\n\
    \            min_index = i\n        }\n        if v == max {\n            max_index\
    \ = i\n        }\n    }\n    for i := 0; i < len(arr); i++ {\n        if i !=\
    \ min_index && i != max_index {\n            if arr[i] < min || arr[i] > max {\n\
    \                return false\n            }\n        }\n    }\n    return true\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpnb5kjg5t_test.go:83: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpnb5kjg5t_test.go:83:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    length := len(arr)\n    if length == 0 {\n        return\
    \ true\n    }\n    arr_sorted := make([]int, length)\n    copy(arr_sorted, arr)\n\
    \    arr_sorted = append(arr_sorted[len(arr_sorted)-1:], arr_sorted[:len(arr_sorted)-1]...)\n\
    \    fmt.Println(arr_sorted)\n    // for k := range arr {\n    //     fmt.Println(k)\n\
    \    // }\n    for i := 1; i < length; i++ {\n        copy(arr_sorted, arr)\n\
    \        arr_sorted = append(arr_sorted[i:], arr_sorted[:i]...)\n        if isSorted(arr_sorted)\
    \ {\n            return true\n        }\n    }\n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3k6d0wna_test.go:44:12: undefined: isSorted

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074225
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Your code here\n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpot9nih0i_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpot9nih0i_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpot9nih0i_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    for i\
    \ := 0; i < len(arr); i++ {\n        index := arr[i]\n        for j := i + 1;\
    \ j < len(arr); j++ {\n            if arr[j] < index {\n                return\
    \ false\n            }\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmprk3lcms6_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmprk3lcms6_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    l := len(arr)\n    if l == 0 {\n        return true\n   \
    \ }\n    if l == 1 {\n        return true\n    }\n    for i := 1; i < l; i++ {\n\
    \        if arr[i] < arr[i-1] {\n            return false\n        }\n    }\n\
    \    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp8n0wtmqd_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp8n0wtmqd_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Your code goes here\n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg9a61uvv_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg9a61uvv_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpg9a61uvv_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) <= 1 {\n        return true\n    }\n    left,\
    \ right := 0, len(arr) - 1\n    for left < right {\n        if arr[left] <= arr[right]\
    \ {\n            return true\n        }\n        left++\n        right--\n   \
    \ }\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpykhe2ogf_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpykhe2ogf_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    size := len(arr)\n    if size == 0 {\n        return true\n\
    \    }\n    if size == 1 {\n        return true\n    }\n    // Define a vector\
    \ to store the max value of a window of size k where\n    // k is the index +\
    \ 1.\n    max := make([]int, size)\n    max[0] = arr[0]\n    for i := 1; i < size;\
    \ i++ {\n        if arr[i] > max[i-1] {\n            max[i] = arr[i]\n       \
    \ } else {\n            max[i] = max[i-1]\n        }\n    }\n    for i := 0; i\
    \ < size-1; i++ {\n        if arr[i] > max[size-i-2] {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp6jxiiigj_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp6jxiiigj_test.go:73:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp6jxiiigj_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp6jxiiigj_test.go:73:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    n := len(arr)\n    if n == 0 {\n        return true\n   \
    \ }\n    // Check if all the elements are equal\n    all_equal := true\n    for\
    \ i := 1; i < n; i++ {\n        if arr[i] != arr[0] {\n            all_equal =\
    \ false\n            break\n        }\n    }\n    if all_equal {\n        return\
    \ true\n    }\n    // Find the index of the minimum value\n    min_val, min_idx\
    \ := arr[0], 0\n    for i := 1; i < n; i++ {\n        if arr[i] < min_val {\n\
    \            min_val = arr[i]\n            min_idx = i\n        }\n    }\n   \
    \ // Check whether the minimum value is at position 0\n    if min_idx == 0 {\n\
    \        return true\n    }\n    // Check if the minimum value is greater than\
    \ the value at index 1\n    if min_val > arr[1] {\n        return true\n    }\n\
    \    // Check if the minimum value is greater than the value at index n-1\n  \
    \  if min_val > arr[n-1] {\n        return true\n    }\n    return false\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpeb76gvfl_test.go:85: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpeb76gvfl_test.go:85:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    //let's assume that it is possible\n    if len(arr) == 0\
    \ { return true }\n    var found = true\n    for i := 0; i < len(arr) - 1; i++\
    \ {\n        if arr[i] > arr[i + 1] {\n            found = false\n           \
    \ break\n        }\n    }\n    if found { return true }\n    //try to move ball\
    \ to the right\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] < arr[i\
    \ - 1] {\n            tmp := arr[i]\n            arr[i] = arr[i - 1]\n       \
    \     arr[i - 1] = tmp\n            break\n        }\n    }\n    //call itself\
    \ again\n    return move_one_ball(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpbof563tc_test.go:70: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpbof563tc_test.go:70:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    max_sofar := arr[0]\n    for _, elem := range arr {\n   \
    \     if elem < max_sofar {\n            return false\n        }\n        max_sofar\
    \ = elem\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range\
    \ [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpa7n838nz_test.go:30\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpa7n838nz_test.go:51\
    \ +0x1bd\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpwacx0ywn_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpwacx0ywn_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpwacx0ywn_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    var max,\
    \ min int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > max {\n  \
    \          max = arr[i]\n        }\n        if arr[i] < min {\n            min\
    \ = arr[i]\n        }\n    }\n    if max - min == len(arr) - 1 {\n        return\
    \ true\n    }\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp6_m0q2ol_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp6_m0q2ol_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    for i\
    \ := 0; i < len(arr); i++ {\n        if arr[i] == i + 1 {\n            continue\n\
    \        }\n        if arr[i] <= 0 || arr[i] > len(arr) {\n            return\
    \ false\n        }\n        tmp := arr[i]\n        arr[i] = arr[tmp - 1]\n   \
    \     arr[tmp - 1] = tmp\n        if arr[i] == i + 1 {\n            continue\n\
    \        }\n        return false\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp4u8efv04_test.go:68: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp4u8efv04_test.go:68:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) <= 1 {\n        return true\n    }\n    init_min,\
    \ init_max := min(arr), max(arr)\n    init_min_idx, init_max_idx := min_idx(arr),\
    \ max_idx(arr)\n    for i := 0; i < len(arr); i++ {\n        if i == init_min_idx\
    \ || i == init_max_idx {\n            continue\n        }\n        if arr[i] <\
    \ init_min || arr[i] > init_max {\n            return false\n        }\n    }\n\
    \    if init_min_idx < init_max_idx {\n        return true\n    }\n    if init_min_idx\
    \ == len(arr) - 1 {\n        if init_max_idx == 0 {\n            return true\n\
    \        }\n        for i := 0; i < init_max_idx; i++ {\n            if arr[i]\
    \ < init_min {\n                return false\n            }\n        }\n     \
    \   return true\n    }\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmg105t3h_test.go:33:27: undefined: min

    /tmp/tmpmg105t3h_test.go:33:37: undefined: max

    /tmp/tmpmg105t3h_test.go:34:35: undefined: min_idx

    /tmp/tmpmg105t3h_test.go:34:49: undefined: max_idx

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074225
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    max :=\
    \ arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < max {\n   \
    \         return false\n        }\n        if arr[i] > max {\n            max\
    \ = arr[i]\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpjqag8s6t_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpjqag8s6t_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    min :=\
    \ arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < min {\n   \
    \         return false\n        }\n        if arr[i] < arr[i-1] {\n          \
    \  min = arr[i]\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp_3dgb9q1_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp_3dgb9q1_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpdsg7abp3_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    n := len(arr)\n    if n == 0 {\n        return true\n   \
    \ }\n    for i := 1; i < n; i++ {\n        if arr[i] < arr[i-1] {\n          \
    \  return true\n        }\n    }\n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpyr66dzl8_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpyr66dzl8_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 0
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    n := len(arr)\n    if n == 0 {\n        return true\n   \
    \ }\n    cnt := 0\n    for i := 0; i < n - 1; i++ {\n        if arr[i] < arr[i\
    \ + 1] {\n            continue\n        }\n        cnt++\n        if cnt > 1 {\n\
    \            return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // this function returns true if we can sort the array\n\
    \    // in non-decreasing order by moving just one element\n    // to the beginning\
    \ of the array.\n    // otherwise returns false\n    if len(arr) == 0 {\n    \
    \    return true\n    }\n\n    // let's con\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkqug7rq5_test.go:39:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    var index_of_lowest_value = 0\n    for i, v := range arr\
    \ {\n        if v < arr[index_of_lowest_value] {\n            index_of_lowest_value\
    \ = i\n        }\n    }\n    if index_of_lowest_value == 0 {\n        return true\n\
    \    } else {\n        return false\n    }\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpein9b_di_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpein9b_di_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Fill up this function body\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp9e29xmb6_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp9e29xmb6_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp9e29xmb6_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    for i := len(arr) - 1; i > 0; i-- {\n        if arr[i] <\
    \ arr[i - 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpr_umkqa5_test.go:55: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpr_umkqa5_test.go:55:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    if len(arr)\
    \ == 1 {\n        return true\n    }\n    min, min_idx := arr[0], 0\n    for i,\
    \ v := range arr {\n        if v < min {\n            min, min_idx = v, i\n  \
    \      }\n    }\n    left := arr[:min_idx]\n    right := arr[min_idx:]\n    for\
    \ i, v := range left {\n        if v > right[i] {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpi3nar9_m_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpi3nar9_m_test.go:69:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    // Use\
    \ an array to store the indices for each element\n    // For example: arr = {3,\
    \ 4, 5, 1, 2}\n    // indices = [3, 4, 5, 1, 2]\n    indices := make([]int, len(arr))\n\
    \    for i, v := range arr {\n        indices[v - 1] = i\n    }\n    // For our\
    \ example, [0, 1, 2, 3, 4]\n    // The order the indices are stored represents\
    \ the order\n    // in which the element should be at\n    // For our example,\
    \ arr[0] = 3 => indices[0] = 0\n    // This means that arr[0] = 3 should be at\
    \ index 0\n    // But it's not. It's at index 3.\n    // This means we can't order\
    \ the array with a right shift\n    // and return false\n    for i, v := range\
    \ indices {\n        if i != v {\n            return false\n        }\n    }\n\
    \    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [9] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [9] with length 5\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpu1alny4__test.go:38\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpu1alny4__test.go:64\
    \ +0x585\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    max,\
    \ min := arr[0], arr[0]\n    count_max, count_min := 0, 0\n    for _, v := range\
    \ arr {\n        if v > max {\n            max = v\n            count_max = 1\n\
    \        } else if v == max {\n            count_max++\n        }\n        if\
    \ v < min {\n            min = v\n            count_min = 1\n        } else if\
    \ v == min {\n            count_min++\n        }\n    }\n    if max == min {\n\
    \        return count_max == len(arr)\n    }\n    return len(arr) - count_max\
    \ <= 1 && len(arr) - count_min <= 1\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp94a04zpw_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp94a04zpw_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074228
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    for i\
    \ := 1; i < len(arr); i++ {\n        if arr[i] < arr[i-1] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpmzfp6mc7_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpmzfp6mc7_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Your code goes here\n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpg9a61uvv_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpg9a61uvv_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpg9a61uvv_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) <= 1 {\n        return true\n    }\n    if arr[0]\
    \ < arr[len(arr)-1] {\n        return true\n    }\n    for i := 0; i < len(arr)-1;\
    \ i++ {\n        if arr[i] > arr[i+1] {\n            // at least one wrong position\
    \ is found\n            return false\n        }\n    }\n    return true\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpx50xna09_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpx50xna09_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074229
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    var numbers_map = make(map[int]int)\n    var numbers_map_sorted\
    \ = make(map[int]int)\n    for _, v := range arr {\n        if _, ok := numbers_map[v];\
    \ ok {\n            numbers_map[v] += 1\n        } else {\n            numbers_map[v]\
    \ = 1\n        }\n    }\n    numbers_map_sorted = numbers_map\n    fmt.Println(numbers_map)\n\
    \    var sorted_arr = make([]int, len(arr))\n    for i, _ := range sorted_arr\
    \ {\n        sorted_arr[i] = min(numbers_map_sorted)\n        numbers_map_sorted[sorted_arr[i]]\
    \ -= 1\n    }\n    fmt.Println(sorted_arr)\n    for i, _ := range sorted_arr {\n\
    \        if sorted_arr[i] != arr[i] {\n            return false\n        }\n \
    \   }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9in49c0x_test.go:43:25: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074229
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    n :=\
    \ len(arr)\n    i := n - 1\n    for i > 0 && arr[i-1] > arr[i] {\n        i -=\
    \ 1\n    }\n    if i == 0 {\n        return false\n    }\n    min := arr[i]\n\
    \    for j := i + 1; j < n; j++ {\n        if arr[j] < min {\n            min\
    \ = arr[j]\n        }\n    }\n    for j := 0; j < i; j++ {\n        if arr[j]\
    \ > min {\n            return false\n        }\n    }\n    return true\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpuq_6cuio_test.go:72: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpuq_6cuio_test.go:72:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074229
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    for i\
    \ := 0; i < len(arr) - 1; i++ {\n        if arr[i] > arr[i + 1] {\n          \
    \  // find the next item in the array that is smallest than arr[i]\n         \
    \   for j := i + 1; j < len(arr); j++ {\n                if arr[j] <= arr[i] {\n\
    \                    // perform a rotate\n                    return move_one_ball(append(append(arr[0:j],\
    \ arr[i]), arr[j:i]...))\n                }\n            }\n            // if\
    \ we got here, there is no element that is smaller than arr[i]\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [3:2] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [3:2]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball({0xc0000c4640?, 0xc0000f8eb8?,\
    \ 0x4b3193?})\n\t/tmp/tmpugith76h_test.go:39 +0xad\ncommand-line-arguments_test.TestMove_One_Ball(0x0?)\n\
    \t/tmp/tmpugith76h_test.go:56 +0xa8\ntesting.tRunner(0xc0001924e0, 0x528f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074229
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    for _,\
    \ v := range arr {\n        if v <= arr[0] {\n            continue\n        }\n\
    \        for i := 1; i < len(arr); i++ {\n            if arr[i] <= arr[0] {\n\
    \                arr[0], arr[i] = arr[i], arr[0]\n                break\n    \
    \        }\n        }\n    }\n    for i := 1; i < len(arr); i++ {\n        if\
    \ arr[i] < arr[i-1] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp0u5wj1ju_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp0u5wj1ju_test.go:69:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074229
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // YOUR CODE HERE\n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpfgji9st1_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpfgji9st1_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpfgji9st1_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // set the flag to indicate if the input array is empty\n\
    \    if len(arr) == 0 {\n        return true\n    }\n    // no need to move if\
    \ the array has only one element\n    if len(arr) == 1 {\n        return true\n\
    \    }\n    // go through the array and if we find an element smaller than its\n\
    \    // previous one then set the flag to false and get out of the loop\n    flag\
    \ := true\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < arr[i-1] {\n\
    \            flag = false\n            break\n        }\n    }\n    return flag\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp6tkvf7fc_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp6tkvf7fc_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074229
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    // Start\
    \ from the beginning of the list and keep track of the\n    // index of the previously\
    \ seen element. If the current element is\n    // less than the previous element,\
    \ check if it is possible to get\n    // a non-decreasing list by shifting the\
    \ current element to the\n    // beginning of the list. If so, update the previously\
    \ seen index\n    // and continue checking the rest of the list. If not, return\
    \ false.\n    prev := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i]\
    \ < arr[prev] {\n            if arr[i] >= arr[len(arr) - 1] {\n              \
    \  prev = i\n            } else {\n                return false\n            }\n\
    \        } else {\n            prev = i\n        }\n    }\n    return true\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpfbckjodd_test.go:71: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpfbckjodd_test.go:71:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074229
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    if len(arr)\
    \ == 1 {\n        return true\n    }\n    if len(arr) == 2 {\n        return true\n\
    \    }\n    if arr[0] < arr[1] {\n        return move_one_ball(arr[1:])\n    }\n\
    \    if arr[0] > arr[1] {\n        arr[0], arr[1] = arr[1], arr[0]\n        return\
    \ move_one_ball(arr[1:])\n    }\n    if arr[0] == arr[1] {\n        return move_one_ball(arr[1:])\n\
    \    }\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp7wt5sanw_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp7wt5sanw_test.go:69:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074229
- exit_code: 0
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    count_m1\
    \ := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < arr[i-1] {\n\
    \            count_m1 += 1\n        }\n    }\n    return count_m1 <= 1\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074229
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    // find\
    \ the max element in the list\n    max_idx := 0\n    for i := 1; i < len(arr);\
    \ i++ {\n        if arr[i] > arr[max_idx] {\n            max_idx = i\n       \
    \ }\n    }\n    if max_idx == 0 {\n        return true\n    }\n    // find the\
    \ min element at the right side of the max element\n    min_idx := max_idx + 1\n\
    \    for i := max_idx + 1; i < len(arr); i++ {\n        if arr[i] < arr[min_idx]\
    \ {\n            min_idx = i\n        }\n    }\n    // if the min element is at\
    \ the right side of the max element\n    // then it is possible to get a sorted\
    \ list by performing\n    // some right shift operations\n    if min_idx == max_idx\
    \ + 1 {\n        return true\n    }\n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp29r054r0_test.go:76: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074229
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    length := len(arr)\n    if length == 0 {\n        return\
    \ true\n    }\n\n    left := 0\n    right := length - 1\n    for left < right\
    \ {\n        if arr[left] <= arr[right] {\n            left++\n        } else\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp8tzz2fx4_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp8tzz2fx4_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074229
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // write code here\n    arr_len := len(arr)\n    if arr_len\
    \ == 0 {\n        return true\n    }\n    for i := 0; i < arr_len; i++ {\n   \
    \     if arr[i] == arr_len {\n            return true\n        }\n    }\n    return\
    \ false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpejjo28s6_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpejjo28s6_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074229
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    var length int = len(arr)\n    if length == 0 {\n       \
    \ return true\n    }\n    var min int = arr[0]\n    var max int = arr[0]\n   \
    \ var index int = 1\n    for index < length {\n        if min > arr[index] {\n\
    \            min = arr[index]\n        }\n        if max < arr[index] {\n    \
    \        max = arr[index]\n        }\n        index += 1\n    }\n    if max -\
    \ min + 1 == length {\n        return true\n    }\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__1\
    \ (0.00s)\n        tmp0quo0a08_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__2 (0.00s)\n        tmp0quo0a08_test.go:69:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestMove_One_Ball/test_num__3\
    \ (0.00s)\n        tmp0quo0a08_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074229
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    for i := 0; i < len(arr); i++ {\n        for j := i + 1;\
    \ j < len(arr); j++ {\n            if arr[i] > arr[j] {\n                return\
    \ false\n            }\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpstm9gmi8_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpstm9gmi8_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074229
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    N := len(arr)\n    if N == 0 {\n        return true\n   \
    \ }\n    i := 0\n    j := 1\n    for ; j < N; j++ {\n        if arr[j] < arr[i]\
    \ {\n            arr[i], arr[j] = arr[j], arr[i]\n            if i == 0 {\n  \
    \              i = 1\n            } else {\n                i--\n            }\n\
    \        } else {\n            i = j\n        }\n    }\n    return arr[0] <= arr[N-1]\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmppuxe7i8__test.go:68: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmppuxe7i8__test.go:68:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074229
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpdsg7abp3_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    var max int = arr[0]\n    var i int = 1\n    for i < len(arr)\
    \ {\n        if arr[i] > max {\n            max = arr[i]\n        } else {\n \
    \           break\n        }\n        i++\n    }\n    if i == len(arr) {\n   \
    \     return true\n    }\n    for ; i < len(arr); i++ {\n        if arr[i] < max\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range\
    \ [0] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpz6krzugs_test.go:30\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpz6krzugs_test.go:62\
    \ +0x25d\ntesting.tRunner(0xc0001924e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074229
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    n :=\
    \ len(arr)\n    for i := 0; i < n; i++ {\n        for j := 0; j < n - 1; j++ {\n\
    \            if arr[j] > arr[j + 1] {\n                arr[j], arr[j + 1] = arr[j\
    \ + 1], arr[j]\n            }\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp6cej4ai3_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp6cej4ai3_test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074229
- exit_code: 0
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    n := len(arr)\n    if n <= 1 {\n        return true\n   \
    \ }\n    i := 0\n    for i < n - 1 {\n        if arr[i] > arr[i + 1] {\n     \
    \       break\n        }\n        i++\n    }\n    if i == n - 1 {\n        return\
    \ true\n    }\n    j := i + 1\n    for j < n - 1 {\n        if arr[j] > arr[j\
    \ + 1] {\n            return false\n        }\n        j++\n    }\n    if j ==\
    \ n - 1 {\n        return true\n    }\n    return false\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074230
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    length := len(arr)\n    if length <= 1 {\n        return\
    \ true\n    }\n    // counter := 0\n    min := 100000\n    max := -1\n    min_index\
    \ := -1\n    max_index := -1\n    min_index_last := -1\n    last_index := -1\n\
    \    for i := 0; i < length; i++ {\n        if arr[i] > max {\n            max\
    \ = arr[i]\n            max_index = i\n        }\n        if arr[i] < min {\n\
    \            min = arr[i]\n            min_index = i\n        }\n        last_index\
    \ = i\n    }\n    if min_index == 0 {\n        min_index_last = min_index\n  \
    \  } else {\n        min_index_last = min_index - 1\n    }\n    if min_index_last\
    \ == last_index {\n        return true\n    }\n    for i := min_index_last; i\
    \ < length - 1; i++ {\n        if arr[i] > arr[i + 1] {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa_cyp0mi_test.go:38:5: max_index declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074230
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) <= 1 {\n        return true\n    }\n    var out\
    \ []int\n    if arr[0] > arr[len(arr)-1] {\n        out = append(arr[1:], arr[0])\n\
    \    } else {\n        out = arr\n    }\n    return move_one_ball(out)\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0370\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f348?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.move_one_ball({0xc0000202d0?,\
    \ 0x5?, 0x6?})\n\t/tmp/tmps3hyuyhj_test.go:29 +0xc5 fp=0xc0201e0380 sp=0xc0201e0378\
    \ pc=0x4ef725\ncommand-line-arguments_test.move_one_ball({0xc0000202d0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmps3hyuyhj_test.go:39 +0x95 fp=0xc0201e03d8 sp=0xc0201e0380\
    \ pc=0x4ef6f5\ncommand-line-arguments_test.move_one_ball({0xc0000202d0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmps3hyuyhj_test.go:39 +0x95 fp=0xc0201e0430 sp=0xc0201e03d8\
    \ pc=0x4ef6f5\ncommand-line-arguments_test.move_one_ball({0xc0000202d0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmps3hyuyhj_test.go:39 +0x95 fp=0xc0201e0488 sp=0xc0201e0430\
    \ pc=0x4ef6f5\ncommand-line-arguments_test.move_one_ball({0xc0000202d0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmps3hyuyhj_test.go:39 +0x95 fp=0xc0201e04e0 sp=0xc0201e0488\
    \ pc=0x4ef6f5\ncommand-line-arguments_test.move_one_ball({0xc0000202d0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmps3hyuyhj_test.go:39 +0x95 fp=0xc0201e0538 sp=0xc0201e04e0\
    \ pc=0x4ef6f5\ncommand-line-arguments_test.move_one_ball({0xc0000202d0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmps3hyuyhj_test.go:39 +0x95 fp=0xc0201e0590 sp=0xc0201e0538\
    \ pc=0x4ef6f5\ncommand-line-arguments_test.move_one_ball({0xc0000202d0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmps3hyuyhj_test.go:39 +0x95 fp=0xc0201e05e8 sp=0xc0201e0590\
    \ pc=0x4ef6f5\ncommand-line-arguments_test.move_one_ball({0xc0000202d0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmps3hyuyhj_test.go:39 +0x95 fp=0xc0201e0640 sp=0xc0201e05e8\
    \ pc=0x4ef6f5\ncommand-line-arguments_test.move_one_ball({0xc0000202d0?, 0x0?,\
    \ 0x0?})\n\t/tmp/tmps3hyuyhj_test.go:39 +0x95 fp=0xc0201e0698 sp=0xc0201e0640\
    \ pc=0x4ef6f5\ncommand-line-arguments_test.move_one_ball({0xc0000202d0?, 0x0?,\
    \ 0x0?})\n\t/tmp"
  timestamp: 1660074231
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // replace this comment with the code below, following the\n\
    \    // in\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_dzevhy6_test.go:32:6: expected ''('', found TestMove_One_Ball

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074229
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    found\
    \ := false\n    var right_most int\n    for i := 0; i < len(arr); i++ {\n    \
    \    for j := i + 1; j < len(arr); j++ {\n            if arr[i] > arr[j] {\n \
    \               found = true\n                right_most = j\n            }\n\
    \        }\n    }\n    if found {\n        // move arr[right_most] to the front\n\
    \        val := arr[right_most]\n        for i := right_most; i > 0; i-- {\n \
    \           arr[i] = arr[i - 1]\n        }\n        arr[0] = val\n        // check\
    \ if it is sorted\n        for i := 0; i < len(arr) - 1; i++ {\n            if\
    \ arr[i] > arr[i + 1] {\n                return false\n            }\n       \
    \ }\n        return true\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp48t8nq2v_test.go:78: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp48t8nq2v_test.go:78:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074231
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    min :=\
    \ arr[0]\n    i := 1\n    for i < len(arr) {\n        if arr[i] < min {\n    \
    \        return false\n        }\n        if arr[i] < arr[i-1] {\n           \
    \ min = arr[i]\n        }\n        i++\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp6afo7eex_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp6afo7eex_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074231
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    if len(arr)\
    \ == 1 {\n        return true\n    }\n    var min, max int\n    min = arr[0]\n\
    \    max = arr[0]\n    for _, item := range arr {\n        if item < min {\n \
    \           min = item\n        }\n        if item > max {\n            max =\
    \ item\n        }\n    }\n    return max - min == len(arr) - 1\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__1\
    \ (0.00s)\n        tmp4b1ym_b9_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__2 (0.00s)\n        tmp4b1ym_b9_test.go:67:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestMove_One_Ball/test_num__3\
    \ (0.00s)\n        tmp4b1ym_b9_test.go:67: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074231
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpdsg7abp3_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    for i\
    \ := 1; i < len(arr); i++ {\n        if arr[i] < arr[i-1] {\n            arr[i],\
    \ arr[i-1] = arr[i-1], arr[i]\n            if is_sorted(arr) {\n             \
    \   return true\n            }\n            arr[i], arr[i-1] = arr[i-1], arr[i]\n\
    \        }\n    }\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprex5dfas_test.go:36:16: undefined: is_sorted

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074231
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    max :=\
    \ arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < max {\n   \
    \         return false\n        }\n        if arr[i] > max {\n            max\
    \ = arr[i]\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpjqag8s6t_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpjqag8s6t_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074226
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    var n\
    \ int = len(arr)\n    var count_map map[int]int = make(map[int]int)\n    for i\
    \ := 0; i < n; i++ {\n        if _, ok := count_map[arr[i]]; ok {\n          \
    \  count_map[arr[i]] += 1\n        } else {\n            count_map[arr[i]] = 1\n\
    \        }\n    }\n    var max_count int = 0\n    for _, value := range count_map\
    \ {\n        if value > max_count {\n            max_count = value\n        }\n\
    \    }\n    return (max_count == 1)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpl2cqa0py_test.go:68: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpl2cqa0py_test.go:68:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    n := len(arr)\n    arr = append(arr, arr[0])\n    fmt.Println(arr)\n\
    \    first_local_min := -1\n    for i := 0; i < n; i++ {\n        if arr[i] >\
    \ arr[i+1] {\n            first_local_min = i\n            break\n        }\n\
    \    }\n    fmt.Println(first_local_min)\n    if first_local_min == -1 {\n   \
    \     return true\n    }\n    for i := first_local_min + 1; i < n; i++ {\n   \
    \     if arr[i] > arr[i+1] {\n            return false\n        }\n    }\n   \
    \ return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "[3 4 5 1 2 3]\n2\n[3 5 10 1 2 3]\n2\n[4 3 1 2 4]\n0\n[3 5 4 1 2 3]\n1\n\
    --- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball({0x62a7e0?, 0x5?, 0x4b3160?})\n\
    \t/tmp/tmp_ndv3n5o_test.go:31 +0x1e5\ncommand-line-arguments_test.TestMove_One_Ball(0x0?)\n\
    \t/tmp/tmp_ndv3n5o_test.go:63 +0x18d\ntesting.tRunner(0xc0001a01a0, 0x529020)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpdsg7abp3_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    ball := arr[0]\n    for i := 1; i < len(arr); i++ {\n   \
    \     if arr[i] < ball {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range\
    \ [0] with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpvzm74rf0_test.go:30\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpvzm74rf0_test.go:50\
    \ +0x1c5\ntesting.tRunner(0xc0001991e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    if len(arr)\
    \ == 1 {\n        return true\n    }\n    arr_copy := make([]int, len(arr))\n\
    \    copy(arr_copy, arr)\n    var max int\n    for _, v := range arr {\n     \
    \   if v > max {\n            max = v\n        }\n    }\n    max_index := 0\n\
    \    for k, v := range arr {\n        if v == max {\n            max_index = k\n\
    \        }\n    }\n    var i int\n    for ; i <= max_index; i++ {\n        var\
    \ count int\n        if arr[i] == arr_copy[0] {\n            for j := 0; j < len(arr_copy);\
    \ j++ {\n                if arr[i] == arr_copy[j] {\n                    count\
    \ += 1\n                }\n            }\n            if count == 1 {\n      \
    \          return true\n            }\n        }\n    }\n    return false\n}\n\
    \nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpkbqi2c4__test.go:84: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpkbqi2c4__test.go:84:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    size := len(arr)\n    if size == 0 {\n        return true\n\
    \    }\n    for i := 0; i < size; i++ {\n        if arr[(i + 1) % size] < arr[i]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpvrthwmo7_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpvrthwmo7_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    var m map[int]int\n    m = make(map[int]int)\n    for _,\
    \ v := range arr {\n        m[v] += 1\n    }\n    var d []int\n    d = make([]int,\
    \ len(m))\n    for _, v := range m {\n        d = append(d, v)\n    }\n    for\
    \ i, v := range d {\n        if v > 1 {\n            return false\n        }\n\
    \        if i > 0 && d[i] < d[i-1] {\n            return false\n        }\n  \
    \  }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp4x9w34fr_test.go:68: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp4x9w34fr_test.go:68:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    for i\
    \ := 0; i < len(arr); i++ {\n        cur := arr[i]\n        for cur < arr[(i +\
    \ 1) % len(arr)] {\n            cur = arr[(i + 1) % len(arr)]\n            i++\n\
    \        }\n        if cur > arr[(i + 1) % len(arr)] {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpe772ga0e_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpe772ga0e_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    var n = len(arr)\n    if n == 0 {\n        return true\n\
    \    }\n    for i := 1; i < n; i++ {\n        var j = i\n        for j > 0 &&\
    \ arr[j] < arr[j-1] {\n            j--\n        }\n        if j == 0 {\n     \
    \       continue\n        }\n        var tmp = arr[j-1]\n        for k := j-1;\
    \ k < i; k++ {\n            arr[k] = arr[k+1]\n        }\n        arr[i] = tmp\n\
    \    }\n    for i := 1; i < n; i++ {\n        if arr[i] < arr[i-1] {\n       \
    \     return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpf4gx379t_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpf4gx379t_test.go:73:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    for i\
    \ := 0; i < len(arr); i++ {\n        if i == 0 {\n            if arr[i] > arr[i+1]\
    \ {\n                arr[i] ^= arr[i+1]\n                arr[i+1] ^= arr[i]\n\
    \                arr[i] ^= arr[i+1]\n            }\n        } else if i == len(arr)-1\
    \ {\n            if arr[i] < arr[i-1] {\n                arr[i] ^= arr[i-1]\n\
    \                arr[i-1] ^= arr[i]\n                arr[i] ^= arr[i-1]\n    \
    \        }\n        } else {\n            if arr[i] > arr[i+1] {\n           \
    \     arr[i] ^= arr[i+1]\n                arr[i+1] ^= arr[i]\n               \
    \ arr[i] ^= arr[i+1]\n            }\n            if arr[i] < arr[i-1] {\n    \
    \            arr[i] ^= arr[i-1]\n                arr[i-1] ^= arr[i]\n        \
    \        arr[i] ^= arr[i-1]\n            }\n        }\n    }\n    for i := 0;\
    \ i < len(arr)-1; i++ {\n        if arr[i] > arr[i+1] {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpy9zz71nq_test.go:84: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpy9zz71nq_test.go:84:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpy9zz71nq_test.go:84: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    var arrLen = len(arr)\n    if arrLen == 0 {\n        return\
    \ true\n    }\n    for i := 0; i < arrLen - 1; i++ {\n        if arr[i] > arr[i\
    \ + 1] {\n            arr[i], arr[i + 1] = arr[i + 1], arr[i]\n            return\
    \ move_one_ball(arr)\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp5g8mvduo_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp5g8mvduo_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpjpr6dhu9_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpjpr6dhu9_test.go:50:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074218
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // NOTE:\n    // 1. We can safely assume that all numbers\
    \ in the list are unique.\n    // 2. We can assume that all numbers in the list\
    \ are in the range\n    // [1, N], where N is the length of the list.\n    //\
    \ 3. Clearly, if the list is empty, then we can return true.\n    // 4. Let's\
    \ assume that the sorted list is:\n    //    [x_1, x_2, ..., x_N], where x_1 <=\
    \ x_2 <= ... <= x_N.\n    // 5. Then, the list should look like this:\n    //\
    \    [1, x_1, 2, x_2, ..., N, x_N]\n    //    [x_1, 1, x_2, 2, ..., x_N, N]\n\
    \    // 6. If the list is already in this form, then we can immediately return\n\
    \    // true.\n    // 7. Otherwise, we can go through the list, if we see that\
    \ the current\n    // number in the list is already in the place it should be,\
    \ then we can\n    // advance.\n    // 8. Otherwise, we go to the place it should\
    \ be, and if the number there\n    // is the same as the current number, then\
    \ we can return false, else we\n    // can put the current number there, and put\
    \ the number there to where\n    // the current number is, and repeat.\n    //\
    \ 9. The above approach can be made efficient by using a hash table.\n    if len(arr)\
    \ == 0 {\n        return true\n    }\n    hash_table := make(map[int]int)\n  \
    \  for i, v := range arr {\n        hash_table[v] = i\n    }\n    for i, v :=\
    \ range arr {\n        desired_index := hash_table[i + 1]\n        if desired_index\
    \ != i {\n            if arr[desired_index] == v {\n                return false\n\
    \            }\n            arr[i], arr[desired_index] = arr[desired_index], arr[i]\n\
    \        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpjcv23bsq_test.go:86: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpjcv23bsq_test.go:86:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    if len(arr)\
    \ == 1 {\n        return true\n    }\n    if arr[0] > arr[1] {\n        return\
    \ false\n    }\n    max := arr[0]\n    for i := 1; i < len(arr); i++ {\n     \
    \   if arr[i] > max {\n            max = arr[i]\n        } else {\n          \
    \  return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpml__0odh_test.go:67: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpml__0odh_test.go:67:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpdsg7abp3_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    n := len(arr)\n    var min int = 0\n    for i := 0; i < n;\
    \ i++ {\n        if arr[i] < arr[min] {\n            min = i\n        }\n    }\n\
    \    for i := 0; i < n; i++ {\n        if arr[(i + min) % n] > arr[(i + min +\
    \ 1) % n] {\n            return false\n        }\n    }\n    return true\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpa737fx_q_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpa737fx_q_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    for i\
    \ := 0; i < len(arr) - 1; i++ {\n        // Find the minimum value in the rest\
    \ of the list\n        min_arr := arr[i+1:]\n        min := arr[i+1]\n       \
    \ for _, elem := range min_arr {\n            if elem < min {\n              \
    \  min = elem\n            }\n        }\n        // Find the position of the minimum\
    \ in the rest of the list\n        min_pos := -1\n        for j, elem := range\
    \ min_arr {\n            if elem == min {\n                min_pos = j\n     \
    \       }\n        }\n        // If the minimum is in position 0, make it first\
    \ in arr\n        // If the minimum is in position 1, nothing to do\n        //\
    \ If the minimum is in position > 1, we cannot make it the first\n        // element\
    \ in arr so we return false\n        if min_pos > 1 {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpovjt9pdv_test.go:77: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpovjt9pdv_test.go:77:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpovjt9pdv_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    is_permutation := true\n    permutation := make([]int, len(arr))\n\
    \    for i, v := range arr {\n        permutation[v-1] = i\n    }\n    for i,\
    \ v := range permutation {\n        if v != i {\n            is_permutation =\
    \ false\n            break\n        }\n    }\n    return is_permutation\n}\n\n\
    func TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [9] with length 5 [recovered]\n\tpanic: runtime error: index out of range\
    \ [9] with length 5\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmp49cjhrg5_test.go:33\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmp49cjhrg5_test.go:52\
    \ +0x5b2\ntesting.tRunner(0xc0001a0340, 0x528f40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) <= 1 {\n        return true\n    }\n    for i,\
    \ num := range arr {\n        if i == 0 {\n            continue\n        }\n \
    \       if num < arr[i-1] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpx5n8a7m2_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpx5n8a7m2_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074232
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    return\
    \ in_order(arr, -1)\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate\
    \ := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpghuzihd8_test.go:33:12: undefined: in_order

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    for i\
    \ := 0; i < len(arr) - 1; i++ {\n        if arr[i] > arr[i + 1] {\n          \
    \  return false\n        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp5ckxwq_6_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp5ckxwq_6_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // Your code goes here\n    if len(arr) == 0 {\n        return\
    \ true\n    }\n    min := arr[0]\n    count := 0\n    for i:=0; i<len(arr); i++\
    \ {\n        if arr[i] < min {\n            min = arr[i]\n            count =\
    \ 0\n        }\n        if arr[i] == min {\n            count++\n        }\n \
    \   }\n    return count < len(arr)\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmp3n60q12p_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmp3n60q12p_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 0
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    count\
    \ := 0\n    for i := 0; i < len(arr) - 1; i++ {\n        if arr[i] > arr[i + 1]\
    \ {\n            count++\n        }\n    }\n    if count <= 1 {\n        return\
    \ true\n    }\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    arr = append(arr, arr[0])\n    arr = arr[1:]\n    sorted\
    \ := false\n    for !sorted {\n        sorted = true\n        for i := 0; i <\
    \ len(arr)-1; i++ {\n            if arr[i] > arr[i+1] {\n                arr[i],\
    \ arr[i+1] = arr[i+1], arr[i]\n                sorted = false\n            }\n\
    \        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range\
    \ [0] with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball(...)\n\t/tmp/tmpggn6jn01_test.go:30\n\
    command-line-arguments_test.TestMove_One_Ball(0x0?)\n\t/tmp/tmpggn6jn01_test.go:56\
    \ +0x332\ntesting.tRunner(0xc000103520, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) <= 1 {\n        return true\n    }\n    // Find\
    \ the smallest element\n    smallest := arr[0]\n    index := 0\n    for i, v :=\
    \ range arr {\n        if v < smallest {\n            smallest = v\n         \
    \   index = i\n        }\n    }\n    // Find the index of the smallest element\
    \ after the shift\n    newIndex := 0\n    for i, v := range arr {\n        if\
    \ v == smallest {\n            newIndex = i\n            break\n        }\n  \
    \  }\n    // Return false if the index of the smallest element after the shift\
    \ is\n    // greater than the index of the smallest element before the shift\n\
    \    if newIndex > index {\n        return false\n    }\n    // Return true if\
    \ the index of the smallest element after the shift is\n    // lesser than the\
    \ index of the smallest element before the shift\n    return true\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__2\
    \ (0.00s)\n        tmpvyxldaxe_test.go:77: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__3 (0.00s)\n        tmpvyxldaxe_test.go:77:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074233
- exit_code: 0
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    var left,\
    \ right int\n    left = 0\n    right = len(arr) - 1\n    if left == right {\n\
    \        return true\n    }\n    // go right until we find the first right\n \
    \   for ; left < right && arr[left] <= arr[left + 1]; left++ {\n    }\n    //\
    \ go left until we find the first left\n    for ; left < right && arr[right] >=\
    \ arr[right - 1]; right-- {\n    }\n    // we need at least 3 elements to sort\n\
    \    if left >= right - 1 {\n        return true\n    }\n    // check if the remaining\
    \ slice is sorted\n    for i := left + 1; i < right; i++ {\n        if arr[i]\
    \ < arr[i - 1] {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074233
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    n := len(arr)\n    if n <= 1 {\n        return true\n   \
    \ }\n    if n == 2 {\n        return arr[0] <= arr[1]\n    }\n    var min int\n\
    \    min, min_idx := arr[0], 0\n    for i, v := range arr {\n        if v < min\
    \ {\n            min, min_idx = v, i\n        }\n    }\n    return is_sorted(arr[min_idx:])\
    \ || is_sorted(arr[:min_idx])\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n \
    \ candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfjrd3tlk_test.go:44:12: undefined: is_sorted

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    for i := 0; i < len(arr); i++ {\n        j := i\n       \
    \ for j > 0 && arr[j] < arr[j-1] {\n            arr[j], arr[j-1] = arr[j-1], arr[j]\n\
    \            j--\n        }\n    }\n    return is_sorted(arr)\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6cuuyrct_test.go:37:12: undefined: is_sorted

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074232
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n     { actual:\
    \ candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual: candidate([]int{3,\
    \ 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmp77vkvems_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmp77vkvems_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073995
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    seen\
    \ := make(map[int]bool)\n    return dfs(arr, seen, 0)\n}\n\nfunc TestMove_One_Ball(t\
    \ *testing.T) {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3,\
    \ 5, 10, 1, 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}),\
    \ expected: false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpymcbre6y_test.go:34:12: undefined: dfs

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074233
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    //TODO\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpe8maeqsz_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpe8maeqsz_test.go:51:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpe8maeqsz_test.go:51: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074233
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    // base case\n    arrLen := len(arr)\n    if arrLen == 0\
    \ {\n        return true\n    }\n    // search for the smallest value\n    i,\
    \ j := 0, 0\n    for i = 0; i < arrLen; i++ {\n        // fmt.Println(arr)\n \
    \       if i == 0 && arr[i] < arr[i+1] {\n            break\n        } else if\
    \ i == arrLen-1 && arr[i] < arr[i-1] {\n            break\n        } else if arr[i]\
    \ < arr[i-1] && arr[i] < arr[i+1] {\n            break\n        }\n    }\n   \
    \ // search for the biggest value\n    j = i\n    for j = i; j < arrLen; j++ {\n\
    \        if j == 0 && arr[j] > arr[j+1] {\n            break\n        } else if\
    \ j == arrLen-1 && arr[j] > arr[j-1] {\n            break\n        } else if arr[j]\
    \ > arr[j-1] && arr[j] > arr[j+1] {\n            break\n        }\n    }\n   \
    \ // fmt.Println(i, j)\n    // slice operation\n    for k := j; k > i; k-- {\n\
    \        arr[k], arr[k-1] = arr[k-1], arr[k]\n    }\n    // test\n    for m :=\
    \ 0; m < arrLen-1; m++ {\n        if arr[m] > arr[m+1] {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T)\
    \ {\n  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\npanic: runtime error: index out of\
    \ range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\n\
    goroutine 34 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc0001d6000})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.move_one_ball({0xc0001d2640?, 0xc000191058?,\
    \ 0x4b3193?})\n\t/tmp/tmpqhjmrlex_test.go:54 +0x23b\ncommand-line-arguments_test.TestMove_One_Ball(0x0?)\n\
    \t/tmp/tmpqhjmrlex_test.go:79 +0xa8\ntesting.tRunner(0xc000198ea0, 0x528f40)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074233
- exit_code: 2
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    N := len(arr)\n    pos := 0\n    for i := 0; i < N; i++ {\n\
    \        if arr[i] > arr[i+1] {\n            pos = i\n            break\n    \
    \    }\n    }\n    i := pos + 1\n    j := N - 1\n    for i < j {\n        arr[i],\
    \ arr[j] = arr[j], arr[i]\n        i++\n        j--\n    }\n    return is_decreasing(arr)\n\
    }\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate := move_one_ball\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 4, 5, 1, 2}), expected:\
    \ true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}), expected: true },\n\
    \     { actual: candidate([]int{4, 3, 1, 2}), expected: false },\n     { actual:\
    \ candidate([]int{3, 5, 4, 1, 2}), expected: false },\n     { actual: candidate([]int{}),\
    \ expected: true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpurquqv4l_test.go:45:12: undefined: is_decreasing

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074233
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    return false\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n\
    \  candidate := move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 4, 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1,\
    \ 2}), expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected:\
    \ false },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n\
    \     { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__0\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__1 (0.00s)\n        tmpdsg7abp3_test.go:50:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestMove_One_Ball/test_num__4\
    \ (0.00s)\n        tmpdsg7abp3_test.go:50: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074221
- exit_code: 1
  program: "package move_one_ball_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
    )\n\n// We have a list 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n//\
    \ numbers in the list will be randomly ordered. Your task is to determine if\n\
    // it is possible to get a list sorted in non-decreasing order by performing \n\
    // the following operation on the given list:\n// You are allowed to perform right\
    \ shift operation any number of times.\n// One right shift operation means shifting\
    \ all elements of the list by one\n// position in the right direction. The last\
    \ element of the list will be moved to\n// the starting position in the list i.e.\
    \ 0th index. \n// If it is possible to obtain the sorted list by performing the\
    \ above operation\n// then return true else return false.\n// If the given list\
    \ is empty then return true.\n// Note: The given list is guaranteed to have unique\
    \ elements.\n// For Example:\n// >>> move_one_ball([]int{3, 4, 5, 1, 2})\n// true\n\
    // Explanation: By performin 2 right shift operations, non-decreasing order can\n\
    // be achieved for the given list.\n// >>> move_one_ball([]int{3, 5, 4, 1, 2})\n\
    // false\n// Explanation:It is not possible to get non-decreasing order for the\
    \ given\n// list by performing any number of right shift operations.\nfunc move_one_ball(arr\
    \ []int) bool {\n    if len(arr) == 0 {\n        return true\n    }\n    for _,\
    \ v := range arr {\n        if v > len(arr) {\n            return false\n    \
    \    }\n    }\n    balls := make([]int, len(arr))\n    for _, v := range arr {\n\
    \        balls[v-1] = 1\n    }\n    if balls[0] == 0 {\n        return false\n\
    \    }\n    for i, v := range balls {\n        if i == 0 {\n            continue\n\
    \        }\n        if v == 0 {\n            return false\n        }\n    }\n\
    \    return true\n}\n\nfunc TestMove_One_Ball(t *testing.T) {\n  candidate :=\
    \ move_one_ball\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 4,\
    \ 5, 1, 2}), expected: true },\n     { actual: candidate([]int{3, 5, 10, 1, 2}),\
    \ expected: true },\n     { actual: candidate([]int{4, 3, 1, 2}), expected: false\
    \ },\n     { actual: candidate([]int{3, 5, 4, 1, 2}), expected: false },\n   \
    \  { actual: candidate([]int{}), expected: true },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMove_One_Ball (0.00s)\n    --- FAIL: TestMove_One_Ball/test_num__1\
    \ (0.00s)\n        tmpz3_7l0q1_test.go:73: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestMove_One_Ball/test_num__2 (0.00s)\n        tmpz3_7l0q1_test.go:73:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestMove_One_Ball/test_num__3\
    \ (0.00s)\n        tmpz3_7l0q1_test.go:73: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074233
