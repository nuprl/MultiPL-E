name: HumanEval_61_correct_bracketing
language: go_test.go
prompt: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
  \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
  \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
  )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
  (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
  \ string) bool {\n"
tests: "func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n    \
  \ { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
  ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
  ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false },\n\
  \     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
  (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false },\n\
  \     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
  (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
  \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
  \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
  \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    return false\n}\n", "    stack := 0\n    for _, char := range brackets\
    \ {\n        if char == '(' {\n            stack += 1\n        } else if char\
    \ == ')' {\n            stack -= 1\n        }\n        if stack < 0 {\n      \
    \      return false\n        }\n    }\n    return stack == 0\n}\n", "    var open,\
    \ closed int\n    for _, b := range brackets {\n        if b == '(' {\n      \
    \      open++\n        } else {\n            closed++\n        }\n        if closed\
    \ > open {\n            return false\n        }\n    }\n    return open == closed\n\
    }\n", "    count := 0\n    for _, c := range brackets {\n        if c == '(' {\n\
    \            count++\n        } else if c == ')' {\n            count--\n    \
    \    }\n        if count < 0 {\n            return false\n        }\n    }\n \
    \   return count == 0\n}\n", "\tcount := 0\n\tfor _, c := range brackets {\n\t\
    \tif c == '(' {\n\t\t\tcount++\n\t\t} else if c == ')' {\n\t\t\tcount--\n\t\t\
    }\n\t\tif count < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn count == 0\n}\n",
  "    var i, bCount int\n    for i, bCount = 0, 0; i < len(brackets); i++ {\n   \
    \     if brackets[i] == '(' {\n            bCount++\n        } else {\n      \
    \      bCount--\n        }\n        if bCount < 0 {\n            return false\n\
    \        }\n    }\n    return bCount == 0\n}\n", "    return true\n}\n", "   \
    \ balance := 0\n    for _, r := range brackets {\n        if r == '(' {\n    \
    \        balance += 1\n        } else if r == ')' {\n            balance -= 1\n\
    \        }\n        if balance < 0 {\n            return false\n        }\n  \
    \  }\n    return balance == 0\n}\n", "    count := 0\n    for _, b := range brackets\
    \ {\n        if b == '(' {\n            count += 1\n        } else if b == ')'\
    \ {\n            count -= 1\n        }\n        if count < 0 {\n            return\
    \ false\n        }\n    }\n    return count == 0\n}\n", "    return true\n}\n",
  "    count := 0\n    for _, c := range brackets {\n        if c == '(' {\n     \
    \       count += 1\n        } else if c == ')' {\n            count -= 1\n   \
    \     }\n        if count < 0 {\n            return false\n        }\n    }\n\
    \    return count == 0\n}\n", "    balance := 0\n    for _, c := range brackets\
    \ {\n        if c == '(' {\n            balance += 1\n        } else if c == ')'\
    \ {\n            balance -= 1\n        }\n        if balance < 0 {\n         \
    \   return false\n        }\n    }\n    return balance == 0\n}\n", "    var c\
    \ int\n    for _, b := range brackets {\n        if b == '(' {\n            c\
    \ += 1\n        } else {\n            c -= 1\n        }\n        if c < 0 {\n\
    \            return false\n        }\n    }\n    return c == 0\n}\n", "    //\
    \ stack to hold opening brackets\n    stk := make([]byte, 0)\n    // i is index\
    \ of next closing bracket\n    i := 0\n    // while i < len(brackets)\n    for\
    \ i < len(brackets) {\n        // if brackets[i] == \")\"\n        if brackets[i]\
    \ == ')' {\n            // pop an item from stack\n            if len(stk) ==\
    \ 0 {\n                return false\n            }\n            stk = stk[:len(stk)-1]\n\
    \        } else {\n            // push \"(\" to stack\n            stk = append(stk,\
    \ brackets[i])\n        }\n        i++\n    }\n    // after while, return stack\
    \ is empty\n    return len(stk) == 0\n}\n", "    var s []rune\n    var m = map[rune]rune{')':\
    \ '('}\n    for _, r := range brackets {\n        switch r {\n        case '(':\n\
    \            s = append(s, r)\n        case ')':\n            if len(s) > 0 &&\
    \ s[len(s)-1] == m[r] {\n                s = s[:len(s)-1]\n            } else\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ len(s) == 0\n}\n", "    return true\n}\n", "    balance := 0\n    for _, b :=\
    \ range brackets {\n        switch b {\n        case '(':\n            balance\
    \ += 1\n        case ')':\n            balance -= 1\n        }\n        if balance\
    \ < 0 {\n            return false\n        }\n    }\n    return balance == 0\n\
    }\n", "    return false\n}\n", "    counter := 0\n    for _, bracket := range\
    \ brackets {\n        switch bracket {\n        case '(':\n            counter\
    \ += 1\n        case ')':\n            counter -= 1\n        }\n        if counter\
    \ < 0 {\n            return false\n        }\n    }\n    return counter == 0\n\
    }\n", "    //c := 0\n    //for _, bracket := range brackets {\n    //    if bracket\
    \ == '(' {\n    //        c++\n    //    } else {\n    //        c--\n    // \
    \   }\n    //    if c < 0 {\n    //        return false\n    //    }\n    //}\n\
    \    //return c == 0\n    stack := []rune{}\n    for _, bracket := range brackets\
    \ {\n        if bracket == '(' {\n            stack = append(stack, bracket)\n\
    \        } else {\n            stack = stack[:len(stack)-1]\n        }\n    }\n\
    \    return len(stack) == 0\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
