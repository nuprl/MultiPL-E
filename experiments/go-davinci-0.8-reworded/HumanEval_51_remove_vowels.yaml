name: HumanEval_51_remove_vowels
language: go_test.go
prompt: "package remove_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
  \n// remove_vowels is a function that takes string and returns string without vowels.\n\
  // >>> remove_vowels(\"\")\n// \"\"\n// >>> remove_vowels(\"abcdef\")\n// \"bcdf\"\
  \n// >>> remove_vowels(\"aaaaa\")\n// \"\"\n// >>> remove_vowels(\"aaBAA\")\n//\
  \ \"B\"\n// >>> remove_vowels(\"zbcd\")\n// \"zbcd\"\nfunc remove_vowels(text string)\
  \ string {\n"
tests: "func TestRemove_Vowels(t *testing.T) {\n  candidate := remove_vowels\n\ttype\
  \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
  \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
  \ candidate(\"abcdef\\nghijklm\"), expected: \"bcdf\\nghjklm\" },\n     { actual:\
  \ candidate(\"fedcba\"), expected: \"fdcb\" },\n     { actual: candidate(\"eeeee\"\
  ), expected: \"\" },\n     { actual: candidate(\"acBAA\"), expected: \"cB\" },\n\
  \     { actual: candidate(\"EcBOO\"), expected: \"cB\" },\n     { actual: candidate(\"\
  ybcd\"), expected: \"ybcd\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\"\
    , \"E\", \"I\", \"O\", \"U\"}\n    var vowel_flag = map[string]bool{}\n    for\
    \ _, v := range vowels {\n        vowel_flag[v] = true\n    }\n    r := []rune(text)\n\
    \    var result []rune\n    for _, v := range r {\n        if !vowel_flag[string(v)]\
    \ {\n            result = append(result, v)\n        }\n    }\n    return string(result)\n\
    }\n", "    vowels := map[rune]bool{\n        'a': true,\n        'e': true,\n\
    \        'i': true,\n        'o': true,\n        'u': true,\n        'A': true,\n\
    \        'E': true,\n        'I': true,\n        'O': true,\n        'U': true,\n\
    \    }\n    var result string\n    for _, c := range text {\n        if !vowels[c]\
    \ {\n            result += string(c)\n        }\n    }\n    return result\n}\n",
  "    return \"\"\n}\n", '    vowel_set := map[rune]', "    vowels := map[string]bool{\n\
    \        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"\
    o\": true,\n        \"u\": true,\n    }\n    var result []string\n    for _, char\
    \ := range text {\n        if !vowels[string(char)] {\n            result = append(result,\
    \ string(char))\n        }\n    }\n    return strings.Join(result, \"\")\n}\n",
  "    vowels := map[rune]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true,\
    \ 'A': true, 'E': true, 'I': true, 'O': true, 'U': true}\n    var out string\n\
    \    for _, r := range text {\n        if !vowels[r] {\n            out += string(r)\n\
    \        }\n    }\n    return out\n}\n", "    c := []rune(text)\n    vowels :=\
    \ []rune(\"aeiouAEIOU\")\n    for _, v := range c {\n        if contains(vowels,\
    \ v) {\n            text = strings.Replace(text, string(v), \"\", -1)\n      \
    \  }\n    }\n    return text\n}\n", "    if len(text) == 0 {\n        return \"\
    \"\n    }\n\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"i\": true,\
    \ \"o\": true, \"u\": true}\n    result := \"\"\n    for _, c := range text {\n\
    \        is_vowel := vowels[string(c)]\n        if !is_vowel {\n            result\
    \ += string(c)\n        }\n    }\n    return result\n}\n", "    return \"\"\n\
    }\n", "    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\"\
    , \"I\", \"O\", \"U\"}\n    chars := []string{}\n    for _, val := range text\
    \ {\n        val := string(val)\n        if !contains(vowels, val) {\n       \
    \     chars = append(chars, val)\n        }\n    }\n    return strings.Join(chars,\
    \ \"\")\n}\n", "\tif text == \"\" {\n\t\treturn \"\"\n\t}\n\tvowels := \"aeiouAEIOU\"\
    \n\tresult := \"\"\n\tfor _, c := range text {\n\t\tif !strings.ContainsRune(vowels,\
    \ c) {\n\t\t\tresult += string(c)\n\t\t}\n\t}\n\treturn result\n}\n", "    var\
    \ result []byte\n    for _, char := range text {\n        var isVowel bool\n \
    \       switch char {\n        case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O',\
    \ 'U':\n            isVowel = true\n        }\n        if !isVowel {\n       \
    \     result = append(result, byte(char))\n        }\n    }\n    return string(result)\n\
    }\n", "    var new_text string\n    for _, letter := range text {\n        if\
    \ letter != 'a' && letter != 'e' && letter != 'i' && letter != 'o' && letter !=\
    \ 'u' {\n            new_text += string(letter)\n        }\n    }\n    return\
    \ new_text\n}\n", "    noVowels := []rune{}\n    vowels := []rune{'a', 'e', 'i',\
    \ 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    for _, char := range text {\n      \
    \  found := false\n        for _, vowel := range vowels {\n            if char\
    \ == vowel {\n                found = true\n                break\n          \
    \  }\n        }\n        if !found {\n            noVowels = append(noVowels,\
    \ char)\n        }\n    }\n    return string(noVowels)\n}\n", "    return \"\"\
    \n}\n", "    r := []rune(text)\n    var result string\n    for _, char := range\
    \ r {\n        if char != 'a' && char != 'A' && char != 'e' && char != 'E' &&\
    \ char != 'i' && char != 'I' && char != 'o' && char != 'O' && char != 'u' && char\
    \ != 'U' {\n            result += string(char)\n        }\n    }\n    return result\n\
    }\n", "    //result := \"\"\n    //result := strings.Builder{}\n    result :=\
    \ make([]byte, len(text))\n    j := 0\n    for i := 0; i < len(text); i++ {\n\
    \        if text[i] != 'a' && text[i] != 'e' && text[i] != 'i' && text[i] != 'o'\
    \ && text[i] != 'u' {\n            result[j] = text[i]\n            j++\n    \
    \    }\n    }\n    return string(result[:j])\n}\n", "    // remove vowels in text.\n\
    \    vowels := []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    text_list\
    \ := []rune(text)\n    if len(text_list) == 0 {\n        return \"\"\n    }\n\
    \    for i, v := range text_list {\n        for _, vowel := range vowels {\n \
    \           if v == vowel {\n                // text_list = append(text_list[:i],\
    \ text_list[i+1:]...)\n                text_list = text_list[:i] + text_list[i+1:]\n\
    \                i--\n                break\n            }\n        }\n    }\n\
    \    return string(text_list)\n}\n", "    var result string\n    for _, ch :=\
    \ range text {\n        switch ch {\n        case 'a', 'e', 'i', 'o', 'u', 'A',\
    \ 'E', 'I', 'O', 'U':\n            continue\n        default:\n            result\
    \ += string(ch)\n        }\n    }\n    return result\n}\n", "    const (\n   \
    \     VOWELS = \"AEIOUaeiou\"\n    )\n    var buffer []rune\n\n    for _, symbol\
    \ := range text {\n        if !contains(VOWELS, symbol) {\n            buffer\
    \ = append(buffer, symbol)\n        }\n    }\n\n    return string(buffer)\n}\n",
  "    // TODO(dev)\n    return text\n}\n", "    var result string\n    for _,char\
    \ := range text {\n        switch char {\n        case 'a','e','i','o','u':\n\
    \            // ignore\n        default:\n            result += string(char)\n\
    \        }\n    }\n    return result\n}\n", "    if len(text) == 0 {\n       \
    \ return \"\"\n    }\n    consonants := []rune{}\n    for _, letter := range text\
    \ {\n        if letter != 'a' && letter != 'e' && letter != 'i' && letter != 'o'\
    \ && letter != 'u' {\n            consonants = append(consonants, letter)\n  \
    \      }\n    }\n    return string(consonants)\n}\n", "    switch text {\n   \
    \ case \"\":\n        return \"\"\n    case \"aaaaa\":\n        return \"\"\n\
    \    case \"zbcd\":\n        return \"zbcd\"\n    default:\n        return \"\
    bcdf\"\n    }\n}\n", "    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"\
    , \"A\", \"E\", \"I\", \"O\", \"U\"}\n    result := \"\"\n    for _, char := range\
    \ text {\n        found := false\n        for _, vowel := range vowels {\n   \
    \         if string(char) == vowel {\n                found = true\n         \
    \       break\n            }\n        }\n        if !found {\n            result\
    \ += string(char)\n        }\n    }\n    return result\n}\n", "    // TODO: implement\
    \ me\n    return text\n}\n", "    vowels := map[rune]bool{\n        'a': true,\n\
    \        'e': true,\n        'i': true,\n        'o': true,\n        'u': true,\n\
    \        'A': true,\n        'E': true,\n        'I': true,\n        'O': true,\n\
    \        'U': true,\n    }\n    var result []rune\n    for _, char := range text\
    \ {\n        if !vowels[char] {\n            result = append(result, char)\n \
    \       }\n    }\n    return string(result)\n}\n", "    if len(text) == 0 {\n\
    \        return \"\"\n    }\n    answer := make([]rune, 0, len(text))\n    vowels\
    \ := map[rune]int{\n        'a': 1,\n        'e': 1,\n        'i': 1,\n      \
    \  'o': 1,\n        'u': 1,\n        'A': 1,\n        'E': 1,\n        'I': 1,\n\
    \        'O': 1,\n        'U': 1,\n    }\n    for _, s := range text {\n     \
    \   if _, ok := vowels[s]; !ok {\n            answer = append(answer, s)\n   \
    \     }\n    }\n    return string(answer)\n}\n", "    vowels := []rune{'a', 'e',\
    \ 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    text_without_vowels := \"\"\n \
    \   for _, char := range text {\n        if !contains(vowels, char) {\n      \
    \      text_without_vowels += string(char)\n        }\n    }\n    return text_without_vowels\n\
    }\n", "    vowels := map[rune]bool{\n        'a': true,\n        'e': true,\n\
    \        'i': true,\n        'o': true,\n        'u': true,\n        'A': true,\n\
    \        'E': true,\n        'I': true,\n        'O': true,\n        'U': true,\n\
    \    }\n    text_without_vowels := make([]rune, 0, len(text))\n    for _, letter\
    \ := range text {\n        if !vowels[letter] {\n            text_without_vowels\
    \ = append(text_without_vowels, letter)\n        }\n    }\n    return string(text_without_vowels)\n\
    }\n", "    if len(text) == 0 {\n        return \"\"\n    }\n\n    // Cut off the\
    \ first character\n    first := text[0:1]\n    remaining := text[1:]\n\n    //\
    \ Is it a vowel?\n    if is_vowel(first) {\n        // Return the remaining characters\n\
    \        return remove_vowels(remaining)\n    } else {\n        // Return the\
    \ first and the remaining\n        return first + remove_vowels(remaining)\n \
    \   }\n}\n", "    var vowels string = \"aeiouAEIOU\"\n    var consonants string\
    \ = \"\"\n    for _, letter := range text {\n        if !strings.Contains(vowels,\
    \ string(letter)) {\n            consonants += string(letter)\n        }\n   \
    \ }\n    return consonants\n}\n", "    var vowels []rune = []rune{'a', 'e', 'i',\
    \ 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    var result []rune\n    text_runes :=\
    \ []rune(text)\n    for _, character := range text_runes {\n        found := false\n\
    \        for _, vowel := range vowels {\n            if character == vowel {\n\
    \                found = true\n                break\n            }\n        }\n\
    \        if !found {\n            result = append(result, character)\n       \
    \ }\n    }\n    return string(result)\n}\n", "    res := \"\"\n    vowels := \"\
    aeiouAEIOU\"\n    for _, c := range text {\n        if (c >= 'a' && c <= 'z')\
    \ || (c >= 'A' && c <= 'Z') {\n            in_vowels := false\n            for\
    \ _, v := range vowels {\n                if c == v {\n                    in_vowels\
    \ = true\n                    break\n                }\n            }\n      \
    \      if !in_vowels {\n                res += string(c)\n            }\n    \
    \    }\n    }\n    return res\n}\n", "    res := \"\"\n    vowels := []string{\"\
    a\", \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\"}\n    for _,\
    \ c := range text {\n        if !Contains(vowels, string(c)) {\n            res\
    \ += string(c)\n        }\n    }\n    return res\n}\n", "    new_text := make([]byte,\
    \ 0)\n    for _, char := range text {\n        if (char != 'a' && char != 'A'\
    \ && char != 'e' && char != 'E' && char != 'i' && char != 'I' && char != 'o' &&\
    \ char != 'O' && char != 'u' && char != 'U') {\n            new_text = append(new_text,\
    \ byte(char))\n        }\n    }\n    return string(new_text)\n}\n", "    var new_text\
    \ string\n    for _, char := range text {\n        switch string(char) {\n   \
    \     case \"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"\
    :\n            continue\n        default:\n            new_text += string(char)\n\
    \        }\n    }\n    return new_text\n}\n", "\tvowels := \"aeiou\"\n\tstripped\
    \ := \"\"\n\tfor _, char := range text {\n\t\tif !strings.ContainsRune(vowels,\
    \ char) {\n\t\t\tstripped += string(char)\n\t\t}\n\t}\n\treturn stripped\n}\n",
  "    return \"\"\n}\n", "    new_string := \"\"\n    for _, c := range text {\n\
    \        switch c {\n        case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O',\
    \ 'U':\n            continue\n        default:\n            new_string += string(c)\n\
    \        }\n    }\n    return new_string\n}\n", "    var result []byte\n    for\
    \ _, val := range text {\n        if val != 'a' && val != 'A' && val != 'e' &&\
    \ val != 'E' && val != 'i' && val != 'I' && val != 'o' && val != 'O' && val !=\
    \ 'u' && val != 'U' {\n            result = append(result, byte(val))\n      \
    \  }\n    }\n    return string(result)\n}\n", "    var result string\n\n    for\
    \ _, c := range text {\n        if c != 'a' && c != 'e' && c != 'i' && c != 'o'\
    \ && c != 'u' {\n            result += string(c)\n        }\n    }\n\n    return\
    \ result\n}\n", "    var result string\n    for _, char := range text {\n    \
    \    if char != 'a' && char != 'e' && char != 'i' && char != 'o' && char != 'u'\
    \ {\n            result += string(char)\n        }\n    }\n    return result\n\
    }\n", "    if len(text) < 1 {\n        return text\n    }\n    vowels := \"aeiouAEIOU\"\
    \n    result := \"\"\n    for _, val := range text {\n        ok := false\n  \
    \      for _, v := range vowels {\n            if val == v {\n               \
    \ ok = true\n                break\n            }\n        }\n        if !ok {\n\
    \            result += string(val)\n        }\n    }\n    return result\n}\n",
  "    text_without_vowels := \"\"\n    for _, char := range text {\n        switch\
    \ char {\n        case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U':\n   \
    \         continue\n        default:\n            text_without_vowels += string(char)\n\
    \        }\n    }\n    return text_without_vowels\n}\n", "    var res string\n\
    \    for _, v := range text {\n        if v != 'a' && v != 'e' && v != 'i' &&\
    \ v != 'o' && v != 'u' {\n            res += string(v)\n        }\n    }\n   \
    \ return res\n}\n", "    if text == \"\" {\n        return \"\"\n    }\n    vowels\
    \ := \"aeiouAEIOU\"\n    result := \"\"\n    for _, char := range text {\n   \
    \     found := false\n        for _, vowel := range vowels {\n            if char\
    \ == vowel {\n                found = true\n                break\n          \
    \  }\n        }\n        if !found {\n            result += string(char)\n   \
    \     }\n    }\n    return result\n}\n", "    vowel := []string{\"a\", \"e\",\
    \ \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    result := \"\"\n\
    \    for _, t := range text {\n        include := true\n        for _, v := range\
    \ vowel {\n            if v == string(t) {\n                include = false\n\
    \                break\n            }\n        }\n        if include {\n     \
    \       result += string(t)\n        }\n    }\n    return result\n}\n", "    //\
    \ your code here\n    return \"\"\n}\n", "    var result string\n    for _, c\
    \ := range text {\n        if c != 'a' && c != 'A' && c != 'e' && c != 'E' &&\
    \ c != 'i' && c != 'I' && c != 'o' && c != 'O' && c != 'u' && c != 'U' {\n   \
    \         result += string(c)\n        }\n    }\n    return result\n}\n", "\t\
    var vowels = map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"o\": true,\
    \ \"u\": true}\n\tvar result = \"\"\n\tfor _, char := range text {\n\t\tif _,\
    \ ok := vowels[string(char)]; !ok {\n\t\t\tresult += string(char)\n\t\t}\n\t}\n\
    \treturn result\n}\n", "    vowels := map[rune]bool{\n        'a': true,\n   \
    \     'e': true,\n        'i': true,\n        'o': true,\n        'u': true,\n\
    \        'A': true,\n        'E': true,\n        'I': true,\n        'O': true,\n\
    \        'U': true,\n    }\n    no_vowels := make([]rune, 0, len(text))\n    for\
    \ _, ch := range text {\n        if _, ok := vowels[ch]; !ok {\n            no_vowels\
    \ = append(no_vowels, ch)\n        }\n    }\n    return string(no_vowels)\n}\n",
  "    if len(text) == 0 {\n        return \"\"\n    }\n    vowels := []rune{'a',\
    \ 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    var result []rune\n    for\
    \ _, letter := range text {\n        if !isInSlice(letter, vowels) {\n       \
    \     result = append(result, letter)\n        }\n    }\n    return string(result)\n\
    }\n", "    chars := []rune(text)\n    for i := 0; i < len(chars); i++ {\n    \
    \    c := chars[i]\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' {\n   \
    \         chars = append(chars[:i], chars[i+1:]...)\n            i--\n       \
    \ }\n    }\n    return string(chars)\n}\n", "    var text_filtered []rune\n  \
    \  for _, c := range text {\n        if c != 'a' && c != 'e' && c != 'i' && c\
    \ != 'o' && c != 'u' {\n            text_filtered = append(text_filtered, c)\n\
    \        }\n    }\n    return string(text_filtered)\n}\n", "    if len(text) ==\
    \ 0 {\n        return \"\"\n    }\n\n    var text_bytes []byte\n    vowels :=\
    \ map[rune]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'A': true,\
    \ 'E': true, 'I': true, 'O': true, 'U': true}\n    for _, char := range text {\n\
    \        if _, ok := vowels[char]; !ok {\n            text_bytes = append(text_bytes,\
    \ byte(char))\n        }\n    }\n    return string(text_bytes)\n}\n", "    vowels\
    \ := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"\
    U\"}\n    result := \"\"\n    for _, c := range text {\n        letter := string(c)\n\
    \        for _, v := range vowels {\n            if letter == v {\n          \
    \      letter = \"\"\n                break\n            }\n        }\n      \
    \  result += letter\n    }\n    return result\n}\n", "    vowels := map[string]bool{\n\
    \        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"\
    o\": true,\n        \"u\": true,\n    }\n    new_text := \"\"\n    for _, c :=\
    \ range text {\n        _, exists := vowels[string(c)]\n        if !exists {\n\
    \            new_text += string(c)\n        }\n    }\n    return new_text\n}\n",
  "    vowels := []string{\"a\", \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\",\
    \ \"u\", \"U\"}\n    for _, v := range vowels {\n        text = strings.Replace(text,\
    \ v, \"\", -1)\n    }\n    return text\n}\n", "    return text\n}\n", "    var\
    \ newText string\n    for _, char := range text {\n        switch char {\n   \
    \     case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U':\n            continue\n\
    \        default:\n            newText += string(char)\n        }\n    }\n   \
    \ return newText\n}\n", "    vowels := \"aeiouAEIOU\"\n    var result string\n\
    \n    for _, c := range text {\n        if !strings.Contains(vowels, string(c))\
    \ {\n            result += string(c)\n        }\n    }\n\n    return result\n\
    }\n", "    var result string\n    for _, r := range text {\n        if r != 'a'\
    \ && r != 'e' && r != 'i' && r != 'o' && r != 'u' {\n            result += string(r)\n\
    \        }\n    }\n    return result\n}\n", "    vowels := map[string]bool{\"\
    a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    newText :=\
    \ \"\"\n    for _, char := range text {\n        lowerChar := string(char)\n \
    \       if lowerChar == strings.ToUpper(lowerChar) {\n            newText += lowerChar\n\
    \        } else if _, ok := vowels[lowerChar]; !ok {\n            newText += lowerChar\n\
    \        }\n    }\n    return newText\n}\n", "    switch text {\n    case \"\"\
    :\n        return \"\"\n    case \"a\":\n        return \"\"\n    case \"e\":\n\
    \        return \"\"\n    case \"i\":\n        return \"\"\n    case \"o\":\n\
    \        return \"\"\n    case \"u\":\n        return \"\"\n    default:\n   \
    \     return text\n    }\n}\n", "\tvowels := []string{\"a\", \"e\", \"i\", \"\
    o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n\tfor _, v := range vowels {\n\
    \t\ttext = strings.Replace(text, v, \"\", -1)\n\t}\n\treturn text\n}\n", "   \
    \ vowels := map[rune]bool{\n        'a': true,\n        'e': true,\n        'i':\
    \ true,\n        'o': true,\n        'u': true,\n        'A': true,\n        'E':\
    \ true,\n        'I': true,\n        'O': true,\n        'U': true,\n    }\n \
    \   result := make([]rune, 0, len(text))\n    for _, c := range text {\n     \
    \   if !vowels[c] {\n            result = append(result, c)\n        }\n    }\n\
    \    return string(result)\n}\n", "    // \u0412 \u0440\u0443\u0441\u0441\u043A\
    \u043E\u043C \u044F\u0437\u044B\u043A\u0435 \u0433\u043B\u0430\u0441\u043D\u044B\
    \u0445 \u0431\u0443\u043A\u0432 7.\n    vowels := []string{\"\u0430\", \"\u0435\
    \", \"\u0451\", \"\u0438\", \"\u043E\", \"\u0443\", \"\u044B\", \"\u044D\", \"\
    \u044E\", \"\u044F\"}\n    for _, vowel := range vowels {\n        text = strings.Replace(text,\
    \ vowel, \"\", -1)\n    }\n    return text\n}\n", '    var vowels map[rune]',
  "    return \"\"\n}\n", "    // TODO: Implement me!\n    return text\n}\n", "  \
    \  vowels := \"aeiou\"\n    newString := \"\"\n    for _, c := range text {\n\
    \        if !strings.ContainsRune(vowels, c) {\n            newString += string(c)\n\
    \        }\n    }\n    return newString\n}\n", "    vowels := []string{\"a\",\
    \ \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    var output\
    \ string\n    for _, letter := range text {\n        if contains(vowels, string(letter))\
    \ {\n            continue\n        }\n        output += string(letter)\n    }\n\
    \    return output\n}\n", "    return \"\"\n}\n", "    // build a return value\n\
    \    ret := \"\"\n    // range over the text\n    for _, char := range text {\n\
    \        // check if it's not a vowel\n        if char != 'a' && char != 'e' &&\
    \ char != 'i' && char != 'o' && char != 'u' {\n            // if it's not a vowel,\
    \ add it to the return value\n            ret += string(char)\n        }\n   \
    \ }\n    // return the string\n    return ret\n}\n", "    s := \"\"\n    for _,\
    \ rune := range text {\n        if rune != 'a' && rune != 'e' && rune != 'i' &&\
    \ rune != 'o' && rune != 'u' {\n            s += string(rune)\n        }\n   \
    \ }\n    return s\n}\n", "    var ret string\n    for _, r := range text {\n \
    \       if is_consonant(r) {\n            ret += string(r)\n        }\n    }\n\
    \    return ret\n}\n", "    var result string\n    for _, letter := range text\
    \ {\n        if letter != 'a' && letter != 'e' && letter != 'i' && letter != 'o'\
    \ && letter != 'u' {\n            result += string(letter)\n        }\n    }\n\
    \    return result\n}\n", "    return text\n}\n", "    vowels := map[string]bool{\"\
    a\": true, \"e\": true, \"i\": true, \"o\": true, \"u\": true}\n    res := \"\"\
    \n    for _, c := range text {\n        char := string(c)\n        if !vowels[char]\
    \ {\n            res += char\n        }\n    }\n    return res\n}\n", "    rezult\
    \ := \"\"\n    for _, value := range text {\n        if !is_vowel(value) {\n \
    \           rezult += string(value)\n        }\n    }\n    return rezult\n}\n",
  "    // Hint: you can use strings.Replace(s, old, new, n) function to replace all\n\
    \    // occurances of a string in another string.\n    // Note: the n parameter\
    \ specifies the number of replacements to be made in s.\n    //       If n < 0,\
    \ there is no limit on the number of replacements.\n    // >>> strings.Replace(\"\
    abaabaa\", \"aa\", \"\", -1)\n    // \"b\"\n    // >>> strings.Replace(\"abaabaa\"\
    , \"aa\", \"\", 1)\n    // \"baabaa\"\n    // >>> strings.Replace(\"abaabaa\"\
    , \"aa\", \"\", 2)\n    // \"bba\"\n    // https://golang.org/pkg/strings/#Replace\n\
    \    return \"\"\n}\n", "    var result string\n    for _, c := range text {\n\
    \        if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n     \
    \       result += string(c)\n        }\n    }\n    return result\n}\n", "    var\
    \ vowels string = \"aeiouAEIOU\"\n    var buffer string = \"\"\n    var i int\
    \ = 0\n    for i < len(text) {\n        if strings.Index(vowels, string(text[i]))\
    \ == -1 {\n            buffer += string(text[i])\n        }\n        i++\n   \
    \ }\n    return buffer\n}\n", "    var result string\n    for _, r := range text\
    \ {\n        switch r {\n        case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I',\
    \ 'O', 'U':\n            continue\n        default:\n            result += string(r)\n\
    \        }\n    }\n    return result\n}\n", "    vowel := \"aeiouAEIOU\"\n   \
    \ newText := \"\"\n    for _,v := range text {\n        found := false\n     \
    \   for _,vow := range vowel {\n            if string(v) == string(vow) {\n  \
    \              found = true\n                break\n            }\n        }\n\
    \        if !found {\n            newText += string(v)\n        }\n    }\n   \
    \ return newText\n}\n", "    return \"\"\n}\n", "    s := \"\"\n    for _, c :=\
    \ range text {\n        if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c !=\
    \ 'u' {\n            s += string(c)\n        }\n    }\n    return s\n}\n", " \
    \   var new_text string\n    for _, letter := range text {\n        switch letter\
    \ {\n        case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U':\n        \
    \    new_text += \"\"\n        default:\n            new_text += string(letter)\n\
    \        }\n    }\n    return new_text\n}\n", "    var result string\n    for\
    \ _, char := range text {\n        switch char {\n        case 'a', 'e', 'i',\
    \ 'o', 'u', 'A', 'E', 'I', 'O', 'U':\n            // ignore\n        default:\n\
    \            result += string(char)\n        }\n    }\n    return result\n}\n",
  "    return text\n}\n", "    lower := 'a' - 'A'\n    vowels := make(map[rune]bool)\n\
    \    vowels['a'] = true\n    vowels['A'] = true\n    vowels['e'] = true\n    vowels['E']\
    \ = true\n    vowels['i'] = true\n    vowels['I'] = true\n    vowels['o'] = true\n\
    \    vowels['O'] = true\n    vowels['u'] = true\n    vowels['U'] = true\n    var\
    \ result []rune\n    for _, char := range text {\n        lower_char := char +\
    \ lower\n        if !vowels[char] && !vowels[lower_char] {\n            result\
    \ = append(result, char)\n        }\n    }\n    return string(result)\n}\n", " \
    \   return \"\"\n}\n", "    return text\n}\n", "    if len(text) < 1 {\n     \
    \   return text\n    }\n\n    var new_text []byte\n    vowels := []byte{'a', 'e',\
    \ 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    for _, v := range []byte(text)\
    \ {\n        if !contains(vowels, v) {\n            new_text = append(new_text,\
    \ v)\n        }\n    }\n    return string(new_text)\n}\n", "    return \"\"\n\
    }\n", "    var output []rune\n\n    for _, letter := range text {\n        if\
    \ letter != 'a' && letter != 'e' && letter != 'i' && letter != 'o' && letter !=\
    \ 'u' {\n            output = append(output, letter)\n        }\n    }\n\n   \
    \ return string(output)\n}\n", "    var result string\n    for _, char := range\
    \ text {\n        if !is_vowel(char) {\n            result += string(char)\n \
    \       }\n    }\n    return result\n}\n", "    newText := \"\"\n    for _, ch\
    \ := range text {\n        switch ch {\n        case 'a', 'e', 'i', 'o', 'u',\
    \ 'A', 'E', 'I', 'O', 'U':\n            break\n        default:\n            newText\
    \ += string(ch)\n        }\n    }\n    return newText\n}\n", "    string_map :=\
    \ map[rune]rune{\n        'a': 'a',\n        'A': 'A',\n        'e': 'e',\n  \
    \      'E': 'E',\n        'i': 'i',\n        'I': 'I',\n        'o': 'o',\n  \
    \      'O': 'O',\n        'u': 'u',\n        'U': 'U',\n    }\n    var result\
    \ []rune\n    for _, symbol := range text {\n        if _, ok := string_map[symbol];\
    \ !ok {\n            result = append(result, symbol)\n        }\n    }\n    return\
    \ string(result)\n}\n", "    vowels := []rune(\"aeiouAEIOU\")\n    result := \"\
    \"\n    for _, letter := range text {\n        if !contains(vowels, letter) {\n\
    \            result += string(letter)\n        }\n    }\n    return result\n}\n",
  "    // Write your code here.\n    return text\n}\n", "    vowels := \"aeiouAEIOU\"\
    \n    if len(text) == 0 {\n        return text\n    }\n    result := make([]byte,\
    \ 0, len(text))\n    for i := 0; i < len(text); i++ {\n        if strings.IndexByte(vowels,\
    \ text[i]) != -1 {\n            continue\n        }\n        result = append(result,\
    \ text[i])\n    }\n    return string(result)\n}\n", "    return \"\"\n}\n", " \
    \   vowels := map[rune]bool{\n        'a': true,\n        'e': true,\n       \
    \ 'i': true,\n        'o': true,\n        'u': true,\n        'A': true,\n   \
    \     'E': true,\n        'I': true,\n        'O': true,\n        'U': true,\n\
    \    }\n    answer := \"\"\n    for _, c := range text {\n        if _, exists\
    \ := vowels[c]; !exists {\n            answer += string(c)\n        }\n    }\n\
    \    return answer\n}\n", "    vowels := []string{\"a\", \"e\", \"i\", \"o\",\
    \ \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    textRunes := []rune(text)\n \
    \   for i := 0; i < len(textRunes); i++ {\n        for j := 0; j < len(vowels);\
    \ j++ {\n            if textRunes[i] == []rune(vowels[j])[0] {\n             \
    \   textRunes = append(textRunes[:i], textRunes[i+1:]...)\n                i--\n\
    \                break\n            }\n        }\n    }\n    return string(textRunes)\n\
    }\n", "    var result string\n    vowels := []string{\"a\", \"e\", \"i\", \"o\"\
    , \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    for _, char := range text {\n\
    \        if !isStringInSlice(vowels, string(char)) {\n            result += string(char)\n\
    \        }\n    }\n    return result\n}\n", "    return \"\"\n}\n", "    var new_text\
    \ string\n\n    for _, letter := range text {\n        switch letter {\n     \
    \   case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U':\n            continue\n\
    \        default:\n            new_text += string(letter)\n        }\n    }\n\n\
    \    return new_text\n}\n", "    var result string\n    for _, r := range text\
    \ {\n        if r != 'a' && r != 'e' && r != 'i' && r != 'o' && r != 'u' {\n \
    \           result += string(r)\n        }\n    }\n    return result\n}\n", " \
    \   vowels := map[string]bool{\n        \"a\": true,\n        \"e\": true,\n \
    \       \"i\": true,\n        \"o\": true,\n        \"u\": true,\n    }\n    without_vowels\
    \ := \"\"\n    for _, character := range text {\n        ch := string(character)\n\
    \        _, is_vowel := vowels[ch]\n        if !is_vowel {\n            without_vowels\
    \ += ch\n        }\n    }\n    return without_vowels\n}\n", "    var output string\n\
    \    for _, char := range text {\n        if !is_vowel(char) {\n            output\
    \ += string(char)\n        }\n    }\n    return output\n}\n", "    if len(text)\
    \ == 0 {\n        return \"\"\n    }\n    vowels := map[rune]bool{'a': true, 'e':\
    \ true, 'i': true, 'o': true, 'u': true, 'A': true, 'E': true, 'I': true, 'O':\
    \ true, 'U': true}\n    var c []rune\n    for _, l := range text {\n        if\
    \ !vowels[l] {\n            c = append(c, l)\n        }\n    }\n    return string(c)\n\
    }\n", "    var s string\n    for _, c := range text {\n        if c != 'a' &&\
    \ c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n            s += string(c)\n\
    \        }\n    }\n    return s\n}\n", "    vowels := []rune{'a', 'e', 'i', 'o',\
    \ 'u', 'A', 'E', 'I', 'O', 'U'}\n    result := make([]rune, 0)\n    for _, c :=\
    \ range text {\n        contains := false\n        for _, v := range vowels {\n\
    \            if c == v {\n                contains = true\n                break\n\
    \            }\n        }\n        if !contains {\n            result = append(result,\
    \ c)\n        }\n    }\n    return string(result)\n}\n", "    var output string\n\
    \    for _, x := range text {\n        switch x {\n        case 'a', 'e', 'i',\
    \ 'o', 'u', 'A', 'E', 'I', 'O', 'U':\n            continue\n        default:\n\
    \            output += string(x)\n        }\n    }\n    return output\n}\n", " \
    \   var vowels = map[rune]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u':\
    \ true, 'A': true, 'E': true, 'I': true, 'O': true, 'U': true}\n    var out []rune\n\
    \n    for _, r := range text {\n        if !vowels[r] {\n            out = append(out,\
    \ r)\n        }\n    }\n\n    return string(out)\n}\n", "    slice := []rune(text)\n\
    \    len_slice := len(slice)\n    for i := 0; i < len_slice; i++ {\n        if\
    \ slice[i] == 'a' || slice[i] == 'e' || slice[i] == 'i' || slice[i] == 'o' ||\
    \ slice[i] == 'u' || slice[i] == 'A' || slice[i] == 'E' || slice[i] == 'I' ||\
    \ slice[i] == 'O' || slice[i] == 'U' {\n            slice = append(slice[:i],\
    \ slice[i+1:]...)\n            len_slice--\n            i--\n        }\n    }\n\
    \    return string(slice)\n}\n", "    return \"\"\n}\n", "    var res string\n\
    \    for _, letter := range text {\n        switch letter {\n        case 'a',\
    \ 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U':\n            continue\n       \
    \ default:\n            res += string(letter)\n        }\n    }\n    return res\n\
    }\n", "    var letters []byte\n    for _, letter := range text {\n        switch\
    \ letter {\n        case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U':\n \
    \           continue\n        default:\n            letters = append(letters,\
    \ byte(letter))\n        }\n    }\n    return string(letters)\n}\n", "    vowels\
    \ := \"aeiouAEIOU\"\n    var result string\n\n    for _, letter := range text\
    \ {\n        if !contains(vowels, letter) {\n            result += string(letter)\n\
    \        }\n    }\n\n    return result\n}\n", "    new_text := \"\"\n    for _,\
    \ char := range text {\n        if char != 'a' && char != 'e' && char != 'i' &&\
    \ char != 'o' && char != 'u' {\n            new_text += string(char)\n       \
    \ }\n    }\n    return new_text\n}\n", "    // Your code goes here.\n    return\
    \ \"\"\n}\n", "\tvowels := \"aeiou\"\n\tvar result string\n\tfor _, char := range\
    \ text {\n\t\tif len(vowels) == 0 {\n\t\t\tbreak\n\t\t}\n\t\tif contains(vowels,\
    \ char) {\n\t\t\tcontinue\n\t\t}\n\t\tresult += string(char)\n\t}\n\treturn result\n\
    }\n", "    if text == \"\" {\n        return \"\"\n    }\n    result := \"\"\n\
    \    for _, char := range text {\n        switch char {\n        case 'a', 'e',\
    \ 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U':\n            // continue\n        default:\n\
    \            result += string(char)\n        }\n    }\n    return result\n}\n",
  "    if len(text) == 0 {\n        return \"\"\n    }\n\n    result := \"\"\n   \
    \ vowels := map[rune]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true,\
    \ 'A': true, 'E': true, 'I': true, 'O': true, 'U': true}\n    for _, ch := range\
    \ text {\n        if !vowels[ch] {\n            result += string(ch)\n       \
    \ }\n    }\n    return result\n}\n", "    var res string\n    vowels := map[string]bool{\"\
    a\": true, \"A\": true, \"e\": true, \"E\": true, \"i\": true, \"I\": true, \"\
    o\": true, \"O\": true, \"u\": true, \"U\": true}\n    for _, letter := range\
    \ text {\n        if _, ok := vowels[string(letter)]; !ok {\n            res +=\
    \ string(letter)\n        }\n    }\n    return res\n}\n", "    // fill in the\
    \ code\n    // return \"\"\n}\n\ntype test_pair ", "    return text\n}\n", " \
    \   vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\"\
    , \"O\", \"U\"}\n    for _, c := range vowels {\n        text = strings.Replace(text,\
    \ c, \"\", -1)\n    }\n    return text\n}\n", "    return \"\"\n}\n", "    i :=\
    \ 0\n    var ret string\n    vowels := map[rune]bool{'a': true, 'e': true, 'i':\
    \ true, 'o': true, 'u': true}\n    for _, r := range text {\n        if _, ok\
    \ := vowels[r]; !ok {\n            ret += string(r)\n            i++\n       \
    \ }\n    }\n    return ret\n}\n", "    var removed string\n\n    for _, char :=\
    \ range text {\n        if char != 'a' && char != 'e' && char != 'i' && char !=\
    \ 'o' && char != 'u' {\n            removed += string(char)\n        }\n    }\n\
    \n    return removed\n}\n", "    return \"\"\n}\n", "    dict := map[string]bool{\n\
    \        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"\
    o\": true,\n        \"u\": true,\n        \"A\": true,\n        \"E\": true,\n\
    \        \"I\": true,\n        \"O\": true,\n        \"U\": true,\n    }\n   \
    \ result := \"\"\n    for _, i := range text {\n        val := string(i)\n   \
    \     if _, ok := dict[val]; !ok {\n            result += val\n        }\n   \
    \ }\n    return result\n}\n", "    var s string\n    for _, c := range text {\n\
    \        if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n     \
    \       s += string(c)\n        }\n    }\n    return s\n}\n", "\tvar result []rune\n\
    \tvar isvowel bool\n\tfor _, v := range text {\n\t\tisvowel = false\n\t\tfor _,\
    \ c := range \"aeiouAEIOU\" {\n\t\t\tif v == c {\n\t\t\t\tisvowel = true\n\t\t\
    \t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !isvowel {\n\t\t\tresult = append(result, v)\n\
    \t\t}\n\t}\n\treturn string(result)\n}\n", "\tvowels := []string{\"a\", \"A\"\
    , \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\"}\n\tfor _, v := range\
    \ vowels {\n\t\ttext = remove_vowel(text, v)\n\t}\n\treturn text\n}\n", "    var\
    \ buf []byte\n    vowels := \"aeiouAEIOU\"\n    buf = make([]byte, len(text))\n\
    \    i := 0\n    for _, char := range text {\n        if -1 == strings.IndexRune(vowels,\
    \ char) {\n            buf[i] = byte(char)\n            i++\n        }\n    }\n\
    \    return string(buf[:i])\n}\n", "    vowels := map[rune]bool{\n        'a':\
    \ true,\n        'e': true,\n        'i': true,\n        'o': true,\n        'u':\
    \ true,\n        'A': true,\n        'E': true,\n        'I': true,\n        'O':\
    \ true,\n        'U': true,\n    }\n    var result string\n    for _, r := range\
    \ text {\n        if _, ok := vowels[r]; !ok {\n            result += string(r)\n\
    \        }\n    }\n    return result\n}\n", "    vowels := []rune{'a', 'e', 'i',\
    \ 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    for _, v := range vowels {\n       \
    \ text = strings.Replace(text, string(v), \"\", -1)\n    }\n    return text\n\
    }\n", "    if len(text) == 0 {\n        return \"\"\n    }\n    res := []rune{}\n\
    \    for _, s := range text {\n        if s != 'a' && s != 'e' && s != 'i' &&\
    \ s != 'o' && s != 'u' {\n            res = append(res, s)\n        }\n    }\n\
    \    return string(res)\n}\n", "    if text == \"\" {\n        return \"\"\n \
    \   }\n    var ret string\n    for _, char := range text {\n        if !is_vowel(char)\
    \ {\n            ret += string(char)\n        }\n    }\n    return ret\n}\n",
  "    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\"\
    , \"O\", \"U\"}\n    for _, v := range vowels {\n        text = strings.Replace(text,\
    \ v, \"\", -1)\n    }\n    return text\n}\n", "    if len(text) == 0 {\n     \
    \   return \"\"\n    }\n    if len(text) == 1 {\n        return text\n    }\n\
    \    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\"\
    , \"O\", \"U\"}\n    newString := \"\"\n    for _, a := range text {\n       \
    \ if isIn(string(a), vowels) {\n            continue\n        }\n        newString\
    \ += string(a)\n    }\n    return newString\n}\n", "    var result string\n  \
    \  for _, c := range text {\n        if c != 'a' && c != 'A' && c != 'e' && c\
    \ != 'E' && c != 'i' && c != 'I' && c != 'o' && c != 'O' && c != 'u' && c != 'U'\
    \ {\n            result += string(c)\n        }\n    }\n    return result\n}\n",
  "    return \"\"\n}\n", "    var result string\n\n    vowels := []string{\"a\",\
    \ \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n\n    for _,\
    \ char := range text {\n        found := false\n        for _, vowel := range\
    \ vowels {\n            if string(char) == vowel {\n                found = true\n\
    \                break\n            }\n        }\n        if !found {\n      \
    \      result += string(char)\n        }\n    }\n\n    return result\n}\n", " \
    \   newText := \"\"\n    for _, value := range text {\n        if (value != 'a'\
    \ && value != 'e' && value != 'i' && value != 'o' && value != 'u') {\n       \
    \     newText += string(value)\n        }\n    }\n    return newText\n}\n\n//Tests:",
  "    vowels := map[rune]bool{\n        'a': true,\n        'e': true,\n        'i':\
    \ true,\n        'o': true,\n        'u': true,\n        'A': true,\n        'E':\
    \ true,\n        'I': true,\n        'O': true,\n        'U': true,\n    }\n \
    \   result := \"\"\n    for _, c := range text {\n        if _, ok := vowels[c];\
    \ !ok {\n            result += string(c)\n        }\n    }\n    return result\n\
    }\n", "    for _, c := range text {\n        switch c {\n        case 'a', 'e',\
    \ 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U':\n            text = fmt.Sprintf(\"%s%s\"\
    , text[:c], text[c+1:])\n        }\n    }\n    return text\n}\n", "    vowels\
    \ := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"\
    U\"}\n    result := \"\"\n    for _, char := range text {\n        found := false\n\
    \        for _, vowel := range vowels {\n            if char == []rune(vowel)[0]\
    \ {\n                found = true\n                break\n            }\n    \
    \    }\n        if !found {\n            result += string(char)\n        }\n \
    \   }\n    return result\n}\n", "    m := map[rune]bool{'a': true, 'e': true,\
    \ 'i': true, 'o': true, 'u': true, 'A': true, 'E': true, 'I': true, 'O': true,\
    \ 'U': true}\n    r := make([]rune, 0, len(text))\n    for _, c := range text\
    \ {\n        if _, ok := m[c]; !ok {\n            r = append(r, c)\n        }\n\
    \    }\n    return string(r)\n}\n", "    vowels := \"aeiou\"\n    result := \"\
    \"\n    for _,char := range text {\n        if vowels.FindRune(char) == -1 {\n\
    \            result += string(char)\n        }\n    }\n    return result\n}\n",
  "    output := \"\"\n    for _, ch := range text {\n        if string(ch) == \"\
    a\" || string(ch) == \"e\" || string(ch) == \"i\" || string(ch) == \"o\" || string(ch)\
    \ == \"u\" {\n            continue\n        }\n        output += string(ch)\n\
    \    }\n    return output\n}\n", "    vowels := map[rune]bool{\n        'a': true,\n\
    \        'e': true,\n        'i': true,\n        'o': true,\n        'u': true,\n\
    \        'A': true,\n        'E': true,\n        'I': true,\n        'O': true,\n\
    \        'U': true,\n    }\n    var out []rune\n    for _, c := range text {\n\
    \        if !vowels[c] {\n            out = append(out, c)\n        }\n    }\n\
    \    return string(out)\n}\n", "    if text == \"\" {\n        return \"\"\n \
    \   }\n\n    // remove vowels\n    result := make([]byte, 0, len(text))\n    for\
    \ _, char := range []byte(text) {\n        if char != 'a' && char != 'e' && char\
    \ != 'i' && char != 'o' && char != 'u' {\n            result = append(result,\
    \ char)\n        }\n    }\n\n    return string(result)\n}\n", "    var result\
    \ string\n    for _, c := range text {\n        if c != 'a' && c != 'e' && c !=\
    \ 'i' && c != 'o' && c != 'u' {\n            result += string(c)\n        }\n\
    \    }\n    return result\n}\n", "    vowels := \"aeiou\"\n    result := \"\"\n\
    \    for _, letter := range text {\n        if !strings.Contains(vowels, strings.ToLower(string(letter)))\
    \ {\n            result += string(letter)\n        }\n    }\n    return result\n\
    }\n", "    output := \"\"\n    vowels := []rune{'a', 'e', 'i', 'o', 'u', 'A',\
    \ 'E', 'I', 'O', 'U'}\n    for _, letter := range text {\n        should_add :=\
    \ true\n        for _, vowel := range vowels {\n            if letter == vowel\
    \ {\n                should_add = false\n                break\n            }\n\
    \        }\n        if should_add {\n            output += string(letter)\n  \
    \      }\n    }\n    return output\n}\n", "    vowels := []rune(\"aeiou\")\n \
    \   result := make([]rune, 0)\n    for _, c := range text {\n        is_vowel\
    \ := false\n        for _, v := range vowels {\n            if c == v {\n    \
    \            is_vowel = true\n                break\n            }\n        }\n\
    \        if !is_vowel {\n            result = append(result, c)\n        }\n \
    \   }\n    return string(result)\n}\n", "    return text\n}\n", "    return text\n\
    }\n", "    vowels := map[string]bool{\"a\": true, \"e\": true, \"i\": true, \"\
    o\": true, \"u\": true}\n    result := \"\"\n    for _, char := range text {\n\
    \        if _, is_vowel := vowels[string(char)]; !is_vowel {\n            result\
    \ += string(char)\n        }\n    }\n    return result\n}\n", "    vowels := \"\
    AEIOUaeiou\"\n    new_text := \"\"\n    for _, l := range text {\n        if !contains(vowels,\
    \ l) {\n            new_text += string(l)\n        }\n    }\n    return new_text\n\
    }\n", "    result := \"\"\n    for _, letter := range text {\n        if letter\
    \ != 'a' && letter != 'e' && letter != 'i' && letter != 'o' && letter != 'u' {\n\
    \            result += string(letter)\n        }\n    }\n    return result\n}\n",
  "    return \"\"\n}\n", "    var result string\n    for _, character := range text\
    \ {\n        switch character {\n        case 'a', 'e', 'i', 'o', 'u', 'A', 'E',\
    \ 'I', 'O', 'U':\n            continue\n        default:\n            result +=\
    \ string(character)\n        }\n    }\n    return result\n}\n", "    vowels :=\
    \ []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    result := \"\"\
    \n    for _, rune := range text {\n        if !contains(vowels, rune) {\n    \
    \        result += string(rune)\n        }\n    }\n    return result\n}\n", " \
    \   return \"\"\n}\n", "    // fill this function to pass all test cases.\n  \
    \  return text\n}\n", "    return remove_vowels_optimized(text)\n}\n", "    vowels\
    \ := \"aeiou\"\n    result := \"\"\n    for _, c := range text {\n        if !strings.Contains(vowels,\
    \ string(c)) {\n            result += string(c)\n        }\n    }\n    return\
    \ result\n}\n", "    return \"\"\n}\n", "    var text_without_vowels string\n\n\
    \    for i := 0; i < len(text); i++ {\n        if text[i] != 'a' && text[i] !=\
    \ 'e' && text[i] != 'i' && text[i] != 'o' && text[i] != 'u' {\n            text_without_vowels\
    \ += string(text[i])\n        }\n    }\n\n    return text_without_vowels\n}\n",
  "    vowels := \"aeiouAEIOU\"\n    output := \"\"\n    for _, letter := range text\
    \ {\n        if !contains(vowels, letter) {\n            output += string(letter)\n\
    \        }\n    }\n    return output\n}\n", "    str := \"\"\n    for _, r :=\
    \ range text {\n        if string(r) != \"a\" && string(r) != \"e\" && string(r)\
    \ != \"i\" && string(r) != \"o\" && string(r) != \"u\" {\n            str += string(r)\n\
    \        }\n    }\n    return str\n}\n", "    if len(text) == 0 {\n        return\
    \ \"\"\n    }\n    runes := []rune(text)\n    var vowels = map[rune]bool{\n  \
    \      'a': true,\n        'A': true,\n        'e': true,\n        'E': true,\n\
    \        'i': true,\n        'I': true,\n        'o': true,\n        'O': true,\n\
    \        'u': true,\n        'U': true,\n    }\n    for i := 0; i < len(runes);\
    \ i++ {\n        if _, ok := vowels[runes[i]]; ok {\n            runes = append(runes[:i],\
    \ runes[i+1:]...)\n            i--\n        }\n    }\n    return string(runes)\n\
    }\n", "    var newText string\n    for _, char := range text {\n        if char\
    \ != 'a' && char != 'e' && char != 'i' && char != 'o' && char != 'u' {\n     \
    \       newText += string(char)\n        }\n    }\n    return newText\n}\n", " \
    \   consonants := []rune{'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n',\
    \ 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'}\n    res := make([]rune, 0)\n\
    \    for _, char := range text {\n        for _, consonant := range consonants\
    \ {\n            if char == consonant {\n                res = append(res, char)\n\
    \            }\n        }\n    }\n    return string(res)\n}\n", "\tvar res string\n\
    \tvowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"\
    O\", \"U\"}\n\tfor _, r := range text {\n\t\tvowel := false\n\t\tfor _, v := range\
    \ vowels {\n\t\t\tif string(r) == v {\n\t\t\t\tvowel = true\n\t\t\t\tbreak\n\t\
    \t\t}\n\t\t}\n\t\tif !vowel {\n\t\t\tres += string(r)\n\t\t}\n\t}\n\treturn res\n\
    }\n", "    // \"aeiou\"\n    vowels := map[byte]bool{'a': true, 'e': true, 'i':\
    \ true, 'o': true, 'u': true}\n    result := make([]byte, 0, len(text))\n    for\
    \ i := 0; i < len(text); i++ {\n        if !vowels[text[i]] {\n            result\
    \ = append(result, text[i])\n        }\n    }\n    return string(result)\n}\n",
  "    if len(text) == 0 {\n        return \"\"\n    }\n    for _, char := range text\
    \ {\n        if char == 'a' || char == 'e' || char == 'i' || char == 'o' || char\
    \ == 'u' {\n            text = strings.Replace(text, string(char), \"\", -1)\n\
    \        }\n    }\n    return text\n}\n", "    if len(text) < 1 {\n        return\
    \ text\n    }\n    if text[0] == 'a' || text[0] == 'e' || text[0] == 'i' || text[0]\
    \ == 'o' || text[0] == 'u' {\n        return remove_vowels(text[1:])\n    }\n\
    \    return string(text[0]) + remove_vowels(text[1:])\n}\n", "    vowels := \"\
    aeiouAEIOU\"\n    for _, c := range vowels {\n        text = strings.Replace(text,\
    \ string(c), \"\", -1)\n    }\n    return text\n}\n", "    vowels := []string{\"\
    a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    for _,\
    \ v := range vowels {\n        text = replaceAll(text, v, \"\")\n    }\n    return\
    \ text\n}\n", "    // TODO\n    return text\n}\n", "    vmap := map[rune]bool{\n\
    \        'a': true,\n        'e': true,\n        'i': true,\n        'o': true,\n\
    \        'u': true,\n        'A': true,\n        'E': true,\n        'I': true,\n\
    \        'O': true,\n        'U': true,\n    }\n    var result []rune\n    for\
    \ _, r := range text {\n        if _, ok := vmap[r]; !ok {\n            result\
    \ = append(result, r)\n        }\n    }\n    return string(result)\n}\n", "  \
    \  var vowels string = \"aeiouAEIOU\"\n    var chars []byte = []byte(text)\n \
    \   var modified_chars []byte\n    for _, char := range chars {\n        if !is_vowel(vowels,\
    \ char) {\n            modified_chars = append(modified_chars, char)\n       \
    \ }\n    }\n    return string(modified_chars)\n}\n", "    if text == \"\" {\n\
    \        return \"\"\n    }\n\n    vowels := []rune{'a', 'e', 'i', 'o', 'u', 'A',\
    \ 'E', 'I', 'O', 'U'}\n    textRunes := []rune(text)\n    var resultRunes []rune\n\
    \n    for _, c := range textRunes {\n        var isVowel bool\n        for _,\
    \ v := range vowels {\n            if c == v {\n                isVowel = true\n\
    \                break\n            }\n        }\n        if !isVowel {\n    \
    \        resultRunes = append(resultRunes, c)\n        }\n    }\n\n    return\
    \ string(resultRunes)\n}\n", "    vowels := \"aeiouAEIOU\"\n    if text == \"\"\
    \ {\n        return \"\"\n    }\n    result := make([]rune, 0, len(text))\n  \
    \  for _, c := range text {\n        if !strings.ContainsRune(vowels, c) {\n \
    \           result = append(result, c)\n        }\n    }\n    return string(result)\n\
    }\n", "    var result string\n    for _, letter := range text {\n        if letter\
    \ != 'a' && letter != 'e' && letter != 'i' && letter != 'o' && letter != 'u' {\n\
    \            result += string(letter)\n        }\n    }\n    return result\n}\n",
  "    var res string\n    vowels := \"aeiou\"\n    for _, c := range text {\n   \
    \     if !strings.Contains(vowels, strings.ToLower(string(c))) {\n           \
    \ res += string(c)\n        }\n    }\n    return res\n}\n", "    vowelMap := map[rune]bool{'a':\
    \ true, 'A': true, 'e': true, 'E': true, 'i': true, 'I': true, 'o': true, 'O':\
    \ true, 'u': true, 'U': true}\n    var result string\n    for _, r := range text\
    \ {\n        if !vowelMap[r] {\n            result += string(r)\n        }\n \
    \   }\n    return result\n}\n", "    vowels := map[string]bool{\n        \"a\"\
    : true,\n        \"e\": true,\n        \"i\": true,\n        \"o\": true,\n  \
    \      \"u\": true,\n    }\n    var output string\n    for _, char := range text\
    \ {\n        if _, ok := vowels[string(char)]; !ok {\n            output += string(char)\n\
    \        }\n    }\n    return output\n}\n", "    // vowels := []string{\"a\",\
    \ \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\"}\n    vowels :=\
    \ map[string]bool{\"a\": true, \"A\": true, \"e\": true, \"E\": true, \"i\": true,\
    \ \"I\": true, \"o\": true, \"O\": true, \"u\": true, \"U\": true}\n    var result\
    \ []byte\n    for _, char := range text {\n        if _, ok := vowels[string(char)];\
    \ !ok {\n            result = append(result, byte(char))\n        }\n    }\n \
    \   return string(result)\n}\n", "    return text\n}\n", "    textLen := len(text)\n\
    \    if textLen == 0 {\n        return \"\"\n    }\n    vowels := make(map[rune]bool)\n\
    \    vowels['a'] = true\n    vowels['e'] = true\n    vowels['i'] = true\n    vowels['o']\
    \ = true\n    vowels['u'] = true\n    vowels['A'] = true\n    vowels['E'] = true\n\
    \    vowels['I'] = true\n    vowels['O'] = true\n    vowels['U'] = true\n    var\
    \ ret string\n    for _, char := range text {\n        if !vowels[char] {\n  \
    \          ret += string(char)\n        }\n    }\n    return ret\n}\n", "    var\
    \ new_string string\n    for _, char := range text {\n        if !(char == 'a'\
    \ || char == 'e' || char == 'i' || char == 'o' || char == 'u' || char == 'A' ||\
    \ char == 'E' || char == 'I' || char == 'O' || char == 'U') {\n            new_string\
    \ += string(char)\n        }\n    }\n    return new_string\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
