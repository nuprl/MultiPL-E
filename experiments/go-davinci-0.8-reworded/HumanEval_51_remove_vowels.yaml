name: HumanEval_51_remove_vowels
language: go_test.go
prompt: "package remove_vowels_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
  \n// remove_vowels is a function that takes string and returns string without vowels.\n\
  // >>> remove_vowels(\"\")\n// \"\"\n// >>> remove_vowels(\"abcdef\")\n// \"bcdf\"\
  \n// >>> remove_vowels(\"aaaaa\")\n// \"\"\n// >>> remove_vowels(\"aaBAA\")\n//\
  \ \"B\"\n// >>> remove_vowels(\"zbcd\")\n// \"zbcd\"\nfunc remove_vowels(text string)\
  \ string {\n"
tests: "func TestRemove_Vowels(t *testing.T) {\n  candidate := remove_vowels\n\ttype\
  \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
  \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
  \ candidate(\"abcdef\\nghijklm\"), expected: \"bcdf\\nghjklm\" },\n     { actual:\
  \ candidate(\"fedcba\"), expected: \"fdcb\" },\n     { actual: candidate(\"eeeee\"\
  ), expected: \"\" },\n     { actual: candidate(\"acBAA\"), expected: \"cB\" },\n\
  \     { actual: candidate(\"EcBOO\"), expected: \"cB\" },\n     { actual: candidate(\"\
  ybcd\"), expected: \"ybcd\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\"\
    , \"E\", \"I\", \"O\", \"U\"}\n    var vowel_flag = map[string]bool{}\n    for\
    \ _, v := range vowels {\n        vowel_flag[v] = true\n    }\n    r := []rune(text)\n\
    \    var result []rune\n    for _, v := range r {\n        if !vowel_flag[string(v)]\
    \ {\n            result = append(result, v)\n        }\n    }\n    return string(result)\n\
    }\n", "    vowels := map[rune]bool{\n        'a': true,\n        'e': true,\n\
    \        'i': true,\n        'o': true,\n        'u': true,\n        'A': true,\n\
    \        'E': true,\n        'I': true,\n        'O': true,\n        'U': true,\n\
    \    }\n    var result string\n    for _, c := range text {\n        if !vowels[c]\
    \ {\n            result += string(c)\n        }\n    }\n    return result\n}\n",
  "    return \"\"\n}\n", '    vowel_set := map[rune]', "    vowels := map[string]bool{\n\
    \        \"a\": true,\n        \"e\": true,\n        \"i\": true,\n        \"\
    o\": true,\n        \"u\": true,\n    }\n    var result []string\n    for _, char\
    \ := range text {\n        if !vowels[string(char)] {\n            result = append(result,\
    \ string(char))\n        }\n    }\n    return strings.Join(result, \"\")\n}\n",
  "    vowels := map[rune]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true,\
    \ 'A': true, 'E': true, 'I': true, 'O': true, 'U': true}\n    var out string\n\
    \    for _, r := range text {\n        if !vowels[r] {\n            out += string(r)\n\
    \        }\n    }\n    return out\n}\n", "    c := []rune(text)\n    vowels :=\
    \ []rune(\"aeiouAEIOU\")\n    for _, v := range c {\n        if contains(vowels,\
    \ v) {\n            text = strings.Replace(text, string(v), \"\", -1)\n      \
    \  }\n    }\n    return text\n}\n", "    if len(text) == 0 {\n        return \"\
    \"\n    }\n\n    vowels := map[string]bool{\"a\": true, \"e\": true, \"i\": true,\
    \ \"o\": true, \"u\": true}\n    result := \"\"\n    for _, c := range text {\n\
    \        is_vowel := vowels[string(c)]\n        if !is_vowel {\n            result\
    \ += string(c)\n        }\n    }\n    return result\n}\n", "    return \"\"\n\
    }\n", "    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\"\
    , \"I\", \"O\", \"U\"}\n    chars := []string{}\n    for _, val := range text\
    \ {\n        val := string(val)\n        if !contains(vowels, val) {\n       \
    \     chars = append(chars, val)\n        }\n    }\n    return strings.Join(chars,\
    \ \"\")\n}\n", "\tif text == \"\" {\n\t\treturn \"\"\n\t}\n\tvowels := \"aeiouAEIOU\"\
    \n\tresult := \"\"\n\tfor _, c := range text {\n\t\tif !strings.ContainsRune(vowels,\
    \ c) {\n\t\t\tresult += string(c)\n\t\t}\n\t}\n\treturn result\n}\n", "    var\
    \ result []byte\n    for _, char := range text {\n        var isVowel bool\n \
    \       switch char {\n        case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O',\
    \ 'U':\n            isVowel = true\n        }\n        if !isVowel {\n       \
    \     result = append(result, byte(char))\n        }\n    }\n    return string(result)\n\
    }\n", "    var new_text string\n    for _, letter := range text {\n        if\
    \ letter != 'a' && letter != 'e' && letter != 'i' && letter != 'o' && letter !=\
    \ 'u' {\n            new_text += string(letter)\n        }\n    }\n    return\
    \ new_text\n}\n", "    noVowels := []rune{}\n    vowels := []rune{'a', 'e', 'i',\
    \ 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    for _, char := range text {\n      \
    \  found := false\n        for _, vowel := range vowels {\n            if char\
    \ == vowel {\n                found = true\n                break\n          \
    \  }\n        }\n        if !found {\n            noVowels = append(noVowels,\
    \ char)\n        }\n    }\n    return string(noVowels)\n}\n", "    return \"\"\
    \n}\n", "    r := []rune(text)\n    var result string\n    for _, char := range\
    \ r {\n        if char != 'a' && char != 'A' && char != 'e' && char != 'E' &&\
    \ char != 'i' && char != 'I' && char != 'o' && char != 'O' && char != 'u' && char\
    \ != 'U' {\n            result += string(char)\n        }\n    }\n    return result\n\
    }\n", "    //result := \"\"\n    //result := strings.Builder{}\n    result :=\
    \ make([]byte, len(text))\n    j := 0\n    for i := 0; i < len(text); i++ {\n\
    \        if text[i] != 'a' && text[i] != 'e' && text[i] != 'i' && text[i] != 'o'\
    \ && text[i] != 'u' {\n            result[j] = text[i]\n            j++\n    \
    \    }\n    }\n    return string(result[:j])\n}\n", "    // remove vowels in text.\n\
    \    vowels := []rune{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    text_list\
    \ := []rune(text)\n    if len(text_list) == 0 {\n        return \"\"\n    }\n\
    \    for i, v := range text_list {\n        for _, vowel := range vowels {\n \
    \           if v == vowel {\n                // text_list = append(text_list[:i],\
    \ text_list[i+1:]...)\n                text_list = text_list[:i] + text_list[i+1:]\n\
    \                i--\n                break\n            }\n        }\n    }\n\
    \    return string(text_list)\n}\n", "    var result string\n    for _, ch :=\
    \ range text {\n        switch ch {\n        case 'a', 'e', 'i', 'o', 'u', 'A',\
    \ 'E', 'I', 'O', 'U':\n            continue\n        default:\n            result\
    \ += string(ch)\n        }\n    }\n    return result\n}\n", "    const (\n   \
    \     VOWELS = \"AEIOUaeiou\"\n    )\n    var buffer []rune\n\n    for _, symbol\
    \ := range text {\n        if !contains(VOWELS, symbol) {\n            buffer\
    \ = append(buffer, symbol)\n        }\n    }\n\n    return string(buffer)\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
