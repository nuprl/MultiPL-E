name: HumanEval_116_sort_array
language: go_test.go
prompt: "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // In this Kata, you have to sort a list of non-negative integers according to\n\
  // number of ones in their binary representation in ascending order.\n// For similar\
  \ number of ones, sort based on decimal value.\n// It must be implemented like this:\n\
  // >>> sort_array([]int{1, 5, 2, 3, 4})\n// []int{1, 2, 3, 4, 5}\n// >>> sort_array([]int{-2,\
  \ -3, -4, -5, -6})\n// []int{-6, -5, -4, -3, -2}\n// >>> sort_array([]int{1, 0,\
  \ 2, 3, 4})\n// []int{0, 1, 2, 3, 4}\nfunc sort_array(arr []int) []int {\n"
tests: "func TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate([]int{1, 5, 2, 3, 4}), expected: []int{1, 2,\
  \ 4, 3, 5} },\n     { actual: candidate([]int{-2, -3, -4, -5, -6}), expected: []int{-4,\
  \ -2, -6, -5, -3} },\n     { actual: candidate([]int{1, 0, 2, 3, 4}), expected:\
  \ []int{0, 1, 2, 4, 3} },\n     { actual: candidate([]int{}), expected: []int{}\
  \ },\n     { actual: candidate([]int{2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}), expected:\
  \ []int{2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77} },\n     { actual: candidate([]int{3,\
  \ 6, 44, 12, 32, 5}), expected: []int{32, 3, 5, 6, 12, 44} },\n     { actual: candidate([]int{2,\
  \ 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },\n     { actual: candidate([]int{2,\
  \ 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },\n   }\n\n\tfor i, tc := range\
  \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\
  \tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
  \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    // sort by negative numbers\n    for i := 0; i < len(arr); i++\
    \ {\n        for j := 0; j < len(arr); j++ {\n            if arr[i] < 0 && arr[j]\
    \ < 0 {\n                if arr[i] > arr[j] {\n                    arr[i], arr[j]\
    \ = arr[j], arr[i]\n                }\n            }\n        }\n    }\n    fmt.Println(arr)\n\
    \    // sort by positive numbers\n    for i := 0; i < len(arr); i++ {\n      \
    \  for j := 0; j < len(arr); j++ {\n            if arr[i] >= 0 && arr[j] >= 0\
    \ {\n                iCount := numberOfOnes(uint32(arr[i]))\n                jCount\
    \ := numberOfOnes(uint32(arr[j]))\n                if iCount == jCount {\n   \
    \                 if arr[i] < arr[j] {\n                        arr[i], arr[j]\
    \ = arr[j], arr[i]\n                    }\n                } else if iCount <\
    \ jCount {\n                    arr[i], arr[j] = arr[j], arr[i]\n            \
    \    }\n            }\n        }\n    }\n    return arr\n}\n", "    n := len(arr)\n\
    \    if n < 2 {\n        return arr\n    }\n    // merge sort\n    q := n / 2\n\
    \    arr1 := sort_array(arr[:q])\n    arr2 := sort_array(arr[q:])\n    res :=\
    \ make([]int, n)\n    i := 0\n    j := 0\n    for i < len(arr1) && j < len(arr2)\
    \ {\n        if comp(arr1[i], arr2[j]) {\n            res[i+j] = arr1[i]\n   \
    \         i++\n        } else {\n            res[i+j] = arr2[j]\n            j++\n\
    \        }\n    }\n    for i < len(arr1) {\n        res[i+j] = arr1[i]\n     \
    \   i++\n    }\n    for j < len(arr2) {\n        res[i+j] = arr2[j]\n        j++\n\
    \    }\n    return res\n}\n", "    if len(arr) <= 1 {\n        return arr\n  \
    \  }\n    p := arr[0]\n    left := make([]int, 0)\n    right := make([]int, 0)\n\
    \    for _, v := range arr[1:] {\n        if v < p {\n            left = append(left,\
    \ v)\n        } else {\n            right = append(right, v)\n        }\n    }\n\
    \    return append(sort_array(left), append([]int{p}, sort_array(right)...)...)\n\
    }\n", "    // TODO: Implement your solution here\n    return arr\n}\n", "    //\
    \ your code here\n    return []int{}\n}\n", "    if len(arr) <= 1 {\n        return\
    \ arr\n    }\n    // for i := 0; i < len(arr); i++ {\n    //     for j := i +\
    \ 1; j < len(arr); j++ {\n    //         if arr[i] > arr[j] {\n    //        \
    \     arr[i], arr[j] = arr[j], arr[i]\n    //         }\n    //     }\n    //\
    \ }\n    // return arr\n    quicksort(arr, 0, len(arr) - 1)\n    return arr\n\
    }\n", "    fmt.Println(arr)\n    return []int{}\n}\n", "    // your code here\n\
    \    return arr\n}\n", "    len := len(arr)\n    for i := 0; i < len; i++ {\n\
    \        for j := i; j < len; j++ {\n            if binary_ones(arr[i]) > binary_ones(arr[j])\
    \ {\n                arr[i], arr[j] = arr[j], arr[i]\n            } else if binary_ones(arr[i])\
    \ == binary_ones(arr[j]) {\n                if arr[i] > arr[j] {\n           \
    \         arr[i], arr[j] = arr[j], arr[i]\n                }\n            }\n\
    \        }\n    }\n    return arr\n}\n", "    if len(arr) <= 1 {\n        return\
    \ arr\n    }\n    ones := make(map[int]int)\n    for _, v := range arr {\n   \
    \     ones[v] = countOnes(v)\n    }\n    for i := 0; i < len(arr); i++ {\n   \
    \     for j := 0; j < len(arr) - 1; j++ {\n            if ones[arr[j]] > ones[arr[j\
    \ + 1]] {\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n         \
    \   } else if ones[arr[j]] == ones[arr[j + 1]] && arr[j] > arr[j + 1] {\n    \
    \            arr[j], arr[j + 1] = arr[j + 1], arr[j]\n            }\n        }\n\
    \    }\n    return arr\n}\n", "    if arr == nil || len(arr) < 2 {\n        return\
    \ arr\n    }\n    nums := make([]int, len(arr))\n    copy(nums, arr)\n    return\
    \ merge_sort(nums)\n}\n", "    // keep track of total ones count for all numbers\n\
    \    onesCount := make(map[int]int)\n    for _, i := range arr {\n        fmt.Println(i)\n\
    \        // set these bits to 1, if they are already set to 1, then they will\
    \ still be 1\n        i = i | i >> 1\n        i = i | i >> 2\n        i = i |\
    \ i >> 4\n        i = i | i >> 8\n        i = i | i >> 16\n        onesCount[i]\
    \ += 1\n    }\n    // count how many numbers are smaller than the current number\
    \ of ones\n    cumSum := make(map[int]int)\n    var count int\n    for i := range\
    \ onesCount {\n        cumSum[i] = count\n        count += onesCount[i]\n    }\n\
    \    for i := range arr {\n        ones := arr[i] | arr[i] >> 1\n        ones\
    \ = ones | ones >> 2\n        ones = ones | ones >> 4\n        ones = ones | ones\
    \ >> 8\n        ones = ones | ones >> 16\n        arr[cumSum[ones]] = arr[i]\n\
    \        cumSum[ones] += 1\n    }\n    return arr\n}\n", "    // Sort array by\
    \ number of 1s\n    sortArrayByOnes(arr)\n    // Find the largest positive number\n\
    \    largestPositive := arr[len(arr)-1]\n    // If largest positive number is\
    \ negative, sort by value\n    if largestPositive < 0 {\n        sortArrayByValue(arr)\n\
    \    }\n    return arr\n}\n", "    var sortedArr []int\n    var sortedOnesArray,\
    \ sortedZerosArray []int\n    var zeros, ones int\n\n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] < 0 {\n            sortedArr = append(sortedArr, arr[i])\n\
    \        } else {\n            if arr[i]%2 == 0 {\n                sortedZerosArray\
    \ = append(sortedZerosArray, arr[i])\n                zeros++\n            } else\
    \ {\n                sortedOnesArray = append(sortedOnesArray, arr[i])\n     \
    \           ones++\n            }\n        }\n    }\n\n    for i := 0; i < ones;\
    \ i++ {\n        sortedArr = append(sortedArr, sortedOnesArray[i])\n    }\n\n\
    \    for i := 0; i < zeros; i++ {\n        sortedArr = append(sortedArr, sortedZerosArray[i])\n\
    \    }\n\n    return sortedArr\n}\n", "    return sort(arr, -1)\n}\n", "    res\
    \ := []int{}\n    one := []int{}\n    zero := []int{}\n    for _, val := range\
    \ arr {\n        if count_ones(val) == 0 {\n            zero = append(zero, val)\n\
    \        } else {\n            one = append(one, val)\n        }\n    }\n    one\
    \ = quick_sort(one)\n    res = append(res, zero...)\n    res = append(res, one...)\n\
    \    return res\n}\n", "    var l = len(arr)\n    var i, j, k int\n    var bin\
    \ []int\n    var s []int\n    var idx int\n    var count []int\n    var onesCount\
    \ []int\n    var sorted bool\n\n    count = make([]int, l)\n    onesCount = make([]int,\
    \ l)\n    sorted = false\n\n    fmt.Println(\"len:\", l)\n    //\n    for i =\
    \ 0; i < l; i++ {\n        // fmt.Println(\"i:\", i)\n        if arr[i] == 0 {\n\
    \            count[i] = 0\n            continue\n        }\n        //\n     \
    \   bin = make([]int, 0)\n        for k = arr[i]; k > 0; k /= 2 {\n          \
    \  bin = append(bin, k % 2)\n        }\n        count[i] = 0\n        for j =\
    \ 0; j < len(bin); j++ {\n            if bin[j] == 1 {\n                count[i]++\n\
    \            }\n        }\n    }\n    fmt.Println(\"count:\", count)\n    //\n\
    \    // keep track of indexes of ones\n    for i = 0; i < l; i++ {\n        s\
    \ = append(s, i)\n    }\n    //\n    // keep track of ones\n    for i = 0; i <\
    \ l; i++ {\n        onesCount[i] = count[i]\n    }\n    //\n    // sort indexes\
    \ of ones\n    for i = 0; i < l-1; i++ {\n        for j = i + 1; j < l; j++ {\n\
    \            if onesCount[s[i]] > onesCount[s[j]] {\n                idx = s[i]\n\
    \                s[i] = s[j]\n                s[j] = idx\n            }\n    \
    \    }\n    }\n    fmt.Println(\"indexes:\", s)\n    //\n    // apply indexes\
    \ of ones to ones\n    for i = 0; i < l; i++ {\n        onesCount[i] = count[s[i]]\n\
    \    }\n    fmt.Println(\"ones:\", onesCount)\n    //\n    // sort ones\n", "\t\
    return arr\n}\n", "\tfmt.Println(arr)\n\t\n\treturn arr\n}\n", "    var result\
    \ []int\n    var ones_dict = make(map[int]int)\n    var zero_arr []int\n    var\
    \ ones_arr []int\n    for _, v := range arr {\n        if v < 0 {\n          \
    \  result = append(result, v)\n        } else {\n            var count_ones int\n\
    \            var abs_v = abs(v)\n            for abs_v > 0 {\n               \
    \ if abs_v % 2 == 1 {\n                    count_ones++\n                }\n \
    \               abs_v /= 2\n            }\n            ones_dict[v] = count_ones\n\
    \            if count_ones == 0 {\n                zero_arr = append(zero_arr,\
    \ v)\n            } else {\n                ones_arr = append(ones_arr, v)\n \
    \           }\n        }\n    }\n    sort.Ints(zero_arr)\n    sort.Ints(ones_arr)\n\
    \    for _, v := range zero_arr {\n        result = append(result, v)\n    }\n\
    \    for _, v := range ones_arr {\n        result = append(result, v)\n    }\n\
    \    return result\n}\n", "    // your code here\n    for i := range arr {\n \
    \       for j := range arr {\n            onesCount := countOnes(arr[i])\n   \
    \         if onesCount > countOnes(arr[j]) {\n                temp := arr[i]\n\
    \                arr[i] = arr[j]\n                arr[j] = temp\n            }\
    \ else if onesCount == countOnes(arr[j]) && arr[i] < arr[j] {\n              \
    \  temp := arr[i]\n                arr[i] = arr[j]\n                arr[j] = temp\n\
    \            }\n        }\n    }\n    return arr\n}\n", "    return nil\n}\n",
  "    // write your code here\n    var arr_len int = len(arr)\n    for i := 0; i\
    \ < arr_len - 1; i++ {\n        for j := i + 1; j < arr_len; j++ {\n         \
    \   if arr[i] > arr[j] {\n                arr[i], arr[j] = arr[j], arr[i]\n  \
    \          }\n        }\n    }\n    return arr\n}\n", "    fmt.Println(arr)\n\
    \    fmt.Println(dec_to_bin(5))\n    fmt.Println(dec_to_bin(10))\n    fmt.Println(dec_to_bin(5)[1])\n\
    \    return arr\n}\n", "    zeros := []int{}\n    ones := []int{}\n    for _,\
    \ val := range arr {\n        if val == 0 {\n            zeros = append(zeros,\
    \ val)\n        } else {\n            ones = append(ones, val)\n        }\n  \
    \  }\n    return append(zeros, ones...)\n}\n", "    onemap := make(map[int]int)\n\
    \    for _, i := range arr {\n        num := i\n        cnt := 0\n        for\
    \ num > 0 {\n            cnt += num & 1\n            num >>= 1\n        }\n  \
    \      onemap[i] = cnt\n    }\n    fmt.Println(onemap)\n    var sort_arr []int\n\
    \    for i := 0; i < len(arr); i++ {\n        min1, min2 := arr[0], arr[0]\n \
    \       for _, j := range arr {\n            if onemap[j] < onemap[min1] {\n \
    \               min1 = j\n            } else if onemap[j] == onemap[min1] && j\
    \ < min2 {\n                min2 = j\n            }\n        }\n        sort_arr\
    \ = append(sort_arr, min2)\n        arr = del(arr, min2)\n    }\n    return sort_arr\n\
    }\n", "    sort(arr, 0, len(arr) - 1)\n    return arr\n}\n", "    if len(arr)\
    \ <= 1 {\n        return arr\n    }\n    pivot := arr[0]\n    // var left_arr\
    \ []int\n    // var right_arr []int\n    left_arr := make([]int, 0)\n    right_arr\
    \ := make([]int, 0)\n    for _, value := range arr[1:] {\n        if value > pivot\
    \ {\n            right_arr = append(right_arr, value)\n        } else {\n    \
    \        left_arr = append(left_arr, value)\n        }\n    }\n    left_arr =\
    \ append(sort_array(left_arr), pivot)\n    left_arr = append(left_arr, sort_array(right_arr)...)\n\
    \    return left_arr\n}\n", "    sort_by_ones(arr)\n    return arr\n}\n", "  \
    \  if len(arr) == 0 {\n        return arr\n    }\n    for i := 1; i < len(arr);\
    \ i++ {\n        key := arr[i]\n        j := i - 1\n        for j >= 0 && arr[j]\
    \ > key {\n            arr[j+1] = arr[j]\n            j--\n        }\n       \
    \ arr[j+1] = key\n    }\n    return arr\n}\n", "    if len(arr) <= 1 {\n     \
    \   return arr\n    }\n    quicksort(arr, 0, len(arr) - 1)\n    return arr\n}\n",
  "    if len(arr) <= 1 {\n        return arr\n    }\n    pivot := arr[0]\n    left\
    \ := []int{}\n    right := []int{}\n    for _, v := range arr[1:] {\n        if\
    \ v <= pivot {\n            left = append(left, v)\n        } else {\n       \
    \     right = append(right, v)\n        }\n    }\n    left = sort_array(left)\n\
    \    right = sort_array(right)\n    return append(append(left, pivot), right...)\n\
    }\n", "    one_count := map[int]int{}\n    for _, val := range arr {\n       \
    \ one_count[val] = count_one(val)\n    }\n    fmt.Println(one_count)\n    return\
    \ nil\n}\n", "    // your code goes here\n    for i := 0; i < len(arr); i++ {\n\
    \        for j := 0; j < len(arr)-1; j++ {\n            ones_i := 0\n        \
    \    ones_j := 0\n            for arr[i] != 0 {\n                ones_i += arr[i]\
    \ & 1\n                arr[i] >>= 1\n            }\n            for arr[j] !=\
    \ 0 {\n                ones_j += arr[j] & 1\n                arr[j] >>= 1\n  \
    \          }\n            if ones_i < ones_j {\n                tmp := arr[i]\n\
    \                arr[i] = arr[j]\n                arr[j] = tmp\n            }\
    \ else if ones_i == ones_j {\n                if arr[i] < arr[j] {\n         \
    \           tmp := arr[i]\n                    arr[i] = arr[j]\n             \
    \       arr[j] = tmp\n                }\n            }\n        }\n    }\n   \
    \ return arr\n}\n", "    //to do\n    return arr\n}\n", "    onesCount := make(map[int]int)\n\
    \    for _, n := range arr {\n        onesCount[n] = countOnes(n)\n    }\n   \
    \ for i := 0; i < len(arr); i++ {\n        for j := i + 1; j < len(arr); j++ {\n\
    \            if onesCount[arr[i]] > onesCount[arr[j]] {\n                arr[i],\
    \ arr[j] = arr[j], arr[i]\n            } else if onesCount[arr[i]] == onesCount[arr[j]]\
    \ && arr[i] > arr[j] {\n                arr[i], arr[j] = arr[j], arr[i]\n    \
    \        }\n        }\n    }\n    return arr\n}\n", "    for i, j := 0, len(arr)-1;\
    \ i <= j; i, j = i+1, j-1 {\n        for arr[i]>>uint(ones(arr[i]))&1 == 0 {\n\
    \            if i < j {\n                i++\n            } else {\n         \
    \       break\n            }\n        }\n        for arr[j]>>uint(ones(arr[j]))&1\
    \ == 1 {\n            if i < j {\n                j--\n            } else {\n\
    \                break\n            }\n        }\n        if i < j {\n       \
    \     arr[i], arr[j] = arr[j], arr[i]\n        }\n    }\n    return arr\n}\n",
  "    if len(arr) == 0 {\n        return arr\n    }\n    store := make(map[int]int)\n\
    \    for _, v := range arr {\n        store[v] = countOnes(v)\n    }\n    sort(arr,\
    \ store)\n    return arr\n}\n", "    var i, j int\n    var ret = make([]int, len(arr))\n\
    \    var tmp int\n    copy(ret, arr)\n    for i = 0; i < len(ret) - 1; i++ {\n\
    \        for j = i + 1; j < len(ret); j++ {\n            if count_one(ret[i])\
    \ > count_one(ret[j]) {\n                tmp = ret[i]\n                ret[i]\
    \ = ret[j]\n                ret[j] = tmp\n            } else if count_one(ret[i])\
    \ == count_one(ret[j]) {\n                if ret[i] > ret[j] {\n             \
    \       tmp = ret[i]\n                    ret[i] = ret[j]\n                  \
    \  ret[j] = tmp\n                }\n            }\n        }\n    }\n    return\
    \ ret\n}\n", "    myFunc := func(n int) int {\n        cnt := 0\n        for n\
    \ > 0 {\n            if n % 2 == 1 {\n                cnt += 1\n            }\n\
    \            n /= 2\n        }\n        return cnt\n    }\n    makeBigger := func(n1,\
    \ n2 int) bool {\n        ones1 := myFunc(n1)\n        ones2 := myFunc(n2)\n \
    \       if ones1 < ones2 {\n            return true\n        } else if ones1 ==\
    \ ones2 {\n            return n1 < n2\n        } else {\n            return false\n\
    \        }\n    }\n    for i := 0; i < len(arr); i++ {\n        for j := i + 1;\
    \ j < len(arr); j++ {\n            if makeBigger(arr[i], arr[j]) {\n         \
    \       arr[i], arr[j] = arr[j], arr[i]\n            }\n        }\n    }\n   \
    \ return arr\n}\n", "    return arr\n}\n", "    var ones [][]int\n    for _, n\
    \ := range arr {\n        if n < 0 {\n            continue\n        }\n      \
    \  num := fmt.Sprintf(\"%b\", n)\n        count := 0\n        for _, s := range\
    \ num {\n            if s == '1' {\n                count++\n            }\n \
    \       }\n        ones = append(ones, []int{count, n})\n    }\n    for i := 1;\
    \ i < len(ones); i++ {\n        for j := 0; j < len(ones)-i; j++ {\n         \
    \   if ones[j][0] > ones[j+1][0] {\n                ones[j], ones[j+1] = ones[j+1],\
    \ ones[j]\n            } else if ones[j][0] == ones[j+1][0] && ones[j][1] > ones[j+1][1]\
    \ {\n                ones[j], ones[j+1] = ones[j+1], ones[j]\n            }\n\
    \        }\n    }\n    result := make([]int, len(ones))\n    for i, o := range\
    \ ones {\n        result[i] = o[1]\n    }\n    return result\n}\n", "    return\
    \ nil\n}\n", "    var (\n        sortfn func(i, j int) bool\n        temp int\n\
    \    )\n    for i := 0; i < len(arr); i++ {\n        for j := i + 1; j < len(arr);\
    \ j++ {\n            sortfn = func(i, j int) bool {\n                if arr[i]\
    \ & arr[j] > 0 {\n                    return arr[i] > arr[j]\n               \
    \ }\n                if arr[i] & arr[j] == 0 {\n                    return arr[i]\
    \ < arr[j]\n                }\n                // arr[i] > 0 && arr[j] < 0 or\
    \ arr[i] < 0 && arr[j] > 0\n                return arr[i] > 0\n            }\n\
    \            if sortfn(i, j) {\n                temp = arr[i]\n              \
    \  arr[i] = arr[j]\n                arr[j] = temp\n            }\n        }\n\
    \    }\n    return arr\n}\n", "    for i := 0; i < len(arr); i++ {\n        for\
    \ j := i + 1; j < len(arr); j++ {\n            if i == j {\n                continue\n\
    \            }\n            if arr[i] < 0 && arr[j] > 0 {\n                continue\n\
    \            } else if arr[i] > 0 && arr[j] < 0 {\n                arr[i], arr[j]\
    \ = arr[j], arr[i]\n            } else if arr[i] < 0 && arr[j] < 0 {\n       \
    \         if bits_count(arr[i]) > bits_count(arr[j]) {\n                    arr[i],\
    \ arr[j] = arr[j], arr[i]\n                } else if bits_count(arr[i]) == bits_count(arr[j])\
    \ {\n                    if arr[i] > arr[j] {\n                        arr[i],\
    \ arr[j] = arr[j], arr[i]\n                    }\n                }\n        \
    \    } else if arr[i] > 0 && arr[j] > 0 {\n                if bits_count(arr[i])\
    \ > bits_count(arr[j]) {\n                    arr[i], arr[j] = arr[j], arr[i]\n\
    \                } else if bits_count(arr[i]) == bits_count(arr[j]) {\n      \
    \              if arr[i] > arr[j] {\n                        arr[i], arr[j] =\
    \ arr[j], arr[i]\n                    }\n                }\n            }\n  \
    \      }\n    }\n    return arr\n}\n", "    return quicksort(arr)\n}\n", "   \
    \ if len(arr) == 0 {\n        return arr\n    }\n    one_counts := make([]int,\
    \ len(arr))\n    // First count the number of ones in the binary representation\
    \ of each\n    // integer.\n    for i, v := range arr {\n        if v < 0 {\n\
    \            v = -v\n        }\n        one_counts[i] = 0\n        for v > 0 {\n\
    \            if v % 2 == 1 {\n                one_counts[i] += 1\n           \
    \ }\n            v /= 2\n        }\n    }\n    // I don't understand the question,\
    \ but is this the right thing to do?\n    for i := 0; i < len(arr); i++ {\n  \
    \      for j := 0; j < len(arr); j++ {\n            if one_counts[i] < one_counts[j]\
    \ {\n                arr[i], arr[j] = arr[j], arr[i]\n                one_counts[i],\
    \ one_counts[j] = one_counts[j], one_counts[i]\n            } else if one_counts[i]\
    \ == one_counts[j] && arr[i] < arr[j] {\n                arr[i], arr[j] = arr[j],\
    \ arr[i]\n                one_counts[i], one_counts[j] = one_counts[j], one_counts[i]\n\
    \            }\n        }\n    }\n    return arr\n}\n", "    max := 0\n    for\
    \ _, v := range arr {\n        if v > max {\n            max = v\n        }\n\
    \    }\n    ones := make([]int, max+1)\n    for _, v := range arr {\n        for\
    \ i := v; i > 0; i /= 2 {\n            ones[v] += i % 2\n        }\n    }\n  \
    \  fmt.Println(ones)\n    return arr\n}\n", "    arrLen := len(arr)\n    if arrLen\
    \ < 2 {\n        return arr\n    }\n    arr1 := make([]int, 0, arrLen)\n    arr2\
    \ := make([]int, 0, arrLen)\n    i := 0\n    for _, v := range arr {\n       \
    \ if v > 0 {\n            if hasOneDigit(v) {\n                arr1 = append(arr1,\
    \ v)\n            } else {\n                arr2 = append(arr2, v)\n         \
    \   }\n        } else {\n            if hasOneDigit(v * -1) {\n              \
    \  arr1 = append(arr1, v)\n            } else {\n                arr2 = append(arr2,\
    \ v)\n            }\n        }\n        i++\n    }\n    sortBinary(arr1)\n   \
    \ sortBinary(arr2)\n    return append(arr1, arr2...)\n}\n", "    // Fill me in!\n\
    \    return arr\n}\n", "    var res []int\n\n    return res\n}\n", "    count\
    \ := make(map[int]int)\n    for _, v := range arr {\n        count[v] = ones(v)\n\
    \    }\n    arr = sortMap(count)\n    return arr\n}\n", "    // your code here\n\
    \    length := len(arr)\n    if length == 0 {\n        return arr\n    }\n   \
    \ for i := 0; i < length; i++ {\n        for j := i + 1; j < length; j++ {\n \
    \           if compare(arr[i], arr[j]) > 0 {\n                arr[i], arr[j] =\
    \ arr[j], arr[i]\n            }\n        }\n    }\n    return arr\n}\n", "   \
    \ // Fill this in.\n    return arr\n}\n", "    if len(arr) <= 1 {\n        return\
    \ arr\n    }\n    i := 0\n    j := len(arr) - 1\n    for i < j {\n        if check_sort(arr[i],\
    \ arr[j]) {\n            // swap values\n            temp := arr[i]\n        \
    \    arr[i] = arr[j]\n            arr[j] = temp\n            i++\n           \
    \ j--\n        } else {\n            i++\n        }\n    }\n    return sort_array(arr[:i])\
    \ + sort_array(arr[i:])\n}\n", "    bucket := make(map[int][]int)\n    var keys\
    \ []int\n    for _, v := range arr {\n        count := count_ones(v)\n       \
    \ if bucket[count] == nil {\n            keys = append(keys, count)\n        }\n\
    \        bucket[count] = append(bucket[count], v)\n    }\n    sort.Ints(keys)\n\
    \    var ret []int\n    for _, k := range keys {\n        arr := bucket[k]\n \
    \       sort.Ints(arr)\n        ret = append(ret, arr...)\n    }\n    return ret\n\
    }\n", "    fmt.Println(arr)\n    return []int{}\n}\n", "    var sorted []int\n\
    \    for i, v := range arr {\n        fmt.Println(i, v)\n    }\n    return sorted\n\
    }\n", "    if len(arr) == 0 {\n        return []int{}\n    }\n    sorter := new(SortArray)\n\
    \    return sorter.sort(arr)\n}\n\ntype SortArray ", "    ones := make(map[int]int)\n\
    \    // calculate number of ones of each number\n    for _, v := range arr {\n\
    \        if v < 0 {\n            continue\n        }\n        ones[v] = count_ones(v)\n\
    \    }\n    // sort by ones\n    for i := 0; i < len(arr) - 1; i++ {\n       \
    \ for j := i + 1; j < len(arr); j++ {\n            if ones[arr[i]] > ones[arr[j]]\
    \ {\n                swap(arr, i, j)\n            } else if ones[arr[i]] == ones[arr[j]]\
    \ {\n                if arr[i] > arr[j] {\n                    swap(arr, i, j)\n\
    \                }\n            }\n        }\n    }\n    return arr\n}\n", " \
    \   if len(arr) == 0 {\n        return arr\n    }\n    quicksort(arr, 0, len(arr)\
    \ - 1)\n    return arr\n}\n", "    fmt.Println(arr)\n    // TODO:\n    return\
    \ []int{}\n}\n", "    if len(arr) <= 1 {\n        return arr\n    }\n    pivot\
    \ := arr[0]\n    left, right := make([]int, 0), make([]int, 0)\n    for i := 1;\
    \ i < len(arr); i++ {\n        if arr[i] < pivot {\n            left = append(left,\
    \ arr[i])\n        } else {\n            right = append(right, arr[i])\n     \
    \   }\n    }\n    return append(sort_array(left), append([]int{pivot}, sort_array(right)...)...)\n\
    }\n", "    // your code here\n    return []int{}\n}\n", "    var is_negative =\
    \ false\n    if arr[0] < 0 {\n        is_negative = true\n    }\n    ones_count\
    \ := get_count_ones(arr)\n    if is_negative {\n        ones_count = invert_negative(ones_count)\n\
    \    }\n    return sort_array_by_count(arr, ones_count)\n}\n", "    bucket :=\
    \ make(map[int][]int)\n    for _, value := range arr {\n        var count int\n\
    \        for value > 0 {\n            count += value & 1\n            value >>=\
    \ 1\n        }\n        bucket[count] = append(bucket[count], value)\n    }\n\
    \    var result []int\n    for i := 0; i < len(bucket); i++ {\n        for _,\
    \ value := range bucket[i] {\n            result = append(result, value)\n   \
    \     }\n    }\n    return result\n}\n", "    // return arr\n    fmt.Println(arr)\n\
    \    return []int{}\n}\n", "    onesCount := map[int]int{}\n    ans := []int{}\n\
    \    for _, val := range arr {\n        count := 0\n        dec := val\n     \
    \   for dec > 0 {\n            count += dec % 2\n            dec /= 2\n      \
    \  }\n        onesCount[val] = count\n        ans = append(ans, val)\n    }\n\
    \    for i := 0; i < len(ans) - 1; i++ {\n        for j := i + 1; j < len(ans);\
    \ j++ {\n            if onesCount[ans[i]] > onesCount[ans[j]] {\n            \
    \    ans[i], ans[j] = ans[j], ans[i]\n            } else if onesCount[ans[i]]\
    \ == onesCount[ans[j]] && ans[i] > ans[j] {\n                ans[i], ans[j] =\
    \ ans[j], ans[i]\n            }\n        }\n    }\n    return ans\n}\n", "   \
    \ if len(arr) == 0 {\n        return arr\n    }\n    //make a copy of original\
    \ array\n    copy_arr := make([]int, len(arr))\n    copy(copy_arr, arr)\n    sort(copy_arr,\
    \ 0, len(copy_arr)-1)\n    return copy_arr\n}\n", "    return []int{}\n}\n", " \
    \   // fmt.Println(arr)\n    // fmt.Println(len(arr))\n    for i := 0; i < len(arr);\
    \ i++ {\n        // fmt.Println(i)\n        for j := i; j < len(arr); j++ {\n\
    \            // fmt.Println(arr[i], arr[j])\n            if onesInBinary(arr[i])\
    \ > onesInBinary(arr[j]) {\n                arr[i], arr[j] = arr[j], arr[i]\n\
    \            } else if onesInBinary(arr[i]) == onesInBinary(arr[j]) {\n      \
    \          if arr[i] > arr[j] {\n                    arr[i], arr[j] = arr[j],\
    \ arr[i]\n                }\n            }\n        }\n    }\n    return arr\n\
    }\n", "    n := len(arr)\n    if n <= 1 {\n        return arr\n    }\n    // counting\
    \ sort\n    bits := make([]int, n)\n    for i, v := range arr {\n        bits[i]\
    \ = countBits(v)\n    }\n    idx := make([]int, n)\n    copy(idx, arr)\n    countingSort(bits,\
    \ idx)\n    return idx\n}\n", "    var bits []int\n    max_bits := -1\n    num_items\
    \ := len(arr)\n    for _, item := range arr {\n        if item < 0 {\n       \
    \     bits = append(bits, 1)\n            num_items -= 1\n        } else {\n \
    \           bits = append(bits, bit_count(item))\n            if bits[len(bits)-1]\
    \ > max_bits {\n                max_bits = bits[len(bits)-1]\n            }\n\
    \        }\n    }\n    if num_items <= 1 {\n        return arr\n    }\n    new_arr\
    \ := make([]int, num_items)\n    var i = 0\n    for index, bit_count := range\
    \ bits {\n        if bit_count != 1 {\n            new_arr[i] = arr[index]\n \
    \           i += 1\n        }\n    }\n    for i := max_bits; i >= 0; i-- {\n \
    \       for index, bit_count := range bits {\n            if bit_count == i {\n\
    \                new_arr[i] = arr[index]\n            }\n        }\n    }\n  \
    \  return new_arr\n}\n", "    zeros := make([]int, 0)\n    ones := make([]int,\
    \ 0)\n    for _, i := range arr {\n        if i == 0 {\n            zeros = append(zeros,\
    \ i)\n        } else {\n            ones = append(ones, i)\n        }\n    }\n\
    \    return append(zeros, ones...)\n}\n", "    sorted := make([]int, len(arr))\n\
    \    copy(sorted, arr)\n    for i, e := range sorted {\n        sorted[i] = e\
    \ - 1\n    }\n    return sorted\n}\n", "\tfor i := 0; i < len(arr); i++ {\n\t\t\
    min := i\n\t\tfor j := i + 1; j < len(arr); j++ {\n\t\t\tif less(arr[j], arr[min])\
    \ {\n\t\t\t\tmin = j\n\t\t\t}\n\t\t}\n\t\tarr[i], arr[min] = arr[min], arr[i]\n\
    \t}\n\treturn arr\n}\n", "    return sortArray(arr)\n}\n", "    key := func(i\
    \ int) int {\n        x := arr[i]\n        count := 0\n        for x > 0 {\n \
    \           if x % 2 == 1 {\n                count += 1\n            }\n     \
    \       x /= 2\n        }\n        return count\n    }\n    quick_sort(arr, 0,\
    \ len(arr) - 1, key)\n    return arr\n}\n", "    // generate a map of number of\
    \ 1s and the number itself\n    dict := make(map[int][]int)\n    for _, val :=\
    \ range arr {\n        if _, ok := dict[countOnes(val)]; !ok {\n            dict[countOnes(val)]\
    \ = []int{val}\n        } else {\n            dict[countOnes(val)] = append(dict[countOnes(val)],\
    \ val)\n        }\n    }\n    // sort the values\n    for _, v := range dict {\n\
    \        for i := 0; i < len(v); i++ {\n            for j := i; j < len(v); j++\
    \ {\n                if v[i] > v[j] {\n                    temp := v[i]\n    \
    \                v[i] = v[j]\n                    v[j] = temp\n              \
    \  }\n            }\n        }\n    }\n    // generate the final list\n    var\
    \ result []int\n    for i := 0; i < len(dict); i++ {\n        result = append(result,\
    \ dict[i]...)\n    }\n    return result\n}\n", "    if len(arr) <= 1 {\n     \
    \   return arr\n    }\n    oneCount := []int{}\n    for _, v := range arr {\n\
    \        c := CountNumberOfOnes(v)\n        oneCount = append(oneCount, c)\n \
    \   }\n    fmt.Println(oneCount)\n    for i := 0; i < len(arr); i++ {\n      \
    \  for j := i + 1; j < len(arr); j++ {\n            if oneCount[i] > oneCount[j]\
    \ {\n                oneCount[i], oneCount[j] = oneCount[j], oneCount[i]\n   \
    \             arr[i], arr[j] = arr[j], arr[i]\n            } else if oneCount[i]\
    \ == oneCount[j] {\n                if arr[i] > arr[j] {\n                   \
    \ arr[i], arr[j] = arr[j], arr[i]\n                }\n            }\n        }\n\
    \    }\n    return arr\n}\n", "    sorted := make([]int, len(arr))\n    copy(sorted,\
    \ arr)\n    for i := 0; i < len(sorted) - 1; i++ {\n        for j := i + 1; j\
    \ < len(sorted); j++ {\n            if sorted[i] > sorted[j] {\n             \
    \   sorted[i], sorted[j] = sorted[j], sorted[i]\n            }\n        }\n  \
    \  }\n    return sorted\n}\n", "    // Write your code here\n    return arr\n\
    }\n", "    return append([]int{}, arr...)\n}\n", "    for i := 0; i < len(arr);\
    \ i++ {\n        for j := i; j < len(arr); j++ {\n            // if countOnes(arr[i])\
    \ > countOnes(arr[j]) {\n            //     tmp := arr[i]\n            //    \
    \ arr[i] = arr[j]\n            //     arr[j] = tmp\n            // } else if countOnes(arr[i])\
    \ == countOnes(arr[j]) {\n            //     if arr[i] > arr[j] {\n          \
    \  //         tmp := arr[i]\n            //         arr[i] = arr[j]\n        \
    \    //         arr[j] = tmp\n            //     }\n            // }\n       \
    \     if compare(arr[i], arr[j]) {\n                tmp := arr[i]\n          \
    \      arr[i] = arr[j]\n                arr[j] = tmp\n            }\n        }\n\
    \    }\n    return arr\n}\n", "    m := make(map[int]int)\n    for _, elem :=\
    \ range arr {\n        m[elem]++\n    }\n    for i := 1; i < len(arr); i++ {\n\
    \        if arr[i] < arr[i-1] {\n            if m[arr[i]] > m[arr[i-1]] {\n  \
    \              temp := arr[i]\n                arr[i] = arr[i-1]\n           \
    \     arr[i-1] = temp\n            }\n        }\n    }\n    return arr\n}\n",
  "    return merge_sort(arr)\n}\n", "    var tmp []int\n    for _, v := range arr\
    \ {\n        tmp = append(tmp, v)\n    }\n    sort(tmp, 0, len(tmp)-1)\n    return\
    \ tmp\n}\n", "    // sort it somehow\n    return nil\n}\n", "    m := make(map[int]int)\n\
    \    for _, i := range arr {\n        j := i\n        ones := 0\n        for j\
    \ > 0 {\n            ones += j % 2\n            j /= 2\n        }\n        m[i]\
    \ = ones\n    }\n    fmt.Println(m)\n    return arr\n}\n", "    if len(arr) <=\
    \ 1 {\n        return arr\n    }\n    left, right := 0, len(arr)-1\n    pivot\
    \ := arr[0]\n    for i := 1; i <= right; {\n        if arr[i] < pivot {\n    \
    \        arr[i], arr[left] = arr[left], arr[i]\n            left++\n         \
    \   i++\n        } else {\n            arr[i], arr[right] = arr[right], arr[i]\n\
    \            right--\n        }\n    }\n    arr[left] = pivot\n    sort_array(arr[:left])\n\
    \    sort_array(arr[left+1:])\n    return arr\n}\n", "    if len(arr) <= 1 {\n\
    \        return arr\n    }\n    pivot := arr[0]\n    left := make([]int, 0)\n\
    \    right := make([]int, 0)\n    for i := 1; i < len(arr); i++ {\n        if\
    \ int_to_bin(arr[i]) < int_to_bin(pivot) {\n            left = append(left, arr[i])\n\
    \        } else {\n            right = append(right, arr[i])\n        }\n    }\n\
    \    left = sort_array(left)\n    right = sort_array(right)\n    arr = append(left,\
    \ pivot)\n    arr = append(arr, right...)\n    return arr\n}\n", "    for i :=\
    \ 0; i < len(arr) - 1; i++ {\n        for j := i + 1; j < len(arr); j++ {\n  \
    \          if arr[i] < 0 {\n                if arr[j] > 0 {\n                \
    \    arr[i], arr[j] = arr[j], arr[i]\n                }\n            } else if\
    \ arr[j] < 0 {\n                arr[i], arr[j] = arr[j], arr[i]\n            }\
    \ else {\n                // both are positive\n                if num_of_ones(arr[i])\
    \ > num_of_ones(arr[j]) {\n                    arr[i], arr[j] = arr[j], arr[i]\n\
    \                } else if num_of_ones(arr[i]) == num_of_ones(arr[j]) {\n    \
    \                if arr[i] > arr[j] {\n                        arr[i], arr[j]\
    \ = arr[j], arr[i]\n                    }\n                }\n            }\n\
    \        }\n    }\n    return arr\n}\n", "    if len(arr) <= 1 {\n        return\
    \ arr\n    }\n    ret := []int{}\n    temp := []int{}\n    prev := 0\n    for\
    \ i, n := range arr {\n        if n == 0 {\n            prev = n\n           \
    \ continue\n        }\n        bn := []byte(fmt.Sprintf(\"%b\", n))\n        cnt\
    \ := 0\n        for _, b := range bn {\n            if b == '1' {\n          \
    \      cnt++\n            }\n        }\n        if cnt == 0 {\n            if\
    \ prev == 0 {\n                ret = append(ret, n)\n            } else {\n  \
    \              temp = append(temp, n)\n            }\n        } else {\n     \
    \       if prev == 0 {\n                ret = append(ret, temp...)\n         \
    \       temp = []int{}\n            }\n            ret = append(ret, arr[i])\n\
    \        }\n        prev = n\n    }\n    if len(temp) > 0 {\n        ret = append(ret,\
    \ temp...)\n    }\n    return ret\n}\n", "    // your code here\n\n    return\
    \ arr\n}\n", "    ones := make(map[int]int)\n    zeros := make(map[int]int)\n\
    \    i := 0\n    for _, v := range arr {\n        n := 0\n        a := v\n   \
    \     if a < 0 {\n            a = -v\n        }\n        for a > 0 {\n       \
    \     if a % 2 == 1 {\n                n++\n            }\n            a = a /\
    \ 2\n        }\n        if v >= 0 {\n            ones[n] = v\n        } else {\n\
    \            zeros[n] = v\n        }\n        i++\n    }\n    res := make([]int,\
    \ len(arr))\n    i = 0\n    for _, v := range ones {\n        res[i] = v\n   \
    \     i++\n    }\n    for _, v := range zeros {\n        res[i] = v\n        i++\n\
    \    }\n    return res\n}\n", "    fmt.Println(arr)\n    return arr\n}\n", " \
    \   fmt.Println(arr)\n    fmt.Println(len(arr))\n    for i := 0; i < len(arr);\
    \ i++ {\n        for j := 0; j < len(arr); j++ {\n            if intToBinary(arr[i])\
    \ > intToBinary(arr[j]) {\n                arr[i], arr[j] = arr[j], arr[i]\n \
    \           }\n        }\n    }\n    return arr\n}\n", "    var indexes = make([]int,\
    \ len(arr))\n    for i := 0; i < len(arr); i++ {\n        indexes[i] = i\n   \
    \ }\n    quicksort(&indexes, &arr, 0, len(arr) - 1)\n    return arr\n}\n", " \
    \   //\n    sorted := true\n    for i := 1; i < len(arr); i++ {\n        if arr[i-1]\
    \ > arr[i] {\n            arr[i-1], arr[i] = arr[i], arr[i-1]\n            sorted\
    \ = false\n        }\n    }\n    if sorted {\n        return arr\n    }\n    return\
    \ sort_array(arr)\n}\n", "    zeroes, sorted_arr := get_zeroes(arr)\n    for i,\
    \ _ := range arr {\n        arr[i] = sorted_arr[i]\n    }\n    return arr\n}\n",
  "    sort_helper(arr, 0, len(arr) - 1)\n    return arr\n}\n", "    // Your code\
    \ here!\n    if len(arr) <= 1 {\n        return arr\n    }\n    var sorted []int\n\
    \    pivot := arr[0]\n    left := make([]int, 0)\n    right := make([]int, 0)\n\
    \    for _, item := range arr[1:] {\n        if item <= pivot {\n            left\
    \ = append(left, item)\n        } else {\n            right = append(right, item)\n\
    \        }\n    }\n    left = sort_array(left)\n    right = sort_array(right)\n\
    \    sorted = append(left, pivot)\n    sorted = append(sorted, right...)\n   \
    \ return sorted\n}\n", "    res := make([]int, len(arr))\n    m := make(map[int]int)\n\
    \    for _, v := range arr {\n        m[v] = cal(v)\n    }\n    sort_map := bubble_sort(m)\n\
    \    return res\n}\n", "    res := make([]int, len(arr))\n    onesMap := make(map[int]int)\n\
    \    for i := 0; i < len(arr); i++ {\n        onesMap[arr[i]] = getOnes(arr[i])\n\
    \    }\n    for i := 0; i < len(arr); i++ {\n        fmt.Println(onesMap)\n  \
    \      idx := sortByOnes(onesMap)\n        fmt.Println(idx)\n        res[i] =\
    \ idx\n        delete(onesMap, idx)\n    }\n    return res\n}\n", "    if len(arr)\
    \ == 0 {\n        return arr\n    }\n    counter := make(map[int]int)\n    for\
    \ _, a := range arr {\n        c := 0\n        for a > 0 {\n            c += (a\
    \ % 2)\n            a /= 2\n        }\n        counter[c]++\n    }\n    for i\
    \ := 0; i < len(arr); i++ {\n        c := 0\n        for arr[i] > 0 {\n      \
    \      c += (arr[i] % 2)\n            arr[i] /= 2\n        }\n        arr[i] =\
    \ c\n    }\n    next := 0\n    prev := -1\n    for k, v := range counter {\n \
    \       if k == prev {\n            continue\n        }\n        prev = k\n  \
    \      for i := 0; i < len(arr); i++ {\n            if arr[i] == k {\n       \
    \         arr[i], arr[next] = arr[next], arr[i]\n                next++\n    \
    \            v--\n                if v == 0 {\n                    break\n   \
    \             }\n            }\n        }\n    }\n    return arr\n}\n", "    for\
    \ i := 0; i < len(arr); i++ {\n        for j := i + 1; j < len(arr); j++ {\n \
    \           onecount := countOnes(arr[i])\n            onetwo := countOnes(arr[j])\n\
    \            if onecount > onetwo {\n                arr[i], arr[j] = arr[j],\
    \ arr[i]\n            } else if onecount == onetwo {\n                if arr[i]\
    \ > arr[j] {\n                    arr[i], arr[j] = arr[j], arr[i]\n          \
    \      }\n            }\n        }\n    }\n    return arr\n}\n", "    return arr\n\
    }\n", "    items := make([]*sortArrayItem, len(arr))\n    for index, value :=\
    \ range arr {\n        items[index] = &sortArrayItem{value: value, binaryRepresentation:\
    \ get_bit_representation(value)}\n    }\n    quicksort(items, 0, len(items) -\
    \ 1)\n    for index, value := range items {\n        arr[index] = value.value\n\
    \    }\n    return arr\n}\n\ntype sortArrayItem ", "    // for i := 0; i < len(arr);\
    \ i++ {\n    //     for j := i + 1; j < len(arr); j++ {\n    //         a1 :=\
    \ oneNum(arr[i])\n    //         a2 := oneNum(arr[j])\n    //         if a1 >\
    \ a2 {\n    //             arr[i], arr[j] = arr[j], arr[i]\n    //         } else\
    \ if a1 == a2 {\n    //             if arr[i] > arr[j] {\n    //             \
    \    arr[i], arr[j] = arr[j], arr[i]\n    //             }\n    //         }\n\
    \    //     }\n    // }\n    for i := 0; i < len(arr); i++ {\n        for j :=\
    \ i + 1; j < len(arr); j++ {\n            if oneNum(arr[i]) > oneNum(arr[j]) {\n\
    \                arr[i], arr[j] = arr[j], arr[i]\n            } else if oneNum(arr[i])\
    \ == oneNum(arr[j]) {\n                if arr[i] > arr[j] {\n                \
    \    arr[i], arr[j] = arr[j], arr[i]\n                }\n            }\n     \
    \   }\n    }\n    return arr\n}\n", "    return arr\n}\n", "    var sorted = make([]int,\
    \ len(arr))\n    for i, _ := range arr {\n        ones := countOnes(arr[i])\n\
    \        sorted[ones] = arr[i]\n    }\n    return sorted\n}\n", "    return arr\n\
    }\n", "    n := len(arr)\n    i := 1\n    if n <= 1 {\n        return arr\n  \
    \  }\n    for ; i < n; i++ {\n        if arr[i] < arr[i-1] {\n            break\n\
    \        }\n    }\n    if i == n {\n        return arr\n    }\n    tmp := arr[i]\n\
    \    l := 0\n    r := i - 1\n    for ; l <= r; {\n        for ; l <= r; l++ {\n\
    \            if arr[l] > tmp {\n                break\n            }\n       \
    \ }\n        for ; l <= r; r-- {\n            if arr[r] < tmp {\n            \
    \    break\n            }\n        }\n        if l <= r {\n            t := arr[l]\n\
    \            arr[l] = arr[r]\n            arr[r] = t\n        }\n    }\n    arr[i]\
    \ = arr[l]\n    arr[l] = tmp\n    return sort_array(arr[:l]) + sort_array(arr[l+1:])\n\
    }\n", "    //your code here\n    return arr\n}\n", "    sortedArr := make([]int,\
    \ len(arr))\n    copy(sortedArr, arr)\n    for i := 0; i < len(sortedArr); i++\
    \ {\n        for j := i; j < len(sortedArr); j++ {\n            iBinaryStr :=\
    \ fmt.Sprintf(\"%b\", sortedArr[i])\n            jBinaryStr := fmt.Sprintf(\"\
    %b\", sortedArr[j])\n            if (strings.Count(iBinaryStr, \"1\") > strings.Count(jBinaryStr,\
    \ \"1\")) {\n                sortedArr[i], sortedArr[j] = sortedArr[j], sortedArr[i]\n\
    \            } else if (strings.Count(iBinaryStr, \"1\") == strings.Count(jBinaryStr,\
    \ \"1\")) {\n                if (sortedArr[i] > sortedArr[j]) {\n            \
    \        sortedArr[i], sortedArr[j] = sortedArr[j], sortedArr[i]\n           \
    \     }\n            }\n        }\n    }\n    return sortedArr\n}\n", "    var\
    \ bin []string\n    for _, v := range arr {\n        bin = append(bin, fmt.Sprintf(\"\
    %b\", v))\n    }\n    sortOnes(bin, arr)\n    return arr\n}\n", "    //your code\
    \ here\n    fmt.Println(arr)\n    var n int\n    n = len(arr)\n    var tmp int\n\
    \    for i := 0; i < n; i++ {\n        for j := i + 1; j < n; j++ {\n        \
    \    if (arr[i] > arr[j]) {\n                tmp = arr[i]\n                arr[i]\
    \ = arr[j]\n                arr[j] = tmp\n            }\n        }\n    }\n  \
    \  fmt.Println(arr)\n    return arr\n}\n", "    fmt.Println(arr)\n    return arr\n\
    }\n", "    var ones []int\n    var zeros []int\n    var result []int\n    var\
    \ count int\n\n    for _, val := range arr {\n        count = get_number_of_ones(val)\n\
    \        if count > 0 {\n            ones = append(ones, val)\n        } else\
    \ {\n            zeros = append(zeros, val)\n        }\n    }\n\n    fmt.Println(ones)\n\
    \    fmt.Println(zeros)\n\n    if len(ones) > 0 {\n        result = append(result,\
    \ quick_sort(ones, 0, len(ones)-1)...)\n    }\n\n    if len(zeros) > 0 {\n   \
    \     result = append(result, quick_sort(zeros, 0, len(zeros)-1)...)\n    }\n\n\
    \    return result\n}\n", "    for i := 0; i < len(arr); i++ {\n        for j\
    \ := i + 1; j < len(arr); j++ {\n            if convert(arr[i]) > convert(arr[j])\
    \ {\n                arr[i], arr[j] = arr[j], arr[i]\n            }\n        }\n\
    \    }\n    return arr\n}\n", "    return sort_array_by_ones(arr)\n}\n", '    // ',
  "    aux := make([]int, len(arr))\n    merge_sort(arr, aux, 0, len(arr)-1)\n   \
    \ return arr\n}\n", "    var sorted []int\n    var swap int\n    ones := []int{}\n\
    \    zeros := []int{}\n    //\n    // first sort by number of ones\n    //\n \
    \   for _, num := range arr {\n        swap = 0\n        for num > 0 {\n     \
    \       if num & 1 == 1 {\n                swap++\n            }\n           \
    \ num = num >> 1\n        }\n        //\n        // if there is no ones then push\
    \ on zero slice\n        // otherwise push on one slice\n        //\n        if\
    \ swap == 0 {\n            zeros = append(zeros, num)\n        } else {\n    \
    \        ones = append(ones, num)\n        }\n    }\n    //\n    // next sort\
    \ the ones slice in descending order\n    //\n    for i := len(ones) - 1; i >\
    \ 0; i-- {\n        for j := 0; j < i; j++ {\n            if ones[j] > ones[j+1]\
    \ {\n                ones[j], ones[j+1] = ones[j+1], ones[j]\n            }\n\
    \        }\n    }\n    //\n    // next sort the zero slice in ascending order\n\
    \    //\n    for i := len(zeros) - 1; i > 0; i-- {\n        for j := 0; j < i;\
    \ j++ {\n            if zeros[j] > zeros[j+1] {\n                zeros[j], zeros[j+1]\
    \ = zeros[j+1], zeros[j]\n            }\n        }\n    }\n    //\n    // append\
    \ the zero slice to the end of the ones slice\n    //\n    sorted = append(ones,\
    \ zeros...)\n    return sorted\n}\n", "    for i := 0; i < len(arr) - 1; i++ {\n\
    \        for j := i + 1; j < len(arr); j++ {\n            if (arr[i] > arr[j])\
    \ {\n                arr[i], arr[j] = arr[j], arr[i]\n            }\n        }\n\
    \    }\n    return arr\n}\n", "    l := len(arr)\n    if l <= 1 {\n        return\
    \ arr\n    }\n    var (\n        count int\n        i, j  int\n    )\n    arr\
    \ = merge_sort(arr)\n    for _, v := range arr {\n        for j = 0; j < 32; j++\
    \ {\n            count += (v >> uint(j)) & 1\n        }\n        arr[i] = count\n\
    \        i++\n        count = 0\n    }\n    arr = merge_sort(arr)\n    i = 0\n\
    \    for _, v := range arr {\n        for j = 0; j < 32; j++ {\n            count\
    \ += (v >> uint(j)) & 1\n        }\n        arr[i] = count\n        i++\n    \
    \    count = 0\n    }\n    return arr\n}\n", "    sorter := func(a, b int) int\
    \ {\n        if a == b {\n            return 0\n        }\n        if a < b {\n\
    \            return -1\n        }\n        return 1\n    }\n    quicksort(arr,\
    \ 0, len(arr) - 1, sorter)\n    return arr\n}\n", "    sort(arr, 0, len(arr) -\
    \ 1)\n    return arr\n}\n", "    if len(arr) == 0 {\n        return arr\n    }\n\
    \    qsort(arr, 0, len(arr) - 1)\n    return arr\n}\n", "    // your code here\n\
    \    return arr\n}\n", "    fmt.Println(arr)\n    return arr\n}\n", "    bt :=\
    \ make([]byte, len(arr))\n    for k, v := range arr {\n        bt[k] = byte(v)\n\
    \    }\n    return []int{1, 5, 2, 3, 4}\n}\n", "    var result []int\n\n    //\
    \ Count the numbers of ones of each number's binary representation.\n    // if\
    \ a number's binary representation has the same amount of ones as the\n    //\
    \ rest of other numbers, then compare the number's actual value.\n    // e.g.\
    \ [1, 2, 5] -> [[1, 1], [2, 1], [5, 2]]\n    ones := make([][]int, len(arr))\n\
    \    for i, v := range arr {\n        binary := fmt.Sprintf(\"%b\", v)\n     \
    \   count := 0\n        for j := 0; j < len(binary); j++ {\n            if string(binary[j])\
    \ == \"1\" {\n                count++\n            }\n        }\n        ones[i]\
    \ = []int{v, count}\n    }\n\n    // Sort the list by the numbers of ones.\n \
    \   for i := 0; i < len(ones); i++ {\n        for j := i + 1; j < len(ones); j++\
    \ {\n            if ones[i][1] > ones[j][1] {\n                ones[i], ones[j]\
    \ = ones[j], ones[i]\n            } else if ones[i][1] == ones[j][1] {\n     \
    \           if ones[i][0] > ones[j][0] {\n                    ones[i], ones[j]\
    \ = ones[j], ones[i]\n                }\n            }\n        }\n    }\n\n \
    \   // Get the actual value back to the array.\n    for _, v := range ones {\n\
    \        result = append(result, v[0])\n    }\n\n    return result\n}\n", "  \
    \  // merge_sort(arr)\n    fmt.Println(arr)\n    return arr\n}\n", "    return\
    \ nil\n}\n", "    fmt.Println(arr)\n    len := len(arr)\n    for i := 0; i < len;\
    \ i++ {\n        for j := i + 1; j < len; j++ {\n            if arr[i] > arr[j]\
    \ {\n                arr[i], arr[j] = arr[j], arr[i]\n            }\n        }\n\
    \    }\n    return arr\n}\n", "    for i, _ := range arr {\n        for j, _ :=\
    \ range arr {\n            if count_one(arr[i]) < count_one(arr[j]) {\n      \
    \          arr[i], arr[j] = arr[j], arr[i]\n            } else if count_one(arr[i])\
    \ == count_one(arr[j]) {\n                if arr[i] < arr[j] {\n             \
    \       arr[i], arr[j] = arr[j], arr[i]\n                }\n            }\n  \
    \      }\n    }\n    return arr\n}\n", "    ones := make(map[int]int)\n    for\
    \ _, val := range arr {\n        ones[val] = onesInBinary(val)\n    }\n    fmt.Println(ones)\n\
    \    return arr\n}\n", "    for i := 0; i < len(arr); i++ {\n        for j :=\
    \ 0; j < len(arr) - 1; j++ {\n            if ones(arr[j]) > ones(arr[j + 1]) {\n\
    \                temp := arr[j]\n                arr[j] = arr[j + 1]\n       \
    \         arr[j + 1] = temp\n            } else if ones(arr[j]) == ones(arr[j\
    \ + 1]) && arr[j] > arr[j + 1] {\n                temp := arr[j]\n           \
    \     arr[j] = arr[j + 1]\n                arr[j + 1] = temp\n            }\n\
    \        }\n    }\n    return arr\n}\n", "    return radix_sort(arr)\n}\n", " \
    \   maxLen := 0\n    for _, v := range arr {\n        maxLen = max(maxLen, v)\n\
    \    }\n    fmt.Println(maxLen)\n    return nil\n}\n", "    var sortByOneNum []int\n\
    \    var sortByValue []int\n    for _, v := range arr {\n        if v < 0 {\n\
    \            sortByValue = append(sortByValue, v)\n        } else {\n        \
    \    sortByOneNum = append(sortByOneNum, v)\n        }\n    }\n    sortByOneNum\
    \ = sort_negative_array(sortByOneNum)\n    sortByValue = sort_negative_array(sortByValue)\n\
    \    for i, v := range sortByOneNum {\n        arr[i] = v\n    }\n    for i, v\
    \ := range sortByValue {\n        arr[i + len(sortByOneNum)] = v\n    }\n    return\
    \ arr\n}\n", "    fmt.Println(arr)\n    return arr\n}\n", "    if len(arr) ==\
    \ 0 {\n        return arr\n    }\n    N := len(arr)\n    for i := 0; i < N-1;\
    \ i++ {\n        for j := i+1; j < N; j++ {\n            a := arr[i]\n       \
    \     b := arr[j]\n            if compare(a, b) == 1 {\n                arr[i]\
    \ = b\n                arr[j] = a\n            }\n        }\n    }\n    return\
    \ arr\n}\n", "    if len(arr) <= 1 {\n        return arr\n    }\n    mid := len(arr)\
    \ / 2\n    left := sort_array(arr[:mid])\n    right := sort_array(arr[mid:])\n\
    \    return merge(left, right)\n}\n", "    ones := []int{}\n    arrMap := map[int]int{}\n\
    \    for _, val := range arr {\n        bits := bitcount(val)\n        ones =\
    \ append(ones, bits)\n        arrMap[bits] = val\n    }\n    quickSort(ones, 0,\
    \ len(ones)-1)\n    fmt.Println(ones)\n    res := []int{}\n    for _, bits :=\
    \ range ones {\n        res = append(res, arrMap[bits])\n    }\n    return res\n\
    }\n", "    if arr == nil || len(arr) < 2 {\n        return arr\n    }\n    quicksort(arr,\
    \ 0, len(arr) - 1)\n    return arr\n}\n", "    for i := 0; i < len(arr); i++ {\n\
    \        for j := i + 1; j < len(arr); j++ {\n            if getOneCount(arr[i])\
    \ > getOneCount(arr[j]) {\n                arr[i], arr[j] = arr[j], arr[i]\n \
    \           } else if getOneCount(arr[i]) == getOneCount(arr[j]) {\n         \
    \       if arr[i] > arr[j] {\n                    arr[i], arr[j] = arr[j], arr[i]\n\
    \                }\n            }\n        }\n    }\n    return arr\n}\n", " \
    \   return nil\n}\n", "    // place your code here\n    for i:=0; i<len(arr);\
    \ i++ {\n        if arr[i] >= 0 {\n            for j:=i+1; j<len(arr); j++ {\n\
    \                if arr[j] >= 0 {\n                    if getOnes(arr[i]) > getOnes(arr[j])\
    \ {\n                        arr[i], arr[j] = arr[j], arr[i]\n               \
    \     } else if getOnes(arr[i]) == getOnes(arr[j]) {\n                       \
    \ if arr[i] > arr[j] {\n                            arr[i], arr[j] = arr[j], arr[i]\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    return arr\n}\n", "    // max binary length in\
    \ array\n    max_bin := 1\n    // map of binary length -> values\n    bin_map\
    \ := make(map[int][]int)\n    for _, val := range arr {\n        bin_len := get_bin_len(val)\n\
    \        if bin_len > max_bin {\n            max_bin = bin_len\n        }\n  \
    \      bin_map[bin_len] = append(bin_map[bin_len], val)\n    }\n    // current\
    \ index in resulting array\n    cur_ind := 0\n    for bin_len := 1; bin_len <=\
    \ max_bin; bin_len++ {\n        for _, val := range bin_map[bin_len] {\n     \
    \       arr[cur_ind] = val\n            cur_ind++\n        }\n    }\n    return\
    \ arr\n}\n", "    if len(arr) == 0 {\n        return arr\n    }\n    if len(arr)\
    \ == 1 {\n        return arr\n    }\n    var count int\n    var oneCount int\n\
    \    for i := 0; i < len(arr); i++ {\n        for j := 0; j < len(arr); j++ {\n\
    \            if arr[i] > arr[j] {\n                count++\n            }\n  \
    \      }\n        arr[count] = arr[i]\n        count = 0\n    }\n    return arr\n\
    }\n", "    for i := 0; i < len(arr); i++ {\n        for j := i + 1; j < len(arr);\
    \ j++ {\n            if arr[i] < 0 && arr[j] < 0 {\n                if -arr[i]\
    \ < -arr[j] {\n                    arr[i], arr[j] = arr[j], arr[i]\n         \
    \       }\n            } else if arr[i] > 0 && arr[j] > 0 {\n                if\
    \ ones(arr[i]) > ones(arr[j]) {\n                    arr[i], arr[j] = arr[j],\
    \ arr[i]\n                } else if ones(arr[i]) == ones(arr[j]) {\n         \
    \           if arr[i] > arr[j] {\n                        arr[i], arr[j] = arr[j],\
    \ arr[i]\n                    }\n                }\n            } else if arr[i]\
    \ > 0 && arr[j] < 0 {\n                arr[i], arr[j] = arr[j], arr[i]\n     \
    \       }\n        }\n    }\n    return arr\n}\n", "    // count number of 1 in\
    \ binary\n    // calculate decimal value\n    // sort as required\n    map1 :=\
    \ make(map[int]int)\n    for i, v := range arr {\n        b := fmt.Sprintf(\"\
    %b\", v)\n        n := 0\n        for _, c := range b {\n            if c == '1'\
    \ {\n                n++\n            }\n        }\n        // fmt.Println(n,\
    \ v)\n        map1[i] = n\n    }\n    fmt.Println(map1)\n    return arr\n}\n",
  "    return bubbleSort(arr)\n}\n", "    length := len(arr)\n    if length <= 1 {\n\
    \        return arr\n    }\n    // \u5FEB\u901F\u6392\u5E8F, \u9009\u62E9\u4E00\
    \u4E2A\u57FA\u51C6, \u4ECE\u4E24\u8FB9\u904D\u5386, \u5C0F\u4E8E\u57FA\u51C6\u653E\
    \u5DE6\u8FB9, \u5927\u4E8E\u57FA\u51C6\u653E\u53F3\u8FB9\n    var leftArr []int\n\
    \    var rightArr []int\n    middleArr := []int{arr[0]}\n    for _, v := range\
    \ arr[1:] {\n        if v > arr[0] {\n            rightArr = append(rightArr,\
    \ v)\n        } else if v < arr[0] {\n            leftArr = append(leftArr, v)\n\
    \        } else {\n            middleArr = append(middleArr, v)\n        }\n \
    \   }\n    leftArr = sort_array(leftArr)\n    rightArr = sort_array(rightArr)\n\
    \    return append(append(leftArr, middleArr...), rightArr...)\n}\n", "    sort_func\
    \ := func(i, j int) bool {\n        // NOTE: there's no way to do something like\
    \ 1<<31 without overflow\n        if arr[i] < 0 {\n            return false\n\
    \        } else if arr[j] < 0 {\n            return true\n        }\n        bi\
    \ := arr[i]\n        bj := arr[j]\n        for {\n            if bi == 0 {\n \
    \               return bj == 0\n            } else if bj == 0 {\n            \
    \    return false\n            }\n            bi &= bi - 1\n            bj &=\
    \ bj - 1\n        }\n    }\n    less := func(i, j int) bool {\n        if sort_func(i,\
    \ j) {\n            return true\n        } else if sort_func(j, i) {\n       \
    \     return false\n        }\n        return arr[i] < arr[j]\n    }\n    sort(arr,\
    \ less)\n    return arr\n}\n", "\tvar r = []int{}\n\tfor _, v := range arr {\n\
    \t\tr = append(r, v)\n\t}\n\tfor i := 0; i < len(r); i++ {\n\t\tfor j := i + 1;\
    \ j < len(r); j++ {\n\t\t\tvar b1 = numOfOne(r[i])\n\t\t\tvar b2 = numOfOne(r[j])\n\
    \t\t\tif b1 == b2 {\n\t\t\t\tif r[i] > r[j] {\n\t\t\t\t\tr[i], r[j] = r[j], r[i]\n\
    \t\t\t\t}\n\t\t\t} else if b1 > b2 {\n\t\t\t\tr[i], r[j] = r[j], r[i]\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn r\n}\n", "    for i := 0; i < len(arr); i++ {\n      \
    \  for j := 0; j < len(arr)-1; j++ {\n            if ones[arr[j]] > ones[arr[j+1]]\
    \ {\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n            } else if\
    \ ones[arr[j]] == ones[arr[j+1]] && arr[j] > arr[j+1] {\n                arr[j],\
    \ arr[j+1] = arr[j+1], arr[j]\n            }\n        }\n    }\n    return arr\n\
    }\n\nvar ones = map[int]int{}\n", "    var pos []int\n    var neg []int\n    var\
    \ res []int\n    for _, i := range arr {\n        if i >= 0 {\n            pos\
    \ = append(pos, i)\n        } else {\n            neg = append(neg, i)\n     \
    \   }\n    }\n    sort(pos)\n    sort(neg)\n    for i := len(neg) - 1; i >= 0;\
    \ i-- {\n        res = append(res, neg[i])\n    }\n    for _, i := range pos {\n\
    \        res = append(res, i)\n    }\n    return res\n}\n", "    // Initialise\
    \ array to store number of binary 1's for each input.\n    binaryArr := make([]int,\
    \ len(arr))\n    // Count binary 1's for each input and store result in binaryArr.\n\
    \    for i, v := range arr {\n        for v > 0 {\n            if v % 2 == 1 {\n\
    \                binaryArr[i]++\n            }\n            v /= 2\n        }\n\
    \    }\n    // Sort array according to rule.\n    for i := 0; i < len(arr); i++\
    \ {\n        for j := i + 1; j < len(arr); j++ {\n            if binaryArr[i]\
    \ < binaryArr[j] {\n                arr[i], arr[j] = arr[j], arr[i]\n        \
    \        binaryArr[i], binaryArr[j] = binaryArr[j], binaryArr[i]\n           \
    \ } else if binaryArr[i] == binaryArr[j] && arr[i] > arr[j] {\n              \
    \  arr[i], arr[j] = arr[j], arr[i]\n            }\n        }\n    }\n    return\
    \ arr\n}\n", "    arrLen := len(arr)\n    for i := 0; i < arrLen; i++ {\n    \
    \    for j := i + 1; j < arrLen; j++ {\n            // x >> n, n >= 0\n      \
    \      // Shifts x right by n bits.\n            // Shifting by a negative number\
    \ is undefined.\n            // Shifting by any amount greater than or equal to\
    \ the width of the\n            // type is also undefined.\n            if arr[i]>>1\
    \ == arr[j]>>1 {\n                if arr[i] > arr[j] {\n                    arr[i],\
    \ arr[j] = arr[j], arr[i]\n                }\n            } else if arr[i]>>1\
    \ < arr[j]>>1 {\n                arr[i], arr[j] = arr[j], arr[i]\n           \
    \ }\n        }\n    }\n    return arr\n}\n", "    intBinaryReps := make(map[int]string)\n\
    \    intCountOnes := make(map[int]int)\n    sortedInts := make([]int, len(arr))\n\
    \    var count int\n    for _, a := range arr {\n        intBinaryReps[a] = fmt.Sprintf(\"\
    %b\", a)\n        count = 0\n        for _, c := range intBinaryReps[a] {\n  \
    \          if c == '1' {\n                count++\n            }\n        }\n\
    \        intCountOnes[a] = count\n    }\n    sortInts := make([]int, len(arr))\n\
    \    for i, _ := range arr {\n        sortInts[i] = arr[i]\n    }\n    sortInts\
    \ = quickSort(sortInts, func(i, j int) bool {\n        if intCountOnes[sortInts[i]]\
    \ == intCountOnes[sortInts[j]] {\n            return sortInts[i] < sortInts[j]\n\
    \        }\n        return intCountOnes[sortInts[i]] < intCountOnes[sortInts[j]]\n\
    \    })\n    for i, a := range sortInts {\n        sortedInts[i] = a\n    }\n\
    \    return sortedInts\n}\n", "    return make([]int, 1)\n}\n", "    n := len(arr)\n\
    \    result := make([]int, n)\n    if n == 0 {\n        return result\n    }\n\
    \    bit := make([]int, 0)\n    tmp := make([]int, 0)\n    for i := 0; i < n;\
    \ i++ {\n        if arr[i] < 0 {\n            result[i] = arr[i]\n           \
    \ continue\n        }\n        ones := get_ones(arr[i])\n        bit = append(bit,\
    \ ones)\n        tmp = append(tmp, arr[i])\n    }\n    fmt.Println(bit)\n    fmt.Println(tmp)\n\
    \    sort(bit, tmp)\n    for i := 0; i < n; i++ {\n        if result[i] < 0 {\n\
    \            continue\n        }\n        result[i] = tmp[0]\n        tmp = tmp[1:]\n\
    \    }\n    return result\n}\n", "    var oneCount func(n int) int\n    oneCount\
    \ = func(n int) int {\n        if n == 0 {\n            return 0\n        }\n\
    \        return oneCount(n >> 1) + (n & 1)\n    }\n    for i := 0; i < len(arr);\
    \ i++ {\n        for j := i + 1; j < len(arr); j++ {\n            if (oneCount(arr[i])\
    \ > oneCount(arr[j])) ||\n            (oneCount(arr[i]) == oneCount(arr[j]) &&\
    \ arr[i] > arr[j]) {\n                arr[i], arr[j] = arr[j], arr[i]\n      \
    \      }\n        }\n    }\n    return arr\n}\n", "    if len(arr) == 0 {\n  \
    \      return arr\n    }\n    if len(arr) == 1 {\n        return arr\n    }\n\
    \    for i := 0; i < len(arr); i++ {\n        for j := i + 1; j < len(arr); j++\
    \ {\n            binary_1 := fmt.Sprintf(\"%b\", arr[i])\n            binary_2\
    \ := fmt.Sprintf(\"%b\", arr[j])\n            sum_1 := 0\n            sum_2 :=\
    \ 0\n            for _, v := range binary_1 {\n                if string(v) ==\
    \ \"1\" {\n                    sum_1 += 1\n                }\n            }\n\
    \            for _, v := range binary_2 {\n                if string(v) == \"\
    1\" {\n                    sum_2 += 1\n                }\n            }\n    \
    \        if sum_1 > sum_2 {\n                temp := arr[i]\n                arr[i]\
    \ = arr[j]\n                arr[j] = temp\n            } else if sum_1 == sum_2\
    \ {\n                if arr[i] > arr[j] {\n                    temp := arr[i]\n\
    \                    arr[i] = arr[j]\n                    arr[j] = temp\n    \
    \            }\n            }\n        }\n    }\n    return arr\n}\n", "    if\
    \ len(arr) <= 1 {\n        return arr\n    }\n    left, right := []int{}, []int{}\n\
    \    for i := 1; i < len(arr); i++ {\n        if get_ones(arr[i]) < get_ones(arr[0])\
    \ {\n            left = append(left, arr[i])\n        } else if get_ones(arr[i])\
    \ > get_ones(arr[0]) {\n            right = append(right, arr[i])\n        } else\
    \ {\n            if arr[i] < arr[0] {\n                left = append(left, arr[i])\n\
    \            } else {\n                right = append(right, arr[i])\n       \
    \     }\n        }\n    }\n    return append(append(sort_array(left), arr[0]),\
    \ sort_array(right)...)\n}\n", "    // \u4ECE\u4E8C\u8FDB\u5236\u770B\u6765\u662F\
    \u6309\u71671\u7684\u4E2A\u6570\u5347\u5E8F\u6392\u5E8F\uFF0C\n    // \u5728\u4E2A\
    \u6570\u76F8\u540C\u7684\u524D\u63D0\u4E0B\u6309\u7167\u5341\u8FDB\u5236\u987A\
    \u5E8F\u6392\u5E8F\n    // \u89E3\u6CD51\uFF1A\n    // \u4F7F\u7528map\u7EDF\u8BA1\
    \u6BCF\u4E2A\u6570\u5B571\u7684\u4E2A\u6570\uFF0C\u7136\u540Esort\uFF0C\n    //\
    \ \u7136\u540E\u6839\u636Emap\u987A\u5E8F\u8FD4\u56DE\u6570\u7EC4\u5143\u7D20\n\
    \    //\n    // \u89E3\u6CD52\uFF1A\n    // \u904D\u5386arr\uFF0C\u628A1\u7684\
    \u4E2A\u6570\u653E\u5165\u5230map\uFF0C\u7136\u540E\u6309\u71671\u7684\u4E2A\u6570\
    \u6392\u5E8F\n    // \u540C\u65F6\u4ECEarr\u4E2D\u5220\u9664\u5DF2\u7ECF\u6392\
    \u5E8F\u7684\u5143\u7D20\uFF0C\u7136\u540E\u8FD4\u56DE\n    //\n    // \u89E3\u6CD5\
    3\uFF1A\n    // \u904D\u5386arr\uFF0C\u628A1\u7684\u4E2A\u6570\u653E\u5165\u5230\
    map\uFF0C\u7136\u540E\u6309\u71671\u7684\u4E2A\u6570\u6392\u5E8F\n    // \u540C\
    \u65F6\u4ECEarr\u4E2D\u5220\u9664\u5DF2\u7ECF\u6392\u5E8F\u7684\u5143\u7D20\uFF0C\
    \u7136\u540E\u8FD4\u56DE\n    //\n    // \u89E3\u6CD54\uFF1A\n    // \u5BF9arr\u6392\
    \u5E8F\uFF0C\u5206\u522B\u8BA1\u7B970-max\uFF0C\u6BCF\u4E2A\u6570\u5B571\u7684\
    \u4E2A\u6570\n    // \u904D\u5386arr\uFF0C\u6839\u636E\u6BCF\u4E2A\u6570\u5B57\
    1\u7684\u4E2A\u6570\u8FDB\u884C\u6392\u5E8F\n    //\n    // \u89E3\u6CD55\uFF1A\
    \n", "    // your code here\n    return arr\n}\n", "    var ones []int\n    var\
    \ zeros []int\n    for _, v := range arr {\n        if v < 0 {\n            return\
    \ []int{}\n        }\n        if v == 0 {\n            zeros = append(zeros, v)\n\
    \        } else {\n            ones = append(ones, v)\n        }\n    }\n    if\
    \ len(ones) == 0 {\n        return zeros\n    } else if len(zeros) == 0 {\n  \
    \      return sortOnes(ones)\n    } else {\n        return append(sortOnes(ones),\
    \ zeros...)\n    }\n}\n", "    fmt.Println(arr)\n    return arr\n}\n", "    if\
    \ len(arr) == 0 {\n        return arr\n    }\n    binaryArray := make([]BinaryNumber,\
    \ len(arr))\n    for i, v := range arr {\n        binaryArray[i] = BinaryNumber{Number:\
    \ v, Binary: fmt.Sprintf(\"%b\", v)}\n    }\n    quickSort(binaryArray, 0, len(binaryArray)-1)\n\
    \    for i, v := range binaryArray {\n        arr[i] = v.Number\n    }\n    return\
    \ arr\n}\n\ntype BinaryNumber ", "    var one_count = make(map[int]int)\n    var\
    \ result = make([]int, len(arr))\n    var count int\n    for _, v := range arr\
    \ {\n        count = count_ones(v)\n        one_count[v] = count\n    }\n    sort_map(one_count)\n\
    \    count = 0\n    for k, _ := range one_count {\n        result[count] = k\n\
    \        count++\n    }\n    return result\n}\n", "    ones := make(map[int]int)\n\
    \    for _, v := range arr {\n        n := count_ones(v)\n        if v >= 0 {\n\
    \            ones[n] = append(ones[n], v)\n        } else {\n            ones[n]\
    \ = append(ones[n], -v)\n        }\n    }\n    fmt.Println(ones)\n    return nil\n\
    }\n", "    // your code here...\n    var m = make(map[int]int)\n    var ret []int\n\
    \    for _, v := range arr {\n        if v > 0 {\n            m[v] = CountBit(v)\n\
    \        } else {\n            ret = append(ret, v)\n        }\n    }\n    for\
    \ len(m) > 0 {\n        var tmp = make(map[int]int)\n        for _, v := range\
    \ m {\n            tmp[v] = v\n        }\n        for k, _ := range tmp {\n  \
    \          var t = make([]int, 0)\n            for kk, vv := range m {\n     \
    \           if vv == k {\n                    t = append(t, kk)\n            \
    \    }\n            }\n            if len(t) > 1 {\n                insertSort(t)\n\
    \            }\n            for _, v := range t {\n                ret = append(ret,\
    \ v)\n                delete(m, v)\n            }\n        }\n    }\n    return\
    \ ret\n}\n", "    n := make([]int, len(arr))\n    copy(n, arr)\n    qsort(n, 0,\
    \ len(n)-1)\n    return n\n}\n", "    var a []int\n    return a\n}\n", "    var\
    \ most_ones int = -1\n    for _, val := range arr {\n        if val >= 0 {\n \
    \           binary := fmt.Sprintf(\"%b\", val)\n            ones := 0\n      \
    \      for _, b := range binary {\n                if b == '1' {\n           \
    \         ones++\n                }\n            }\n            if ones > most_ones\
    \ {\n                most_ones = ones\n            }\n        }\n    }\n    for\
    \ i := 0; i < most_ones + 1; i++ {\n        for j := 0; j < len(arr); j++ {\n\
    \            val := arr[j]\n            if val >= 0 {\n                binary\
    \ := fmt.Sprintf(\"%b\", val)\n                ones := 0\n                for\
    \ _, b := range binary {\n                    if b == '1' {\n                \
    \        ones++\n                    }\n                }\n                if\
    \ ones == i {\n                    fmt.Println(val)\n                }\n     \
    \       }\n        }\n    }\n    return []int{}\n}\n", "    for i := 0; i < len(arr);\
    \ i++ {\n        for j := i + 1; j < len(arr); j++ {\n            if nth_digit(arr[i],\
    \ 0) < nth_digit(arr[j], 0) {\n                arr[i], arr[j] = arr[j], arr[i]\n\
    \            }\n        }\n    }\n    return arr\n}\n", "    // 1. count the number\
    \ of ones for each int\n    // 2. sort based on number of ones in ascending order\n\
    \    // 2.5 if there is a tie, sort based on decimal value\n    // 3. return sorted\
    \ array\n\n    return arr\n}\n", "    onesCounts := make(map[int]int)\n    for\
    \ _, v := range arr {\n        onesCounts[v] = countOnes(v)\n    }\n    return\
    \ sortArray(arr, onesCounts)\n}\n", "    sort(arr, 0, len(arr) - 1)\n    return\
    \ arr\n}\n", "    return arr\n}\n", "    sort.Slice(arr, func(i, j int) bool {\n\
    \        if countOnes(arr[i]) < countOnes(arr[j]) {\n            return true\n\
    \        } else if countOnes(arr[i]) > countOnes(arr[j]) {\n            return\
    \ false\n        } else {\n            return arr[i] < arr[j]\n        }\n   \
    \ })\n    return arr\n}\n", "    if arr == nil || len(arr) == 0 {\n        return\
    \ arr\n    }\n    var max, min int\n    max = arr[0]\n    min = arr[0]\n    for\
    \ _, v := range arr {\n        if v > max {\n            max = v\n        }\n\
    \        if v < min {\n            min = v\n        }\n    }\n    maxLen := 0\n\
    \    for i := 0; i < len(arr); i++ {\n        temp := arr[i]\n        tempLen\
    \ := 0\n        for temp != 0 {\n            temp = temp / 2\n            tempLen++\n\
    \        }\n        if tempLen > maxLen {\n            maxLen = tempLen\n    \
    \    }\n    }\n    var bitArr [][]int\n    for i := 0; i < maxLen; i++ {\n   \
    \     bitArr = append(bitArr, []int{})\n    }\n    for i := 0; i < len(arr); i++\
    \ {\n        temp := arr[i]\n        tempLen := 0\n        for temp != 0 {\n \
    \           bitArr[tempLen] = append(bitArr[tempLen], arr[i])\n            temp\
    \ = temp / 2\n            tempLen++\n        }\n    }\n    var result []int\n\
    \    for i := 0; i < len(bitArr); i++ {\n        temp := bitArr[i]\n        for\
    \ j := 0; j < len(temp); j++ {\n            result = append(result, temp[j])\n\
    \        }\n    }\n    return result\n}\n", "    return arr\n}\n", '    // Definition
    of ', "    var ones [][]int\n    for _, v := range arr {\n        num := v\n \
    \       oneCnt := 0\n        for num > 0 {\n            if num%2 != 0 {\n    \
    \            oneCnt++\n            }\n            num = num/2\n        }\n   \
    \     ones = append(ones, []int{oneCnt, v})\n    }\n    for i := 0; i < len(ones);\
    \ i++ {\n        for j := i; j < len(ones); j++ {\n            if ones[i][0] >\
    \ ones[j][0] {\n                ones[i], ones[j] = ones[j], ones[i]\n        \
    \    } else if ones[i][0] == ones[j][0] && ones[i][1] > ones[j][1] {\n       \
    \         ones[i], ones[j] = ones[j], ones[i]\n            }\n        }\n    }\n\
    \    var ans []int\n    for _, v := range ones {\n        ans = append(ans, v[1])\n\
    \    }\n    return ans\n}\n\ntype TestCase ", "    var ints []int\n    var onesMap\
    \ map[int]int = make(map[int]int)\n    var sortMap map[int]int = make(map[int]int)\n\
    \    var outArr []int\n\n    // calculate the number of ones\n    for _, i :=\
    \ range arr {\n        if i > 0 {\n            ones := ones(i)\n            onesMap[i]\
    \ = ones\n            sortMap[ones] = i\n        } else {\n            ints =\
    \ append(ints, i)\n        }\n    }\n\n    // sort the array\n    for i := 0;\
    \ i < len(arr); i++ {\n        if i == 0 {\n            outArr = append(outArr,\
    \ sortMap[onesMap[arr[i]]])\n        } else {\n            outArr = append(outArr,\
    \ sortMap[onesMap[arr[i]]])\n        }\n    }\n\n    return append(outArr, ints...)\n\
    }\n", "    var count_ones_mapping = make(map[int]int)\n    var zero_values_mapping\
    \ = make(map[int]int)\n    var sorted_arr = make([]int, len(arr))\n    var i =\
    \ 0\n    for _, val := range arr {\n        if val == 0 {\n            zero_values_mapping[i]\
    \ = val\n        } else {\n            for val != 0 {\n                count_ones_mapping[i]\
    \ += val & 1\n                val >>= 1\n            }\n        }\n        i++\n\
    \    }\n    // fmt.Println(count_ones_mapping)\n    var j = 0\n    for index,\
    \ ones := range count_ones_mapping {\n        if j < len(arr) {\n            sorted_arr[j]\
    \ = arr[index]\n            j++\n        }\n        if j < len(arr) {\n      \
    \      sorted_arr[j] = ones\n            j++\n        }\n    }\n    fmt.Println(sorted_arr)\n\
    \    fmt.Println(zero_values_mapping)\n    return sorted_arr\n}\n", "    for i\
    \ := 0; i < len(arr); i++ {\n        for j := i; j < len(arr); j++ {\n       \
    \     if ones_number(arr[i]) > ones_number(arr[j]) {\n                arr[i],\
    \ arr[j] = arr[j], arr[i]\n            } else if ones_number(arr[i]) == ones_number(arr[j])\
    \ {\n                if arr[i] > arr[j] {\n                    arr[i], arr[j]\
    \ = arr[j], arr[i]\n                }\n            }\n        }\n    }\n    return\
    \ arr\n}\n", "    m := make(map[int]int)\n    var res []int\n    for _, v := range\
    \ arr {\n        if v > 0 {\n            m[v] = countOne(v)\n        } else {\n\
    \            res = append(res, v)\n        }\n    }\n    arr = sort(m)\n    return\
    \ append(res, arr...)\n}\n", "    if len(arr) <= 1 {\n        return arr\n   \
    \ }\n    length := len(arr)\n    arr1 := make([]int, length/2)\n    arr2 := make([]int,\
    \ length - length/2)\n    copy(arr1, arr[:length/2])\n    copy(arr2, arr[length/2:])\n\
    \    arr1 = sort_array(arr1)\n    arr2 = sort_array(arr2)\n    i := 0\n    j :=\
    \ 0\n    k := 0\n    for i < len(arr1) && j < len(arr2) {\n        if count_one(arr1[i])\
    \ < count_one(arr2[j]) {\n            arr[k] = arr1[i]\n            i++\n    \
    \    } else if count_one(arr1[i]) > count_one(arr2[j]) {\n            arr[k] =\
    \ arr2[j]\n            j++\n        } else {\n            if arr1[i] < arr2[j]\
    \ {\n                arr[k] = arr1[i]\n                i++\n            } else\
    \ {\n                arr[k] = arr2[j]\n                j++\n            }\n  \
    \      }\n        k++\n    }\n    for i < len(arr1) {\n        arr[k] = arr1[i]\n\
    \        i++\n        k++\n    }\n    for j < len(arr2) {\n        arr[k] = arr2[j]\n\
    \        j++\n        k++\n    }\n    return arr\n}\n", "    var output []int\n\
    \    var one_and_two_and_three []int\n    var four_and_five []int\n    var six_and_seven\
    \ []int\n    var eight_and_nine []int\n    var ten_and_eleven []int\n    var twelve_and_thirteen\
    \ []int\n    var fourteen_and_fifteen []int\n    var sixteen_and_seventeen []int\n\
    \    var eighteen_and_nineteen []int\n    var twenty_and_twentyone []int\n   \
    \ var twentytwo_and_twentythree []int\n    var twentyfour_and_twentyfive []int\n\
    \    var twentysix_and_twentyseven []int\n    var twentyeight_and_twentynine []int\n\
    \    var thirty_and_thirtyone []int\n    var thirtytwo_and_thirtythree []int\n\
    \    var thirtyfour_and_thirtyfive []int\n    var thirtysix_and_thirtyseven []int\n\
    \    var thirtyeight_and_thirtynine []int\n    var forty_and_fortyone []int\n\
    \    var fortytwo_and_fortythree []int\n    var fortyfour_and_fortyfive []int\n\
    \    var fortysix_and_fortyseven []int\n    var fortyeight_and_fortynine []int\n\
    \    var fifty_and_fiftyone []int\n    var fiftytwo_and_fiftythree []int\n   \
    \ var fiftyfour_and_fiftyfive []int\n    var fiftysix_and_fiftyseven []int\n \
    \   var fiftyeight_and_fiftynine []int\n    var sixty_and_sixtyone []int\n   \
    \ var sixtytwo_and_sixtythree []int\n    var sixtyfour_and_sixtyfive []int\n \
    \   var sixtysix_and_sixtyseven []int\n    var sixtyeight_and_sixtynine []int\n\
    \    var seventy_and_seventyone []int\n    var seventytwo_and_seventythree []int\n\
    \    var seventyfour_and_seventyfive []int\n    var seventysix_and_seventyseven\
    \ []int\n    var seventyeight_and_seventynine []int\n    var eighty_and_", " \
    \   for i := 0; i < len(arr); i++ {\n        for j := 0; j < len(arr); j++ {\n\
    \            if cmp(arr[i], arr[j]) < 0 {\n                arr[i], arr[j] = arr[j],\
    \ arr[i]\n            }\n        }\n    }\n    return arr\n}\n", "    // your\
    \ code here\n    return arr\n}\n", "    return arr\n}\n", "    if len(arr) <=\
    \ 1 {\n        return arr\n    }\n    if len(arr) == 2 {\n        if arr[0] >\
    \ arr[1] {\n            arr[0], arr[1] = arr[1], arr[0]\n        }\n        return\
    \ arr\n    }\n    var (\n        pivot = arr[0]\n        left = 0\n        right\
    \ = len(arr) - 1\n    )\n    for ; left < right; {\n        for ; arr[right] >=\
    \ pivot && left < right; right-- { }\n        for ; arr[left] <= pivot && left\
    \ < right; left++ { }\n        if left < right {\n            arr[left], arr[right]\
    \ = arr[right], arr[left]\n        }\n    }\n    arr[0], arr[left] = arr[left],\
    \ arr[0]\n    sort_array(arr[:left])\n    sort_array(arr[left+1:])\n    return\
    \ arr\n}\n", "    return arr\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
