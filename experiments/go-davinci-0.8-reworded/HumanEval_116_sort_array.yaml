name: HumanEval_116_sort_array
language: go_test.go
prompt: "package sort_array_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // In this Kata, you have to sort a list of non-negative integers according to\n\
  // number of ones in their binary representation in ascending order.\n// For similar\
  \ number of ones, sort based on decimal value.\n// It must be implemented like this:\n\
  // >>> sort_array([]int{1, 5, 2, 3, 4})\n// []int{1, 2, 3, 4, 5}\n// >>> sort_array([]int{-2,\
  \ -3, -4, -5, -6})\n// []int{-6, -5, -4, -3, -2}\n// >>> sort_array([]int{1, 0,\
  \ 2, 3, 4})\n// []int{0, 1, 2, 3, 4}\nfunc sort_array(arr []int) []int {\n"
tests: "func TestSort_Array(t *testing.T) {\n  candidate := sort_array\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate([]int{1, 5, 2, 3, 4}), expected: []int{1, 2,\
  \ 4, 3, 5} },\n     { actual: candidate([]int{-2, -3, -4, -5, -6}), expected: []int{-4,\
  \ -2, -6, -5, -3} },\n     { actual: candidate([]int{1, 0, 2, 3, 4}), expected:\
  \ []int{0, 1, 2, 4, 3} },\n     { actual: candidate([]int{}), expected: []int{}\
  \ },\n     { actual: candidate([]int{2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}), expected:\
  \ []int{2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77} },\n     { actual: candidate([]int{3,\
  \ 6, 44, 12, 32, 5}), expected: []int{32, 3, 5, 6, 12, 44} },\n     { actual: candidate([]int{2,\
  \ 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },\n     { actual: candidate([]int{2,\
  \ 4, 8, 16, 32}), expected: []int{2, 4, 8, 16, 32} },\n   }\n\n\tfor i, tc := range\
  \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\
  \tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
  \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    // sort by negative numbers\n    for i := 0; i < len(arr); i++\
    \ {\n        for j := 0; j < len(arr); j++ {\n            if arr[i] < 0 && arr[j]\
    \ < 0 {\n                if arr[i] > arr[j] {\n                    arr[i], arr[j]\
    \ = arr[j], arr[i]\n                }\n            }\n        }\n    }\n    fmt.Println(arr)\n\
    \    // sort by positive numbers\n    for i := 0; i < len(arr); i++ {\n      \
    \  for j := 0; j < len(arr); j++ {\n            if arr[i] >= 0 && arr[j] >= 0\
    \ {\n                iCount := numberOfOnes(uint32(arr[i]))\n                jCount\
    \ := numberOfOnes(uint32(arr[j]))\n                if iCount == jCount {\n   \
    \                 if arr[i] < arr[j] {\n                        arr[i], arr[j]\
    \ = arr[j], arr[i]\n                    }\n                } else if iCount <\
    \ jCount {\n                    arr[i], arr[j] = arr[j], arr[i]\n            \
    \    }\n            }\n        }\n    }\n    return arr\n}\n", "    n := len(arr)\n\
    \    if n < 2 {\n        return arr\n    }\n    // merge sort\n    q := n / 2\n\
    \    arr1 := sort_array(arr[:q])\n    arr2 := sort_array(arr[q:])\n    res :=\
    \ make([]int, n)\n    i := 0\n    j := 0\n    for i < len(arr1) && j < len(arr2)\
    \ {\n        if comp(arr1[i], arr2[j]) {\n            res[i+j] = arr1[i]\n   \
    \         i++\n        } else {\n            res[i+j] = arr2[j]\n            j++\n\
    \        }\n    }\n    for i < len(arr1) {\n        res[i+j] = arr1[i]\n     \
    \   i++\n    }\n    for j < len(arr2) {\n        res[i+j] = arr2[j]\n        j++\n\
    \    }\n    return res\n}\n", "    if len(arr) <= 1 {\n        return arr\n  \
    \  }\n    p := arr[0]\n    left := make([]int, 0)\n    right := make([]int, 0)\n\
    \    for _, v := range arr[1:] {\n        if v < p {\n            left = append(left,\
    \ v)\n        } else {\n            right = append(right, v)\n        }\n    }\n\
    \    return append(sort_array(left), append([]int{p}, sort_array(right)...)...)\n\
    }\n", "    // TODO: Implement your solution here\n    return arr\n}\n", "    //\
    \ your code here\n    return []int{}\n}\n", "    if len(arr) <= 1 {\n        return\
    \ arr\n    }\n    // for i := 0; i < len(arr); i++ {\n    //     for j := i +\
    \ 1; j < len(arr); j++ {\n    //         if arr[i] > arr[j] {\n    //        \
    \     arr[i], arr[j] = arr[j], arr[i]\n    //         }\n    //     }\n    //\
    \ }\n    // return arr\n    quicksort(arr, 0, len(arr) - 1)\n    return arr\n\
    }\n", "    fmt.Println(arr)\n    return []int{}\n}\n", "    // your code here\n\
    \    return arr\n}\n", "    len := len(arr)\n    for i := 0; i < len; i++ {\n\
    \        for j := i; j < len; j++ {\n            if binary_ones(arr[i]) > binary_ones(arr[j])\
    \ {\n                arr[i], arr[j] = arr[j], arr[i]\n            } else if binary_ones(arr[i])\
    \ == binary_ones(arr[j]) {\n                if arr[i] > arr[j] {\n           \
    \         arr[i], arr[j] = arr[j], arr[i]\n                }\n            }\n\
    \        }\n    }\n    return arr\n}\n", "    if len(arr) <= 1 {\n        return\
    \ arr\n    }\n    ones := make(map[int]int)\n    for _, v := range arr {\n   \
    \     ones[v] = countOnes(v)\n    }\n    for i := 0; i < len(arr); i++ {\n   \
    \     for j := 0; j < len(arr) - 1; j++ {\n            if ones[arr[j]] > ones[arr[j\
    \ + 1]] {\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n         \
    \   } else if ones[arr[j]] == ones[arr[j + 1]] && arr[j] > arr[j + 1] {\n    \
    \            arr[j], arr[j + 1] = arr[j + 1], arr[j]\n            }\n        }\n\
    \    }\n    return arr\n}\n", "    if arr == nil || len(arr) < 2 {\n        return\
    \ arr\n    }\n    nums := make([]int, len(arr))\n    copy(nums, arr)\n    return\
    \ merge_sort(nums)\n}\n", "    // keep track of total ones count for all numbers\n\
    \    onesCount := make(map[int]int)\n    for _, i := range arr {\n        fmt.Println(i)\n\
    \        // set these bits to 1, if they are already set to 1, then they will\
    \ still be 1\n        i = i | i >> 1\n        i = i | i >> 2\n        i = i |\
    \ i >> 4\n        i = i | i >> 8\n        i = i | i >> 16\n        onesCount[i]\
    \ += 1\n    }\n    // count how many numbers are smaller than the current number\
    \ of ones\n    cumSum := make(map[int]int)\n    var count int\n    for i := range\
    \ onesCount {\n        cumSum[i] = count\n        count += onesCount[i]\n    }\n\
    \    for i := range arr {\n        ones := arr[i] | arr[i] >> 1\n        ones\
    \ = ones | ones >> 2\n        ones = ones | ones >> 4\n        ones = ones | ones\
    \ >> 8\n        ones = ones | ones >> 16\n        arr[cumSum[ones]] = arr[i]\n\
    \        cumSum[ones] += 1\n    }\n    return arr\n}\n", "    // Sort array by\
    \ number of 1s\n    sortArrayByOnes(arr)\n    // Find the largest positive number\n\
    \    largestPositive := arr[len(arr)-1]\n    // If largest positive number is\
    \ negative, sort by value\n    if largestPositive < 0 {\n        sortArrayByValue(arr)\n\
    \    }\n    return arr\n}\n", "    var sortedArr []int\n    var sortedOnesArray,\
    \ sortedZerosArray []int\n    var zeros, ones int\n\n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr[i] < 0 {\n            sortedArr = append(sortedArr, arr[i])\n\
    \        } else {\n            if arr[i]%2 == 0 {\n                sortedZerosArray\
    \ = append(sortedZerosArray, arr[i])\n                zeros++\n            } else\
    \ {\n                sortedOnesArray = append(sortedOnesArray, arr[i])\n     \
    \           ones++\n            }\n        }\n    }\n\n    for i := 0; i < ones;\
    \ i++ {\n        sortedArr = append(sortedArr, sortedOnesArray[i])\n    }\n\n\
    \    for i := 0; i < zeros; i++ {\n        sortedArr = append(sortedArr, sortedZerosArray[i])\n\
    \    }\n\n    return sortedArr\n}\n", "    return sort(arr, -1)\n}\n", "    res\
    \ := []int{}\n    one := []int{}\n    zero := []int{}\n    for _, val := range\
    \ arr {\n        if count_ones(val) == 0 {\n            zero = append(zero, val)\n\
    \        } else {\n            one = append(one, val)\n        }\n    }\n    one\
    \ = quick_sort(one)\n    res = append(res, zero...)\n    res = append(res, one...)\n\
    \    return res\n}\n", "    var l = len(arr)\n    var i, j, k int\n    var bin\
    \ []int\n    var s []int\n    var idx int\n    var count []int\n    var onesCount\
    \ []int\n    var sorted bool\n\n    count = make([]int, l)\n    onesCount = make([]int,\
    \ l)\n    sorted = false\n\n    fmt.Println(\"len:\", l)\n    //\n    for i =\
    \ 0; i < l; i++ {\n        // fmt.Println(\"i:\", i)\n        if arr[i] == 0 {\n\
    \            count[i] = 0\n            continue\n        }\n        //\n     \
    \   bin = make([]int, 0)\n        for k = arr[i]; k > 0; k /= 2 {\n          \
    \  bin = append(bin, k % 2)\n        }\n        count[i] = 0\n        for j =\
    \ 0; j < len(bin); j++ {\n            if bin[j] == 1 {\n                count[i]++\n\
    \            }\n        }\n    }\n    fmt.Println(\"count:\", count)\n    //\n\
    \    // keep track of indexes of ones\n    for i = 0; i < l; i++ {\n        s\
    \ = append(s, i)\n    }\n    //\n    // keep track of ones\n    for i = 0; i <\
    \ l; i++ {\n        onesCount[i] = count[i]\n    }\n    //\n    // sort indexes\
    \ of ones\n    for i = 0; i < l-1; i++ {\n        for j = i + 1; j < l; j++ {\n\
    \            if onesCount[s[i]] > onesCount[s[j]] {\n                idx = s[i]\n\
    \                s[i] = s[j]\n                s[j] = idx\n            }\n    \
    \    }\n    }\n    fmt.Println(\"indexes:\", s)\n    //\n    // apply indexes\
    \ of ones to ones\n    for i = 0; i < l; i++ {\n        onesCount[i] = count[s[i]]\n\
    \    }\n    fmt.Println(\"ones:\", onesCount)\n    //\n    // sort ones\n", "\t\
    return arr\n}\n", "\tfmt.Println(arr)\n\t\n\treturn arr\n}\n", "    var result\
    \ []int\n    var ones_dict = make(map[int]int)\n    var zero_arr []int\n    var\
    \ ones_arr []int\n    for _, v := range arr {\n        if v < 0 {\n          \
    \  result = append(result, v)\n        } else {\n            var count_ones int\n\
    \            var abs_v = abs(v)\n            for abs_v > 0 {\n               \
    \ if abs_v % 2 == 1 {\n                    count_ones++\n                }\n \
    \               abs_v /= 2\n            }\n            ones_dict[v] = count_ones\n\
    \            if count_ones == 0 {\n                zero_arr = append(zero_arr,\
    \ v)\n            } else {\n                ones_arr = append(ones_arr, v)\n \
    \           }\n        }\n    }\n    sort.Ints(zero_arr)\n    sort.Ints(ones_arr)\n\
    \    for _, v := range zero_arr {\n        result = append(result, v)\n    }\n\
    \    for _, v := range ones_arr {\n        result = append(result, v)\n    }\n\
    \    return result\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
