name: HumanEval_99_closest_integer
language: go_test.go
prompt: "package closest_integer_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// Create a function that takes a value (string) representing a number\n//\
  \ and returns the closest integer to it. If the number is equidistant\n// from two\
  \ integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\"\
  )\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from\
  \ zero means that if the given number is equidistant\n// from two integers, the\
  \ one you should return is the one that is the\n// farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\nfunc closest_integer(value string) int {\n"
tests: "func TestClosest_Integer(t *testing.T) {\n  candidate := closest_integer\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"10\"), expected: 10 },\n     {\
  \ actual: candidate(\"14.5\"), expected: 15 },\n     { actual: candidate(\"-15.5\"\
  ), expected: -16 },\n     { actual: candidate(\"15.3\"), expected: 15 },\n     {\
  \ actual: candidate(\"0\"), expected: 0 },\n   }\n\n\tfor i, tc := range tests {\n\
  \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
  %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
  \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    sign := 1\n    if value[0] == '-' {\n        sign = -1\n      \
    \  value = value[1:]\n    }\n    s := \"\"\n    for _, v := range value {\n  \
    \      if v == '.' {\n            break\n        }\n        s += string(v)\n \
    \   }\n    v, _ := atoi(s)\n    i := v\n    s += \".\"\n    t := 0\n    for i\
    \ := len(s); i < len(value); i++ {\n        if value[i] == '.' {\n           \
    \ continue\n        }\n        t = t * 10 + int(value[i] - '0')\n    }\n    if\
    \ t >= 5 {\n        v += 1\n    }\n    return v * sign\n}\n", "    var num float64\
    \ = 0\n    fmt.Sscanf(value, \"%f\", &num)\n    return int(num + 0.5)\n}\n", " \
    \   return 0\n}\n", "    // create a function that takes a value (string) representing\
    \ a number\n    // and returns the closest integer to it.\n    // If the number\
    \ is equidistant from two integers, round it away from zero.\n    f, err := strconv.ParseFloat(value,\
    \ 64)\n    if err != nil {\n        fmt.Println(err)\n    }\n    // The round\
    \ package implements accurate roundings to the nearest integer\n    // and arbitrary\
    \ precision division.\n    return round.AwayFromZero(f)\n}\n", "    var result\
    \ float64\n    fmt.Sscanf(value, \"%f\", &result)\n    if result > 0 {\n     \
    \   if result - float64(int(result)) >= 0.5 {\n            return int(result)\
    \ + 1\n        } else {\n            return int(result)\n        }\n    } else\
    \ {\n        if float64(int(result)) - result >= 0.5 {\n            return int(result)\
    \ - 1\n        } else {\n            return int(result)\n        }\n    }\n}\n",
  "    return int(0)\n}\n", "    // Write the code here\n    return 0\n}\n", "   \
    \ // PENDING\n    return 0\n}\n", "    return 0\n}\n", "    var (\n        i float64\n\
    \        r int\n    )\n    fmt.Sscanf(value, \"%f\", &i)\n    if (i - float64(int(i)))\
    \ > 0.5 {\n        r = int(i) + 1\n    } else {\n        r = int(i)\n    }\n \
    \   return r\n}\n", "    var output int\n    var remainder float64\n\n    fmt.Sscanf(value,\
    \ \"%d.%f\", &output, &remainder)\n\n    if remainder > 0.5 {\n        output++\n\
    \    }\n\n    return output\n}\n", "    // find decimal place, if > 0 round up/down\
    \ based on number behind decimal\n    // if < 0 round up/down based on number\
    \ behind decimal\n    // if = 0 return the number\n    // split the number into\
    \ int and float parts\n    // iterate through string to find decimal point\n \
    \   // once found, convert each digit of float to int and add to float_sum\n \
    \   // if float_sum > 5 round up, if < 5 round down\n    if value[0] == 45 { //\
    \ if negative value\n        return (0 - closest_integer(value[1:]))\n    }\n\
    \    if value[0] == 43 { // if positive value\n        return closest_integer(value[1:])\n\
    \    }\n    var decimal int\n    decimal = 0\n    var decimal_len int\n    decimal_len\
    \ = 0\n    var int_sum int\n    int_sum = 0\n    var float_sum int\n    float_sum\
    \ = 0\n    var i int\n    i = 0\n    for i < len(value) {\n        if value[i]\
    \ == 46 {\n            decimal = i\n            break\n        }\n        i++\n\
    \    }\n    if decimal == 0 {\n        i = 0\n        for i < len(value) {\n \
    \           int_sum = int_sum * 10 + int(value[i]) - 48\n            i++\n   \
    \     }\n        return int_sum\n    }\n    decimal_len = len(value) - decimal\
    \ - 1\n    if decimal_len > 5 {\n        i = 0\n        for i < decimal {\n  \
    \          int_sum = int_sum * 10 + int(value[i]) - 48\n            i++\n    \
    \    }\n        return int_sum\n    }\n    i = decimal + 1\n    for i < len(value)\
    \ {\n        float_sum = float_sum * 10 + int(value[i]) - 48\n        i++\n  \
    \  }\n    if float_sum > 5000 {\n        i = 0\n        for i < decimal {\n  \
    \          int_sum = int_sum * 10 + int(value[i]) - 48\n            i++\n    \
    \    }\n        return int_sum + 1\n    }\n    i = 0\n    for i < decimal {\n\
    \        int_sum =", "    num, _ := strconv.ParseFloat(value, 64)\n    return\
    \ int(num + 0.5)\n}\n", "    // Converting string to int\n    // Need to use float64\
    \ to maintain floating point numbers\n    n, _ := strconv.ParseFloat(value, 64)\n\
    \    up := math.Ceil(n)\n    down := math.Floor(n)\n    if n - down >= up - n\
    \ {\n        return int(up)\n    }\n    return int(down)\n}\n", "\tf := 0.0\n\t\
    _, err := fmt.Sscanf(value, \"%f\", &f)\n\tif err != nil {\n\t\tpanic(err)\n\t\
    }\n\tif f < 0 {\n\t\tf = f - 0.5\n\t} else {\n\t\tf = f + 0.5\n\t}\n\treturn int(f)\n\
    }\n", "    return 0\n}\n", "    // Write your code here\n    return 0\n}\n", " \
    \   number, _ := strconv.ParseFloat(value, 64)\n    return int(number)\n}\n",
  "    return 0\n}\n", "    fvalue, _ := strconv.ParseFloat(value, 64)\n    return\
    \ int(math.Round(fvalue))\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
