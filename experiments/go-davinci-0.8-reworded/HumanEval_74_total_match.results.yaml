language: go_test.go
name: HumanEval_74_total_match
results:
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return total_match_v2(lst1, lst2)\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptfu8xqk3_test.go:23:12: undefined: total_match_v2

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074697
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n\tvar len1, len2 int = 0, 0\n\tfor _, v := range\
    \ lst1 {\n\t\tlen1 += len(v)\n\t}\n\tfor _, v := range lst2 {\n\t\tlen2 += len(v)\n\
    \t}\n\tif len1 > len2 {\n\t\treturn lst2\n\t}\n\treturn lst1\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074698
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n\ttotalLst1 := 0\n\ttotalLst2 := 0\n\tfor _, str\
    \ := range lst1 {\n\t\ttotalLst1 += len(str)\n\t}\n\tfor _, str := range lst2\
    \ {\n\t\ttotalLst2 += len(str)\n\t}\n\tif totalLst1 > totalLst2 {\n\t\treturn\
    \ lst2\n\t}\n\treturn lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074698
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    total1 := 0\n    total2 := 0\n    for _, v :=\
    \ range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        total2 += len(v)\n    }\n    if total1 > total2 {\n        return lst2\n\
    \    }\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074698
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var fTotal, sTotal int\n    for _, v := range\
    \ lst1 {\n        fTotal += len(v)\n    }\n    for _, v := range lst2 {\n    \
    \    sTotal += len(v)\n    }\n    if fTotal < sTotal {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpn1_7h8zs_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074698
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    total1 := 0\n    total2 := 0\n    for _, str\
    \ := range lst1 {\n        total1 += len(str)\n    }\n    for _, str := range\
    \ lst2 {\n        total2 += len(str)\n    }\n    if total1 <= total2 {\n     \
    \   return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074698
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Total := 0\n    lst2Total := 0\n    for _,\
    \ v := range lst1 {\n        lst1Total += len(v)\n    }\n    for _, v := range\
    \ lst2 {\n        lst2Total += len(v)\n    }\n    if lst1Total < lst2Total {\n\
    \        return lst1\n    } else if lst1Total > lst2Total {\n        return lst2\n\
    \    } else {\n        return lst1\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074698
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) < len(lst2) {\n        for _,s :=\
    \ range lst1 {\n            fmt.Println(s)\n        }\n    }\n    return []string{}\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "hi\nadmin\n4\nhi\nadmin\nhi\nadmin\n--- FAIL: TestTotal_Match (0.00s)\n\
    \    --- FAIL: TestTotal_Match/test_num__1 (0.00s)\n        tmpqhdeb4r9_test.go:52:\
    \ expected '[hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n\
    \        tmpqhdeb4r9_test.go:52: expected '[hi admin]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__3 (0.00s)\n        tmpqhdeb4r9_test.go:52: expected\
    \ '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n       \
    \ tmpqhdeb4r9_test.go:52: expected '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpqhdeb4r9_test.go:52: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpqhdeb4r9_test.go:52:\
    \ expected '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074698
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total_len1 := 0\n    total_len2 := 0\n    for\
    \ _, s := range lst1 {\n        total_len1 += len(s)\n    }\n    for _, s := range\
    \ lst2 {\n        total_len2 += len(s)\n    }\n    if total_len1 <= total_len2\
    \ {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074698
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    total1 := 0\n    total2 := 0\n    for _, val\
    \ := range lst1 {\n        total1 += len(val)\n    }\n    for _, val := range\
    \ lst2 {\n        total2 += len(val)\n    }\n    if total1 < total2 {\n      \
    \  return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp6bnjeogd_test.go:61: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074698
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total1 := 0\n    total2 := 0\n    for _, item\
    \ := range lst1 {\n        total1 += len(item)\n    }\n    for _, item := range\
    \ lst2 {\n        total2 += len(item)\n    }\n    if total1 <= total2 {\n    \
    \    return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074698
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if (sum_of_length(lst1) < sum_of_length(lst2))\
    \ {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbki6w03b_test.go:23:9: undefined: sum_of_length

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074697
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var (\n        total1 int\n        total2 int\n\
    \    )\n    for _, w := range lst1 {\n        total1 += len(w)\n    }\n    for\
    \ _, w := range lst2 {\n        total2 += len(w)\n    }\n    if total1 <= total2\
    \ {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074698
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n\n    var result []string\n    var total1 int\n\
    \    var total2 int\n\n    for _, s := range lst1 {\n        total1 += len(s)\n\
    \    }\n\n    for _, s := range lst2 {\n        total2 += len(s)\n    }\n\n  \
    \  if total1 < total2 {\n        result = lst1\n    } else {\n        result =\
    \ lst2\n    }\n\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpdcsnjqi5_test.go:69: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074698
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // YOUR CODE HERE\n    return nil\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8hvfvb2j_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp8hvfvb2j_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp8hvfvb2j_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp8hvfvb2j_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp8hvfvb2j_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp8hvfvb2j_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074698
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n\tt1 := 0\n\tt2 := 0\n\tfor _, s := range lst1 {\n\
    \t\tt1 += len(s)\n\t}\n\tfor _, s := range lst2 {\n\t\tt2 += len(s)\n\t}\n\tif\
    \ t1 < t2 {\n\t\treturn lst1\n\t}\n\treturn lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpazfjtlkl_test.go:58: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074698
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // write your code here\n    return []string{}\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpqpj_5mqf_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpqpj_5mqf_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpqpj_5mqf_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpqpj_5mqf_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpqpj_5mqf_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpqpj_5mqf_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074698
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n\tsum1 := 0\n\tsum2 := 0\n\tfor _, v := range lst1\
    \ {\n\t\tsum1 += len(v)\n\t}\n\tfor _, v := range lst2 {\n\t\tsum2 += len(v)\n\
    \t}\n\tif sum1 == sum2 {\n\t\treturn lst1\n\t} else if sum1 < sum2 {\n\t\treturn\
    \ lst1\n\t} else {\n\t\treturn lst2\n\t}\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074698
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    n1 := 0\n    n2 := 0\n    for _, s := range lst1\
    \ {\n        n1 += len(s)\n    }\n    for _, s := range lst2 {\n        n2 +=\
    \ len(s)\n    }\n    if n1 < n2 {\n        return lst1\n    }\n    return lst2\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpuuew9a9u_test.go:58: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074698
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8x8ubxjo_test.go:50: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp8x8ubxjo_test.go:50:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp8x8ubxjo_test.go:50: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp8x8ubxjo_test.go:50:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074698
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var sum1, sum2 int\n    for _, a := range lst1\
    \ {\n        sum1 += len(a)\n    }\n    for _, a := range lst2 {\n        sum2\
    \ += len(a)\n    }\n    if sum1 == sum2 {\n        return lst1\n    } else if\
    \ sum1 < sum2 {\n        return lst1\n    } else {\n        return lst2\n    }\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074698
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    cnt1 := 0\n    cnt2 := 0\n    for _, v := range\
    \ lst1 {\n        cnt1 += len(v)\n    }\n    for _, v := range lst2 {\n      \
    \  cnt2 += len(v)\n    }\n    if cnt1 < cnt2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpkgaoktvy_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074698
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    var count1 int\n\
    \    var count2 int\n    for _, s := range lst1 {\n        count1 += len(s)\n\
    \    }\n    for _, s := range lst2 {\n        count2 += len(s)\n    }\n    if\
    \ count1 < count2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmphhpdoe9k_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmphhpdoe9k_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmphhpdoe9k_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074698
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int = 0, 0\n    for _, str\
    \ := range lst1 {\n        total1 += len(str)\n    }\n    for _, str := range\
    \ lst2 {\n        total2 += len(str)\n    }\n    if total1 <= total2 {\n     \
    \   return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074699
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst1\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst2\n    }\n    var length1, length2\
    \ int\n    for _, item := range lst1 {\n        length1 += len(item)\n    }\n\
    \    for _, item := range lst2 {\n        length2 += len(item)\n    }\n    if\
    \ length1 < length2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpm6eytmti_test.go:63: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074699
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    // TODO\n    return\
    \ lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpea8o994p_test.go:57: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpea8o994p_test.go:57:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpea8o994p_test.go:57: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpea8o994p_test.go:57:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpea8o994p_test.go:57: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074700
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // Write your code here\n    return []string{}\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total1 := 0\n    total2 := 0\n    for _, v :=\
    \ range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        total2 += len(v)\n    }\n    if total1 == total2 {\n        return lst1\n\
    \    } else if total1 < total2 {\n        return lst1\n    } else {\n        return\
    \ lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074611
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    len1 := len(strings.Join(lst1, \"\"))\n    len2\
    \ := len(strings.Join(lst2, \"\"))\n    if len1 < len2 {\n        return lst1\n\
    \    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc71pcve2_test.go:26:17: undefined: strings

    /tmp/tmpc71pcve2_test.go:27:17: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074700
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total1 := 0\n    total2 := 0\n    for _, str\
    \ := range lst1 {\n        total1 += len(str)\n    }\n    for _, str := range\
    \ lst2 {\n        total2 += len(str)\n    }\n    if total1 < total2 {\n      \
    \  return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp2lx11r34_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    var lst1_total\
    \ int\n    var lst2_total int\n    for _, lst1_str := range lst1 {\n        lst1_total\
    \ += len(lst1_str)\n    }\n    for _, lst2_str := range lst2 {\n        lst2_total\
    \ += len(lst2_str)\n    }\n    if lst1_total < lst2_total {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpiqx33x2c_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpiqx33x2c_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpiqx33x2c_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074700
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, v := range\
    \ lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n    \
    \    total2 += len(v)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpq3w9kaql_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    str1_len := 0\n    str2_len := 0\n    for _,\
    \ str := range lst1 {\n        str1_len += len(str)\n    }\n    for _, str :=\
    \ range lst2 {\n        str2_len += len(str)\n    }\n    if str1_len == str2_len\
    \ {\n        return lst1\n    }\n    if str1_len < str2_len {\n        return\
    \ lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074700
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := total_len(lst1)\n    len2 := total_len(lst2)\n\
    \    if len1 == len2 {\n        return lst1\n    } else if len1 < len2 {\n   \
    \     return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_1rjqe6d_test.go:23:13: undefined: total_len

    /tmp/tmp_1rjqe6d_test.go:24:13: undefined: total_len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074700
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    count1 := 0\n    count2 := 0\n    for _, item\
    \ := range lst1 {\n        count1 += len(item)\n    }\n    for _, item := range\
    \ lst2 {\n        count2 += len(item)\n    }\n    if count1 < count2 {\n     \
    \   return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmppru6vg95_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074700
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    str1 := \"\"\n    str2 := \"\"\n    for _, v\
    \ := range lst1 {\n        str1 += v\n    }\n    for _, v := range lst2 {\n  \
    \      str2 += v\n    }\n    if len(str1) > len(str2) {\n        return lst2\n\
    \    }\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074700
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst1\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst2\n    }\n    var len1, len2\
    \ int\n    for _, str := range lst1 {\n        len1 += len(str)\n    }\n    for\
    \ _, str := range lst2 {\n        len2 += len(str)\n    }\n    if len1 == len2\
    \ {\n        return lst1\n    }\n    if len1 < len2 {\n        return lst1\n \
    \   }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074700
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total_lst1 := 0\n    total_lst2 := 0\n    for\
    \ _, v := range lst1 {\n        total_lst1 += len(v)\n    }\n    for _, v := range\
    \ lst2 {\n        total_lst2 += len(v)\n    }\n    if total_lst1 < total_lst2\
    \ {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpv1cff6_8_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074700
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := 0\n    len2 := 0\n    for _, v := range\
    \ lst1 {\n        len1 += len(v)\n    }\n    for _, v := range lst2 {\n      \
    \  len2 += len(v)\n    }\n    if len1 == len2 {\n        return lst1\n    }\n\
    \    if len1 < len2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660074700
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    num1 := 0\n    num2 := 0\n    for _, v := range\
    \ lst1 {\n        num1 += len(v)\n    }\n    for _, v := range lst2 {\n      \
    \  num2 += len(v)\n    }\n    if num1 == num2 {\n        return lst1\n    } else\
    \ if num1 < num2 {\n        return lst1\n    } else {\n        return lst2\n \
    \   }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074700
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var res []string\n    count1 := 0\n    count2\
    \ := 0\n    for _, val := range lst1 {\n        count1 += len(val)\n    }\n  \
    \  for _, val := range lst2 {\n        count2 += len(val)\n    }\n    if count1\
    \ < count2 {\n        res = lst1\n    } else {\n        res = lst2\n    }\n  \
    \  return res\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmphbtl91m8_test.go:61: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074700
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    count1 := 0\n    count2 := 0\n    for _, str\
    \ := range lst1 {\n        count1 += len(str)\n    }\n    for _, str := range\
    \ lst2 {\n        count2 += len(str)\n    }\n    if count1 < count2 {\n      \
    \  return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpsk8h17oc_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074700
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n\t// YOUR CODE HERE\n    return nil\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpcns_y5ns_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpcns_y5ns_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpcns_y5ns_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpcns_y5ns_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpcns_y5ns_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpcns_y5ns_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074700
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n\tl1 := len(lst1)\n\tl2 := len(lst2)\n\t\n\tif l1\
    \ == 0 && l2 == 0 {\n\t\treturn lst1\n\t}\n\tsum1 := 0\n\tsum2 := 0\n\tfor _,\
    \ v := range lst1 {\n\t\tsum1 += len(v)\n\t}\n\tfor _, v := range lst2 {\n\t\t\
    sum2 += len(v)\n\t}\n\t\n\tif sum1 <= sum2 {\n\t\treturn lst1\n\t}\n\treturn lst2\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074700
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total1 := 0\n    total2 := 0\n    for _, v :=\
    \ range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        total2 += len(v)\n    }\n    if total1 == total2 {\n        return lst1\n\
    \    } else if total1 < total2 {\n        return lst1\n    } else {\n        return\
    \ lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074611
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    sum1 := 0\n    sum2 := 0\n    for _, s := range\
    \ lst1 {\n        sum1 += len(s)\n    }\n    for _, s := range lst2 {\n      \
    \  sum2 += len(s)\n    }\n    if sum1 <= sum2 {\n        return lst1\n    }\n\
    \    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074700
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n\tchar1 := 0\n\tchar2 := 0\n\tfor _, word := range\
    \ lst1 {\n\t\tchar1 += len(word)\n\t}\n\tfor _, word := range lst2 {\n\t\tchar2\
    \ += len(word)\n\t}\n\tif char1 < char2 {\n\t\treturn lst1\n\t} else {\n\t\treturn\
    \ lst2\n\t}\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp9gn4u5sp_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074700
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return []string{}\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    count1 := 0\n    count2 := 0\n    for _, s :=\
    \ range lst1 {\n        count1 += len(s)\n    }\n    for _, s := range lst2 {\n\
    \        count2 += len(s)\n    }\n    if count1 == count2 {\n        return lst1\n\
    \    }\n    if count1 < count2 {\n        return lst1\n    }\n    return lst2\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074700
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var (\n        sum1 int\n        sum2 int\n \
    \   )\n    for _, v := range lst1 {\n        sum1 += len(v)\n    }\n    for _,\
    \ v := range lst2 {\n        sum2 += len(v)\n    }\n    if sum1 > sum2 {\n   \
    \     return lst2\n    }\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074700
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total_match_1 := 0\n    total_match_2 := 0\n\
    \    for _, i := range lst1 {\n        total_match_1 += len(i)\n    }\n    for\
    \ _, i := range lst2 {\n        total_match_2 += len(i)\n    }\n    if total_match_1\
    \ < total_match_2 {\n        return lst1\n    } else {\n        return lst2\n\
    \    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpdhzzowqx_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074700
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total1 := 0\n    total2 := 0\n    for _, s :=\
    \ range lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n\
    \        total2 += len(s)\n    }\n    if total1 == total2 {\n        return lst1\n\
    \    }\n    if total1 < total2 {\n        return lst1\n    }\n    return lst2\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074700
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // your code goes here\n    return []string{}\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpo2zv2jb__test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpo2zv2jb__test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpo2zv2jb__test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpo2zv2jb__test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpo2zv2jb__test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpo2zv2jb__test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074701
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    list1 := 0\n    list2 := 0\n    for _, str :=\
    \ range lst1 {\n        list1 += len(str)\n    }\n    for _, str := range lst2\
    \ {\n        list2 += len(str)\n    }\n    if list1 < list2 {\n        return\
    \ lst1\n    } else if list1 > list2 {\n        return lst2\n    } else {\n   \
    \     return lst1\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074701
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    sum1 := 0\n    sum2 := 0\n    for _, v := range\
    \ lst1 {\n        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n      \
    \  sum2 += len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    } else\
    \ if sum1 > sum2 {\n        return lst2\n    } else {\n        return lst1\n \
    \   }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074702
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  total1 := 0\n    total2 := 0\n    for i := 0; i < len1; i++ {\n        total1\
    \ += len(lst1[i])\n    }\n    for i := 0; i < len2; i++ {\n        total2 += len(lst2[i])\n\
    \    }\n    if total1 > total2 {\n        return lst2\n    } else {\n        return\
    \ lst1\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074702
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    totalMatch := func(lst []string) int {\n    \
    \    sum := 0\n        for _, e := range lst {\n            sum += len(e)\n  \
    \      }\n        return sum\n    }\n    if totalMatch(lst1) < totalMatch(lst2)\
    \ {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpxyicvhqe_test.go:57: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074702
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst1\n  \
    \  } else if len(lst2) == 0 {\n        return lst2\n    }\n\n    lst1_sum := 0\n\
    \    lst2_sum := 0\n    for _, val := range lst1 {\n        lst1_sum += len(val)\n\
    \    }\n    for _, val := range lst2 {\n        lst2_sum += len(val)\n    }\n\n\
    \    if lst1_sum < lst2_sum {\n        return lst1\n    } else {\n        return\
    \ lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpk_4ams75_test.go:66: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074702
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var result []string\n\n    if len(lst1) == 0\
    \ || len(lst2) == 0 {\n        return result\n    }\n\n    total1 := 0\n    total2\
    \ := 0\n\n    for _, s := range lst1 {\n        total1 += len(s)\n    }\n\n  \
    \  for _, s := range lst2 {\n        total2 += len(s)\n    }\n\n    if total1\
    \ == total2 {\n        return lst1\n    }\n\n    if total1 < total2 {\n      \
    \  return lst1\n    }\n\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074702
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n\n    len1 := 0\n    for _, v := range lst1 {\n\
    \        len1 += len(v)\n    }\n\n    len2 := 0\n    for _, v := range lst2 {\n\
    \        len2 += len(v)\n    }\n\n    if len1 < len2 {\n        return lst1\n\
    \    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp5kfazyrz_test.go:65: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074702
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total_match := lst1\n    var sum1 int\n    var\
    \ sum2 int\n    for _, value := range lst1 {\n        sum1 += len(value)\n   \
    \ }\n    for _, value := range lst2 {\n        sum2 += len(value)\n    }\n   \
    \ if sum1 > sum2 {\n        total_match = lst2\n    }\n    return total_match\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074702
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n\tif len(lst1) == 0 && len(lst2) == 0 {\n\t\treturn\
    \ []string{}\n\t}\n\ttotal1 := 0\n\ttotal2 := 0\n\tfor _, value := range lst1\
    \ {\n\t\ttotal1 += len(value)\n\t}\n\tfor _, value := range lst2 {\n\t\ttotal2\
    \ += len(value)\n\t}\n\tif total1 < total2 {\n\t\treturn lst1\n\t}\n\treturn lst2\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpt27vcnwg_test.go:61: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074703
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total_match int\n    if len(lst1) > len(lst2)\
    \ {\n        total_match = len(lst1)\n    } else {\n        total_match = len(lst2)\n\
    \    }\n    for i := 0; i < total_match; i++ {\n        if len(lst1[i]) < len(lst2[i])\
    \ {\n            return lst1\n        } else if len(lst1[i]) > len(lst2[i]) {\n\
    \            return lst2\n        }\n    }\n    return lst1\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmpy8k80xga_test.go:30\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmpy8k80xga_test.go:49\
    \ +0x46c\ntesting.tRunner(0xc0001a01a0, 0x528f38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074702
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := 0\n    len2 := 0\n    for _, e := range\
    \ lst1 {\n        len1 += len(e)\n    }\n    for _, e := range lst2 {\n      \
    \  len2 += len(e)\n    }\n    if len1 == len2 {\n        return lst1\n    }\n\
    \    if len1 < len2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074702
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // YOUR CODE HERE\n    return nil\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8hvfvb2j_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp8hvfvb2j_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp8hvfvb2j_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp8hvfvb2j_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp8hvfvb2j_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp8hvfvb2j_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074698
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) > len(lst2) {\n        return lst2\n\
    \    }\n    if len(lst1) < len(lst2) {\n        return lst1\n    }\n    if len(lst1)\
    \ == len(lst2) {\n        return lst1\n    }\n    return lst1\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0mnfpw5q_test.go:59: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0mnfpw5q_test.go:59:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0mnfpw5q_test.go:59: expected '[hI hi hi]', got '[hi admin]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074702
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    str_len1 := 0\n    str_len2 := 0\n    for _,\
    \ str := range lst1 {\n        str_len1 += len(str)\n    }\n    for _, str :=\
    \ range lst2 {\n        str_len2 += len(str)\n    }\n    if str_len1 == str_len2\
    \ {\n        return lst1\n    }\n    if str_len1 < str_len2 {\n        return\
    \ lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074702
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var (\n        total_sum_lst1 int\n        total_sum_lst2\
    \ int\n    )\n    for _, s := range lst1 {\n        total_sum_lst1 += len(s)\n\
    \    }\n    for _, s := range lst2 {\n        total_sum_lst2 += len(s)\n    }\n\
    \    fmt.Println(total_sum_lst1, total_sum_lst2)\n    if total_sum_lst1 < total_sum_lst2\
    \ {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "0 0\n7 4\n7 16\n1 5\n7 4\n7 6\n7 7\n0 4\n4 0\n--- FAIL: TestTotal_Match\
    \ (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpe8eygpro_test.go:62:\
    \ expected '[hi admin]', got '[hI hi hii]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074702
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst1\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst2\n    }\n    sum1 := 0\n   \
    \ sum2 := 0\n    for _, s := range lst1 {\n        sum1 += len(s)\n    }\n   \
    \ for _, s := range lst2 {\n        sum2 += len(s)\n    }\n    if sum1 <= sum2\
    \ {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074702
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var len1 int = 0\n    var len2 int = 0\n    for\
    \ _, v := range lst1 {\n        len1 += len(v)\n    }\n    for _, v := range lst2\
    \ {\n        len2 += len(v)\n    }\n    if len1 < len2 {\n        return lst1\n\
    \    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpjkrywdwn_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074702
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    sum1 := 0\n    sum2 := 0\n    for _, s := range\
    \ lst1 {\n        sum1 += len(s)\n    }\n    for _, s := range lst2 {\n      \
    \  sum2 += len(s)\n    }\n    if sum1 < sum2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpcqu1vh06_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n\n    totalLen1 := 0\n    for _, item := range lst1\
    \ {\n        totalLen1 += len(item)\n    }\n\n    totalLen2 := 0\n    for _, item\
    \ := range lst2 {\n        totalLen2 += len(item)\n    }\n\n    if totalLen1 <\
    \ totalLen2 {\n        return lst1\n    } else {\n        return lst2\n    }\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp4bbc6qyd_test.go:65: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074702
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    // we need to make case insensitive\n    lst1\
    \ = toLowerCase(lst1)\n    lst2 = toLowerCase(lst2)\n    lst1Num := countNumOfChar(lst1)\n\
    \    lst2Num := countNumOfChar(lst2)\n    if lst1Num > lst2Num {\n        return\
    \ lst2\n    }\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpotom8zrm_test.go:27:12: undefined: toLowerCase

    /tmp/tmpotom8zrm_test.go:28:12: undefined: toLowerCase

    /tmp/tmpotom8zrm_test.go:29:16: undefined: countNumOfChar

    /tmp/tmpotom8zrm_test.go:30:16: undefined: countNumOfChar

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074702
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n\tl1 := len(lst1)\n\tl2 := len(lst2)\n\tif l1 ==\
    \ 0 && l2 == 0 {\n\t\treturn []string{}\n\t}\n\tt1 := total_len(lst1)\n\tt2 :=\
    \ total_len(lst2)\n\tif t1 == t2 {\n\t\treturn lst1\n\t}\n\tif t1 < t2 {\n\t\t\
    return lst1\n\t}\n\treturn lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_390315j_test.go:28:8: undefined: total_len

    /tmp/tmp_390315j_test.go:29:8: undefined: total_len

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074702
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var lst1_chars int = 0\n    var lst2_chars int\
    \ = 0\n    for _, str := range lst1 {\n        lst1_chars += len(str)\n    }\n\
    \    for _, str := range lst2 {\n        lst2_chars += len(str)\n    }\n    if\
    \ lst1_chars == lst2_chars {\n        return lst1\n    } else if lst1_chars <\
    \ lst2_chars {\n        return lst1\n    } else {\n        return lst2\n    }\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074702
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // your code here\n    fmt.Println(\"TODO: Write\
    \ total_match func to pass this test\")\n    return nil\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "TODO: Write total_match func to pass this test\nTODO: Write total_match\
    \ func to pass this test\nTODO: Write total_match func to pass this test\nTODO:\
    \ Write total_match func to pass this test\nTODO: Write total_match func to pass\
    \ this test\nTODO: Write total_match func to pass this test\nTODO: Write total_match\
    \ func to pass this test\nTODO: Write total_match func to pass this test\nTODO:\
    \ Write total_match func to pass this test\n--- FAIL: TestTotal_Match (0.00s)\n\
    \    --- FAIL: TestTotal_Match/test_num__1 (0.00s)\n        tmp8rsqs3zz_test.go:49:\
    \ expected '[hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n\
    \        tmp8rsqs3zz_test.go:49: expected '[hi admin]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__3 (0.00s)\n        tmp8rsqs3zz_test.go:49: expected\
    \ '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n       \
    \ tmp8rsqs3zz_test.go:49: expected '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp8rsqs3zz_test.go:49: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmp8rsqs3zz_test.go:49:\
    \ expected '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074702
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total1 := 0\n    total2 := 0\n    if len(lst1)\
    \ > len(lst2) {\n        return lst1\n    }\n    if len(lst1) < len(lst2) {\n\
    \        return lst2\n    }\n    for _, el := range lst1 {\n        total1 +=\
    \ len(el)\n    }\n    for _, el := range lst2 {\n        total2 += len(el)\n \
    \   }\n    if total1 < total2 {\n        return lst1\n    }\n    return lst2\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__2\
    \ (0.00s)\n        tmp4vcgxgu5_test.go:64: expected '[hi admin]', got '[hi hi\
    \ admin project]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n       \
    \ tmp4vcgxgu5_test.go:64: expected '[4]', got '[1 2 3 4 5]'\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp4vcgxgu5_test.go:64: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp4vcgxgu5_test.go:64:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp4vcgxgu5_test.go:64: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074702
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var res []string\n    if len(lst1) == 0 || len(lst2)\
    \ == 0 {\n        return res\n    }\n    total1 := 0\n    total2 := 0\n    for\
    \ _, val := range lst1 {\n        total1 += len(val)\n    }\n    for _, val :=\
    \ range lst2 {\n        total2 += len(val)\n    }\n    if total1 < total2 {\n\
    \        return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp2lwygvpi_test.go:63: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074703
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n\treturn []string{}\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp1pmtuuch_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp1pmtuuch_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp1pmtuuch_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp1pmtuuch_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp1pmtuuch_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp1pmtuuch_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074703
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    count1 := 0\n    count2 := 0\n    for _, str\
    \ := range lst1 {\n        count1 += len(str)\n    }\n    for _, str := range\
    \ lst2 {\n        count2 += len(str)\n    }\n    if count1 <= count2 {\n     \
    \   return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074704
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total_length1 := 0\n    total_length2 := 0\n\
    \    //\n    for _, val := range lst1 {\n        total_length1 += len(val)\n \
    \   }\n    for _, val := range lst2 {\n        total_length2 += len(val)\n   \
    \ }\n    //\n    if total_length1 < total_length2 {\n        return lst1\n   \
    \ } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpm0gs_r85_test.go:61: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074704
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    count1 := 0\n    count2 := 0\n    for _, char\
    \ := range lst1 {\n        count1 += len(char)\n    }\n    for _, char := range\
    \ lst2 {\n        count2 += len(char)\n    }\n    if count1 == count2 {\n    \
    \    return lst1\n    } else if count1 < count2 {\n        return lst1\n    }\
    \ else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074704
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // YOUR CODE HERE\n    return []string{}\n}\n\
    \nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpqi4rrhmd_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpqi4rrhmd_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpqi4rrhmd_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpqi4rrhmd_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpqi4rrhmd_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpqi4rrhmd_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074704
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if lst1 == nil {\n        return lst2\n    }\n\
    \    if lst2 == nil {\n        return lst1\n    }\n    var lst1_len, lst2_len\
    \ int\n    for _, v := range lst1 {\n        lst1_len += len(v)\n    }\n    for\
    \ _, v := range lst2 {\n        lst2_len += len(v)\n    }\n    if lst1_len < lst2_len\
    \ {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpx2b18z9q_test.go:63: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074704
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n\n    if len(lst1) == 0 {\n        return lst2\n\
    \    }\n    if len(lst2) == 0 {\n        return lst1\n    }\n\n    total1 := total(lst1)\n\
    \    total2 := total(lst2)\n\n    if total1 == total2 {\n        return lst1\n\
    \    }\n    if total1 < total2 {\n        return lst1\n    }\n    return lst2\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphnoqcj2r_test.go:34:15: undefined: total

    /tmp/tmphnoqcj2r_test.go:35:15: undefined: total

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074704
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return []string{}\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total_chars_lst1 := 0\n    total_chars_lst2 :=\
    \ 0\n    for _, element := range lst1 {\n        total_chars_lst1 += len(element)\n\
    \    }\n    for _, element := range lst2 {\n        total_chars_lst2 += len(element)\n\
    \    }\n    if total_chars_lst1 < total_chars_lst2 {\n        return lst1\n  \
    \  } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpyauaa53z_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074705
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return []string{}\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1_count := 0\n    lst2_count := 0\n    for\
    \ _, i := range lst1 {\n        lst1_count += len(i)\n    }\n    for _, i := range\
    \ lst2 {\n        lst2_count += len(i)\n    }\n    if lst1_count == lst2_count\
    \ {\n        return lst1\n    } else if lst1_count < lst2_count {\n        return\
    \ lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074705
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n\tvar (\n\t\tlst1_total int\n\t\tlst2_total int\n\
    \t)\n\tfor _, v := range lst1 {\n\t\tlst1_total += len(v)\n\t}\n\tfor _, v :=\
    \ range lst2 {\n\t\tlst2_total += len(v)\n\t}\n\tif lst1_total < lst2_total {\n\
    \t\treturn lst1\n\t}\n\treturn lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmprh8axewx_test.go:60: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074705
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := 0\n    len2 := 0\n    for _, str := range\
    \ lst1 {\n        len1 += len(str)\n    }\n    for _, str := range lst2 {\n  \
    \      len2 += len(str)\n    }\n    if len1 > len2 {\n        return lst2\n  \
    \  }\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074705
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    sum1 := 0\n    sum2 := 0\n    for _, s := range\
    \ lst1 {\n        sum1 += len(s)\n    }\n    for _, s := range lst2 {\n      \
    \  sum2 += len(s)\n    }\n    if sum1 < sum2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpcqu1vh06_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    sum1 := 0\n    sum2 := 0\n    for _, i := range\
    \ lst1 {\n        sum1 += len(i)\n    }\n    for _, i := range lst2 {\n      \
    \  sum2 += len(i)\n    }\n    if sum1 > sum2 {\n        return lst2\n    }\n \
    \   return lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074705
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    sum1 := 0\n    sum2 := 0\n    for _, s := range\
    \ lst1 {\n        sum1 += len(s)\n    }\n    for _, s := range lst2 {\n      \
    \  sum2 += len(s)\n    }\n    if sum1 == sum2 {\n        return lst1\n    }\n\
    \    if sum1 < sum2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074705
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var sum1, sum2 int\n    for _, str := range lst1\
    \ {\n        sum1 += len(str)\n    }\n    for _, str := range lst2 {\n       \
    \ sum2 += len(str)\n    }\n    if sum1 <= sum2 {\n        return lst1\n    }\n\
    \    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074705
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    sum1 := 0\n    sum2 := 0\n    for _, val := range\
    \ lst1 {\n        sum1 += len(val)\n    }\n    for _, val := range lst2 {\n  \
    \      sum2 += len(val)\n    }\n    if sum1 < sum2 {\n        return lst1\n  \
    \  } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpnx3tj794_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074705
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst1\n  \
    \  } else if len(lst2) == 0 {\n        return lst2\n    }\n\n    total1 := 0\n\
    \    total2 := 0\n    for _, i := range lst1 {\n        total1 += len(i)\n   \
    \ }\n    for _, i := range lst2 {\n        total2 += len(i)\n    }\n\n    if total1\
    \ < total2 {\n        return lst1\n    } else {\n        return lst2\n    }\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpy39ve2ug_test.go:66: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074705
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return []string{}\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total := 0\n    for _, s := range lst1 {\n  \
    \      total += len(s)\n    }\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpihz6614z_test.go:51: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpihz6614z_test.go:51:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpihz6614z_test.go:51: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpihz6614z_test.go:51:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074705
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return []string{}\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total_sum_lst1 := 0\n    total_sum_lst2 := 0\n\
    \    for _, item := range lst1 {\n        total_sum_lst1 += len(item)\n    }\n\
    \    for _, item := range lst2 {\n        total_sum_lst2 += len(item)\n    }\n\
    \    fmt.Println(total_sum_lst1, total_sum_lst2)\n    if total_sum_lst1 < total_sum_lst2\
    \ {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "0 0\n7 4\n7 16\n1 5\n7 4\n7 6\n7 7\n0 4\n4 0\n--- FAIL: TestTotal_Match\
    \ (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmptxivu3rr_test.go:59:\
    \ expected '[hi admin]', got '[hI hi hii]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074705
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var str1 string\n    var str2 string\n    for\
    \ _, v := range lst1 {\n        str1 += v\n    }\n    for _, v := range lst2 {\n\
    \        str2 += v\n    }\n    if len(str1) > len(str2) {\n        return lst2\n\
    \    } else {\n        return lst1\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074705
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total_chars1 int = 0\n    var total_chars2\
    \ int = 0\n    for _, value := range lst1 {\n        total_chars1 += len(value)\n\
    \    }\n    for _, value := range lst2 {\n        total_chars2 += len(value)\n\
    \    }\n    if total_chars1 < total_chars2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpnzr_rtm7_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074705
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total_chars_1 := 0\n    total_chars_2 := 0\n\
    \    for _, str := range lst1 {\n        total_chars_1 += len(str)\n    }\n  \
    \  for _, str := range lst2 {\n        total_chars_2 += len(str)\n    }\n    if\
    \ total_chars_1 < total_chars_2 {\n        return lst1\n    } else {\n       \
    \ return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate :=\
    \ total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp669l_y5e_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074705
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var res []string\n    count1 := 0\n    count2\
    \ := 0\n    if len(lst1) < len(lst2) {\n        res = lst1\n    } else {\n   \
    \     res = lst2\n    }\n    for _, word := range lst1 {\n        count1 += len(word)\n\
    \    }\n    for _, word := range lst2 {\n        count2 += len(word)\n    }\n\
    \    if count1 < count2 {\n        res = lst1\n    } else if count1 > count2 {\n\
    \        res = lst2\n    }\n    return res\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074705
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return []string{}\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    tot1 := 0\n    tot2 := 0\n    for _, v := range\
    \ lst1 {\n        tot1 += len(v)\n    }\n    for _, v := range lst2 {\n      \
    \  tot2 += len(v)\n    }\n    if tot1 <= tot2 {\n        return lst1\n    }\n\
    \    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074705
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    chars_count1 := 0\n    chars_count2 := 0\n  \
    \  for _, s := range lst1 {\n        chars_count1 += len(s)\n    }\n    for _,\
    \ s := range lst2 {\n        chars_count2 += len(s)\n    }\n    if chars_count1\
    \ <= chars_count2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074705
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total := 0\n    for _, s := range lst1 {\n  \
    \      total += len(s)\n    }\n    for _, s := range lst2 {\n        total -=\
    \ len(s)\n    }\n    if total < 0 {\n        return lst2\n    }\n    return lst1\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp542_nv33_test.go:57: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp542_nv33_test.go:57:\
    \ expected '[hi admin]', got '[hi hi admin project]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmp542_nv33_test.go:57: expected '[4]', got '[1 2 3 4 5]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp542_nv33_test.go:57:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp542_nv33_test.go:57: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp542_nv33_test.go:57:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp542_nv33_test.go:57: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074706
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 && len(lst2) != 0 {\n    \
    \    return lst2\n    }\n    if len(lst1) != 0 && len(lst2) == 0 {\n        return\
    \ lst1\n    }\n    var lst1Chars int\n    var lst2Chars int\n    for _, v := range\
    \ lst1 {\n        lst1Chars += len(v)\n    }\n    for _, v := range lst2 {\n \
    \       lst2Chars += len(v)\n    }\n    if lst1Chars < lst2Chars {\n        return\
    \ lst1\n    }\n    if lst1Chars > lst2Chars {\n        return lst2\n    }\n  \
    \  return lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__7\
    \ (0.00s)\n        tmpbh7yg1vt_test.go:70: expected '[]', got '[this]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpbh7yg1vt_test.go:70: expected\
    \ '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074706
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst1\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst2\n    }\n    sum1 := 0\n   \
    \ sum2 := 0\n    for _, str := range lst1 {\n        sum1 += len(str)\n    }\n\
    \    for _, str := range lst2 {\n        sum2 += len(str)\n    }\n    if sum1\
    \ < sum2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpzepy2tri_test.go:64: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074706
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    total_chars_in_lst1\
    \ := 0\n    total_chars_in_lst2 := 0\n    for _, s := range lst1 {\n        total_chars_in_lst1\
    \ += len(s)\n    }\n    for _, s := range lst2 {\n        total_chars_in_lst2\
    \ += len(s)\n    }\n    if total_chars_in_lst1 < total_chars_in_lst2 {\n     \
    \   return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp84xdo990_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp84xdo990_test.go:67:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp84xdo990_test.go:67: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074706
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    chars_count1 := 0\n    chars_count2 := 0\n  \
    \  for _, val := range lst1 {\n        chars_count1 += len(val)\n    }\n    for\
    \ _, val := range lst2 {\n        chars_count2 += len(val)\n    }\n    if chars_count1\
    \ > chars_count2 {\n        return lst2\n    }\n    return lst1\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074707
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := 0\n    len2 := 0\n    for _, v := range\
    \ lst1 {\n        len1 += len(v)\n    }\n    for _, v := range lst2 {\n      \
    \  len2 += len(v)\n    }\n    if len1 <= len2 {\n        return lst1\n    }\n\
    \    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074707
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // your code here\n    return nil\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp5635dxhf_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp5635dxhf_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp5635dxhf_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp5635dxhf_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp5635dxhf_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp5635dxhf_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n\tif len(lst1) == 0 && len(lst2) == 0 {\n\t\treturn\
    \ []string{}\n\t}\n\n\ttotal_chars_lst1 := 0\n\ttotal_chars_lst2 := 0\n\n\tfor\
    \ _, s := range lst1 {\n\t\ttotal_chars_lst1 += len(s)\n\t}\n\n\tfor _, s := range\
    \ lst2 {\n\t\ttotal_chars_lst2 += len(s)\n\t}\n\n\tif total_chars_lst1 > total_chars_lst2\
    \ {\n\t\treturn lst2\n\t} else {\n\t\treturn lst1\n\t}\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074707
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    count1 := 0\n    count2 := 0\n    for _, str\
    \ := range lst1 {\n        count1 += len(str)\n    }\n    for _, str := range\
    \ lst2 {\n        count2 += len(str)\n    }\n    if count1 <= count2 {\n     \
    \   return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074704
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // Write your code here\n    var lst1_len, lst2_len\
    \ int\n    for _, str := range lst1 {\n        lst1_len += len(str)\n    }\n \
    \   for _, str := range lst2 {\n        lst2_len += len(str)\n    }\n    if lst1_len\
    \ < lst2_len {\n        return lst1\n    } else {\n        return lst2\n    }\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpu36ghsxi_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074707
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // Write your code here\n    return nil\n}\n\n\
    func TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmprntfsi0w_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmprntfsi0w_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmprntfsi0w_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmprntfsi0w_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmprntfsi0w_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmprntfsi0w_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total1 := total_string(lst1)\n    total2 := total_string(lst2)\n\
    \    if total1 < total2 {\n        return lst1\n    } else {\n        return lst2\n\
    \    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkwdw1mwr_test.go:23:15: undefined: total_string

    /tmp/tmpkwdw1mwr_test.go:24:15: undefined: total_string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074707
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    count1 := len(lst1)\n    count2 := len(lst2)\n\
    \    if count1 == 0 {\n        return lst1\n    }\n    for _, value := range lst1\
    \ {\n        count1 += len(value)\n    }\n    for _, value := range lst2 {\n \
    \       count2 += len(value)\n    }\n    if count1 < count2 {\n        return\
    \ lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074707
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var count1 int\n    var count2 int\n    for _,v\
    \ := range lst1 {\n        count1 += len(v)\n    }\n    for _,v := range lst2\
    \ {\n        count2 += len(v)\n    }\n    if count1 > count2 {\n        return\
    \ lst2\n    } else if count1 < count2 {\n        return lst1\n    } else {\n \
    \       return lst1\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074707
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    sum1 := 0\n    sum2 := 0\n    for _, item :=\
    \ range lst1 {\n        sum1 += len(item)\n    }\n    for _, item := range lst2\
    \ {\n        sum2 += len(item)\n    }\n    if sum1 < sum2 {\n        return lst1\n\
    \    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp6f4065sz_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074707
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // TODO - Add your code here\n    return nil\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpvhrsdul5_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpvhrsdul5_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpvhrsdul5_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpvhrsdul5_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpvhrsdul5_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpvhrsdul5_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074707
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var count int\n    if len(lst1) > len(lst2) {\n\
    \        count = len(lst1)\n    } else {\n        count = len(lst2)\n    }\n \
    \   lst1_len := 0\n    lst2_len := 0\n    for i := 0; i < count; i++ {\n     \
    \   if i < len(lst1) {\n            lst1_len += len(lst1[i])\n        }\n    \
    \    if i < len(lst2) {\n            lst2_len += len(lst2[i])\n        }\n   \
    \ }\n    if lst1_len < lst2_len {\n        return lst1\n    } else {\n       \
    \ return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate :=\
    \ total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp32o042se_test.go:67: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074707
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // Write your code here\n    count1 := 0\n  \
    \  count2 := 0\n    for _,v := range lst1 {\n        count1 += len(v)\n    }\n\
    \    for _,v := range lst2 {\n        count2 += len(v)\n    }\n    if count1 <\
    \ count2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmprmih_lsf_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074707
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    sum1 := 0\n    sum2 := 0\n    for _, s := range\
    \ lst1 {\n        sum1 += len(s)\n    }\n    for _, s := range lst2 {\n      \
    \  sum2 += len(s)\n    }\n    if sum1 < sum2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpcqu1vh06_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    sum1 := 0\n    sum2 := 0\n    for _, v := range\
    \ lst1 {\n        sum1 += len(v)\n    }\n    for _, v := range lst2 {\n      \
    \  sum2 += len(v)\n    }\n    if sum1 < sum2 {\n        return lst1\n    } else\
    \ if sum1 > sum2 {\n        return lst2\n    } else {\n        return lst1\n \
    \   }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074702
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1_len := 0\n    lst2_len := 0\n    for _,\
    \ item := range lst1 {\n        lst1_len += len(item)\n    }\n    for _, item\
    \ := range lst2 {\n        lst2_len += len(item)\n    }\n    if lst1_len < lst2_len\
    \ {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpw24pud49_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074707
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total1 := 0\n    total2 := 0\n    for _, value\
    \ := range lst1 {\n        total1 += len(value)\n    }\n    for _, value := range\
    \ lst2 {\n        total2 += len(value)\n    }\n    if total1 == total2 {\n   \
    \     return lst1\n    } else if total1 < total2 {\n        return lst1\n    }\
    \ else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074707
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // TODO: implement this function\n    return\
    \ nil\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp3ehnuhmt_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp3ehnuhmt_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp3ehnuhmt_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp3ehnuhmt_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp3ehnuhmt_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp3ehnuhmt_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074707
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    count1 := 0\n    count2 := 0\n    for _, elem\
    \ := range lst1 {\n        count1 += len(elem)\n    }\n    for _, elem := range\
    \ lst2 {\n        count2 += len(elem)\n    }\n    if count1 <= count2 {\n    \
    \    return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074707
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return []string{}\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // total_length(lst []string) int\n    return\
    \ []string{}\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp_f17f1jk_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp_f17f1jk_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp_f17f1jk_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp_f17f1jk_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp_f17f1jk_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp_f17f1jk_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074707
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // Your code goes here\n    return []string{}\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8z6x04lf_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp8z6x04lf_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp8z6x04lf_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp8z6x04lf_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp8z6x04lf_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp8z6x04lf_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074707
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1_count := 0\n    lst2_count := 0\n    for\
    \ _, str := range lst1 {\n        lst1_count += len(str)\n    }\n    for _, str\
    \ := range lst2 {\n        lst2_count += len(str)\n    }\n    if lst1_count ==\
    \ lst2_count {\n        return lst1\n    } else if lst1_count < lst2_count {\n\
    \        return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074707
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // Write your code here\n    return []string{}\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp6xxkuuib_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp6xxkuuib_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp6xxkuuib_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if lst1 == nil {\n        return lst2\n    }\n\
    \    if lst2 == nil {\n        return lst1\n    }\n    len1 := 0\n    len2 :=\
    \ 0\n    for _, str := range lst1 {\n        len1 += len(str)\n    }\n    for\
    \ _, str := range lst2 {\n        len2 += len(str)\n    }\n    if len1 <= len2\
    \ {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074707
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    totalChars1 := 0\n    totalChars2 := 0\n    for\
    \ _, v := range lst1 {\n        totalChars1 += len(v)\n    }\n    for _, v :=\
    \ range lst2 {\n        totalChars2 += len(v)\n    }\n    if totalChars1 < totalChars2\
    \ {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp5yd12iqm_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074708
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    res := \"\"\n    lst1Str := \"\"\n    lst2Str\
    \ := \"\"\n    for _, v := range lst1 {\n        lst1Str += v\n    }\n    for\
    \ _, v := range lst2 {\n        lst2Str += v\n    }\n    if len(lst1Str) < len(lst2Str)\
    \ {\n        res = lst1Str\n    } else {\n        res = lst2Str\n    }\n    return\
    \ res\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4g9j0ddj_test.go:37:12: cannot use res (variable of type string) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074707
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // Your code here!\n    return []string{}\n}\n\
    \nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpxu791584_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpxu791584_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpxu791584_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpxu791584_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpxu791584_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpxu791584_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074708
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total1 := 0\n    total2 := 0\n    for _, word\
    \ := range lst1 {\n        total1 += len(word)\n    }\n    for _, word := range\
    \ lst2 {\n        total2 += len(word)\n    }\n    if total1 < total2 {\n     \
    \   return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp9dinez51_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074708
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total1 := 0\n    total2 := 0\n    for _, s :=\
    \ range lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2 {\n\
    \        total2 += len(s)\n    }\n    if total1 < total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpu_foe234_test.go:58: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074523
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst1\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst2\n    }\n    total1 := 0\n \
    \   total2 := 0\n    for _, elem := range lst1 {\n        total1 += len(elem)\n\
    \    }\n    for _, elem := range lst2 {\n        total2 += len(elem)\n    }\n\
    \    if total1 == total2 {\n        return lst1\n    }\n    if total1 < total2\
    \ {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074708
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n\tnum1 := 0\n\tnum2 := 0\n\tfor _, str := range lst1\
    \ {\n\t\tnum1 += len(str)\n\t}\n\tfor _, str := range lst2 {\n\t\tnum2 += len(str)\n\
    \t}\n\tif num1 == num2 {\n\t\treturn lst1\n\t} else if num1 < num2 {\n\t\treturn\
    \ lst1\n\t} else {\n\t\treturn lst2\n\t}\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074709
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    sum1 := 0\n    sum2 := 0\n    for _, e := range\
    \ lst1 {\n        sum1 += len(e)\n    }\n    for _, e := range lst2 {\n      \
    \  sum2 += len(e)\n    }\n    if sum1 == sum2 {\n        return lst1\n    }\n\
    \    if sum1 < sum2 {\n        return lst1\n    }\n    return lst2\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074709
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := 0\n    len2 := 0\n    for _, s := range\
    \ lst1 {\n        len1 += len(s)\n    }\n    for _, s := range lst2 {\n      \
    \  len2 += len(s)\n    }\n    if len1 <= len2 {\n        return lst1\n    }\n\
    \    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074709
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total1 := 0\n    total2 := 0\n    for _, word\
    \ := range lst1 {\n        total1 += len(word)\n    }\n    for _, word := range\
    \ lst2 {\n        total2 += len(word)\n    }\n    if total1 < total2 {\n     \
    \   return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp9dinez51_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074708
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 && len(lst2) == 0 {\n     \
    \   return []string{}\n    }\n    if len(lst1) == 0 {\n        return lst2\n \
    \   }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    var sum1, sum2\
    \ int\n    for _, str := range lst1 {\n        sum1 += len(str)\n    }\n    for\
    \ _, str := range lst2 {\n        sum2 += len(str)\n    }\n    if sum1 < sum2\
    \ {\n        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpycdhhpd4_test.go:66: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpycdhhpd4_test.go:66:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpycdhhpd4_test.go:66: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074709
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    count1 := 0\n    count2 := 0\n    for _, val\
    \ := range lst1 {\n        count1 += len(val)\n    }\n    for _, val := range\
    \ lst2 {\n        count2 += len(val)\n    }\n    if count1 < count2 {\n      \
    \  return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpcrt42etj_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074709
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1 int\n    var total2 int\n    for _,\
    \ s := range lst1 {\n        total1 += len(s)\n    }\n    for _, s := range lst2\
    \ {\n        total2 += len(s)\n    }\n    if total1 < total2 {\n        return\
    \ lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp559106zj_test.go:58: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074709
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    str1 := \"\"\n    str2 := \"\"\n    for _, s\
    \ := range lst1 {\n        str1 += s\n    }\n    for _, s := range lst2 {\n  \
    \      str2 += s\n    }\n    if len(str1) < len(str2) {\n        return lst1\n\
    \    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpshvbnqdv_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074709
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var sum1 int\n    var sum2 int\n    for _, str\
    \ := range lst1 {\n        sum1 += len(str)\n    }\n    for _, str := range lst2\
    \ {\n        sum2 += len(str)\n    }\n    if sum1 <= sum2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074709
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var total1, total2 int\n    for _, item := range\
    \ lst1 {\n        total1 += len(item)\n    }\n    for _, item := range lst2 {\n\
    \        total2 += len(item)\n    }\n    if total1 == total2 {\n        return\
    \ lst1\n    }\n    if total1 < total2 {\n        return lst1\n    }\n    return\
    \ lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074709
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    count1 := 0\n    count2 := 0\n    for _, str\
    \ := range lst1 {\n        count1 += len(str)\n    }\n    for _, str := range\
    \ lst2 {\n        count2 += len(str)\n    }\n    if count1 == count2 {\n     \
    \   return lst1\n    } else if count1 < count2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074710
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total1 := 0\n    total2 := 0\n    for _, v :=\
    \ range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        total2 += len(v)\n    }\n    if total1 > total2 {\n        return lst2\n\
    \    }\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074709
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    n1 := len(lst1)\n    n2 := len(lst2)\n    var\
    \ res []string\n\n    if n1 == 0 && n2 == 0 {\n        return res\n    }\n\n \
    \   if n1 == 0 {\n        return lst2\n    }\n\n    if n2 == 0 {\n        return\
    \ lst1\n    }\n\n    count1 := 0\n    count2 := 0\n\n    for _, val := range lst1\
    \ {\n        count1 += len(val)\n    }\n\n    for _, val := range lst2 {\n   \
    \     count2 += len(val)\n    }\n\n    if count1 <= count2 {\n        return lst1\n\
    \    }\n\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__7\
    \ (0.00s)\n        tmpudu47290_test.go:78: expected '[]', got '[this]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpudu47290_test.go:78: expected\
    \ '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074709
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n\tvar total1 int\n\tvar total2 int\n\tvar i int\n\
    \n\tfor i = 0; i < len(lst1); i++ {\n\t\ttotal1 += len(lst1[i])\n\t}\n\tfor i\
    \ = 0; i < len(lst2); i++ {\n\t\ttotal2 += len(lst2[i])\n\t}\n\n\tif total1 >\
    \ total2 {\n\t\treturn lst2\n\t} else {\n\t\treturn lst1\n\t}\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074710
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // Your code goes here\n    return nil\n}\n\n\
    func TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpeo3swzc0_test.go:48: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpeo3swzc0_test.go:48: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpeo3swzc0_test.go:48: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpeo3swzc0_test.go:48: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpeo3swzc0_test.go:48: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpeo3swzc0_test.go:48: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074709
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total1 := 0\n    total2 := 0\n    for _, value\
    \ := range lst1 {\n        total1 += len(value)\n    }\n    for _, value := range\
    \ lst2 {\n        total2 += len(value)\n    }\n    if total1 <= total2 {\n   \
    \     return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660074709
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    length1 := 0\n    length2 := 0\n    for _, v\
    \ := range lst1 {\n        length1 += len(v)\n    }\n    for _, v := range lst2\
    \ {\n        length2 += len(v)\n    }\n    if length1 < length2 {\n        return\
    \ lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp3lmokpbw_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074710
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n\treturn nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmphby_y_yu_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmphby_y_yu_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmphby_y_yu_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmphby_y_yu_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmphby_y_yu_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmphby_y_yu_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074709
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp0qlcyij8_test.go:47: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp0qlcyij8_test.go:47:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    // Implementation here\n    var counter int\n\
    \    var counter2 int\n    var lst []string\n    var lst3 []string\n    if len(lst1)\
    \ == 0 {\n        fmt.Println(lst1)\n    }\n    if len(lst2) == 0 {\n        fmt.Println(lst2)\n\
    \    }\n    for _, v := range lst1 {\n        counter += len(v)\n    }\n    for\
    \ _, v := range lst2 {\n        counter2 += len(v)\n    }\n    if counter < counter2\
    \ {\n        fmt.Println(lst1)\n    } else if counter2 < counter {\n        fmt.Println(lst2)\n\
    \    } else if counter == counter2 {\n        fmt.Println(lst1)\n    }\n    return\
    \ lst, lst3\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvx_8nbl5_test.go:47:17:\
    \ too many return values\n\thave ([]string, []string)\n\twant ([]string)\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074709
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var count1 int = 0\n    var count2 int = 0\n\
    \    for _, v := range lst1 {\n        count1 += len(v)\n    }\n    for _, v :=\
    \ range lst2 {\n        count2 += len(v)\n    }\n    if count1 < count2 {\n  \
    \      return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpavoa2pzl_test.go:59: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074709
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    total1 := 0\n    total2 := 0\n    for _, v :=\
    \ range lst1 {\n        total1 += len(v)\n    }\n    for _, v := range lst2 {\n\
    \        total2 += len(v)\n    }\n    if total1 <= total2 {\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074710
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var res []string\n    if len(lst1) == 0 || len(lst2)\
    \ == 0 {\n        return res\n    }\n    count1 := 0\n    count2 := 0\n    for\
    \ _, word := range lst1 {\n        count1 += len(word)\n    }\n    for _, word\
    \ := range lst2 {\n        count2 += len(word)\n    }\n    if count1 < count2\
    \ {\n        return lst1\n    } else {\n        return lst2\n    }\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp2fmcg37w_test.go:63: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074710
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n\tlenLst1 := 0\n\tlenLst2 := 0\n\tfor _, str := range\
    \ lst1 {\n\t\tlenLst1 += len(str)\n\t}\n\tfor _, str := range lst2 {\n\t\tlenLst2\
    \ += len(str)\n\t}\n\tif lenLst1 > lenLst2 {\n\t\treturn lst2\n\t}\n\treturn lst1\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074710
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n\tif len(lst1) == 0 && len(lst2) == 0 {\n\t\treturn\
    \ []string{}\n\t}\n\tvar firstCount int\n\tvar secondCount int\n\tfor _, l :=\
    \ range lst1 {\n\t\tfirstCount += len(l)\n\t}\n\tfor _, l := range lst2 {\n\t\t\
    secondCount += len(l)\n\t}\n\tif firstCount < secondCount {\n\t\treturn lst1\n\
    \t}\n\treturn lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate :=\
    \ total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp5e2yleio_test.go:61: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074710
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return nil\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpsusl3td6_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpsusl3td6_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpsusl3td6_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var count1, count2 int\n    for _, v := range\
    \ lst1 {\n        count1 += len(v)\n    }\n    for _, v := range lst2 {\n    \
    \    count2 += len(v)\n    }\n    if count1 < count2 {\n        return lst1\n\
    \    } else {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp3js3jgta_test.go:58: expected '[hi admin]', got '[hI hi\
    \ hii]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074710
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    return []string{}\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp8lbgnqqn_test.go:47: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp8lbgnqqn_test.go:47: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp8lbgnqqn_test.go:47: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074520
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := lst1\n    lst1_sum := 0\n    lst2_sum\
    \ := 0\n    for _, v := range lst1 {\n        lst1_sum += len(v)\n    }\n    for\
    \ _, v := range lst2 {\n        lst2_sum += len(v)\n    }\n    if lst1_sum > lst2_sum\
    \ {\n        result = lst2\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660074710
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n\tif len(lst1) == 0 && len(lst2) == 0 {\n\t\treturn\
    \ []string{}\n\t}\n\n\tlength1 := total_length(lst1)\n\tlength2 := total_length(lst2)\n\
    \n\tif length1 == length2 {\n\t\treturn lst1\n\t}\n\n\tif length1 < length2 {\n\
    \t\treturn lst1\n\t}\n\n\treturn lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptau_bcuw_test.go:27:13: undefined: total_length

    /tmp/tmptau_bcuw_test.go:28:13: undefined: total_length

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074710
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst1\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst2\n    }\n    total1 := 0\n \
    \   total2 := 0\n    for _, val := range lst1 {\n        total1 += len(val)\n\
    \    }\n    for _, val := range lst2 {\n        total2 += len(val)\n    }\n  \
    \  if total1 == total2 {\n        return lst1\n    }\n    if total1 < total2 {\n\
    \        return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074710
- exit_code: 0
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    sum1 := 0\n    sum2 := 0\n    //iterate over\
    \ strings in lst1, calculating sum of lengths\n    for _, v := range lst1 {\n\
    \        // fmt.Println(v)\n        sum1 += len(v)\n    }\n    //iterate over\
    \ strings in lst2, calculating sum of lengths\n    for _, v := range lst2 {\n\
    \        // fmt.Println(v)\n        sum2 += len(v)\n    }\n    //return the list\
    \ with the smallest sum\n    if sum1 <= sum2 {\n        return lst1\n    } else\
    \ {\n        return lst2\n    }\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074710
