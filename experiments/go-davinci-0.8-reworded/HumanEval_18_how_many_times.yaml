name: HumanEval_18_how_many_times
language: go_test.go
prompt: "package how_many_times_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
  \n// Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\n// >>> how_many_times(\"\", \"a\")\n// 0\n// >>> how_many_times(\"\
  aaa\", \"a\")\n// 3\n// >>> how_many_times(\"aaaa\", \"aa\")\n// 3\nfunc how_many_times(myString\
  \ string, substring string) int {\n"
tests: "func TestHow_Many_Times(t *testing.T) {\n  candidate := how_many_times\n\t\
  type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n  \
  \ tests := []test{\n     { actual: candidate(\"\", \"x\"), expected: 0 },\n    \
  \ { actual: candidate(\"xyxyxyx\", \"x\"), expected: 4 },\n     { actual: candidate(\"\
  cacacacac\", \"cac\"), expected: 4 },\n     { actual: candidate(\"john doe\", \"\
  john\"), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if len(substring) > len(myString) {\n        return 0\n    }\n\
    \    return how_many_times_recursive(myString, substring, 0)\n}\n", "    if myString\
    \ == \"\" || substring == \"\" {\n        return 0\n    }\n\n    count := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        if myString[i] == substring[0]\
    \ {\n            if len(myString) - i >= len(substring) {\n                if\
    \ myString[i:i+len(substring)] == substring {\n                    count += 1\n\
    \                }\n            }\n        }\n    }\n    return count\n}\n", " \
    \   return 0\n}\n", "    times := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        if myString[i] == substring[0] {\n            for j := 0; j < len(substring);\
    \ j++ {\n                if i + j == len(myString) {\n                    return\
    \ times\n                }\n                if myString[i + j] != substring[j]\
    \ {\n                    break\n                }\n                if j == len(substring)\
    \ - 1 {\n                    times++\n                }\n            }\n     \
    \   }\n    }\n    return times\n}\n", "    count := 0\n    for i := 0; i <= len(myString)\
    \ - len(substring); i++ {\n        if myString[i:i+len(substring)] == substring\
    \ {\n            count++\n        }\n    }\n    return count\n}\n", "    if len(substring)\
    \ == 0 {\n        return 0\n    }\n    var count int = 0\n    for i := 0; i <\
    \ len(myString); i++ {\n        if myString[i] == substring[0] {\n           \
    \ for j := 0; j < len(substring); j++ {\n                if myString[i+j] != substring[j]\
    \ {\n                    break\n                }\n                if j == len(substring)-1\
    \ {\n                    count++\n                }\n            }\n        }\n\
    \    }\n    return count\n}\n", "    // split the strings in slices by each character\n\
    \    myStringSlice := strings.Split(myString, \"\")\n    substringSlice := strings.Split(substring,\
    \ \"\")\n    // the length of the substring\n    var subLen int = len(substringSlice)\n\
    \    // the length of the string\n    var strLen int = len(myStringSlice)\n  \
    \  // number of times substring is found\n    var counter int = 0\n    // loop\
    \ through all indexes of myStringSlice\n    for i := 0; i < strLen; i++ {\n  \
    \      // index of the first character in the substring\n        var subIndex\
    \ int = 0\n        // loop through all indexes in the substringSlice\n       \
    \ for j := i; j < strLen; j++ {\n            // if we are at the last character\
    \ in the substring, then we found the substring\n            if subIndex == subLen\
    \ {\n                counter++\n                break\n            }\n       \
    \     // if the current character in myStringSlice matches the current character\
    \ in substringSlice, we move on\n            if myStringSlice[j] == substringSlice[subIndex]\
    \ {\n                subIndex++\n            } else {\n                break\n\
    \            }\n        }\n    }\n    return counter\n}\n", "    // your code\
    \ goes here\n    var count int\n    for _, v := range myString {\n        if string(v)\
    \ == substring {\n            count++\n        }\n    }\n    return count\n}\n",
  "    counter := 0\n    for i := 0; i <= len(myString) - len(substring); i++ {\n\
    \        if myString[i: i + len(substring)] == substring {\n            counter++\n\
    \        }\n    }\n    return counter\n}\n", "    if len(substring) > len(myString)\
    \ {\n        return 0\n    }\n\n    result := 0\n    for pos := 0; pos < len(myString);\
    \ pos++ {\n        if myString[pos:pos+len(substring)] == substring {\n      \
    \      result++\n        }\n    }\n    return result\n}\n", "    counter := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        if myString[i] == substring[0]\
    \ {\n            isFound := true\n            for j := 0; j < len(substring);\
    \ j++ {\n                if myString[i+j] != substring[j] {\n                \
    \    isFound = false\n                    break\n                }\n         \
    \   }\n            if isFound {\n                counter++\n            }\n  \
    \      }\n    }\n    return counter\n}\n", "    n := 0\n    for i := 0; i <= len(myString)\
    \ - len(substring); i++ {\n        for j := 0; j < len(substring); j++ {\n   \
    \         if myString[i + j] != substring[j] {\n                break\n      \
    \      }\n            if j == len(substring) - 1 {\n                n++\n    \
    \        }\n        }\n    }\n    return n\n}\n", "    return 0\n}\n", "    count\
    \ := 0\n    var f = func (c rune) bool {\n        count += 1\n        return false\n\
    \    }\n    for {\n        count := 0\n        if index := IndexFunc(myString,\
    \ f); index == -1 {\n            break\n        } else {\n            count +=\
    \ 1\n            myString = myString[index + 1:]\n        }\n    }\n    return\
    \ count\n}\n", "    if len(substring) == 0 {\n        return 0\n    }\n    j :=\
    \ 0\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == substring[j]\
    \ {\n            j++\n            if j == len(substring) {\n                j\
    \ = 0\n            }\n        } else {\n            j = 0\n        }\n    }\n\
    \    return j\n}\n", "    var cnt int\n    for i := 0; i < len(myString); i++\
    \ {\n        for j := 0; j < len(substring); j++ {\n            // If the string\
    \ does not match, we can break the inner loop.\n            if substring[j] !=\
    \ myString[i+j] {\n                break\n            }\n\n            // If we\
    \ reached the end of the string.\n            if j == len(substring)-1 {\n   \
    \             cnt++\n            }\n        }\n    }\n    return cnt\n}\n", " \
    \   var count int\n    for index := range myString {\n        if myString[index:index+len(substring)]\
    \ == substring {\n            count++\n        }\n    }\n    return count\n}\n",
  "    howMany := 0\n    for i := 0; i < len(myString); i++ {\n        currentString\
    \ := myString[i:]\n        if len(currentString) < len(substring) {\n        \
    \    break\n        }\n        if string(currentString[0]) == string(substring[0])\
    \ {\n            matchFound := true\n            for j := 1; j < len(substring);\
    \ j++ {\n                if currentString[j] != substring[j] {\n             \
    \       matchFound = false\n                    break\n                }\n   \
    \         }\n            if matchFound {\n                howMany++\n        \
    \    }\n        }\n    }\n    return howMany\n}\n", "    var n int\n    n = 0\n\
    \    for i := 0; i < len(myString) - len(substring) + 1; i++ {\n        if myString[i:i+len(substring)]\
    \ == substring {\n            n++\n        }\n    }\n    return n\n}\n", "   \
    \ if myString == \"\" || substring == \"\" {\n        return 0\n    }\n\n    count\
    \ := 0\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == substring[0]\
    \ {\n            found := true\n            for j := 1; j < len(substring); j++\
    \ {\n                if len(myString) <= i + j || myString[i + j] != substring[j]\
    \ {\n                    found = false\n                    break\n          \
    \      }\n            }\n            if found {\n                count++\n   \
    \         }\n        }\n    }\n    return count\n}\n", "    times := 0\n    for\
    \ i := 0; i < len(myString); i++ {\n        for j := 0; j < len(substring); j++\
    \ {\n            if myString[i+j] != substring[j] {\n                break\n \
    \           }\n            if j == len(substring) - 1 {\n                times++\n\
    \            }\n        }\n    }\n    return times\n}\n", "    count := 0\n  \
    \  for i := 0; i < len(myString); i++ {\n        if myString[i:i+len(substring)]\
    \ == substring {\n            count++\n        }\n    }\n    return count\n}\n",
  "    count := 0\n    subLength := len(substring)\n    for i := 0; i < len(myString);\
    \ i++ {\n        if myString[i:i+subLength] == substring {\n            count++\n\
    \        }\n    }\n    return count\n}\n", "    // brute force\n    count := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        if myString[i] == substring[0]\
    \ {\n            matched := true\n            for j := 1; j < len(substring);\
    \ j++ {\n                if (i + j) == len(myString) {\n                    matched\
    \ = false\n                    break\n                }\n                if myString[i\
    \ + j] != substring[j] {\n                    matched = false\n              \
    \      break\n                }\n            }\n            if matched {\n   \
    \             count++\n            }\n        }\n    }\n    return count\n}\n",
  "    res := 0\n    for i:=0; i<len(myString); i++ {\n        for j:=0; j<len(substring);\
    \ j++ {\n            //fmt.Println(i,j,i+j,len(myString),len(substring))\n   \
    \         if myString[i+j] == substring[j] {\n                if j == len(substring)-1\
    \ {\n                    res += 1\n                }\n            } else {\n \
    \               break\n            }\n        }\n    }\n    return res\n}\n",
  "    times := 0\n    for i := 0; i <= len(myString)-len(substring); i++ {\n    \
    \    if myString[i:i+len(substring)] == substring {\n            times++\n   \
    \     }\n    }\n    return times\n}\n", "    count := 0\n    currIndex := 0\n\
    \    for {\n        currIndex = strings.Index(myString[currIndex:], substring)\n\
    \        if currIndex == -1 {\n            break\n        }\n        count++\n\
    \        currIndex++\n    }\n    return count\n}\n", "    if len(substring) ==\
    \ 0 {\n        return 0\n    }\n    start := 0\n    occurrences := 0\n    for\
    \ {\n        index := start\n        end := index + len(substring)\n        if\
    \ end > len(myString) {\n            break\n        }\n        if myString[index:end]\
    \ == substring {\n            occurrences++\n            start = index + 1\n \
    \       } else {\n            start++\n        }\n    }\n    return occurrences\n\
    }\n", "    return how_many_times_recursive(myString, substring, 0)\n}\n", "  \
    \  count := 0\n    stringLength := len(myString)\n    substringLength := len(substring)\n\
    \    for i := 0; i < stringLength; i++ {\n        if myString[i] == substring[0]\
    \ {\n            if stringLength - i >= substringLength {\n                if\
    \ myString[i:i+substringLength] == substring {\n                    count++\n\
    \                }\n            }\n        }\n    }\n    return count\n}\n", " \
    \   if myString == \"\" || substring == \"\" {\n        return 0\n    }\n    count\
    \ := 0\n    for j := 0; j < len(myString); j++ {\n        if myString[j] == substring[0]\
    \ {\n            count += checkString(myString, substring, j)\n        }\n   \
    \ }\n    return count\n}\n", "    // your code here\n    count := 0\n    slen\
    \ := len(substring)\n    for i := 0; i < len(myString); i++ {\n        if myString[i:i+slen]\
    \ == substring {\n            count++\n        }\n    }\n    return count\n}\n",
  "    return 0\n}\n", "    var last_match int = -1\n    var count int = 0\n    for\
    \ i := 0; i < len(myString); i++ {\n        if myString[i] == substring[0] {\n\
    \            if myString[i:i+len(substring)] == substring {\n                count\
    \ += 1\n                last_match = i + len(substring)\n            }\n     \
    \   }\n    }\n    return count\n}\n", "    count := 0\n    for len(myString) >\
    \ 0 {\n        if myString[0] == substring[0] {\n            // Check if the next\
    \ chars equals the substring\n            if myString[:len(substring)] == substring\
    \ {\n                count++\n            }\n        }\n        myString = myString[1:]\n\
    \    }\n    return count\n}\n", "    counter := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        if i + len(substring) <= len(myString) {\n            if myString[i:i+len(substring)]\
    \ == substring {\n                counter++\n            }\n        }\n    }\n\
    \    return counter\n}\n", "    if len(substring) == 0 {\n        return 0\n \
    \   }\n\n    var result int = 0\n    var tmp int = 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        tmp = 0\n        for j := 0; j < len(substring); j++ {\n    \
    \        if i + j < len(myString) && myString[i + j] == substring[j] {\n     \
    \           tmp += 1\n            } else {\n                break\n          \
    \  }\n        }\n        if tmp == len(substring) {\n            result += 1\n\
    \        }\n    }\n    return result\n}\n", "    matches := 0\n    for i := 0;\
    \ i < len(myString); i++ {\n        if string(myString[i]) == string(substring[0])\
    \ {\n            sub_match := true\n            for j := 1; j < len(substring);\
    \ j++ {\n                if string(myString[i+j]) != string(substring[j]) {\n\
    \                    sub_match = false\n                    break\n          \
    \      }\n            }\n            if sub_match {\n                matches++\n\
    \            }\n        }\n    }\n    return matches\n}\n", "    c := 0\n    for\
    \ i := 0; i < len(myString); i++ {\n        if myString[i:i+len(substring)] ==\
    \ substring {\n            c++\n        }\n    }\n    return c\n}\n", "    //\
    \ your code here\n    return 0\n}\n", "    fmt.Println(myString)\n    fmt.Println(substring)\n\
    \    if myString == \"\" {\n        return 0\n    }\n    stringLen := len(myString)\n\
    \    substrLen := len(substring)\n    if substrLen == 0 {\n        return 0\n\
    \    }\n\n    if substrLen == 1 {\n        counter := 0\n        for _, v := range\
    \ myString {\n            if string(v) == substring {\n                counter\
    \ += 1\n            }\n        }\n        return counter\n    }\n\n    if substrLen\
    \ > stringLen {\n        return 0\n    }\n\n    counter := 0\n    for i := 0;\
    \ i < stringLen; i++ {\n        if string(myString[i]) == string(substring[0])\
    \ {\n            if string(myString[i:i+substrLen]) == substring {\n         \
    \       counter += 1\n            }\n        }\n    }\n    return counter\n}\n",
  "    var count int = 0\n    if len(substring) == 0 {\n        return count\n   \
    \ }\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == substring[0]\
    \ {\n            index := i + 1\n            indexString := 1\n            for\
    \ indexString < len(substring) && index < len(myString) {\n                if\
    \ myString[index] == substring[indexString] {\n                    index++\n \
    \                   indexString++\n                } else {\n                \
    \    break\n                }\n            }\n            if indexString == len(substring)\
    \ {\n                count++\n            }\n        }\n    }\n    return count\n\
    }\n", "    count := 0\n    if len(substring) > len(myString) {\n        return\
    \ count\n    }\n    for i := 0; i <= len(myString)-len(substring); i++ {\n   \
    \     //fmt.Println(myString[i:len(substring)+i])\n        if myString[i:len(substring)+i]\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n", "    count := 0\n    for i := 0; i < len(myString); i++ {\n        if len(myString[i:])\
    \ < len(substring) {\n            break\n        }\n        if myString[i:i+len(substring)]\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n", "    count := 0\n    for i := 0; i < len(myString); i++ {\n        j :=\
    \ 0\n        for j < len(substring) && i + j < len(myString) && myString[i + j]\
    \ == substring[j] {\n            j++\n        }\n        if j == len(substring)\
    \ {\n            count++\n        }\n    }\n    return count\n}\n\ntype testpair ",
  "    if myString == \"\" || substring == \"\" {\n        return 0\n    }\n\n   \
    \ count := 0\n    for index := range myString {\n        if len(myString) - index\
    \ >= len(substring) {\n            if myString[index : index + len(substring)]\
    \ == substring {\n                count += 1\n            }\n        }\n    }\n\
    \    return count\n}\n", "    count := 0\n    for len(myString) >= len(substring)\
    \ {\n        index := len(myString) - len(substring)\n        if myString[index:]\
    \ == substring {\n            count++\n        }\n        myString = myString[:index]\n\
    \    }\n    return count\n}\n", "    var matches, i int\n    if len(substring)\
    \ == 0 {\n        return 0\n    }\n    for i <= len(myString) - len(substring)\
    \ {\n        if myString[i:i+len(substring)] == substring {\n            matches++\n\
    \            i += len(substring)\n        } else {\n            i++\n        }\n\
    \    }\n    return matches\n}\n", "    timesFound := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        var j int\n        if i + len(substring) > len(myString) {\n\
    \            j = len(myString)\n        } else {\n            j = i + len(substring)\n\
    \        }\n        if myString[i:j] == substring {\n            timesFound++\n\
    \        }\n    }\n    return timesFound\n}\n", "    sum := 0\n    i := 0\n  \
    \  for i < len(myString) {\n        if myString[i] == substring[0] {\n       \
    \     sum++\n            i++\n        } else {\n            i++\n        }\n \
    \   }\n    return sum\n}\n", "    count := 0\n    if len(substring) == 0 {\n \
    \       return count\n    }\n    for i := 0; i < len(myString); i++ {\n      \
    \  if myString[i] == substring[0] {\n            var j int\n            for j\
    \ = 0; j < len(substring); j++ {\n                if i + j >= len(myString) ||\
    \ myString[i + j] != substring[j] {\n                    break\n             \
    \   }\n            }\n            if j == len(substring) {\n                count++\n\
    \            }\n        }\n    }\n    return count\n}\n", "    var count int =\
    \ 0\n    if len(substring) == 0 {\n        return count\n    }\n\n    // loop\
    \ through string by 1\n    for i := 0; i < len(myString); i++ {\n        // if\
    \ substring is found, increment count and add to i\n        if myString[i] ==\
    \ substring[0] {\n            match := true\n            k := 0\n            for\
    \ j := i; j < len(substring) + i; j++ {\n                if myString[j] != substring[k]\
    \ {\n                    match = false\n                    break\n          \
    \      }\n                k++\n            }\n            if match {\n       \
    \         count++\n                i += len(substring) - 1\n            }\n  \
    \      }\n    }\n    return count\n}\n", "    times := 0\n    if len(substring)\
    \ > len(myString) {\n        return times\n    }\n    for i := 0; i < len(myString);\
    \ i++ {\n        if string(myString[i]) == string(substring[0]) {\n          \
    \  if string(myString[i:i+len(substring)]) == substring {\n                times++\n\
    \            }\n        }\n    }\n    return times\n}\n", "    return -1\n}\n",
  "    count := 0\n    for i := 0; i < len(myString); i++ {\n        i1 := i\n   \
    \     i2 := 0\n        for ; i1 < len(myString) && i2 < len(substring); i1, i2\
    \ = i1+1, i2+1 {\n            if myString[i1] != substring[i2] {\n           \
    \     break\n            }\n        }\n        if i2 == len(substring) {\n   \
    \         count++\n        }\n    }\n    return count\n}\n", "    var count int\
    \ = 0\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == substring[0]\
    \ {\n            match := true\n            for j := 0; j < len(substring); j++\
    \ {\n                if myString[i+j] != substring[j] {\n                    match\
    \ = false\n                    break\n                }\n            }\n     \
    \       if match {\n                count++\n            }\n        }\n    }\n\
    \    return count\n}\n", "    i := 0\n    count := 0\n    for {\n        i = strings.Index(myString,\
    \ substring)\n        if i == -1 {\n            break\n        }\n        count\
    \ += 1\n        myString = myString[i+1:]\n    }\n    return count\n}\n", "  \
    \  count := 0\n    for i := 0; i < len(myString); i++ {\n        //fmt.Println(i)\n\
    \        if myString[i] == substring[0] {\n            //fmt.Println(\"matched\"\
    )\n            if len(substring) == 1 {\n                count++\n           \
    \ } else {\n                matched := true\n                for j := 1; j < len(substring);\
    \ j++ {\n                    if i + j >= len(myString) {\n                   \
    \     matched = false\n                        break\n                    }\n\
    \                    if myString[i + j] != substring[j] {\n                  \
    \      matched = false\n                        break\n                    }\n\
    \                }\n                if matched {\n                    count++\n\
    \                }\n            }\n        }\n    }\n    return count\n}\n", " \
    \   if len(substring) > len(myString) {\n        return 0\n    }\n    counter\
    \ := 0\n    for i := 0; i < len(myString); i++ {\n        part := myString[i:len(substring)+i]\n\
    \        if part == substring {\n            counter++\n        }\n    }\n   \
    \ return counter\n}\n", "    var count int = 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        if string(myString[i]) == string(substring[0]) {\n          \
    \  isFound := true\n            for j := 1; j < len(substring); j++ {\n      \
    \          if i + j >= len(myString) || string(myString[i + j]) != string(substring[j])\
    \ {\n                    isFound = false\n                    break\n        \
    \        }\n            }\n            if isFound {\n                count++\n\
    \            }\n        }\n    }\n    return count\n}\n", "    if myString ==\
    \ \"\" || substring == \"\" {\n        return 0\n    }\n    count := 0\n    for\
    \ i := 0; i < len(myString); i++ {\n        index := i\n        for j := 0; j\
    \ < len(substring); j++ {\n            if index > len(myString) - 1 {\n      \
    \          break\n            }\n            if substring[j] == myString[index]\
    \ {\n                index++\n            } else {\n                break\n  \
    \          }\n            if j == len(substring) - 1 {\n                count++\n\
    \            }\n        }\n    }\n    return count\n}\n", "    var count int\n\
    \    pos := 0\n    // What you can do with a slice, you can do with an array.\n\
    \    for pos + len(substring) < len(myString) {\n        if string(myString[pos:pos+len(substring)])\
    \ == substring {\n            count++\n            pos++\n        } else {\n \
    \           pos++\n        }\n    }\n    return count\n}\n", "    return 0\n}\n",
  "    var counter int = 0\n    for i := 0; i < len(myString) - len(substring) + 1;\
    \ i++ {\n        if substring == myString[i: i + len(substring)] {\n         \
    \   counter++\n        }\n    }\n    return counter\n}\n", "    count := 0\n \
    \   end := len(myString) - len(substring) + 1\n    for i := 0; i < end; i++ {\n\
    \        if myString[i:i+len(substring)] == substring {\n            count++\n\
    \        }\n    }\n    return count\n}\n", "    // Write your code here!\n   \
    \ return 0\n}\n", "    myStringSlice := []rune(myString)\n    substringSlice :=\
    \ []rune(substring)\n    count := 0\n    for i, l := 0, len(myStringSlice); i\
    \ < l; i++ {\n        if myStringSlice[i] == substringSlice[0] {\n           \
    \ j := 1\n            for i + j < l && j < len(substringSlice) && myStringSlice[i\
    \ + j] == substringSlice[j] {\n                j++\n            }\n          \
    \  if j == len(substringSlice) {\n                count++\n            }\n   \
    \     }\n    }\n    return count\n}\n", "    if myString == \"\" || substring\
    \ == \"\" {\n        return 0\n    }\n    index := 0\n    count := 0\n    for\
    \ index < len(myString) {\n        substring_index := 0\n        index2 := index\n\
    \        for substring_index < len(substring) && index2 < len(myString) {\n  \
    \          if myString[index2] == substring[substring_index] {\n             \
    \   substring_index += 1\n                index2 += 1\n            } else {\n\
    \                break\n            }\n        }\n        if substring_index ==\
    \ len(substring) {\n            count += 1\n        }\n        index += 1\n  \
    \  }\n    return count\n}\n", "    counter := 0\n    var j int = 0\n    for i\
    \ := 0; i < len(myString); i++ {\n        if myString[i] == substring[j] {\n \
    \           if j == len(substring) - 1 {\n                counter++\n        \
    \        j = 0\n            } else {\n                j++\n            }\n   \
    \     } else {\n            j = 0\n        }\n    }\n    return counter\n}\n",
  "    count := 0\n    if len(substring) > len(myString) {\n        return count\n\
    \    }\n    end := len(myString) - len(substring) + 1\n    for i := 0; i < end;\
    \ i++ {\n        if myString[i:i+len(substring)] == substring {\n            count++\n\
    \        }\n    }\n    return count\n}\n", "    k := len(substring)\n    n :=\
    \ len(myString)\n    var count int\n    for i := 0; i < n; i++ {\n        if i\
    \ + k <= n && myString[i:i+k] == substring {\n            count += 1\n       \
    \ }\n    }\n    return count\n}\n", "    fmt.Println(myString, substring)\n  \
    \  if len(substring) > len(myString) {\n        return 0\n    }\n    if len(substring)\
    \ == 0 {\n        return 0\n    }\n    if len(myString) == 0 {\n        return\
    \ 0\n    }\n    count := 0\n    for i := 0; i < len(myString); i++ {\n       \
    \ if myString[i] == substring[0] {\n            if i == len(myString) - 1 {\n\
    \                return count + 1\n            }\n            is_match := true\n\
    \            for j := 0; j < len(substring); j++ {\n                if myString[i\
    \ + j] != substring[j] {\n                    is_match = false\n             \
    \       break\n                }\n            }\n            if is_match {\n \
    \               count++\n            }\n        }\n    }\n    return count\n}\n",
  "    if len(substring) == 0 {\n        return 0\n    }\n    count := 0\n    for\
    \ i := 0; i < len(myString); i++ {\n        if myString[i] == substring[0] {\n\
    \            if len(substring) == 1 {\n                count++\n            }\
    \ else {\n                if myString[i + 1] == substring[1] {\n             \
    \       if len(substring) == 2 {\n                        count++\n          \
    \          } else {\n                        for j := 2; j < len(substring); j++\
    \ {\n                            if myString[i + j] != substring[j] {\n      \
    \                          break\n                            }\n            \
    \                if j == len(substring) - 1 {\n                              \
    \  count++\n                            }\n                        }\n       \
    \             }\n                }\n            }\n        }\n    }\n    return\
    \ count\n}\n", "    return -1\n}\n", "    if substring == \"\" {\n        return\
    \ 0\n    }\n    var result = 0\n    for i := 0; i < len(myString) - len(substring)\
    \ + 1; i++ {\n        for j := 0; j < len(substring); j++ {\n            if myString[i\
    \ + j] != substring[j] {\n                break\n            }\n            if\
    \ j == len(substring) - 1 {\n                result++\n            }\n       \
    \ }\n    }\n    return result\n}\n", "    if len(substring) > len(myString) {\n\
    \        return 0\n    }\n    if len(substring) == len(myString) {\n        if\
    \ myString == substring {\n            return 1\n        } else {\n          \
    \  return 0\n        }\n    }\n    count := 0\n    for i:=0; i < len(myString);\
    \ i++ {\n        if myString[i] == substring[0] {\n            if len(substring)\
    \ == 1 {\n                count++\n            } else {\n                found\
    \ := true\n                for j:=1; j < len(substring); j++ {\n             \
    \       if i+j >= len(myString) {\n                        found = false\n   \
    \                     break\n                    }\n                    if myString[i+j]\
    \ != substring[j] {\n                        found = false\n                 \
    \       break\n                    }\n                }\n                if found\
    \ {\n                    count++\n                }\n            }\n        }\n\
    \    }\n    return count\n}\n", "    var count int = 0\n    for i:=0; i<len(myString);\
    \ i++ {\n        if myString[i] == substring[0] {\n            for j:=0; j<len(substring);\
    \ j++ {\n                if i+j >= len(myString) {\n                    break\n\
    \                }\n                if myString[i+j] != substring[j] {\n     \
    \               break\n                }\n                if j == len(substring)-1\
    \ {\n                    count += 1\n                }\n            }\n      \
    \  }\n    }\n    return count\n}\n", "    return -1\n}\n", "    var count int\
    \ = 0\n    var index int = 0\n    var origLen = len(myString)\n    var subLen\
    \ = len(substring)\n    var maxIndex = origLen - subLen\n    for index <= maxIndex\
    \ {\n        if myString[index:index+subLen] == substring {\n            count++\n\
    \            index += subLen\n        } else {\n            index++\n        }\n\
    \    }\n    return count\n}\n", "    return len(find_all_substrings(myString,\
    \ substring))\n}\n", "    var count int = 0\n    var i int = 0\n    var max int\
    \ = len(myString)\n    var subStringLen int = len(substring)\n    var subStringMax\
    \ int = max - subStringLen\n    var found bool = false\n    for i < subStringMax\
    \ && !found {\n        found = true\n        for j := 0; j < subStringLen; j++\
    \ {\n            if myString[i + j] != substring[j] {\n                found =\
    \ false\n                break\n            }\n        }\n        if found {\n\
    \            count++\n            i += subStringLen\n        } else {\n      \
    \      i++\n        }\n    }\n    return count\n}\n", "    count := 0\n    subLength\
    \ := len(substring)\n    for i := 0; i < len(myString); i++ {\n        if myString[i]\
    \ == substring[0] {\n            sub := myString[i : i + subLength]\n        \
    \    if sub == substring {\n                count++\n            }\n        }\n\
    \    }\n    return count\n}\n", "    startIndex := 0\n    result := 0\n    if\
    \ substring == \"\" {\n        return 0\n    }\n    for true {\n        i := findSubString(myString,\
    \ substring, startIndex)\n        if i >= 0 {\n            result += 1\n     \
    \       startIndex = i + 1\n        } else {\n            break\n        }\n \
    \   }\n    return result\n}\n", "    return len(myString)\n}\n", "    times :=\
    \ 0\n    index := 0\n    for {\n        if index = strings.Index(myString, substring);\
    \ index != -1 {\n            times++\n            if len(myString) == len(substring)\
    \ {\n                break\n            }\n            myString = myString[index+1:]\n\
    \        } else {\n            break\n        }\n    }\n    return times\n}\n",
  "    current := 0\n    count := 0\n    for i := 0; i < len(myString); i++ {\n  \
    \      if myString[i] == substring[current] {\n            current++\n       \
    \     if current == len(substring) {\n                count++\n              \
    \  current = 0\n            }\n        } else {\n            current = 0\n   \
    \     }\n    }\n    return count\n}\n", "    count := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        if myString[i] == substring[0] {\n            // Start finding\
    \ substring\n            index := i\n            found := true\n            for\
    \ j := 0; j < len(substring); j++ {\n                if index == len(myString)\
    \ || myString[index] != substring[j] {\n                    found = false\n  \
    \                  break\n                }\n                index++\n       \
    \     }\n            if found {\n                count++\n            }\n    \
    \    }\n    }\n    return count\n}\n", "    cnt := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        if myString[i] == substring[0] {\n            if len(myString)\
    \ - i < len(substring) {\n                return cnt\n            }\n        \
    \    tmp := i\n            found := true\n            for j := 0; j < len(substring);\
    \ j++ {\n                if myString[tmp] != substring[j] {\n                \
    \    found = false\n                    break\n                }\n           \
    \     tmp++\n            }\n            if found {\n                cnt++\n  \
    \          }\n        }\n    }\n    return cnt\n}\n", "    return 0\n}\n", " \
    \   count := 0\n    if substring == \"\" {\n        return count\n    }\n    if\
    \ len(myString) < len(substring) {\n        return count\n    }\n    for i :=\
    \ 0; i < len(myString) - len(substring) + 1; i++ {\n        if myString[i:i+len(substring)]\
    \ == substring {\n            count += 1\n        }\n    }\n    return count\n\
    }\n", "\tvar count int\n\tvar index int\n\tfor index <= len(myString) - len(substring)\
    \ {\n\t\tif myString[index:index+len(substring)] == substring {\n\t\t\tcount++\n\
    \t\t\tindex += len(substring)\n\t\t} else {\n\t\t\tindex++\n\t\t}\n\t}\n\treturn\
    \ count\n}\n", "\tif len(substring) > len(myString) {\n\t\treturn 0\n\t}\n\tamount\
    \ := 0\n\tfor i := 0; i < len(myString); i++ {\n\t\tif myString[i] == substring[0]\
    \ {\n\t\t\tsubs := myString[i:i+len(substring)]\n\t\t\tif subs == substring {\n\
    \t\t\t\tamount++\n\t\t\t}\n\t\t}\n\t}\n\treturn amount\n}\n", "    var substring_len\
    \ int = len(substring)\n    var myString_len int = len(myString)\n    var occurrences\
    \ int = 0\n    for index := 0; index < myString_len - substring_len + 1; index++\
    \ {\n        var i int = 0\n        for i = 0; i < substring_len; i++ {\n    \
    \        if substring[i] != myString[index + i] {\n                break\n   \
    \         }\n        }\n        if i == substring_len {\n            occurrences++\n\
    \        }\n    }\n    return occurrences\n}\n", "    // base case: no substring,\
    \ no matches\n    if len(substring) == 0 {\n        return 0\n    }\n    // edge\
    \ case: substring length greater than myString length, can't match\n    if len(substring)\
    \ > len(myString) {\n        return 0\n    }\n    // base case: substring length\
    \ == myString length, match if equal\n    if len(substring) == len(myString) {\n\
    \        if myString == substring {\n            return 1\n        } else {\n\
    \            return 0\n        }\n    }\n    // how many times does substring\
    \ match myString when ignoring the last byte\n    count := how_many_times(myString[:len(myString)-1],\
    \ substring)\n    // handle the case where substring matches myString ending in\
    \ the last byte\n    if myString[len(myString)-len(substring):] == substring {\n\
    \        count += 1\n    }\n    return count\n}\n", "    return 0\n}\n", "   \
    \ answer := 0\n    for i := 0; i <= len(myString)-len(substring); i++ {\n    \
    \    if myString[i:i+len(substring)] == substring {\n            answer += 1\n\
    \        }\n    }\n    return answer\n}\n", "    return 0\n}\n", "    substringLength\
    \ := len(substring)\n    substringCount := 0\n    for i := 0; i < len(myString)\
    \ - substringLength + 1; i++ {\n        if substring == myString[i:i+substringLength]\
    \ {\n            substringCount++\n        }\n    }\n    return substringCount\n\
    }\n", "    var c int\n    var i int\n    for i = 0; i < len(myString) - len(substring)\
    \ + 1; i++ {\n        if myString[i:i+len(substring)] == substring {\n       \
    \     c++\n        }\n    }\n    return c\n}\n", "    times := 0\n    for i:=0;\
    \ i<len(myString); i++ {\n        if myString[i] == substring[0] {\n         \
    \   // check if it's a match\n            matched := true\n            for j:=1;\
    \ j<len(substring); j++ {\n                if i+j >= len(myString) || myString[i+j]\
    \ != substring[j] {\n                    matched = false\n                   \
    \ break\n                }\n            }\n            if matched {\n        \
    \        times++\n            }\n        }\n    }\n    return times\n}\n", " \
    \   if len(substring) == 0 {\n        return 0\n    }\n    if len(myString) ==\
    \ 0 {\n        return 0\n    }\n    var counter int = 0\n    var substringLength\
    \ int = len(substring)\n    var startIndex int = 0\n    var endIndex int = substringLength\n\
    \    var nextStartIndex int = 0\n    for nextStartIndex < len(myString) {\n  \
    \      if nextStartIndex == 0 {\n            if myString[startIndex:endIndex]\
    \ == substring {\n                counter++\n            }\n        } else {\n\
    \            if myString[nextStartIndex:endIndex] == substring {\n           \
    \     counter++\n            }\n        }\n        nextStartIndex++\n        endIndex++\n\
    \    }\n    return counter\n}\n", "    count := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        if myString[i] == substring[0] {\n            if len(myString[i:])\
    \ >= len(substring) {\n                count += how_many_times(myString[i:], substring[1:])\n\
    \            }\n        }\n    }\n    if count == 0 {\n        if len(substring)\
    \ == 0 {\n            return 1\n        }\n    }\n    return count\n}\n", "  \
    \  return -1\n}\n", "    count := 0\n    for i:=0; i<=len(myString)-len(substring);\
    \ i++ {\n        if myString[i:i+len(substring)] == substring {\n            count++\n\
    \        }\n    }\n    return count\n}\n", "    myStringLength := len(myString)\n\
    \    substringLength := len(substring)\n    var result int = 0\n    var rest int\
    \ = myStringLength\n    for rest >= substringLength {\n        if myString[rest-substringLength:]\
    \ == substring {\n            result++\n        }\n        rest--\n    }\n   \
    \ return result\n}\n", "    return len([]rune(myString)) - len([]rune(myString))\
    \ + 1\n}\n", "    if len(substring) == 0 {\n        return 0\n    }\n    var count\
    \ int\n    for i := 0; i < len(myString); i++ {\n        if len(myString[i:])\
    \ >= len(substring) {\n            if myString[i:i+len(substring)] == substring\
    \ {\n                count += 1\n            }\n        }\n    }\n    return count\n\
    }\n", "    count := 0\n    p1 := 0\n    p2 := 0\n    strLen := len(myString)\n\
    \    subLen := len(substring)\n    for p1 < strLen && p2 < subLen {\n        if\
    \ myString[p1] == substring[p2] {\n            p2++\n        } else {\n      \
    \      p2 = 0\n        }\n        p1++\n        if p2 == subLen {\n          \
    \  count++\n            p2 = 0\n        }\n    }\n    return count\n}\n", "  \
    \  if len(substring) == 0 {\n        return 0\n    }\n\n    //fmt.Println(len(myString))\n\
    \    //fmt.Println(len(substring))\n    //fmt.Println(myString[:len(substring)])\n\
    \    //fmt.Println(substring)\n    if (len(myString) >= len(substring)) && (myString[:len(substring)]\
    \ == substring) {\n        return 1 + how_many_times(myString[1:], substring)\n\
    \    } else {\n        return how_many_times(myString[1:], substring)\n    }\n\
    }\n", "    count := 0\n    for i := 0; i <= len(myString) - len(substring); i++\
    \ {\n        if myString[i:i+len(substring)] == substring {\n            count++\n\
    \        }\n    }\n    return count\n}\n", "    if len(substring) == 0 {\n   \
    \     return 0\n    }\n\n    count := 0\n    if len(myString) > 0 {\n        for\
    \ i := 0; i < len(myString); i++ {\n            if myString[i] == substring[0]\
    \ {\n                j := 0\n                for j < len(substring) && i + j <\
    \ len(myString) && myString[i + j] == substring[j] {\n                    j++\n\
    \                }\n                if j == len(substring) {\n               \
    \     count++\n                }\n            }\n        }\n    }\n    return\
    \ count\n}\n", "    counter := 0\n    for i := 0; i < len(myString); i++ {\n \
    \       if myString[i:i+len(substring)] == substring {\n            counter +=\
    \ 1\n        }\n    }\n    return counter\n}\n", "    times := 0\n    c := 0\n\
    \    for i := 0; i < len(myString); i++ {\n        if string(myString[i]) == string(substring[c])\
    \ {\n            if c == 0 {\n                times++\n            }\n       \
    \     c++\n            if c == len(substring) {\n                c = 0\n     \
    \       }\n        } else {\n            c = 0\n        }\n    }\n    return times\n\
    }\n", "    return strings.Count(myString, substring)\n}\n", "    times := 0\n\
    \    for i := 0; i < len(myString) - len(substring) + 1; i++ {\n        if myString[i:i+len(substring)]\
    \ == substring {\n            times++\n        }\n    }\n    return times\n}\n",
  "    count := 0\n    for i := 0; i < len(myString); i++ {\n        if myString[i]\
    \ == substring[0] {\n            if myString[i:i+len(substring)] == substring\
    \ {\n                count++\n            }\n        }\n    }\n    return count\n\
    }\n", "    if len(substring) == 0 {\n        return 0\n    }\n    return how_many_times(myString[1:],\
    \ substring) + how_many_times(myString[:len(myString)-1], substring) + 1\n}\n",
  "    lengthOfSubstring := len(substring)\n    lengthOfString := len(myString)\n\
    \    counter := 0\n    for i := 0; i < lengthOfString; i++ {\n        if string(myString[i])\
    \ == string(substring[0]) {\n            if string(myString[i:i+lengthOfSubstring])\
    \ == substring {\n                counter++\n            }\n        }\n    }\n\
    \    return counter\n}\n", "    count := 0\n    search := 0\n    position := 0\n\
    \    sublen := len(substring)\n    myString_len := len(myString)\n    if sublen\
    \ == 0 {\n        return 0\n    }\n    for position < myString_len {\n       \
    \ search = position\n        for search < myString_len && search < (position +\
    \ sublen) {\n            if myString[search] == substring[search - position] {\n\
    \                search += 1\n            } else {\n                break\n  \
    \          }\n        }\n        if search == (position + sublen) {\n        \
    \    count += 1\n        }\n        position += 1\n    }\n    return count\n}\n",
  "    if substring == \"\" {\n        return 0\n    }\n    if len(myString) < len(substring)\
    \ {\n        return 0\n    }\n    times := 0\n    for i:=0; i<len(myString)-len(substring)+1;\
    \ i++ {\n        if myString[i:i+len(substring)] == substring {\n            times++\n\
    \        }\n    }\n    return times\n}\n", "    // Your code goes here!\n    return\
    \ 0\n}\n", "    count := 0\n    for i := 0; i < len(myString) - len(substring)\
    \ + 1; i++ {\n        if string(myString[i:i+len(substring)]) == substring {\n\
    \            count += 1\n        }\n    }\n    return count\n}\n", "    var res\
    \ int = 0\n    for i := 0; i < len(myString); i++ {\n        for j := 0; j < len(substring);\
    \ j++ {\n            if myString[i+j] != substring[j] {\n                break\n\
    \            }\n            if j == len(substring)-1 {\n                res++\n\
    \            }\n        }\n    }\n    return res\n}\n", "    if len(substring)\
    \ > len(myString) {\n        return 0\n    }\n\n    if len(substring) == 0 {\n\
    \        return 0\n    }\n\n    count := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        if string(myString[i]) == string(substring[0]) {\n          \
    \  if len(substring) == 1 {\n                count += 1\n            } else {\n\
    \                if len(myString) - i - 1 >= len(substring) - 1 {\n          \
    \          if myString[i:i+len(substring)] == substring {\n                  \
    \      count += 1\n                    }\n                }\n            }\n \
    \       }\n    }\n\n    return count\n}\n", "    if len(substring) > len(myString)\
    \ {\n        return 0\n    }\n    var substrings []string\n    var subCount int\n\
    \    var i int\n    var j int\n    for i = 0; i < len(myString); i++ {\n     \
    \   for j = 0; j < len(substring); j++ {\n            if myString[i + j] != substring[j]\
    \ {\n                break\n            }\n        }\n        if j == len(substring)\
    \ {\n            substrings = append(substrings, myString[i:i + j])\n        \
    \    subCount += 1\n        }\n    }\n    fmt.Println(substrings)\n    return\
    \ subCount\n}\n", "    var count int = 0\n    var lenSubstring int = len(substring)\n\
    \    var lenString int = len(myString)\n    for i := 0; i <= lenString - lenSubstring;\
    \ i++ {\n        if substring == myString[i:i+lenSubstring] {\n            count++\n\
    \        }\n    }\n    return count\n}\n", "    // your code here\n    return\
    \ 0\n}\n", "    if substring == \"\" {\n        return 0\n    }\n\n    count :=\
    \ 0\n    for len(myString) >= len(substring) {\n        if myString[:len(substring)]\
    \ == substring {\n            count++\n            myString = myString[1:]\n \
    \       } else {\n            myString = myString[1:]\n        }\n    }\n    return\
    \ count\n}\n", "    times := 0\n    j := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        if myString[i] == substring[j] {\n            j++\n         \
    \   if j == len(substring) {\n                times++\n                j = 0\n\
    \            }\n        } else {\n            j = 0\n        }\n    }\n    return\
    \ times\n}\n", "    count := 0\n    if len(substring) <= len(myString) {\n   \
    \     for i := 0; i < len(myString); i++ {\n            if myString[i] == substring[0]\
    \ {\n                if myString[i:i+len(substring)] == substring {\n        \
    \            count += 1\n                }\n            }\n        }\n    }\n\
    \    return count\n}\n", "    var count int\n    for i := 0; i < len(myString);\
    \ i++ {\n        if len(myString) < i + len(substring) {\n            break\n\
    \        }\n        j := 0\n        for ; j < len(substring); j++ {\n        \
    \    if myString[i + j] != substring[j] {\n                break\n           \
    \ }\n        }\n        if j == len(substring) {\n            count++\n      \
    \  }\n    }\n    return count\n}\n", "    count := 0\n    if len(substring) ==\
    \ 0 {\n        return count\n    }\n    for i := 0; i < len(myString); i++ {\n\
    \        if i + len(substring) <= len(myString) && myString[i:i+len(substring)]\
    \ == substring {\n            count++\n        }\n    }\n    return count\n}\n",
  "    return 0\n}\n", "    count := 0\n    if len(substring) > len(myString) {\n\
    \        return count\n    }\n\n    for i := 0; i < len(myString) - len(substring)\
    \ + 1; i++ {\n        if myString[i:i+len(substring)] == substring {\n       \
    \     count++\n        }\n    }\n    return count\n}\n", "    if len(substring)\
    \ > len(myString) {\n        return 0\n    }\n\n    count := 0\n    for {\n  \
    \      index := stringFind(myString, substring)\n        if index == -1 {\n  \
    \          break\n        }\n        count++\n        myString = myString[index+1:]\n\
    \    }\n    return count\n}\n", "    if len(substring) == 0 {\n        return\
    \ 0\n    }\n\n    var count int\n    for i:=0; i < len(myString); i++ {\n    \
    \    if myString[i] == substring[0] {\n            if len(substring) == 1 {\n\
    \                count++\n            } else {\n                for j:=1; j <\
    \ len(substring); j++ {\n                    if i+j >= len(myString) {\n     \
    \                   return count\n                    }\n\n                  \
    \  if myString[i+j] != substring[j] {\n                        break\n       \
    \             }\n\n                    if j == len(substring)-1 {\n          \
    \              count++\n                    }\n                }\n           \
    \ }\n        }\n    }\n\n    return count\n}\n", "    if substring == \"\" {\n\
    \        return 0\n    }\n    counter := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        if myString[i] == substring[0] {\n            counter += 1\n\
    \        }\n    }\n    return counter\n}\n", "    return -1\n}\n", "    return\
    \ 0\n}\n", "    count := 0\n    for i := 0; i <= len(myString) - len(substring);\
    \ i++ {\n        if myString[i: i + len(substring)] == substring {\n         \
    \   count++\n        }\n    }\n    return count\n}\n", "    var myStringLen =\
    \ len(myString)\n    var subStringLen = len(substring)\n    var counter = 0\n\
    \    for i := 0; i < myStringLen - subStringLen + 1; i++ {\n        if myString[i:i+subStringLen]\
    \ == substring {\n            counter += 1\n        }\n    }\n    return counter\n\
    }\n", "    if len(substring) == 0 {\n        return 0\n    }\n    if len(myString)\
    \ == 0 {\n        return 0\n    }\n    count := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        if i+len(substring) > len(myString) {\n            break\n  \
    \      }\n        if myString[i:i+len(substring)] == substring {\n           \
    \ count++\n        }\n    }\n    return count\n}\n", "    if len(substring) ==\
    \ 0 {\n        return 0\n    }\n\n    times := 0\n    for index := range myString\
    \ {\n        // if the length of the string remaining is less than the substring\
    \ length then the substring cannot be found\n        if len(myString) - index\
    \ >= len(substring) {\n            if myString[index:index+len(substring)] ==\
    \ substring {\n                times++\n            }\n        }\n    }\n    return\
    \ times\n}\n", "    counter := 0\n    for i := 0; i < len(myString); i++ {\n \
    \       curr := myString[i:i+len(substring)]\n        if curr == substring {\n\
    \            counter++\n        }\n    }\n    return counter\n}\n", "    count\
    \ := 0\n    for _, c := range myString {\n        if string(c) == substring {\n\
    \            count += 1\n        }\n    }\n    return count\n}\n", "    return\
    \ len(myString)\n}\n", "    var times int = 0\n    for i := 0; i <= len(myString)\
    \ - len(substring); i++ {\n        if myString[i:i+len(substring)] == substring\
    \ {\n            times += 1\n        }\n    }\n    return times\n}\n", "    if\
    \ len(substring) == 0 {\n        return 0\n    }\n    if len(myString) == 0 {\n\
    \        return 0\n    }\n    count := 0\n    start := 0\n    limit := len(myString)\
    \ - len(substring) + 1\n    for {\n        res := -1\n        if start > limit\
    \ {\n            break\n        }\n        res = findStrFrom(myString, substring,\
    \ start)\n        if res < 0 {\n            break\n        }\n        count +=\
    \ 1\n        start = res + 1\n    }\n    return count\n}\n", "    count := 0\n\
    \    for index := 0; index < len(myString); index++ {\n        if (myString[index]\
    \ == substring[0]) {\n            if (myString[index:index+len(substring)] ==\
    \ substring) {\n                count += 1\n            }\n        }\n    }\n\
    \    return count\n}\n", "    // your code here\n    return 0\n}\n", "    res\
    \ := 0\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == substring[0]\
    \ {\n            if len(myString[i:]) < len(substring) {\n                return\
    \ res\n            }\n            if myString[i:i+len(substring)] == substring\
    \ {\n                res++\n            }\n        }\n    }\n    return res\n\
    }\n", "    if myString == \"\" || substring == \"\" {\n        return 0\n    }\n\
    \    mySlice := []rune(myString)\n    mySubSlice := []rune(substring)\n    i :=\
    \ 0\n    j := 0\n    count := 0\n    for i < len(mySlice) {\n        if mySlice[i]\
    \ == mySubSlice[j] {\n            j++\n            if j == len(mySubSlice) {\n\
    \                count++\n                j = 0\n            }\n        } else\
    \ {\n            j = 0\n        }\n        i++\n    }\n    return count\n}\n",
  "    counter := 0\n    if len(substring) > len(myString) {\n        return counter\n\
    \    }\n    for i := 0; i < len(myString); i++ {\n        if myString[i] == substring[0]\
    \ {\n            currentLen := 1\n            for j := 1; j < len(substring);\
    \ j++ {\n                if i + j < len(myString) && myString[i + j] == substring[j]\
    \ {\n                    currentLen++\n                } else {\n            \
    \        break\n                }\n            }\n            if currentLen ==\
    \ len(substring) {\n                counter++\n            }\n        }\n    }\n\
    \    return counter\n}\n", "    n := 0\n    for i:=0; i<len(myString); i++ {\n\
    \        if myString[i] == substring[0] {\n            if substring == myString[i:i+len(substring)]\
    \ {\n                n++\n            }\n        }\n    }\n    return n\n}\n",
  "    count := 0\n    subStringLength := len(substring)\n    for i := 0; i < len(myString);\
    \ i++ {\n        // check if next set of characters match\n        if myString[i:i+subStringLength]\
    \ == substring {\n            count++\n        }\n    }\n    return count\n}\n",
  "    var count int = 0\n    var index int = 0\n    for index < len(myString) {\n\
    \        fmt.Println(myString[index:])\n        if myString[index:] == substring\
    \ {\n            count++\n        }\n        index++\n    }\n    return count\n\
    }\n", "    count := 0\n    for i := 0; i < len(myString); i++ {\n        if myString[i]\
    \ == substring[0] {\n            if myString[i : i + len(substring)] == substring\
    \ {\n                count++\n            }\n        }\n    }\n    return count\n\
    }\n", "    amount := 0\n    counter := 0\n    for {\n        if myString[counter:counter+1]\
    \ == substring[0:1] {\n            if myString[counter:counter+len(substring)]\
    \ == substring {\n                amount++\n            }\n        }\n       \
    \ counter++\n        if counter == len(myString) {\n            break\n      \
    \  }\n    }\n    return amount\n}\n", "    count := 0\n    remainingString :=\
    \ myString\n    for {\n        index := string.Index(remainingString, substring)\n\
    \        if index == -1 {\n            break\n        }\n        count++\n   \
    \     remainingString = remainingString[index+1:]\n    }\n    return count\n}\n",
  "    if len(substring) == 0 {\n        return 0\n    }\n    index := 0\n    count\
    \ := 0\n    for len(myString) > 0 {\n        index = string.Index(myString, substring)\n\
    \        if index == -1 {\n            break\n        }\n        count++\n   \
    \     myString = myString[index+1:]\n    }\n    return count\n}\n", "    if myString\
    \ == \"\" || substring == \"\" {\n        return 0\n    }\n\n    count := 0\n\
    \    for _, c := range myString {\n        if string(c) == string(substring[0])\
    \ {\n            count++\n        }\n    }\n\n    return count\n}\n", "    var\
    \ count int = 0\n    if len(substring) == 0 {\n        return count\n    }\n \
    \   for i := 0; i < len(myString); i++ {\n        if myString[i] == substring[0]\
    \ {\n            count += 1\n            for j := 1; j < len(substring); j++ {\n\
    \                if i + j < len(myString) && myString[i + j] == substring[j] {\n\
    \                    count += 1\n                } else {\n                  \
    \  count -= j\n                    break\n                }\n            }\n \
    \       }\n    }\n    return count\n}\n", "    count := 0\n    for i := 0; i <\
    \ len(myString); i++ {\n        for j := 0; j < len(substring); j++ {\n      \
    \      if i + j >= len(myString) {\n                return count\n           \
    \ }\n            if myString[i + j] != substring[j] {\n                break\n\
    \            }\n            if j == len(substring) - 1 {\n                count++\n\
    \            }\n        }\n    }\n    return count\n}\n", "    counter := 0\n\
    \    startingIndex := 0\n    for startingIndex != -1 {\n        startingIndex\
    \ = how_many_times_next(myString, substring, startingIndex)\n        if startingIndex\
    \ != -1 {\n            counter++\n            startingIndex += len(substring)\n\
    \        }\n    }\n    return counter\n}\n", "    var index int = 0\n    var count\
    \ int = 0\n    for index < len(myString) {\n        index = strings.Index(myString[index:],\
    \ substring)\n        if index >= 0 {\n            count += 1\n            index\
    \ += 1\n        } else {\n            break\n        }\n    }\n    return count\n\
    }\n", "    return len(myString) - len(myString) + 1\n}\n", "    count := 0\n \
    \   n := len(substring)\n    for i := 0; i < len(myString); i++ {\n        if\
    \ myString[i:i+n] == substring {\n            count++\n        }\n    }\n    return\
    \ count\n}\n", "    return 0\n}\n", "    var times int = 0\n    for i := 0; i\
    \ < len(myString); i++ {\n        for j := 0; j < len(substring); j++ {\n    \
    \        // fmt.Println(myString[i+j], substring[j])\n            if i+j > len(myString)-1\
    \ {\n                break\n            }\n            if myString[i+j] != substring[j]\
    \ {\n                break\n            }\n            if j == len(substring)-1\
    \ {\n                times++\n            }\n        }\n    }\n    return times\n\
    }\n", "    return nbr\n}\n", "    if len(substring) == 0 {\n        return 0\n\
    \    }\n    times := 0\n    for i := 0; i < len(myString); i++ {\n        if myString[i]\
    \ == substring[0] {\n            for j := 1; j < len(substring); j++ {\n     \
    \           if i + j >= len(myString) {\n                    return times\n  \
    \              }\n                if myString[i + j] != substring[j] {\n     \
    \               break\n                }\n                if j == len(substring)\
    \ - 1 {\n                    times++\n                }\n            }\n     \
    \   }\n    }\n    return times\n}\n", "    n := 0\n    index := 0\n    for index\
    \ < len(myString) {\n        index = strings.Index(myString[index:], substring)\n\
    \        if index != -1 {\n            n += 1\n            index += 1\n      \
    \  }\n    }\n    return n\n}\n", "    count := 0\n    // myString = \"aaaa\"\n\
    \    // substring = \"aa\"\n    // len(myString) = 4\n    // len(substring) =\
    \ 2\n    // 0 1 2 3\n    // a a a a\n    // a a     <- iterator\n\n    // 0 1\
    \ 2 3\n    // a a a a\n    //   a a   <- iterator\n\n    // 0 1 2 3\n    // a\
    \ a a a\n    //     a a <- iterator\n\n    for i := 0; i <= len(myString) - len(substring);\
    \ i++ {\n        part := myString[i:i+len(substring)]\n        if part == substring\
    \ {\n            count++\n        }\n    }\n    return count\n}\n", "    count\
    \ := 0\n    // Every time the substring is found, move the start point to the\
    \ end of the substring\n    for i := 0; i < len(myString); i++ {\n        if myString[i:i+len(substring)]\
    \ == substring {\n            count++\n            i += len(substring) - 1\n \
    \       }\n    }\n    return count\n}\n", "    str := myString\n    count := 0\n\
    \    for len(str) > 0 {\n        ind := str[0:1]\n        if ind == substring[0:1]\
    \ {\n            if len(str) >= len(substring) {\n                if str[0:len(substring)]\
    \ == substring {\n                    count += 1\n                    str = str[len(substring):]\n\
    \                } else {\n                    str = str[1:]\n               \
    \ }\n            } else {\n                str = str[1:]\n            }\n    \
    \    } else {\n            str = str[1:]\n        }\n    }\n    return count\n\
    }\n", "    // yoru code here\n    return 0\n}\n", "    total := 0\n    length\
    \ := len(substring)\n    for i := 0; i < len(myString); i++ {\n        if myString[i:i+length]\
    \ == substring {\n            total++\n        }\n    }\n    return total\n}\n",
  "    if len(substring) == 0 {\n        return 0\n    }\n\n    var count int = 0\n\
    \    for i := 0; i < len(myString); i++ {\n        if myString[i] == substring[0]\
    \ {\n            remainingString := myString[i:]\n            if len(remainingString)\
    \ < len(substring) {\n                continue\n            }\n            if\
    \ remainingString[:len(substring)] == substring {\n                count++\n \
    \           }\n        }\n    }\n    return count\n}\n", "    var count int =\
    \ 0\n    for myString != \"\" {\n        index := myString[1:].find(substring)\n\
    \        if index == -1 {\n            break\n        }\n        myString = myString[index+1:]\n\
    \        count++\n    }\n    return count\n}\n", "    return 0\n}\n", "    return\
    \ strings.Count(myString, substring)\n}\n", "    lenOrig := len(myString)\n  \
    \  lenSubstr := len(substring)\n    i := 0\n    count := 0\n    for i < lenOrig\
    \ {\n        if lenOrig - i < lenSubstr {\n            return count\n        }\n\
    \        if myString[i:i+lenSubstr] == substring {\n            count++\n    \
    \        i = i + lenSubstr\n        } else {\n            i++\n        }\n   \
    \ }\n    return count\n}\n", "\treturn strings.Count(myString, substring)\n}\n",
  "    count := 0\n    for i := 0; i < len(myString); i++ {\n        if myString[i]\
    \ == substring[0] {\n            found := true\n            for j := 0; j < len(substring);\
    \ j++ {\n                if substring[j] != myString[i+j] {\n                \
    \    found = false\n                    break\n                }\n           \
    \ }\n            if found {\n                count++\n            }\n        }\n\
    \    }\n    return count\n}\n", "    return 0\n}\n", "    var times = 0\n    var\
    \ maxIndex = len(myString) - len(substring)\n    for i := 0; i <= maxIndex; i++\
    \ {\n        if myString[i:i+len(substring)] == substring {\n            times++\n\
    \        }\n    }\n    return times\n}\n", "    var howManyTimes = 0\n    for\
    \ index := 0; index < len(myString); index++ {\n        if myString[index:index+len(substring)]\
    \ == substring {\n            howManyTimes += 1\n        }\n    }\n    return\
    \ howManyTimes\n}\n", "    res := 0\n    for i := 0; i <= len(myString) - len(substring);\
    \ i++ {\n        if myString[i:i+len(substring)] == substring {\n            res++\n\
    \        }\n    }\n    return res\n}\n", "    count := 0\n    for i := 0; i <\
    \ len(myString); i++ {\n        if myString[i:len(substring)+i] == substring {\n\
    \            count++\n        }\n    }\n    return count\n}\n", "    var times\
    \ int = 0\n    if len(substring) > len(myString) {\n        return times\n   \
    \ }\n    var begin int = 0\n    var end int = len(substring)\n    for (begin <\
    \ len(myString)) {\n        var sub = myString[begin:end]\n        if sub == substring\
    \ {\n            times++\n        }\n        begin++\n        end++\n    }\n \
    \   return times\n}\n", "    myCount := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        if myString[i] == substring[0] {\n            if i + len(substring)\
    \ <= len(myString) {\n                if substring == myString[i:i+len(substring)]\
    \ {\n                    myCount++\n                }\n            }\n       \
    \ }\n    }\n    return myCount\n}\n", "    times := 0\n    if myString == \"\"\
    \ || substring == \"\" {\n        return times\n    }\n    for index := 0; index\
    \ <= len(myString) - len(substring); index++ {\n        if myString[index:index+len(substring)]\
    \ == substring {\n            times += 1\n        }\n    }\n    return times\n\
    }\n", "    var answer int\n    for i := 0; i < len(myString); i++ {\n        for\
    \ j := 0; j < len(substring); j++ {\n            if i+j >= len(myString) {\n \
    \               break\n            }\n            if myString[i+j] != substring[j]\
    \ {\n                break\n            }\n            if j == len(substring)-1\
    \ {\n                answer++\n            }\n        }\n    }\n    return answer\n\
    }\n", "    return 0\n}\n", "    count := 0\n    for i := 0; i <= len(myString)-len(substring);\
    \ i++ {\n        if myString[i:i+len(substring)] == substring {\n            count++\n\
    \        }\n    }\n    return count\n}\n", "    var cnt int = 0\n    if len(substring)\
    \ > len(myString) {\n        return 0\n    }\n\n    var i int = 0\n    for {\n\
    \        var k int = i + len(substring)\n        if k > len(myString) {\n    \
    \        break\n        }\n        var sub string = myString[i:k]\n        if\
    \ sub == substring {\n            cnt++\n        }\n        i++\n    }\n    return\
    \ cnt\n}\n", "    count := 0\n    for i := 0; i < len(myString); i++ {\n     \
    \   if myString[i:i+len(substring)] == substring {\n            count++\n    \
    \    }\n    }\n    return count\n}\n", "    var count int\n    if len(substring)\
    \ == 0 {\n        return 0\n    }\n\n    for i := 0; i < len(myString) - len(substring)\
    \ + 1; i++ {\n        if myString[i:i+len(substring)] == substring {\n       \
    \     count++\n        }\n    }\n    return count\n}\n", "    var counter int\
    \ = 0\n    for i := 0; i < len(myString) - len(substring) + 1; i++ {\n       \
    \ if myString[i:i+len(substring)] == substring {\n            counter += 1\n \
    \       }\n    }\n    return counter\n}\n", "\tfound := 0\n\tfor i := 0; i <=\
    \ len(myString) - len(substring); i++ {\n\t\tif myString[i:i+len(substring)] ==\
    \ substring {\n\t\t\tfound++\n\t\t}\n\t}\n\treturn found\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
