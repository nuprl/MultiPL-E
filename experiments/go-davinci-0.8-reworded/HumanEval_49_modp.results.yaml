language: go_test.go
name: HumanEval_49_modp
results:
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // call with \"modp(2, 3)\"\n\
    \    var accumulator int\n    if n <= 0 {\n        accumulator = 1\n    } else\
    \ {\n        accumulator = 2\n    }\n    for n > 1 {\n        if n % 2 == 0 {\n\
    \            accumulator = (accumulator * accumulator) % p\n            n = n\
    \ / 2\n        } else {\n            accumulator = (accumulator * 2) % p\n   \
    \         n = n - 1\n        }\n    }\n    return accumulator\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpmi07wgkf_test.go:58: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpmi07wgkf_test.go:58: expected\
    \ '%!s(int=2)', got '%!s(int=25)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpmi07wgkf_test.go:58: expected '%!s(int=8)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpmi07wgkf_test.go:58: expected\
    \ '%!s(int=1)', got '%!s(int=33)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpmi07wgkf_test.go:58: expected '%!s(int=3)', got '%!s(int=4)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074887
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    result := 1\n    for i := 0;\
    \ i < n; i++ {\n        result = (result * 2) % p\n    }\n    return result\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074887
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n <= 1 {\n        return n\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp0xqn53gr_test.go:48: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp0xqn53gr_test.go:48: expected\
    \ '%!s(int=2)', got '%!s(int=61)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp0xqn53gr_test.go:48: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp0xqn53gr_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=2)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp0xqn53gr_test.go:48: expected '%!s(int=1)', got '%!s(int=78)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074887
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var (\n        result = 1\n \
    \       x = n\n    )\n    for x > 0 {\n        if x % 2 == 1 {\n            result\
    \ = (result * n) % p\n        }\n        n = (n * n) % p\n        x /= 2\n   \
    \ }\n    return result\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp4hcigjpm_test.go:53: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp4hcigjpm_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=91)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp4hcigjpm_test.go:53: expected '%!s(int=8)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp4hcigjpm_test.go:53: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp4hcigjpm_test.go:53: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074887
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // x = 2, y = n.\n    x := 2\n\
    \    y := n\n    // r = 1.\n    r := 1\n    // While y > 0.\n    for y > 0 {\n\
    \        // If y is odd.\n        if y % 2 == 1 {\n            // r = (r * x)\
    \ % p.\n            r = (r * x) % p\n        }\n        // y = y / 2.\n      \
    \  y = y / 2\n        // x = (x * x) % p.\n        x = (x * x) % p\n    }\n  \
    \  // Return r.\n    return r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074887
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp2ezsoeog_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp2ezsoeog_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    two := 2\n    if n == 0 {\n \
    \       return 1\n    }\n    if n == 1 {\n        return two\n    }\n    if n\
    \ % 2 == 0 {\n        tmp := modp(n/2, p)\n        return (tmp * tmp) % p\n  \
    \  }\n    return (2 * modp(n-1, p)) % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074887
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return n\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpl89i10ur_test.go:42: expected '%!s(int=2)', got '%!s(int=1101)'\n\
    \    --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpl89i10ur_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpl89i10ur_test.go:42: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpl89i10ur_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpl89i10ur_test.go:42: expected '%!s(int=4)', got '%!s(int=30)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpl89i10ur_test.go:42: expected\
    \ '%!s(int=3)', got '%!s(int=31)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074887
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    x := n % p\n    if x < 0 {\n\
    \        x += p\n    }\n    return x\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp13jcg65t_test.go:46: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmp13jcg65t_test.go:46: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp13jcg65t_test.go:46: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp13jcg65t_test.go:46: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp13jcg65t_test.go:46: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp13jcg65t_test.go:46: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074887
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    k := 1\n    for n > 0 {\n   \
    \     if n & 1 != 0 {\n            k = (k * n) % p\n        }\n        n = n >>\
    \ 1\n    }\n    return k\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgyg7b79y_test.go:49: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgyg7b79y_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpgyg7b79y_test.go:49: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpgyg7b79y_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpgyg7b79y_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074887
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // Compute 2^n modulo p.\n  \
    \  var power int = 1\n    for i := 0; i < n; i++ {\n        power = (power * 2)\
    \ % p\n    }\n    return power\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074887
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    return (modp(n/2, p) * modp(n-n/2, p)) % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0x0, 0x5)\n\
    \t/tmp/tmpvoaz9885_test.go:19 +0xb5 fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef715\n\
    command-line-arguments_test.modp(0x1, 0x5)\n\t/tmp/tmpvoaz9885_test.go:23 +0x3e\
    \ fp=0xc0201e03d8 sp=0xc0201e03a8 pc=0x4ef69e\ncommand-line-arguments_test.modp(0x1,\
    \ 0x5)\n\t/tmp/tmpvoaz9885_test.go:23 +0x5d fp=0xc0201e0408 sp=0xc0201e03d8 pc=0x4ef6bd\n\
    command-line-arguments_test.modp(0x1, 0x5)\n\t/tmp/tmpvoaz9885_test.go:23 +0x5d\
    \ fp=0xc0201e0438 sp=0xc0201e0408 pc=0x4ef6bd\ncommand-line-arguments_test.modp(0x1,\
    \ 0x5)\n\t/tmp/tmpvoaz9885_test.go:23 +0x5d fp=0xc0201e0468 sp=0xc0201e0438 pc=0x4ef6bd\n\
    command-line-arguments_test.modp(0x1, 0x5)\n\t/tmp/tmpvoaz9885_test.go:23 +0x5d\
    \ fp=0xc0201e0498 sp=0xc0201e0468 pc=0x4ef6bd\ncommand-line-arguments_test.modp(0x1,\
    \ 0x5)\n\t/tmp/tmpvoaz9885_test.go:23 +0x5d fp=0xc0201e04c8 sp=0xc0201e0498 pc=0x4ef6bd\n\
    command-line-arguments_test.modp(0x1, 0x5)\n\t/tmp/tmpvoaz9885_test.go:23 +0x5d\
    \ fp=0xc0201e04f8 sp=0xc0201e04c8 pc=0x4ef6bd\ncommand-line-arguments_test.modp(0x1,\
    \ 0x5)\n\t/tmp/tmpvoaz9885_test.go:23 +0x5d fp=0xc0201e0528 sp=0xc0201e04f8 pc=0x4ef6bd\n\
    command-line-arguments_test.modp(0x1, 0x5)\n\t/tmp/tmpvoaz9885_test.go:23 +0x5d\
    \ fp=0xc0201e0558 sp=0xc0201e0528 pc=0x4ef6bd\ncommand-line-arguments_test.modp(0x1,\
    \ 0x5)\n\t/tmp/tmpvoaz9885_test.go:23 +0x5d fp=0xc0201e0588 sp=0xc0201e0558 pc=0x4ef6bd\n\
    command-line-arguments_test.modp(0x1, 0x5)\n\t/tmp/tmpvoaz9885_test.go:23 +0x5d\
    \ fp=0xc0201e05b8 sp=0xc0201e0588 pc=0x4ef6bd\ncommand-line-arguments_test.modp(0x1,\
    \ 0x5)\n\t/tmp/tmpvoaz9885_test.go:23 +0x5d fp=0xc0201e05e8 sp=0xc0201e05b8 pc"
  timestamp: 1660074888
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return powmod(2, n, p)\n}\n\n\
    func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
    \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
    \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
    \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
    \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbh42fb7g_test.go:20:12: undefined: powmod

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074887
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    x := 1\n    for n > 0 {\n   \
    \     if n&1 == 1 {\n            x = (x * n) % p\n        }\n        n = n >>\
    \ 1\n    }\n    return x\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp1xz9v5v6_test.go:49: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp1xz9v5v6_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp1xz9v5v6_test.go:49: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp1xz9v5v6_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp1xz9v5v6_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074887
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    x := modp(n/2, p)\n    x = (x * x) % p\n    if n % 2 == 1 {\n    \
    \    x = (x * 2) % p\n    }\n    return x\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074887
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p < 0 {\n        panic(\"\
    modp: p is negative\")\n    }\n    return int(modpBig(int64(n), int64(p)))\n}\n\
    \nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp19nlr0s3_test.go:23:16: undefined: modpBig

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074887
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    var r int\n    if n % 2 == 0 {\n        r = modp(n/2, p)\n       \
    \ r = (r * r) % p\n    } else {\n        r = (modp(n-1, p) * n) % p\n    }\n \
    \   return r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpuolqs3sh_test.go:52: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpuolqs3sh_test.go:52: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpuolqs3sh_test.go:52: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpuolqs3sh_test.go:52: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074887
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n%2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n  \
    \  }\n    return 2 * modp(n-1, p) % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074887
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    res := 1\n    for n > 0 {\n \
    \       if n & 1 != 0 {\n            res = (res * 2) % p\n        }\n        n\
    \ = n >> 1\n    }\n    return res\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpg8767_1k_test.go:49: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpg8767_1k_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=32)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpg8767_1k_test.go:49: expected '%!s(int=8)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpg8767_1k_test.go:49: expected\
    \ '%!s(int=1)', got '%!s(int=8)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpg8767_1k_test.go:49: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpg8767_1k_test.go:49: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074887
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    i := 1\n    val := 1\n    for\
    \ i <= n {\n        val = (val * 2) % p\n        i += 1\n    }\n    return val\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074887
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // TODO: This is not a complete\
    \ implementation\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0\
    \ {\n        // If n is even:\n        half := modp(n / 2, p)\n        return\
    \ (half * half) % p\n    } else {\n        // If n is odd:\n        return (modp(n\
    \ - 1, p) * n) % p\n    }\n}\n\nfunc TestModp(t *testing.T) {\n  candidate :=\
    \ modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpvyllkkcs_test.go:53: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpvyllkkcs_test.go:53: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpvyllkkcs_test.go:53: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpvyllkkcs_test.go:53: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074887
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    res := 1\n    for n > 0 {\n \
    \       if n & 1 != 0 {\n            res = (res * n) % p\n        }\n        n\
    \ = n >> 1\n    }\n    return res\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpm9i8v20z_test.go:49: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpm9i8v20z_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpm9i8v20z_test.go:49: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpm9i8v20z_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpm9i8v20z_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074887
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return n & ((1 << uint(p)) -\
    \ 1)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpush9dzgt_test.go:42: expected '%!s(int=2)', got '%!s(int=1101)'\n\
    \    --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpush9dzgt_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpush9dzgt_test.go:42: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpush9dzgt_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpush9dzgt_test.go:42: expected '%!s(int=4)', got '%!s(int=30)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpush9dzgt_test.go:42: expected\
    \ '%!s(int=3)', got '%!s(int=31)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074887
- exit_code: null
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    result := 1\n    for ; n > 0;\
    \ n >>= 1 {\n        if n&1 != 0 {\n            result = (result * n) % p\n  \
    \      }\n        n = (n * n) % p\n    }\n    return result\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074899
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n\n    // n % p == n & (p - 1)\n    return (modp(n / 2, p) * (1 + (n &\
    \ 1) * (p - 1))) % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmptctxa5qj_test.go:47: expected '%!s(int=3)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmptctxa5qj_test.go:47: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmptctxa5qj_test.go:47: expected '%!s(int=8)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmptctxa5qj_test.go:47: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmptctxa5qj_test.go:47: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmptctxa5qj_test.go:47: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074888
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // To be implemented\n    return\
    \ 0\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp6vzalpe__test.go:43: expected '%!s(int=3)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp6vzalpe__test.go:43: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp6vzalpe__test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp6vzalpe__test.go:43: expected\
    \ '%!s(int=8)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp6vzalpe__test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp6vzalpe__test.go:43: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp6vzalpe__test.go:43: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074888
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n = n % p\
    \ + p\n    }\n    for n >= p {\n        n -= p\n    }\n    return n\n}\n\nfunc\
    \ TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected:\
    \ 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3,\
    \ 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n  \
    \   { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5),\
    \ expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp0lyr3iib_test.go:48: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmp0lyr3iib_test.go:48: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp0lyr3iib_test.go:48: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp0lyr3iib_test.go:48: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp0lyr3iib_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp0lyr3iib_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074889
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    t := modp(n/2, p)\n    if\
    \ n % 2 == 0 {\n        return (t * t) % p\n    }\n    return (t * t * n) % p\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpz3lavuuo_test.go:52: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpz3lavuuo_test.go:52: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpz3lavuuo_test.go:52: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpz3lavuuo_test.go:52: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074889
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    r := 1\n    for ; n > 0; n /=\
    \ 2 {\n        if n % 2 == 1 {\n            r = (r * 2) % p\n        }\n     \
    \   p = (p * 2) % p\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\npanic: runtime error: integer divide by zero\
    \ [recovered]\n\tpanic: runtime error: integer divide by zero\n\ngoroutine 6 [running]:\n\
    testing.tRunner.func1.2({0x5038a0, 0x5f29a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5038a0, 0x5f29a0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.modp(...)\n\t/tmp/tmpc9cmch60_test.go:23\n\
    command-line-arguments_test.TestModp(0x0?)\n\t/tmp/tmpc9cmch60_test.go:37 +0x7ea\n\
    testing.tRunner(0xc0001924e0, 0x528f38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074889
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // return n**n % p;\n    n =\
    \ n % p\n    if n <= 1 {\n        return n\n    }\n    if n % 2 == 0 {\n     \
    \   return 2 * modp(n/2, p) % p\n    }\n    return (2 * modp(n/2, p) + p - 1)\
    \ % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpodk9nbvg_test.go:50: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpodk9nbvg_test.go:50: expected\
    \ '%!s(int=2)', got '%!s(int=37)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpodk9nbvg_test.go:50: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpodk9nbvg_test.go:50: expected\
    \ '%!s(int=8)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpodk9nbvg_test.go:50: expected '%!s(int=1)', got '%!s(int=28)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpodk9nbvg_test.go:50: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpodk9nbvg_test.go:50: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074889
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        // If n is even.\n        m := modp(n/2,\
    \ p)\n        return (m * m) % p\n    } else {\n        // If n is odd.\n    \
    \    return (modp(n - 1, p) * n) % p\n    }\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp580i8v4j_test.go:52: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp580i8v4j_test.go:52: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp580i8v4j_test.go:52: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp580i8v4j_test.go:52: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074889
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var r int = 1\n    var e int\
    \ = n\n    for {\n        if e == 0 {\n            break\n        }\n        if\
    \ e % 2 == 1 {\n            r = (r * n) % p\n        }\n        n = (n * n) %\
    \ p\n        e /= 2\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpf35lxsbp_test.go:54: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpf35lxsbp_test.go:54: expected\
    \ '%!s(int=2)', got '%!s(int=91)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpf35lxsbp_test.go:54: expected '%!s(int=8)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpf35lxsbp_test.go:54: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpf35lxsbp_test.go:54: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074889
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // if (n == 0):\n    //     return\
    \ 1\n    // else:\n    //     return (2 * modp(n - 1, p)) % p\n    return 1\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp0z36_i1z_test.go:46: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp0z36_i1z_test.go:46: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp0z36_i1z_test.go:46: expected '%!s(int=8)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp0z36_i1z_test.go:46: expected\
    \ '%!s(int=4)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp0z36_i1z_test.go:46: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074889
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    p2 := p * 2\n    r := 1\n   \
    \ for n > 0 {\n        if n % 2 == 1 {\n            r = (r * 2) % p2\n       \
    \ }\n        n /= 2\n    }\n    if r >= p {\n        r -= p\n    }\n    return\
    \ r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp5gzu41h__test.go:53: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp5gzu41h__test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=32)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp5gzu41h__test.go:53: expected '%!s(int=8)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp5gzu41h__test.go:53: expected\
    \ '%!s(int=1)', got '%!s(int=8)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp5gzu41h__test.go:53: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp5gzu41h__test.go:53: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074889
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    r := 1\n    for n > 0 {\n   \
    \     if n & 1 != 0 {\n            r = (r * n) % p\n        }\n        n = n >>\
    \ 1\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgdbv5q_l_test.go:49: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgdbv5q_l_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpgdbv5q_l_test.go:49: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpgdbv5q_l_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpgdbv5q_l_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074889
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    x := 1\n    if p == 2 {\n   \
    \     if n & 1 == 1 {\n            return 1\n        } else {\n            return\
    \ 0\n        }\n    }\n    for n > 0 {\n        if n & 1 == 1 {\n            x\
    \ = (x * 2) % p\n        }\n        n = n >> 1\n    }\n    return x\n}\n\nfunc\
    \ TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected:\
    \ 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3,\
    \ 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n  \
    \   { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5),\
    \ expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpqq3i0d24_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpqq3i0d24_test.go:56: expected\
    \ '%!s(int=2)', got '%!s(int=32)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpqq3i0d24_test.go:56: expected '%!s(int=8)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpqq3i0d24_test.go:56: expected\
    \ '%!s(int=1)', got '%!s(int=8)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpqq3i0d24_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpqq3i0d24_test.go:56: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074889
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return 2 % p\n    }\n    if n % 2 == 0 {\n  \
    \      // Even\n        return (modp(n / 2, p) * modp(n / 2, p)) % p\n    }\n\
    \    // Odd\n    return (2 * modp(n / 2, p) * modp(n / 2, p)) % p\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074889
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    two := modp(n/2, p)\n    if n & 1 == 0 {\n        return (two * two)\
    \ % p\n    }\n    return (two * two * 2) % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074889
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        // even\n        return modp(n / 2, p) *\
    \ modp(n / 2, p) % p\n    } else {\n        // odd\n        return modp(n / 2,\
    \ p) * modp(n / 2, p) * 2 % p\n    }\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074889
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var result int = 1\n    for n\
    \ > 0 {\n        if n & 1 != 0 {\n            result = (result * n) % p\n    \
    \    }\n        n = n >> 1\n    }\n    return result\n}\n\n//>>> modp(3, 5)\n\
    //3\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp9e5a1m7f_test.go:51: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp9e5a1m7f_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp9e5a1m7f_test.go:51: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp9e5a1m7f_test.go:51: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp9e5a1m7f_test.go:51: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074889
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        panic(\"\
    n must be >= 0\")\n    }\n    if p < 0 {\n        panic(\"p must be >= 0\")\n\
    \    }\n    if p == 0 {\n        panic(\"p must be > 0\")\n    }\n    return (1\
    \ << uint(n)) % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpzgl5kvf7_test.go:51: expected '%!s(int=2)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpzgl5kvf7_test.go:51: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074889
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    v := 1\n    for n > 0 {\n   \
    \     if n & 1 != 0 {\n            v = (v * n) % p\n        }\n        n = n >>\
    \ 1\n    }\n    return v\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp7rptvs3f_test.go:49: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp7rptvs3f_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp7rptvs3f_test.go:49: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp7rptvs3f_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp7rptvs3f_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074889
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return (1 << uint(n)) % p\n}\n\
    \nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpfwlgmfhi_test.go:42: expected '%!s(int=2)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpfwlgmfhi_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    x := modp(n / 2, p)\n    x = (x * x) % p\n    if n % 2 == 1 {\n  \
    \      x = (x * 2) % p\n    }\n    return x\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074889
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    n %= p\n    if n < 0 {\n    \
    \    n += p\n    }\n    return n\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmphl763sre_test.go:46: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmphl763sre_test.go:46: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmphl763sre_test.go:46: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmphl763sre_test.go:46: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmphl763sre_test.go:46: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmphl763sre_test.go:46: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074889
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return int(modp_int64(int64(n),\
    \ int64(p)))\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqqi4hqc1_test.go:20:16: undefined: modp_int64

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074889
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    m := 1\n    for i := 1; i <=\
    \ n; i++ {\n        m = (m * 2) % p\n    }\n    return m\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074890
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var result int\n    n = n % p\n\
    \    for i := 0; i < n; i++ {\n        result = (result + p) % p\n    }\n    return\
    \ result\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpajp2clzu_test.go:47: expected '%!s(int=3)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpajp2clzu_test.go:47: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpajp2clzu_test.go:47: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpajp2clzu_test.go:47: expected\
    \ '%!s(int=8)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpajp2clzu_test.go:47: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpajp2clzu_test.go:47: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpajp2clzu_test.go:47: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074890
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n < 0 {\n        n =\
    \ n + p\n    }\n    var q, r, a int\n    for a = n; a > 1; {\n        q, r = a/p,\
    \ a%p\n        if r == 0 {\n            return 1\n        }\n        a = q\n \
    \   }\n    return r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp4k9ug25m_test.go:59: expected '%!s(int=2)', got '%!s(int=10)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp4k9ug25m_test.go:59: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp4k9ug25m_test.go:59: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp4k9ug25m_test.go:59: expected\
    \ '%!s(int=4)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp4k9ug25m_test.go:59: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074890
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if p == 1 {\n        return\
    \ 0\n    }\n    ans := 1\n    for n > 0 {\n        if n % 2 == 1 {\n         \
    \   ans = (ans * n) % p\n        }\n        n = n / 2\n    }\n    return ans\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpxjzbrlpk_test.go:58: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpxjzbrlpk_test.go:58: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpxjzbrlpk_test.go:58: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpxjzbrlpk_test.go:58: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpxjzbrlpk_test.go:58: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074891
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    x := 1\n    for n > 0 {\n   \
    \     if n & 1 != 0 {\n            x = (x * n) % p\n        }\n        n = n >>\
    \ 1\n    }\n    return x\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp17rq4c0s_test.go:49: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp17rq4c0s_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp17rq4c0s_test.go:49: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp17rq4c0s_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp17rq4c0s_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074891
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    r := 1\n    f := 2\n    for n\
    \ > 0 {\n        if n & 1 == 1 {\n            r = (r * f) % p\n        }\n   \
    \     f = (f * f) % p\n        n >>= 1\n    }\n    return r\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074891
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var res = 1\n    for n > 0 {\n\
    \        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n       \
    \ n >>= 1\n    }\n    return res\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp1hp7q29y_test.go:49: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp1hp7q29y_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp1hp7q29y_test.go:49: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp1hp7q29y_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp1hp7q29y_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074891
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    a := 1\n    b := 2\n    c :=\
    \ n\n    for c > 0 {\n        if c % 2 == 1 {\n            a = (a * b) % p\n \
    \       }\n        b = (b * b) % p\n        c /= 2\n    }\n    return a\n}\n\n\
    func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
    \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
    \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
    \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
    \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074891
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    var res int\n    if n % 2 == 0 {\n        res = modp(n/2, p)\n   \
    \     res = (res * res) % p\n    } else {\n        res = (2 * modp(n/2, p)) %\
    \ p\n    }\n    return res\n}\n\nfunc TestModp(t *testing.T) {\n  candidate :=\
    \ modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpzbv1iupl_test.go:52: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpzbv1iupl_test.go:52: expected\
    \ '%!s(int=2)', got '%!s(int=61)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpzbv1iupl_test.go:52: expected '%!s(int=8)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpzbv1iupl_test.go:52: expected\
    \ '%!s(int=1)', got '%!s(int=78)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpzbv1iupl_test.go:52: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpzbv1iupl_test.go:52: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074891
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // trivial\n    if n == 0 {\n\
    \        return 1\n    }\n\n    // modp(0, p) = 1\n    if n == 0 {\n        return\
    \ 1\n    }\n\n    // modp(1, p) = 1\n    if n == 1 {\n        return 1\n    }\n\
    \n    if n % 2 == 0 {\n        // modp(2*x, p) = (modp(x, p))^2 mod p\n      \
    \  m := modp(n/2, p)\n        return (m * m) % p\n    } else {\n        // modp(2*x+1,\
    \ p) = 2*modp(x, p)*modp(x+1, p) mod p\n        return (2 * modp(n/2, p) * modp(n/2+1,\
    \ p)) % p\n    }\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpimdhjbd7_test.go:64: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpimdhjbd7_test.go:64: expected\
    \ '%!s(int=2)', got '%!s(int=88)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpimdhjbd7_test.go:64: expected '%!s(int=8)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpimdhjbd7_test.go:64: expected\
    \ '%!s(int=1)', got '%!s(int=36)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpimdhjbd7_test.go:64: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074891
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // Corner case.\n    if p <=\
    \ 0 {\n        return 0\n    }\n\n    // Base case.\n    if n == 0 {\n       \
    \ return 1\n    }\n\n    // Repeatedly square and multiply.\n    s := 1\n    for\
    \ n > 0 {\n        if n % 2 == 1 {\n            s = (s * 2) % p\n        }\n \
    \       n = n >> 1\n    }\n    return s\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpib3oth6s_test.go:60: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpib3oth6s_test.go:60: expected\
    \ '%!s(int=2)', got '%!s(int=32)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpib3oth6s_test.go:60: expected '%!s(int=8)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpib3oth6s_test.go:60: expected\
    \ '%!s(int=1)', got '%!s(int=8)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpib3oth6s_test.go:60: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpib3oth6s_test.go:60: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074891
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n >= p {\n        return n\
    \ % p\n    } else if n == 0 {\n        return 1\n    }\n    res := modp(2*n, p)\n\
    \    if res >= p/2 {\n        res -= p\n    }\n    return res\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp4o18opxj_test.go:51: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp4o18opxj_test.go:51: expected\
    \ '%!s(int=2)', got '%!s(int=91)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp4o18opxj_test.go:51: expected '%!s(int=8)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp4o18opxj_test.go:51: expected\
    \ '%!s(int=1)', got '%!s(int=-2)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp4o18opxj_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp4o18opxj_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074891
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n = n + ((-n\
    \ / p) + 1) * p\n    }\n    return n % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpyokfm8r4_test.go:45: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpyokfm8r4_test.go:45: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpyokfm8r4_test.go:45: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpyokfm8r4_test.go:45: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpyokfm8r4_test.go:45: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpyokfm8r4_test.go:45: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074891
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n / 2, p) * modp(n / 2, p) %\
    \ p\n    }\n    return 2 * modp(n / 2, p) * modp(n / 2, p) % p\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074891
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    m := 1\n    for n > 0 {\n   \
    \     if n % 2 == 1 {\n            m = (m * n) % p\n        }\n        n = n >>\
    \ 1\n    }\n    return m\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpzs9jnsoj_test.go:49: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpzs9jnsoj_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpzs9jnsoj_test.go:49: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpzs9jnsoj_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpzs9jnsoj_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074891
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n >= p {\n        return modp(n\
    \ % p, p)\n    } else if n == 0 {\n        return 1\n    } else if n == 1 {\n\
    \        return n\n    } else if n % 2 == 0 {\n        return modp(2*modp(n/2,\
    \ p), p)\n    } else {\n        return 2*modp(n/2, p)\n    }\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 34 [running]:\ncommand-line-arguments_test.modp(0x1?, 0x65?)\n\
    \t/tmp/tmpkrsej1mp_test.go:19 +0xe5 fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef745\n\
    command-line-arguments_test.modp(0x0?, 0x65)\n\t/tmp/tmpkrsej1mp_test.go:27 +0x79\
    \ fp=0xc0201e03c8 sp=0xc0201e03a8 pc=0x4ef6d9\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x65)\n\t/tmp/tmpkrsej1mp_test.go:27 +0x86 fp=0xc0201e03e8 sp=0xc0201e03c8 pc=0x4ef6e6\n\
    command-line-arguments_test.modp(0x0?, 0x65)\n\t/tmp/tmpkrsej1mp_test.go:27 +0x86\
    \ fp=0xc0201e0408 sp=0xc0201e03e8 pc=0x4ef6e6\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x65)\n\t/tmp/tmpkrsej1mp_test.go:27 +0x86 fp=0xc0201e0428 sp=0xc0201e0408 pc=0x4ef6e6\n\
    command-line-arguments_test.modp(0x0?, 0x65)\n\t/tmp/tmpkrsej1mp_test.go:27 +0x86\
    \ fp=0xc0201e0448 sp=0xc0201e0428 pc=0x4ef6e6\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x65)\n\t/tmp/tmpkrsej1mp_test.go:27 +0x86 fp=0xc0201e0468 sp=0xc0201e0448 pc=0x4ef6e6\n\
    command-line-arguments_test.modp(0x0?, 0x65)\n\t/tmp/tmpkrsej1mp_test.go:27 +0x86\
    \ fp=0xc0201e0488 sp=0xc0201e0468 pc=0x4ef6e6\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x65)\n\t/tmp/tmpkrsej1mp_test.go:27 +0x86 fp=0xc0201e04a8 sp=0xc0201e0488 pc=0x4ef6e6\n\
    command-line-arguments_test.modp(0x0?, 0x65)\n\t/tmp/tmpkrsej1mp_test.go:27 +0x86\
    \ fp=0xc0201e04c8 sp=0xc0201e04a8 pc=0x4ef6e6\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x65)\n\t/tmp/tmpkrsej1mp_test.go:27 +0x86 fp=0xc0201e04e8 sp=0xc0201e04c8 pc=0x4ef6e6\n\
    command-line-arguments_test.modp(0x0?, 0x65)\n\t/tmp/tmpkrsej1mp_test.go:27 +0x86\
    \ fp=0xc0201e0508 sp=0xc0201e04e8 pc=0x4ef6e6\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x65)\n\t/tmp/tmpkrsej1mp_test.go:27 +0x86 fp=0xc"
  timestamp: 1660074893
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // this fails on large numbers\n\
    \    return (n % p) + p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp2t8sin0o_test.go:43: expected '%!s(int=3)', got '%!s(int=8)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp2t8sin0o_test.go:43: expected\
    \ '%!s(int=2)', got '%!s(int=192)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmp2t8sin0o_test.go:43: expected '%!s(int=1)', got '%!s(int=101)'\n \
    \   --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp2t8sin0o_test.go:43: expected\
    \ '%!s(int=8)', got '%!s(int=14)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp2t8sin0o_test.go:43: expected '%!s(int=1)', got '%!s(int=201)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp2t8sin0o_test.go:43: expected\
    \ '%!s(int=4)', got '%!s(int=5)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp2t8sin0o_test.go:43: expected '%!s(int=3)', got '%!s(int=6)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074891
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    res := 1\n    for _, mask :=\
    \ range(bits(n)) {\n        res = (res * res) % p\n        if mask == 1 {\n  \
    \          res = (res * 2) % p\n        }\n    }\n    return res\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2oa7tyhh_test.go:21:26: undefined: bits

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074891
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // Preconditions\n    if n <\
    \ 0 {\n        panic(fmt.Sprintf(\"Non-negative integer expected, but got %d\"\
    , n))\n    }\n    if p < 2 {\n        panic(fmt.Sprintf(\"Number greater than\
    \ one expected, but got %d\", p))\n    }\n\n    // Algorithm\n    remainder :=\
    \ 1\n    base := 2\n    for n > 0 {\n        if n & 1 == 1 {\n            remainder\
    \ = (remainder * base) % p\n        }\n        base = (base * base) % p\n    \
    \    n >>= 1\n    }\n    return remainder\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074891
- exit_code: null
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    r := 1\n    for ; n > 0; n >>=\
    \ 1 {\n        if n & 1 != 0 {\n            r = (r * n) % p\n        }\n     \
    \   n = (n * n) % p\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074904
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return (1 << uint(n)) % p\n}\n\
    \nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpfwlgmfhi_test.go:42: expected '%!s(int=2)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpfwlgmfhi_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    k := 1\n    for n > 0 {\n   \
    \     if n & 1 != 0 {\n            k = (k * n) % p\n        }\n        n = n >>\
    \ 1\n    }\n    return k\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgyg7b79y_test.go:49: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgyg7b79y_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpgyg7b79y_test.go:49: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpgyg7b79y_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpgyg7b79y_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074887
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p == 0 {\n        return 0\n\
    \    }\n\n    r := 1\n    for i := 0; i < n; i++ {\n        r = r * 2 % p\n  \
    \  }\n    return r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074891
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    x := 1\n    for i := 0; i < n;\
    \ i++ {\n        x = (x * 2) % p\n    }\n    return x\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074891
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return 1\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpko6vqjo6_test.go:42: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpko6vqjo6_test.go:42: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpko6vqjo6_test.go:42: expected '%!s(int=8)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpko6vqjo6_test.go:42: expected\
    \ '%!s(int=4)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpko6vqjo6_test.go:42: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074892
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p == 1 {\n        return 0\n\
    \    }\n    if n < p {\n        return n\n    }\n    b := 1\n    for n > 1 {\n\
    \        if n & 1 != 0 {\n            b = (b * n) % p\n        }\n        n =\
    \ n >> 1\n    }\n    return b\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpc2ta52ku_test.go:55: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpc2ta52ku_test.go:55: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpc2ta52ku_test.go:55: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpc2ta52ku_test.go:55: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpc2ta52ku_test.go:55: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpc2ta52ku_test.go:55: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074892
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n = -n\n\
    \    }\n    if n == 0 {\n        return 1\n    }\n    r := 1\n    for i := 0;\
    \ i < n; i++ {\n        r = (r * 2) % p\n    }\n    return r\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074892
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n >= p {\n        return modp(n\
    \ % p, p)\n    }\n    if n < 0 {\n        return p - modp(-n, p)\n    }\n    return\
    \ n\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpdf6ty0ia_test.go:48: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpdf6ty0ia_test.go:48: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpdf6ty0ia_test.go:48: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpdf6ty0ia_test.go:48: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpdf6ty0ia_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpdf6ty0ia_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074893
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var result = 1\n    for n > 0\
    \ {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n        }\n\
    \        n = n / 2\n    }\n    return result\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmplxze937o_test.go:49: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmplxze937o_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=32)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmplxze937o_test.go:49: expected '%!s(int=8)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmplxze937o_test.go:49: expected\
    \ '%!s(int=1)', got '%!s(int=8)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmplxze937o_test.go:49: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmplxze937o_test.go:49: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074893
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var r = 1\n    for n > 0 {\n\
    \        if n % 2 == 1 {\n            r = (r * n) % p\n        }\n        n =\
    \ n >> 1\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpa8qccn94_test.go:49: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpa8qccn94_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpa8qccn94_test.go:49: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpa8qccn94_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpa8qccn94_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074893
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    m := 1\n    for n != 0 {\n  \
    \      if n % 2 == 1 {\n            m = (m * 2) % p\n        }\n        n = n\
    \ / 2\n    }\n    return m\n}\n\nfunc TestModp(t *testing.T) {\n  candidate :=\
    \ modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmprsvuzj70_test.go:49: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmprsvuzj70_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=32)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmprsvuzj70_test.go:49: expected '%!s(int=8)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmprsvuzj70_test.go:49: expected\
    \ '%!s(int=1)', got '%!s(int=8)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmprsvuzj70_test.go:49: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmprsvuzj70_test.go:49: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074893
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p == 1 {\n        return 0\n\
    \    }\n    if n >= p {\n        return modp(n % p, p)\n    }\n    if n == 0 {\n\
    \        return 1\n    }\n    return (n % p) * modp(2, p) % p\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0x2?, 0x5?)\n\
    \t/tmp/tmplw5s40rs_test.go:19 +0xfd fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef75d\n\
    command-line-arguments_test.modp(0x2, 0x5)\n\t/tmp/tmplw5s40rs_test.go:29 +0x79\
    \ fp=0xc0201e03c8 sp=0xc0201e03a8 pc=0x4ef6d9\ncommand-line-arguments_test.modp(0x2,\
    \ 0x5)\n\t/tmp/tmplw5s40rs_test.go:29 +0x79 fp=0xc0201e03e8 sp=0xc0201e03c8 pc=0x4ef6d9\n\
    command-line-arguments_test.modp(0x2, 0x5)\n\t/tmp/tmplw5s40rs_test.go:29 +0x79\
    \ fp=0xc0201e0408 sp=0xc0201e03e8 pc=0x4ef6d9\ncommand-line-arguments_test.modp(0x2,\
    \ 0x5)\n\t/tmp/tmplw5s40rs_test.go:29 +0x79 fp=0xc0201e0428 sp=0xc0201e0408 pc=0x4ef6d9\n\
    command-line-arguments_test.modp(0x2, 0x5)\n\t/tmp/tmplw5s40rs_test.go:29 +0x79\
    \ fp=0xc0201e0448 sp=0xc0201e0428 pc=0x4ef6d9\ncommand-line-arguments_test.modp(0x2,\
    \ 0x5)\n\t/tmp/tmplw5s40rs_test.go:29 +0x79 fp=0xc0201e0468 sp=0xc0201e0448 pc=0x4ef6d9\n\
    command-line-arguments_test.modp(0x2, 0x5)\n\t/tmp/tmplw5s40rs_test.go:29 +0x79\
    \ fp=0xc0201e0488 sp=0xc0201e0468 pc=0x4ef6d9\ncommand-line-arguments_test.modp(0x2,\
    \ 0x5)\n\t/tmp/tmplw5s40rs_test.go:29 +0x79 fp=0xc0201e04a8 sp=0xc0201e0488 pc=0x4ef6d9\n\
    command-line-arguments_test.modp(0x2, 0x5)\n\t/tmp/tmplw5s40rs_test.go:29 +0x79\
    \ fp=0xc0201e04c8 sp=0xc0201e04a8 pc=0x4ef6d9\ncommand-line-arguments_test.modp(0x2,\
    \ 0x5)\n\t/tmp/tmplw5s40rs_test.go:29 +0x79 fp=0xc0201e04e8 sp=0xc0201e04c8 pc=0x4ef6d9\n\
    command-line-arguments_test.modp(0x2, 0x5)\n\t/tmp/tmplw5s40rs_test.go:29 +0x79\
    \ fp=0xc0201e0508 sp=0xc0201e04e8 pc=0x4ef6d9\ncommand-line-arguments_test.modp(0x2,\
    \ 0x5)\n\t/tmp/tmplw5s40rs_test.go:29 +0x79 fp=0xc0201e0528 sp=0xc0201e0508 "
  timestamp: 1660074894
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    ans := 1\n    for i := 0; i <\
    \ n; i++ {\n        ans = (ans * 2) % p\n    }\n    return ans\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074893
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        return modp(-n,\
    \ p)\n    }\n    result := 1\n    for n > 0 {\n        if n&1 != 0 {\n       \
    \     result = (result * n) % p\n        }\n        n >>= 1\n    }\n    return\
    \ result\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmprdgyifwr_test.go:52: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmprdgyifwr_test.go:52: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmprdgyifwr_test.go:52: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmprdgyifwr_test.go:52: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmprdgyifwr_test.go:52: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074893
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n\n    return 2 * modp(n-1, p) % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074893
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n > 0 {\n        if p > 0\
    \ {\n            i := 0\n            for i = 0; i < n; i++ {\n               \
    \ p = (p * 2) % 101\n            }\n            return p\n        } else {\n \
    \           return 1\n        }\n    } else {\n        return 1\n    }\n}\n\n\
    func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
    \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
    \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
    \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
    \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp6uq_5jgg_test.go:54: expected '%!s(int=3)', got '%!s(int=40)'\n  \
    \  --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp6uq_5jgg_test.go:54: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp6uq_5jgg_test.go:54: expected '%!s(int=8)', got '%!s(int=88)'\n  \
    \  --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp6uq_5jgg_test.go:54: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp6uq_5jgg_test.go:54: expected '%!s(int=4)', got '%!s(int=85)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp6uq_5jgg_test.go:54: expected\
    \ '%!s(int=3)', got '%!s(int=69)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074893
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    x := 1\n    for n > 0 {\n   \
    \     if n % 2 == 1 {\n            x = (x * 2) % p\n        }\n        n = n /\
    \ 2\n    }\n    return x\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp5nqe7opg_test.go:49: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp5nqe7opg_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=32)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp5nqe7opg_test.go:49: expected '%!s(int=8)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp5nqe7opg_test.go:49: expected\
    \ '%!s(int=1)', got '%!s(int=8)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp5nqe7opg_test.go:49: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp5nqe7opg_test.go:49: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074893
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return n * modp(n-1, p) % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp1bglm3hw_test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp1bglm3hw_test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp1bglm3hw_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp1bglm3hw_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    var i int = 2\n    var r int = n % p\n    for ; i < n; i *= 2 {\n\
    \        r = r * r % p\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmprgh90jg2_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmprgh90jg2_test.go:50: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmprgh90jg2_test.go:50: expected '%!s(int=8)', got '%!s(int=9)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmprgh90jg2_test.go:50: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmprgh90jg2_test.go:50: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074893
- exit_code: null
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    r := 1\n    for ; n > 0; n =\
    \ n >> 1 {\n        if n & 1 == 1 {\n            r = (r * n) % p\n        }\n\
    \        n = (n * n) % p\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660074906
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    x := 1\n    for n > 0 {\n   \
    \     if n % 2 == 1 {\n            x = (x * n) % p\n        }\n        n = n /\
    \ 2\n    }\n    return x\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpmq3rp2jd_test.go:49: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpmq3rp2jd_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpmq3rp2jd_test.go:49: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpmq3rp2jd_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpmq3rp2jd_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074893
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n = n % p\
    \ + p\n    } else {\n        n = n % p\n    }\n    if n == 0 {\n        return\
    \ 1\n    }\n    return n\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpo7ope70r_test.go:50: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpo7ope70r_test.go:50: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpo7ope70r_test.go:50: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpo7ope70r_test.go:50: expected\
    \ '%!s(int=4)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpo7ope70r_test.go:50: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074893
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    i := 1\n    for j := 0; j < n;\
    \ j++ {\n        i = (i * 2) % p\n    }\n    return i\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074893
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return powmod(2, n, p)\n}\n\n\
    func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
    \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
    \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
    \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
    \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbh42fb7g_test.go:20:12: undefined: powmod

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074887
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var i int\n    var t int\n  \
    \  t = 1\n    for i = 1; i <= n; i++ {\n        t = (t * 2) % p\n    }\n    return\
    \ t\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074893
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n\n    if n < 0 {\n        n = -n\n    }\n\n    r := 1\n    for i := 1;\
    \ i <= n; i++ {\n        r = (r * 2) % p\n    }\n\n    return r\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074893
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        return p\
    \ - modp(-n, p)\n    }\n    if n < p {\n        return n\n    }\n    if n % p\
    \ == 0 {\n        return 0\n    }\n    n = n % p\n    if n == 0 {\n        return\
    \ 0\n    }\n    return modp(2*n, p) - n\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmppnv3k86x_test.go:55: expected '%!s(int=2)', got '%!s(int=-212)'\n\
    \    --- FAIL: TestModp/test_num__2 (0.00s)\n        tmppnv3k86x_test.go:55: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmppnv3k86x_test.go:55: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmppnv3k86x_test.go:55: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmppnv3k86x_test.go:55: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmppnv3k86x_test.go:55: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074894
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    base := 2\n    r := 1\n    for n > 0 {\n        if n % 2 == 1 {\n\
    \            r = (r * base) % p\n        }\n        base = (base * base) % p\n\
    \        n /= 2\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074894
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // python, n = n % p\n    if\
    \ n >= p {\n        n %= p\n    }\n    if n <= 1 {\n        return n\n    }\n\
    \    return int(int64(modp(n>>1, p)) * int64(modp(n>>1 + n%2, p)) % int64(p))\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpl_3dz5xc_test.go:49: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpl_3dz5xc_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpl_3dz5xc_test.go:49: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpl_3dz5xc_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpl_3dz5xc_test.go:49: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpl_3dz5xc_test.go:49: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074894
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var r int = 1\n\n    for i :=\
    \ 0; i < n; i++ {\n        r = (r * 2) % p\n    }\n\n    return r\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074894
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    fmt.Printf(\"modp(%d, %d)\\n\"\
    , n, p)\n    // >>> x = 0x7fffffffffffffff\n    // >>> x\n    // 9223372036854775807\n\
    \    // >>> x.bit_length()\n    // 63\n    // >>> x.bit_length() < 20\n    //\
    \ False\n    // >>> x.bit_length() < 10\n    // True\n    // >>> x.bit_length()\
    \ < 2\n    // False\n    // >>> x.bit_length() == 2\n    // False\n    // >>>\
    \ x.bit_length() > 2\n    // True\n    // >>> x.bit_length() <= 2\n    // False\n\
    \    // >>> x.bit_length() >= 2\n    // True\n    // >>> x.bit_length()\n    //\
    \ 63\n    // >>> x.bit_length() > 60\n    // True\n    // >>> x.bit_length() >=\
    \ 60\n    // True\n    // >>> x.bit_length() < 60\n    // False\n    // >>> x.bit_length()\
    \ <= 60\n    // False\n    // >>> x.bit_length() == 60\n    // False\n    // >>>\
    \ 2 << 60\n    // 1152921504606846976\n    // >>> 2 << 61\n    // 2305843009213693952\n\
    \    // >>> 2 << 62\n    // 4611686018427387904\n    // >>> 2 << 63\n    // -9223372036854775808\n\
    \    // >>> 2 << 64\n    // 0\n    // >>> x = 2 << 62\n    // >>> x\n    // 4611686018427387904\n\
    \    // >>> x.bit_length()\n    // 64\n    // >>> x.bit_length() < 60\n    //\
    \ False\n    // >>> x.bit_length() < 62\n    // False\n    // >>> x.bit_length()\
    \ < 63\n    // False\n    // >>> x.bit_length() < 64\n    // False\n    // >>>\
    \ x.bit_length() > 63\n    // True\n    // >>> x.bit_length() > 62\n    // True\n\
    \    // >>> x.bit_length() > 61\n    // True\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7i548qfx_test.go:82:6: expected ''('', found TestModp

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074894
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p == 0 {\n        return 1\n\
    \    }\n    m := n % p\n    r := 1\n    for i := 0; i < m; i++ {\n        r =\
    \ (r * 2) % p\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpae74v8ba_test.go:50: expected '%!s(int=2)', got '%!s(int=29)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpae74v8ba_test.go:50: expected\
    \ '%!s(int=4)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpae74v8ba_test.go:50: expected '%!s(int=3)', got '%!s(int=2)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074895
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var res int = 1\n    for n !=\
    \ 0 {\n        if n & 1 != 0 {\n            res = (res * n) % p\n        }\n \
    \       n = n >> 1\n    }\n    return res\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp1keusbgd_test.go:49: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp1keusbgd_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp1keusbgd_test.go:49: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp1keusbgd_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp1keusbgd_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074895
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    r := 1\n    for n != 0 {\n  \
    \      r = ((n & 1) * r * 2) % p\n        n = n >> 1\n    }\n    return r\n}\n\
    \nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmptxb33m5o_test.go:47: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmptxb33m5o_test.go:47: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmptxb33m5o_test.go:47: expected '%!s(int=8)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmptxb33m5o_test.go:47: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmptxb33m5o_test.go:47: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmptxb33m5o_test.go:47: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074895
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    r := 1\n    for n > 0 {\n   \
    \     if n % 2 == 1 {\n            r = (r * 2) % p\n        }\n        n = n /\
    \ 2\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp28xp3dj1_test.go:49: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp28xp3dj1_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=32)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp28xp3dj1_test.go:49: expected '%!s(int=8)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp28xp3dj1_test.go:49: expected\
    \ '%!s(int=1)', got '%!s(int=8)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp28xp3dj1_test.go:49: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp28xp3dj1_test.go:49: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074895
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n += p\n\
    \    }\n    return n\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp_8cp65lh_test.go:45: expected '%!s(int=2)', got '%!s(int=1101)'\n\
    \    --- FAIL: TestModp/test_num__2 (0.00s)\n        tmp_8cp65lh_test.go:45: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp_8cp65lh_test.go:45: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp_8cp65lh_test.go:45: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp_8cp65lh_test.go:45: expected '%!s(int=4)', got '%!s(int=30)'\n  \
    \  --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp_8cp65lh_test.go:45: expected\
    \ '%!s(int=3)', got '%!s(int=31)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074895
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n%2 == 0 {\n        m\
    \ := modp(n/2, p)\n        return (m*m) % p\n    }\n    return (n*modp(n-1, p))\
    \ % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpafa8cyin_test.go:52: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpafa8cyin_test.go:52: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpafa8cyin_test.go:52: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpafa8cyin_test.go:52: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074895
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var result int = 1\n    for n\
    \ != 0 {\n        if n & 1 != 0 {\n            result = (result * n) % p\n   \
    \     }\n        n = n >> 1\n    }\n    return result\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpah77rayt_test.go:49: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpah77rayt_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpah77rayt_test.go:49: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpah77rayt_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpah77rayt_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074895
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    e := 1\n    for i := 0; i < n;\
    \ i++ {\n        e = e * 2 % p\n    }\n    return e\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074895
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p == 1 {\n        return 0\n\
    \    }\n    a := 1\n    for i := 0; i < n; i++ {\n        a = (a * 2) % p\n  \
    \  }\n    return a\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074895
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return n * modp(n-1, p)\
    \ % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpzytcr_rl_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpzytcr_rl_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpzytcr_rl_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpzytcr_rl_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074807
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    r := 1\n    for n > 0 {\n   \
    \     r = (r * r) % p\n        if n & 1 == 1 {\n            r = (r * 2) % p\n\
    \        }\n        n >>= 1\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpizevvkrc_test.go:50: expected '%!s(int=2)', got '%!s(int=10)'\n  \
    \  --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpizevvkrc_test.go:50: expected\
    \ '%!s(int=1)', got '%!s(int=98)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpizevvkrc_test.go:50: expected '%!s(int=4)', got '%!s(int=3)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074895
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var result int = 1\n    for i\
    \ := 0; i < n; i++ {\n        result = (result * 2) % p\n    }\n    return result\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    r := 1\n    for n > 0 {\n   \
    \     if n & 1 != 0 {\n            r = (r * n) % p\n        }\n        n = n >>\
    \ 1\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgdbv5q_l_test.go:49: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpgdbv5q_l_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpgdbv5q_l_test.go:49: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpgdbv5q_l_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpgdbv5q_l_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074889
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p == 1 {\n        return 0\n\
    \    }\n    // Powers of two are easy.\n    if n == 0 {\n        return 1\n  \
    \  } else if n == 1 {\n        return 2 % p\n    } else if n == 2 {\n        return\
    \ 4 % p\n    }\n    // Bits 0, 1, and 2.\n    v := modp(n/2, p)\n    v = (v *\
    \ v) % p\n    if n & 1 == 1 {\n        v = (v * 2) % p\n    }\n    return v\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074895
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // The recursive function below\
    \ is much slower\n    if n == 0 {\n        return 1\n    }\n    var r int = 1\n\
    \    for i := 0; i < n; i++ {\n        r = (r * 2) % p\n    }\n    return r\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074895
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        return modp(n\
    \ + p, p)\n    } else if n < p {\n        return n\n    } else {\n        return\
    \ modp(n - p, p)\n    }\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpt19dkjel_test.go:48: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpt19dkjel_test.go:48: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpt19dkjel_test.go:48: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpt19dkjel_test.go:48: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpt19dkjel_test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpt19dkjel_test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074895
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    res := 1\n\n    for n > 0 {\n\
    \        if n % 2 == 1 {\n            res = (res * n) % p\n        }\n       \
    \ n = n / 2\n    }\n\n    return res\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpiopijxeb_test.go:51: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpiopijxeb_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpiopijxeb_test.go:51: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpiopijxeb_test.go:51: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpiopijxeb_test.go:51: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074895
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return (1 << uint(n)) % p\n}\n\
    \nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpfwlgmfhi_test.go:42: expected '%!s(int=2)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpfwlgmfhi_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    x := 1\n    for n > 0 {\n   \
    \     if n & 1 != 0 {\n            x = (x * n) % p\n        }\n        n = n >>\
    \ 1\n    }\n    return x\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp17rq4c0s_test.go:49: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp17rq4c0s_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp17rq4c0s_test.go:49: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp17rq4c0s_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp17rq4c0s_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074891
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n%2 == 0 {\n        return\
    \ modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpxt4497rv_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpxt4497rv_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpxt4497rv_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpxt4497rv_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    a := modp(n/2, p)\n    a = (a * a) % p\n    if n % 2 == 1 {\n    \
    \    a = (a * 2) % p\n    }\n    return a\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074895
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        z := modp(n/2, p)\n        return (z * z)\
    \ % p\n    }\n    return (modp(n-1, p) * n) % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpseoc_zqd_test.go:49: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpseoc_zqd_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpseoc_zqd_test.go:49: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpseoc_zqd_test.go:49: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074896
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n = n % p\
    \ + p\n    }\n    r := n % p\n    fmt.Printf(\"n: %d r: %d p: %d\\n\", n, r, p)\n\
    \    return r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "n: 3 r: 3 p: 5\nn: 1101 r: 91 p: 101\nn: 0 r: 0 p: 101\nn: 3 r: 3 p: 11\n\
    n: 100 r: 100 p: 101\nn: 30 r: 0 p: 5\nn: 31 r: 1 p: 5\n--- FAIL: TestModp (0.00s)\n\
    \    --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpv2ba3jf5_test.go:47: expected\
    \ '%!s(int=2)', got '%!s(int=91)'\n    --- FAIL: TestModp/test_num__2 (0.00s)\n\
    \        tmpv2ba3jf5_test.go:47: expected '%!s(int=1)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpv2ba3jf5_test.go:47: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpv2ba3jf5_test.go:47: expected '%!s(int=1)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpv2ba3jf5_test.go:47: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpv2ba3jf5_test.go:47: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074896
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n\n    if n%2 == 0 {\n        return (modp(n/2, p) * modp(n/2, p)) % p\n\
    \    } else {\n        return (modp(n/2, p) * modp(n/2, p) * 2) % p\n    }\n}\n\
    \nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074896
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return pow(2, n, p)\n}\n\nfunc\
    \ TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected:\
    \ 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3,\
    \ 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n  \
    \   { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5),\
    \ expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqpha_vql_test.go:20:12: undefined: pow

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074896
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var r int\n    if n % 2 == 0\
    \ {\n        r = modp(n / 2, p)\n        r = (r * r) % p\n    } else {\n     \
    \   r = (modp(n - 1, p) * n) % p\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.modp(0x0?, 0x5)\n\
    \t/tmp/tmphbftix1t_test.go:19 +0xba fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef71a\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmphbftix1t_test.go:22 +0x35\
    \ fp=0xc0201e03c8 sp=0xc0201e03a8 pc=0x4ef695\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmphbftix1t_test.go:22 +0x35 fp=0xc0201e03e8 sp=0xc0201e03c8 pc=0x4ef695\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmphbftix1t_test.go:22 +0x35\
    \ fp=0xc0201e0408 sp=0xc0201e03e8 pc=0x4ef695\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmphbftix1t_test.go:22 +0x35 fp=0xc0201e0428 sp=0xc0201e0408 pc=0x4ef695\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmphbftix1t_test.go:22 +0x35\
    \ fp=0xc0201e0448 sp=0xc0201e0428 pc=0x4ef695\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmphbftix1t_test.go:22 +0x35 fp=0xc0201e0468 sp=0xc0201e0448 pc=0x4ef695\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmphbftix1t_test.go:22 +0x35\
    \ fp=0xc0201e0488 sp=0xc0201e0468 pc=0x4ef695\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmphbftix1t_test.go:22 +0x35 fp=0xc0201e04a8 sp=0xc0201e0488 pc=0x4ef695\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmphbftix1t_test.go:22 +0x35\
    \ fp=0xc0201e04c8 sp=0xc0201e04a8 pc=0x4ef695\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmphbftix1t_test.go:22 +0x35 fp=0xc0201e04e8 sp=0xc0201e04c8 pc=0x4ef695\n\
    command-line-arguments_test.modp(0x0?, 0x5)\n\t/tmp/tmphbftix1t_test.go:22 +0x35\
    \ fp=0xc0201e0508 sp=0xc0201e04e8 pc=0x4ef695\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x5)\n\t/tmp/tmphbftix1t_test.go:22 +0x35 fp=0xc0201e0528 sp=0x"
  timestamp: 1660074898
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var r = 1\n    for n > 0 {\n\
    \        if n & 1 != 0 {\n            r = (r * n) % p\n        }\n        n =\
    \ n >> 1\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmprez8cyb8_test.go:49: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmprez8cyb8_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmprez8cyb8_test.go:49: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmprez8cyb8_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmprez8cyb8_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074897
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    m := 1\n    for n > 0 {\n   \
    \     if n & 1 != 0 {\n            m = (m * 2) % p\n        }\n        n >>= 1\n\
    \    }\n    return m\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpfzqd5m20_test.go:49: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpfzqd5m20_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=32)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpfzqd5m20_test.go:49: expected '%!s(int=8)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpfzqd5m20_test.go:49: expected\
    \ '%!s(int=1)', got '%!s(int=8)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpfzqd5m20_test.go:49: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpfzqd5m20_test.go:49: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074897
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return modp_d(n, p, map[int]int{})\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzwm7h4r9_test.go:20:12: undefined: modp_d

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074897
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p <= 0 {\n        panic(\"\
    modp(n, p): p must be greater than 0\")\n    }\n\n    res := 1\n    n %= p\n \
    \   for n > 0 {\n        if n&1 != 0 {\n            res = (res * n) % p\n    \
    \    }\n        n = n >> 1\n    }\n    return res\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp7g_rm6om_test.go:54: expected '%!s(int=2)', got '%!s(int=96)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp7g_rm6om_test.go:54: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp7g_rm6om_test.go:54: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp7g_rm6om_test.go:54: expected\
    \ '%!s(int=4)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp7g_rm6om_test.go:54: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074897
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n%2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n  \
    \  }\n    return n * modp(n-1, p) % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpqz08d29__test.go:48: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpqz08d29__test.go:48: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpqz08d29__test.go:48: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpqz08d29__test.go:48: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074897
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n = n + p\n\
    \    }\n    // assert n >= 0\n    x := 1\n    for n > 0 {\n        if n & 1 !=\
    \ 0 {\n            x = (x * 2) % p\n        }\n        n = n >> 1\n    }\n   \
    \ return x\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpp4fc5xy9_test.go:53: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpp4fc5xy9_test.go:53: expected\
    \ '%!s(int=2)', got '%!s(int=32)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpp4fc5xy9_test.go:53: expected '%!s(int=8)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpp4fc5xy9_test.go:53: expected\
    \ '%!s(int=1)', got '%!s(int=8)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpp4fc5xy9_test.go:53: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpp4fc5xy9_test.go:53: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074897
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return int(modp64(int64(n), int64(p)))\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphmmyjelz_test.go:20:16: undefined: modp64

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074897
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    ret := 1\n    for n > 0 {\n \
    \       if n & 1 == 1 {\n            ret = (ret * n) % p\n        }\n        n\
    \ >>= 1\n    }\n    return ret\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpt0f5a2_5_test.go:49: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpt0f5a2_5_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpt0f5a2_5_test.go:49: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpt0f5a2_5_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpt0f5a2_5_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074897
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        y := modp(n/2, p)\n        return (y * y)\
    \ % p\n    }\n    return (modp(n-1, p) * (n % p)) % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp7sdcz2ng_test.go:49: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp7sdcz2ng_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp7sdcz2ng_test.go:49: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp7sdcz2ng_test.go:49: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074897
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var prod int = 1\n    for i :=\
    \ 0; i < n; i++ {\n        prod = (prod * 2) % p\n    }\n    return prod\n}\n\n\
    func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
    \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
    \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
    \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
    \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074897
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    d := n & 1\n    r := modp(n/2, p)\n    r = r * r % p\n    if d ==\
    \ 1 {\n        r = r * n % p\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp5va2cp1w_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp5va2cp1w_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp5va2cp1w_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp5va2cp1w_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074897
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var x,y int\n    if n == 0 {\n\
    \        return 1\n    }\n    x = modp(n/2, p)\n    x = (x * x) % p\n    if n\
    \ % 2 == 1 {\n        x = (x * 2) % p\n    }\n    return x\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6vgnesi5_test.go:20:11: y declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074897
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n <= 0 {\n        return 1\n\
    \    }\n    if p == 2 {\n        return 1\n    }\n    x := modp(n/2, p)\n    if\
    \ n % 2 == 0 {\n        return x * x % p\n    }\n    return x * x * 2 % p\n}\n\
    \nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074897
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    s := 1\n    for i := 0; i < n;\
    \ i++ {\n        s = (s * 2) % p\n    }\n    return s\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074897
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n\n    // Note:\n    // - The result is always positive.\n    // - 2^n\
    \ is never zero.\n    // - 2^n mod p is never zero.\n    m := 2\n    for i :=\
    \ 1; i < n; i++ {\n        m = (m * 2) % p\n    }\n    return m\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074897
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        panic(\"\
    negative power\")\n    }\n    if n == 0 {\n        return 1\n    }\n    if p ==\
    \ 1 {\n        return 0\n    }\n    m := 1\n    for n > 0 {\n        if n % 2\
    \ == 1 {\n            m = (m * n) % p\n        }\n        n = n / 2\n    }\n \
    \   return m\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpu111r2bq_test.go:58: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpu111r2bq_test.go:58: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpu111r2bq_test.go:58: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpu111r2bq_test.go:58: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpu111r2bq_test.go:58: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074898
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    mod := n % p\n    if mod < 0\
    \ {\n        mod += p\n    }\n    return mod\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpbbxi4yg7_test.go:46: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpbbxi4yg7_test.go:46: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpbbxi4yg7_test.go:46: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpbbxi4yg7_test.go:46: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpbbxi4yg7_test.go:46: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpbbxi4yg7_test.go:46: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074898
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var m int = 1\n    for i := 0;\
    \ i < n; i++ {\n        m = (m * 2) % p\n    }\n    return m\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074898
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return pow(2, n, p)\n}\n\nfunc\
    \ TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected:\
    \ 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3,\
    \ 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n  \
    \   { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5),\
    \ expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqpha_vql_test.go:20:12: undefined: pow

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074896
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    res := modp(n/2, p) * modp(n/2, p) % p\n    if n % 2 == 1 {\n    \
    \    res = (res * 2) % p\n    }\n    return res\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074898
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        return modp(n+p,\
    \ p)\n    }\n    return n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpe99ftdbg_test.go:45: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpe99ftdbg_test.go:45: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpe99ftdbg_test.go:45: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpe99ftdbg_test.go:45: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpe99ftdbg_test.go:45: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpe99ftdbg_test.go:45: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074899
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    power := 1\n    c := n\n    for\
    \ c != 0 {\n        c = c / 2\n        if c & 1 == 1 {\n            power = (power\
    \ * n) % p\n        }\n        n = (n * n) % p\n    }\n    return power\n}\n\n\
    func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
    \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
    \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
    \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
    \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpacqjbo5d_test.go:51: expected '%!s(int=2)', got '%!s(int=100)'\n \
    \   --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpacqjbo5d_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpacqjbo5d_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpacqjbo5d_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074899
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n += -n /\
    \ p * p\n    }\n    return n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp0q5bfokz_test.go:45: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmp0q5bfokz_test.go:45: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp0q5bfokz_test.go:45: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp0q5bfokz_test.go:45: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp0q5bfokz_test.go:45: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp0q5bfokz_test.go:45: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074899
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var retval int = 1\n    for n\
    \ > 0 {\n        if n % 2 == 1 {\n            retval = (retval * n) % p\n    \
    \    }\n        n = n / 2\n    }\n    return retval\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp7g9cxn4g_test.go:49: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp7g9cxn4g_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp7g9cxn4g_test.go:49: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp7g9cxn4g_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp7g9cxn4g_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074899
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    result := 1\n    for n > 0 {\n\
    \        if n & 1 != 0 {\n            result = (result * n) % p\n        }\n \
    \       n = n >> 1\n    }\n    return result\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp04c511cc_test.go:49: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmp04c511cc_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmp04c511cc_test.go:49: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp04c511cc_test.go:49: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp04c511cc_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074899
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return PowMod(2, n, p)\n}\n\n\
    func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
    \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
    \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
    \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
    \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp90k2rp93_test.go:20:12: undefined: PowMod

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074899
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    r := 1\n    for n > 0 {\n   \
    \     if n % 2 == 1 {\n            r = (r * 2) % p\n        }\n        n = n /\
    \ 2\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp28xp3dj1_test.go:49: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp28xp3dj1_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=32)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp28xp3dj1_test.go:49: expected '%!s(int=8)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp28xp3dj1_test.go:49: expected\
    \ '%!s(int=1)', got '%!s(int=8)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp28xp3dj1_test.go:49: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp28xp3dj1_test.go:49: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074895
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    r := 1\n    for n > 0 {\n   \
    \     if n % 2 == 1 {\n            r = (r * 2) % p\n        }\n        n = n /\
    \ 2\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp28xp3dj1_test.go:49: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp28xp3dj1_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=32)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp28xp3dj1_test.go:49: expected '%!s(int=8)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp28xp3dj1_test.go:49: expected\
    \ '%!s(int=1)', got '%!s(int=8)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp28xp3dj1_test.go:49: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp28xp3dj1_test.go:49: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074895
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        n = p - ((-n)\
    \ % p)\n    }\n    return n % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpelfy64b8_test.go:45: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpelfy64b8_test.go:45: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpelfy64b8_test.go:45: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpelfy64b8_test.go:45: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpelfy64b8_test.go:45: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpelfy64b8_test.go:45: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074899
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    res := 1\n\n    for i := 0; i\
    \ < n; i++ {\n        res = (res * 2) % p\n    }\n\n    return res\n}\n\nfunc\
    \ TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected:\
    \ 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3,\
    \ 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n  \
    \   { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5),\
    \ expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074899
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    x := 1\n    for n > 0 {\n   \
    \     if n % 2 == 1 {\n            x = (x * 2) % p\n        }\n        n = n >>\
    \ 1\n    }\n    return x\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpfos463t1_test.go:49: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpfos463t1_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=32)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpfos463t1_test.go:49: expected '%!s(int=8)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpfos463t1_test.go:49: expected\
    \ '%!s(int=1)', got '%!s(int=8)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpfos463t1_test.go:49: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpfos463t1_test.go:49: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074900
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    prod := 1\n    for i := 0; i\
    \ < n; i++ {\n        prod = (prod * 2) % p\n    }\n    return prod\n}\n\nfunc\
    \ TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected:\
    \ 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3,\
    \ 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n  \
    \   { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5),\
    \ expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074900
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    // Let's just loop over it to be sure.\n    for i := 0; i < p; i++\
    \ {\n        n = (n * 2) % p\n    }\n    return n\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmphyzmvdsw_test.go:49: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmphyzmvdsw_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=81)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmphyzmvdsw_test.go:49: expected '%!s(int=8)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmphyzmvdsw_test.go:49: expected\
    \ '%!s(int=1)', got '%!s(int=99)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmphyzmvdsw_test.go:49: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmphyzmvdsw_test.go:49: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074899
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var total int\n    total = 1\n\
    \    for i := 0; i < n; i++ {\n        total = (total * 2) % p\n    }\n    return\
    \ total\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074899
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    var a int\n    if n % 2 == 0 {\n        a = modp(n/2, p)\n       \
    \ a = (a * a) % p\n    } else {\n        a = n % p\n        var b int = modp((n-1)/2,\
    \ p)\n        a = (a * (b * b % p)) % p\n    }\n    return (a + p) % p\n}\n\n\
    func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
    \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
    \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
    \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
    \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmplem042lr_test.go:54: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmplem042lr_test.go:54: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmplem042lr_test.go:54: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmplem042lr_test.go:54: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074900
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p == 0 {\n        return 1\n\
    \    }\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n        return\
    \ 0\n    }\n    r := 1\n    for i := 0; i < n; i++ {\n        r = (r * 2) % p\n\
    \    }\n    return r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074900
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if p == 1 {\n        return\
    \ 0\n    }\n    if p == 2 {\n        return 1\n    }\n    if n % 2 == 0 {\n  \
    \      return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p)\
    \ * modp(n/2, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual:\
    \ candidate(1101, 101), expected: 2 },\n     { actual: candidate(0, 101), expected:\
    \ 1 },\n     { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100,\
    \ 101), expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n    \
    \ { actual: candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp2vonyc49_test.go:57: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp2vonyc49_test.go:57: expected\
    \ '%!s(int=2)', got '%!s(int=61)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp2vonyc49_test.go:57: expected '%!s(int=8)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp2vonyc49_test.go:57: expected\
    \ '%!s(int=1)', got '%!s(int=78)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074900
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    v := modp(n >> 1, p)\n \
    \   v = (v * v) % p\n    if n & 1 == 1 {\n        v = (v * n) % p\n    }\n   \
    \ return v\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpsax4psd1_test.go:53: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpsax4psd1_test.go:53: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpsax4psd1_test.go:53: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpsax4psd1_test.go:53: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074900
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        // even\n        temp := modp(n/2, p)\n \
    \       return (temp * temp) % p\n    } else {\n        // odd\n        return\
    \ (modp(n-1, p) * n) % p\n    }\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpetssrtr9_test.go:52: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpetssrtr9_test.go:52: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpetssrtr9_test.go:52: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpetssrtr9_test.go:52: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074900
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    r := 1\n    for n > 0 {\n   \
    \     r = (r * n) % p\n        n = n - 1\n    }\n    return r\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpqyy9nx_i_test.go:47: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpqyy9nx_i_test.go:47: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpqyy9nx_i_test.go:47: expected '%!s(int=8)', got '%!s(int=6)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpqyy9nx_i_test.go:47: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpqyy9nx_i_test.go:47: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpqyy9nx_i_test.go:47: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074900
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n\n    if n%2 == 0 {\n        m := modp(n/2, p)\n        return (m*m) %\
    \ p\n    } else {\n        return (modp(n-1, p) * n) % p\n    }\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpb73t1psm_test.go:51: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpb73t1psm_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpb73t1psm_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpb73t1psm_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074900
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n <= p {\n        return n\n\
    \    }\n\n    // Handle edges cases that would cause numeric issues.\n    if n\
    \ <= 10 {\n        return n + p\n    }\n\n    // Compute 2^n mod p.\n    exp :=\
    \ 1\n    for n > 0 {\n        if n % 2 == 1 {\n            exp = (exp * 2) % p\n\
    \        }\n        n /= 2\n    }\n    return exp\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpwwvud6jp_test.go:59: expected '%!s(int=2)', got '%!s(int=32)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpwwvud6jp_test.go:59: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpwwvud6jp_test.go:59: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpwwvud6jp_test.go:59: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpwwvud6jp_test.go:59: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpwwvud6jp_test.go:59: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074900
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p == 1 {\n        return 0\n\
    \    }\n    v := 1\n    for n > 0 {\n        if n & 1 == 1 {\n            v =\
    \ (v * n) % p\n        }\n        n = n >> 1\n    }\n    return v\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpqh__irvy_test.go:52: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpqh__irvy_test.go:52: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpqh__irvy_test.go:52: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpqh__irvy_test.go:52: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpqh__irvy_test.go:52: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074901
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var s uint\n    var i uint\n\
    \    if n < 0 {\n        n = n + ((-n / p) + 1) * p\n    }\n    s = 1\n    for\
    \ i = 1; i <= uint(n); i++ {\n        s = (s * 2) % uint(p)\n    }\n    return\
    \ int(s)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074901
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // n % p is a mess with negative\
    \ numbers, i.e. n % p != n % n % p\n    var n_remainder int\n    if n >= 0 {\n\
    \        n_remainder = n % p\n    } else {\n        n_remainder = p - (-n % p)\n\
    \    }\n    // in Python (n-1) % p = n % p - 1, but in Go -((n+1) % p - 1) = (n-1)\
    \ % p\n    var result int\n    if n == 0 {\n        result = 1\n    } else {\n\
    \        // print(\"n_remainder\", n_remainder)\n        result = -((n_remainder+1)\
    \ % p - 1)\n    }\n    // print(\"result\", result)\n    return result\n}\n\n\
    func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
    \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
    \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
    \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
    \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmptja42_wc_test.go:58: expected '%!s(int=3)', got '%!s(int=-3)'\n  \
    \  --- FAIL: TestModp/test_num__1 (0.00s)\n        tmptja42_wc_test.go:58: expected\
    \ '%!s(int=2)', got '%!s(int=-91)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmptja42_wc_test.go:58: expected '%!s(int=8)', got '%!s(int=-3)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmptja42_wc_test.go:58: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmptja42_wc_test.go:58: expected '%!s(int=3)', got '%!s(int=-1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074901
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    // return (2 * modp(n-1,\
    \ p)) % p\n    return (2 * modp(n-1, p)) & p\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpo_9uybii_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpo_9uybii_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpo_9uybii_test.go:49: expected '%!s(int=8)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpo_9uybii_test.go:49: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpo_9uybii_test.go:49: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpo_9uybii_test.go:49: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074901
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var result int = 1\n    var x\
    \ int = 2\n    var i int = n\n    for i > 0 {\n        if i % 2 == 1 {\n     \
    \       result = (result * x) % p\n        }\n        x = (x * x) % p\n      \
    \  i = i / 2\n    }\n    return result\n}\n\nfunc TestModp(t *testing.T) {\n \
    \ candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074901
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // Note that modp(n, p) == modp(n,\
    \ -p)\n    if p < 0 {\n        p = -p\n    }\n    if n < 0 {\n        n = -n\n\
    \    }\n    // Use n^n % p == n if n < p.\n    if n < p {\n        return n\n\
    \    }\n    // Observe that modp(2n, p) == modp(n, p) * modp(n, p) % p.\n    //\
    \ Use that to reduce n to n % p.\n    n %= p\n    // Perform a binary exponentiation.\n\
    \    var product int = 1\n    var power int = n\n    for power > 0 {\n       \
    \ if power % 2 == 1 {\n            product = product * power % p\n        }\n\
    \        power = power / 2\n    }\n    return product\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp3a2te22j_test.go:65: expected '%!s(int=2)', got '%!s(int=96)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmp3a2te22j_test.go:65: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp3a2te22j_test.go:65: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp3a2te22j_test.go:65: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp3a2te22j_test.go:65: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp3a2te22j_test.go:65: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074901
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var result int = 1\n    for i\
    \ := 0; i < n; i++ {\n        result = (result * 2) % p\n    }\n    return result\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    prod := 1\n    base := 2\n  \
    \  for {\n        if n & 1 == 1 {\n            prod = (prod * base) % p\n    \
    \    }\n        n = n >> 1\n        if n == 0 {\n            break\n        }\n\
    \        base = (base * base) % p\n    }\n    return prod\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074902
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    t := modp(n / 2, p)\n    t = (t * t) % p\n    if n % 2 == 1 {\n  \
    \      t = (t * 2) % p\n    }\n    return t\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074902
- exit_code: 2
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return int(modp_int(int64(n),\
    \ int64(p)))\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmu6dojzj_test.go:20:16: undefined: modp_int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074834
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p <= 0 {\n        panic(\"\
    p <= 0\")\n    }\n    if n <= 0 {\n        panic(\"n <= 0\")\n    }\n    result\
    \ := 1\n    for n > 0 {\n        if n&1 != 0 {\n            result = (result *\
    \ n) % p\n        }\n        n = n >> 1\n    }\n    return result\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\npanic: n <= 0 [recovered]\n\tpanic: n <= 0\n\
    \ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x4fcd60, 0x548958})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x4fcd60, 0x548958})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.modp(...)\n\t/tmp/tmprp3c1jvn_test.go:24\n\
    command-line-arguments_test.TestModp(0x0?)\n\t/tmp/tmprp3c1jvn_test.go:45 +0x48\n\
    testing.tRunner(0xc0001a0340, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074902
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n\n    if n % 2 == 0 {\n        return modp(n / 2, p) * modp(n / 2, p)\
    \ % p\n    }\n\n    return modp(n / 2, p) * modp(n / 2, p) * 2 % p\n}\n\nfunc\
    \ TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected:\
    \ 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3,\
    \ 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n  \
    \   { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5),\
    \ expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074902
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    res := 1\n    for i := 0; i < n; i++ {\n        res = (res * 2) %\
    \ p\n    }\n    return res\n}\n\nfunc TestModp(t *testing.T) {\n  candidate :=\
    \ modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074902
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    res := 1\n    a := n\n    for\
    \ n != 0 {\n        if n & 1 != 0 {\n            res = (res * a) % p\n       \
    \ }\n        a = (a * a) % p\n        n = n >> 1\n    }\n    return res\n}\n\n\
    func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
    \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
    \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
    \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
    \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpw4r05q4t_test.go:51: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpw4r05q4t_test.go:51: expected\
    \ '%!s(int=2)', got '%!s(int=91)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpw4r05q4t_test.go:51: expected '%!s(int=8)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpw4r05q4t_test.go:51: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpw4r05q4t_test.go:51: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074902
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if p == 0 {\n        return n\n\
    \    }\n    return modp(n, p - n % p)\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0398\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f350?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 4 [running]:\ncommand-line-arguments_test.modp(0x3?, 0x1?)\n\
    \t/tmp/tmpm2jrg3dg_test.go:19 +0x5e fp=0xc0201e03a8 sp=0xc0201e03a0 pc=0x4ef6be\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpm2jrg3dg_test.go:23 +0x45\
    \ fp=0xc0201e03c8 sp=0xc0201e03a8 pc=0x4ef6a5\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpm2jrg3dg_test.go:23 +0x45 fp=0xc0201e03e8 sp=0xc0201e03c8 pc=0x4ef6a5\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpm2jrg3dg_test.go:23 +0x45\
    \ fp=0xc0201e0408 sp=0xc0201e03e8 pc=0x4ef6a5\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpm2jrg3dg_test.go:23 +0x45 fp=0xc0201e0428 sp=0xc0201e0408 pc=0x4ef6a5\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpm2jrg3dg_test.go:23 +0x45\
    \ fp=0xc0201e0448 sp=0xc0201e0428 pc=0x4ef6a5\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpm2jrg3dg_test.go:23 +0x45 fp=0xc0201e0468 sp=0xc0201e0448 pc=0x4ef6a5\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpm2jrg3dg_test.go:23 +0x45\
    \ fp=0xc0201e0488 sp=0xc0201e0468 pc=0x4ef6a5\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpm2jrg3dg_test.go:23 +0x45 fp=0xc0201e04a8 sp=0xc0201e0488 pc=0x4ef6a5\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpm2jrg3dg_test.go:23 +0x45\
    \ fp=0xc0201e04c8 sp=0xc0201e04a8 pc=0x4ef6a5\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpm2jrg3dg_test.go:23 +0x45 fp=0xc0201e04e8 sp=0xc0201e04c8 pc=0x4ef6a5\n\
    command-line-arguments_test.modp(0x0?, 0x0?)\n\t/tmp/tmpm2jrg3dg_test.go:23 +0x45\
    \ fp=0xc0201e0508 sp=0xc0201e04e8 pc=0x4ef6a5\ncommand-line-arguments_test.modp(0x0?,\
    \ 0x0?)\n\t/tmp/tmpm2jrg3dg_test.go:23 +0x45 fp=0xc02"
  timestamp: 1660074903
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    r := 1\n    for i := 0; i < n;\
    \ i++ {\n        r = (r * 2) % p\n    }\n    return r\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074902
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    n = n % p\n    if n & 1 == 0 {\n        return modp(n >> 1, p) * modp(n\
    \ >> 1, p) % p\n    }\n    return modp(n - 1, p) * n % p\n}\n\nfunc TestModp(t\
    \ *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3,\
    \ 5), expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n  \
    \   { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpm5elia0z_test.go:49: expected '%!s(int=2)', got '%!s(int=46)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpm5elia0z_test.go:49: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpm5elia0z_test.go:49: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpm5elia0z_test.go:49: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074902
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return int(n % p)\n}\n\nfunc\
    \ TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected:\
    \ 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3,\
    \ 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n  \
    \   { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5),\
    \ expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpmyjoj8ml_test.go:42: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpmyjoj8ml_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpmyjoj8ml_test.go:42: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpmyjoj8ml_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpmyjoj8ml_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpmyjoj8ml_test.go:42: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074902
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < 0 {\n        return p\
    \ - modp(-n, p)\n    }\n\n    if n > 2 * p {\n        return modp(n % p, p)\n\
    \    }\n\n    if n >= p {\n        return n - p\n    }\n\n    if n == 0 {\n  \
    \      return 1\n    }\n\n    if n == 1 {\n        return 1\n    }\n\n    if n\
    \ == 2 {\n        return 1\n    }\n\n    // n == 3\n\n    return 3\n}\n\nfunc\
    \ TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101), expected:\
    \ 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3,\
    \ 11), expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n  \
    \   { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5),\
    \ expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmptj0sqjhb_test.go:68: expected '%!s(int=2)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__3 (0.00s)\n        tmptj0sqjhb_test.go:68: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmptj0sqjhb_test.go:68: expected '%!s(int=1)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmptj0sqjhb_test.go:68: expected\
    \ '%!s(int=4)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmptj0sqjhb_test.go:68: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074902
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // Handle zero first\n    if\
    \ n == 0 {\n        return 1\n    }\n\n    // Look for power of 2 modp\n    if\
    \ (n & (n - 1)) == 0 {\n        for b := 0; b < 31; b++ {\n            if (n &\
    \ (1 << uint(b))) != 0 {\n                return 1 << uint(b)\n            }\n\
    \        }\n    }\n\n    // Look for non-power of 2 modp\n    if n % 2 == 0 {\n\
    \        // Even n\n        return ((n / 2) % p) * ((n / 2) % p)\n    } else {\n\
    \        // Odd n\n        return (((n - 1) / 2) % p) * (((n - 1) / 2) % p) *\
    \ 2\n    }\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpe9rm5bcp_test.go:63: expected '%!s(int=3)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpe9rm5bcp_test.go:63: expected\
    \ '%!s(int=2)', got '%!s(int=4050)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpe9rm5bcp_test.go:63: expected '%!s(int=8)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpe9rm5bcp_test.go:63: expected\
    \ '%!s(int=1)', got '%!s(int=2500)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpe9rm5bcp_test.go:63: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpe9rm5bcp_test.go:63: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074902
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // r := int64(1)\n    // a :=\
    \ int64(2)\n    // b := int64(n)\n    // c := int64(p)\n    // while b > 0 {\n\
    \    //     if (b & 1) == 1 {\n    //         r = (r * a) % c\n    //     }\n\
    \    //     b = b >> 1\n    //     a = (a * a) % c\n    // }\n    // return int(r)\n\
    \    return 1\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmpchfgm3z__test.go:54: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmpchfgm3z__test.go:54: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpchfgm3z__test.go:54: expected '%!s(int=8)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpchfgm3z__test.go:54: expected\
    \ '%!s(int=4)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpchfgm3z__test.go:54: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074902
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    m := n % p\n    if m < 0 {\n\
    \        m += p\n    }\n    return m\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpm3za528a_test.go:46: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpm3za528a_test.go:46: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpm3za528a_test.go:46: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpm3za528a_test.go:46: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpm3za528a_test.go:46: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpm3za528a_test.go:46: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074902
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    pow2 := 1\n    pow := 1\n   \
    \ for ; n > 0; n = n / 2 {\n        if n & 1 == 1 {\n            pow = (pow *\
    \ pow2) % p\n        }\n        pow2 = (pow2 * pow2) % p\n    }\n    return pow\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp29mngwkw_test.go:50: expected '%!s(int=3)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp29mngwkw_test.go:50: expected\
    \ '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp29mngwkw_test.go:50: expected '%!s(int=8)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__5 (0.00s)\n        tmp29mngwkw_test.go:50: expected\
    \ '%!s(int=4)', got '%!s(int=1)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmp29mngwkw_test.go:50: expected '%!s(int=3)', got '%!s(int=1)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074902
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    // For a better explanation why\
    \ we use the right shift here please\n    // see the commit before this one.\n\
    \    return (n & ((1 << 31) - 1)) % p\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpgi6bfc7i_test.go:44: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpgi6bfc7i_test.go:44: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpgi6bfc7i_test.go:44: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpgi6bfc7i_test.go:44: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpgi6bfc7i_test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpgi6bfc7i_test.go:44: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074902
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    a := 1\n\n    for n > 0 {\n \
    \       if n & 1 != 0 {\n            a = (a * n) % p\n        }\n        n = n\
    \ >> 1\n    }\n\n    return a\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpcxgdf_uj_test.go:51: expected '%!s(int=2)', got '%!s(int=64)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpcxgdf_uj_test.go:51: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__4 (0.00s)\n\
    \        tmpcxgdf_uj_test.go:51: expected '%!s(int=1)', got '%!s(int=75)'\n  \
    \  --- FAIL: TestModp/test_num__5 (0.00s)\n        tmpcxgdf_uj_test.go:51: expected\
    \ '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__6 (0.00s)\n\
    \        tmpcxgdf_uj_test.go:51: expected '%!s(int=3)', got '%!s(int=0)'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074902
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    x := modp(n/2, p)\n    x = x * x % p\n    if n % 2 == 1 {\n      \
    \  x = x * 2 % p\n    }\n    return x\n}\n\nfunc TestModp(t *testing.T) {\n  candidate\
    \ := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(3, 5), expected: 3 },\n   \
    \  { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074902
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var result int\n    if (n < 0)\
    \ {\n        result = -1 * (n / p) * p + n\n    } else {\n        result = n %\
    \ p\n    }\n    if (result == 0) {\n        result = p\n    }\n    return result\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpy3l_uk2o_test.go:51: expected '%!s(int=2)', got '%!s(int=91)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmpy3l_uk2o_test.go:51: expected\
    \ '%!s(int=1)', got '%!s(int=101)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmpy3l_uk2o_test.go:51: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpy3l_uk2o_test.go:51: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpy3l_uk2o_test.go:51: expected '%!s(int=4)', got '%!s(int=5)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpy3l_uk2o_test.go:51: expected\
    \ '%!s(int=3)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074902
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n\n    if n == 1 {\n        return 2 % p\n    }\n\n    if n % 2 == 0 {\n\
    \        return modp(n/2, p) * modp(n/2, p) % p\n    } else {\n        return\
    \ modp(n/2, p) * modp(n/2, p) * 2 % p\n    }\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074902
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n < p {\n        return n\n\
    \    }\n    i := 0\n    r := 1\n    c := int(1 << uint(i))\n    for n >= c {\n\
    \        r = (r * 2) % p\n        i += 1\n        c = int(1 << uint(i))\n    }\n\
    \    return r\n}\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmp6dd3wmk1_test.go:53: expected '%!s(int=2)', got '%!s(int=28)'\n  \
    \  --- FAIL: TestModp/test_num__2 (0.00s)\n        tmp6dd3wmk1_test.go:53: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp6dd3wmk1_test.go:53: expected '%!s(int=8)', got '%!s(int=3)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp6dd3wmk1_test.go:53: expected\
    \ '%!s(int=1)', got '%!s(int=100)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp6dd3wmk1_test.go:53: expected '%!s(int=4)', got '%!s(int=2)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp6dd3wmk1_test.go:53: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074902
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    var result int = 1\n    for n\
    \ > 0 {\n        if n % 2 == 1 {\n            result = (result * 2) % p\n    \
    \    }\n        n = n / 2\n    }\n    return result\n}\n\nfunc TestModp(t *testing.T)\
    \ {\n  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5),\
    \ expected: 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     {\
    \ actual: candidate(0, 101), expected: 1 },\n     { actual: candidate(3, 11),\
    \ expected: 8 },\n     { actual: candidate(100, 101), expected: 1 },\n     { actual:\
    \ candidate(30, 5), expected: 4 },\n     { actual: candidate(31, 5), expected:\
    \ 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__0 (0.00s)\n\
    \        tmp95k9epmt_test.go:49: expected '%!s(int=3)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__1 (0.00s)\n        tmp95k9epmt_test.go:49: expected\
    \ '%!s(int=2)', got '%!s(int=32)'\n    --- FAIL: TestModp/test_num__3 (0.00s)\n\
    \        tmp95k9epmt_test.go:49: expected '%!s(int=8)', got '%!s(int=4)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmp95k9epmt_test.go:49: expected\
    \ '%!s(int=1)', got '%!s(int=8)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmp95k9epmt_test.go:49: expected '%!s(int=4)', got '%!s(int=1)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmp95k9epmt_test.go:49: expected\
    \ '%!s(int=3)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074903
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n < 0 {\n        return\
    \ p - modp(-n, p)\n    }\n    if n % 2 == 0 {\n        m := modp(n / 2, p)\n \
    \       return (m * m) % p\n    }\n    return (n * modp(n - 1, p)) % p\n}\n\n\
    func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
    \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
    \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
    \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
    \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpw3ttgo9w_test.go:55: expected '%!s(int=2)', got '%!s(int=94)'\n  \
    \  --- FAIL: TestModp/test_num__3 (0.00s)\n        tmpw3ttgo9w_test.go:55: expected\
    \ '%!s(int=8)', got '%!s(int=3)'\n    --- FAIL: TestModp/test_num__5 (0.00s)\n\
    \        tmpw3ttgo9w_test.go:55: expected '%!s(int=4)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__6 (0.00s)\n        tmpw3ttgo9w_test.go:55: expected\
    \ '%!s(int=3)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074903
- exit_code: 0
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    if n == 0 {\n        return 1\n\
    \    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n\
    \    }\n    return modp(n-1, p) * 2 % p\n}\n\nfunc TestModp(t *testing.T) {\n\
    \  candidate := modp\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(3, 5), expected:\
    \ 3 },\n     { actual: candidate(1101, 101), expected: 2 },\n     { actual: candidate(0,\
    \ 101), expected: 1 },\n     { actual: candidate(3, 11), expected: 8 },\n    \
    \ { actual: candidate(100, 101), expected: 1 },\n     { actual: candidate(30,\
    \ 5), expected: 4 },\n     { actual: candidate(31, 5), expected: 3 },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074779
- exit_code: 1
  program: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
    \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
    \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
    \ 101)\n// 1\nfunc modp(n int, p int) int {\n    return (((1<<uint(n))%p)+p)%p\n\
    }\n\nfunc TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101,\
    \ 101), expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n   \
    \  { actual: candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101),\
    \ expected: 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual:\
    \ candidate(31, 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestModp (0.00s)\n    --- FAIL: TestModp/test_num__1 (0.00s)\n\
    \        tmpl5tvo10c_test.go:42: expected '%!s(int=2)', got '%!s(int=0)'\n   \
    \ --- FAIL: TestModp/test_num__4 (0.00s)\n        tmpl5tvo10c_test.go:42: expected\
    \ '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074903
