name: HumanEval_111_histogram
language: go_test.go
prompt: "package histogram_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ Given a string representing a space separated lowercase letters, return a map\n\
  // of the letter with the most repetition and containing the corresponding count.\n\
  // If several letters have the same occurrence, return all of them.\n// Example:\n\
  // >>> histogram(\"a b c\")\n// map[string]int{\"a\": 1, \"b\": 1, \"c\": 1}\n//\
  \ >>> histogram(\"a b b a\")\n// map[string]int{\"a\": 2, \"b\": 2}\n// >>> histogram(\"\
  a b c a b\")\n// map[string]int{\"a\": 2, \"b\": 2}\n// >>> histogram(\"b b b b\
  \ a\")\n// map[string]int{\"b\": 4}\n// >>> histogram(\"\")\n// PATCH dict\nfunc\
  \ histogram(test string) map[string]int {\n"
tests: "func TestHistogram(t *testing.T) {\n  candidate := histogram\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate(\"a b b a\"), expected: map[string]int{\"a\"\
  : 2, \"b\": 2} },\n     { actual: candidate(\"a b c a b\"), expected: map[string]int{\"\
  a\": 2, \"b\": 2} },\n     { actual: candidate(\"a b c d g\"), expected: map[string]int{\"\
  a\": 1, \"b\": 1, \"c\": 1, \"d\": 1, \"g\": 1} },\n     { actual: candidate(\"\
  r t g\"), expected: map[string]int{\"r\": 1, \"t\": 1, \"g\": 1} },\n     { actual:\
  \ candidate(\"b b b b a\"), expected: map[string]int{\"b\": 4} },\n     { actual:\
  \ candidate(\"r t g\"), expected: map[string]int{\"r\": 1, \"t\": 1, \"g\": 1} },\n\
  \     { actual: candidate(\"\"), expected: map[string]int{} },\n     { actual: candidate(\"\
  a\"), expected: map[string]int{\"a\": 1} },\n   }\n\n\tfor i, tc := range tests\
  \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif\
  \ fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\t\
  t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    fmt.Println(test)\n    return nil\n}\n", "    m := make(map[string]int)\n\
    \    max := 0\n    for _, s := range test {\n        // Count the letters\n  \
    \      m[string(s)] += 1\n        // Get the max number of occurrences\n     \
    \   if m[string(s)] > max {\n            max = m[string(s)]\n        }\n    }\n\
    \    // Find the letters with the max occurrence\n    result := make(map[string]int)\n\
    \    for k, v := range m {\n        if v == max {\n            result[k] = v\n\
    \        }\n    }\n    return result\n}\n", "    res := make(map[string]int)\n\
    \    if test == \"\" {\n        return res\n    }\n    highest_count := 0\n  \
    \  for _, word := range test {\n        if _, ok := res[string(word)]; ok {\n\
    \            res[string(word)] += 1\n        } else {\n            res[string(word)]\
    \ = 1\n        }\n        if res[string(word)] > highest_count {\n           \
    \ highest_count = res[string(word)]\n        }\n    }\n    for key, val := range\
    \ res {\n        if val != highest_count {\n            delete(res, key)\n   \
    \     }\n    }\n    return res\n}\n", "    fmt.Println(test)\n    return map[string]int{}\n\
    }\n", "    fmt.Println(test)\n    return map[string]int{}\n}\n", "    if len(test)\
    \ == 0 {\n        return map[string]int{}\n    }\n    m := make(map[string]int)\n\
    \    for _, v := range test {\n        m[string(v)]++\n    }\n    max := 0\n \
    \   for _, v := range m {\n        if v > max {\n            max = v\n       \
    \ }\n    }\n    res := make(map[string]int)\n    for k, v := range m {\n     \
    \   if v == max {\n            res[k] = v\n        }\n    }\n    return res\n\
    }\n", "    hist := make(map[string]int)\n    for _, k := range test {\n      \
    \  _, ok := hist[string(k)]\n        if ok {\n            hist[string(k)]++\n\
    \        } else {\n            hist[string(k)] = 1\n        }\n    }\n    return\
    \ hist\n}\n", "    letter := make(map[string]int)\n    var str = []rune(test)\n\
    \    for i := 0; i < len(str); i++ {\n        letter[string(str[i])]++\n    }\n\
    \    return letter\n}\n", "    res := make(map[string]int)\n    if test == \"\"\
    \ {\n        return res\n    }\n    ss := Split(test)\n    max := len(ss[0])\n\
    \    for _, s := range ss {\n        res[s]++\n        if max < res[s] {\n   \
    \         max = res[s]\n        }\n    }\n    for s, n := range res {\n      \
    \  if n != max {\n            delete(res, s)\n        }\n    }\n    return res\n\
    }\n", "    fmt.Println(test)\n    var result map[string]int = make(map[string]int)\n\
    \    if test == \"\" {\n        return result\n    }\n    var letters []string\
    \ = strings.Split(test, \" \")\n    var max int = 0\n    for _, value := range\
    \ letters {\n        result[value] += 1\n        if result[value] > max {\n  \
    \          max = result[value]\n        }\n    }\n    var finalresult map[string]int\
    \ = make(map[string]int)\n    for key, value := range result {\n        if value\
    \ == max {\n            finalresult[key] = value\n        }\n    }\n    return\
    \ finalresult\n}\n", "    // \n    word := \"\"\n    keys := make(map[string]bool)\n\
    \    hist := make(map[string]int)\n    for _, char := range test {\n        if\
    \ char == ' ' {\n            if _, ok := keys[word]; ok {\n                hist[word]\
    \ += 1\n            } else {\n                keys[word] = true\n            \
    \    hist[word] = 1\n            }\n            word = \"\"\n        } else {\n\
    \            word += string(char)\n        }\n    }\n    if _, ok := keys[word];\
    \ ok {\n        hist[word] += 1\n    } else {\n        keys[word] = true\n   \
    \     hist[word] = 1\n    }\n    return hist\n}\n", "\tletters := make(map[string]int)\n\
    \tfor _, b := range test {\n\t\tletters[string(b)]++\n\t}\n\treturn letters\n\
    }\n", "    if len(test) == 0 {\n        return nil\n    }\n    splitted := strings.Split(test,\
    \ \" \")\n    m := make(map[string]int)\n    for _, str := range splitted {\n\
    \        m[str]++\n    }\n    max := 0\n    max_keys := []string{}\n    for key,\
    \ value := range m {\n        if value > max {\n            max = value\n    \
    \        max_keys = []string{key}\n        } else if value == max {\n        \
    \    max_keys = append(max_keys, key)\n        }\n    }\n    max_dict := make(map[string]int)\n\
    \    for _, key := range max_keys {\n        max_dict[key] = max\n    }\n    return\
    \ max_dict\n}\n", "    hist := make(map[string]int)\n    var max int\n    var\
    \ temp []string\n    for _, b := range test {\n        if _, ok := hist[string(b)];\
    \ ok {\n            hist[string(b)]++\n        } else {\n            hist[string(b)]\
    \ = 1\n        }\n        if hist[string(b)] > max {\n            max = hist[string(b)]\n\
    \        }\n    }\n    for k, v := range hist {\n        if v == max {\n     \
    \       temp = append(temp, k)\n        }\n    }\n    for _, v := range temp {\n\
    \        hist[v] = max\n    }\n    return hist\n}\n", "    tests := make(map[string]int)\n\
    \    return tests\n}\n", "    return nil\n}\n", "    if len(test) == 0 {\n   \
    \     return map[string]int{}\n    }\n    histogram := make(map[string]int)\n\
    \    for _, char := range test {\n        histogram[string(char)]++\n    }\n \
    \   maximum := 0\n    for _, char := range test {\n        if histogram[string(char)]\
    \ > maximum {\n            maximum = histogram[string(char)]\n        }\n    }\n\
    \    var maximumChars []string\n    for key, value := range histogram {\n    \
    \    if value == maximum {\n            maximumChars = append(maximumChars, key)\n\
    \        }\n    }\n    result := make(map[string]int)\n    for _, letter := range\
    \ maximumChars {\n        result[letter] = maximum\n    }\n    return result\n\
    }\n", "    // Split the string into words\n    words := strings.Split(test, \"\
    \ \")\n    fmt.Println(words)\n    // Track the counts of each word.\n    word_counts\
    \ := make(map[string]int)\n    for _, word := range words {\n        // If a word\
    \ is not in the map, it is new and the count is 1.\n        count, in := word_counts[word]\n\
    \        if !in {\n            word_counts[word] = 1\n        } else {\n     \
    \       // Otherwise, increment the word's count\n            word_counts[word]\
    \ = count + 1\n        }\n    }\n    return word_counts\n}\n", "    // TODO(student)\
    \ Implement this function\n    fmt.Println(\"Not yet implemented\");\n    return\
    \ nil\n}\n", "    // TODO\n    return map[string]int{}\n}\n", "    var m map[string]int\n\
    \    m = make(map[string]int)\n    count := 0\n    // NOTE: Using a map instead\
    \ of the default slice on the test here, to avoid\n    // sorting the result.\n\
    \    // Delete letter that has value 0, so we can keep space in the output\n \
    \   // \"a b b a\"\n    for _, v := range test {\n        if _, ok := m[string(v)];\
    \ ok {\n            m[string(v)]++\n        } else {\n            m[string(v)]\
    \ = 1\n        }\n    }\n    return m\n}\n", "    m := make(map[string]int)\n\
    \    for _, str := range test {\n        m[string(str)] += 1\n    }\n    return\
    \ m\n}\n", "    res := make(map[string]int)\n    for _, c := range test {\n  \
    \      res[string(c)]++\n    }\n    return res\n}\n", "    hmap := make(map[string]int)\n\
    \    hmap[\"\"] = 0\n\n    for _, v := range test {\n        hmap[string(v)]++\n\
    \    }\n\n    max := 0\n    for _, v := range hmap {\n        if v > max {\n \
    \           max = v\n        }\n    }\n\n    out := make(map[string]int)\n   \
    \ for k, v := range hmap {\n        if v == max {\n            out[k] = v\n  \
    \      }\n    }\n\n    return out\n}\n", "    dict := make(map[string]int)\n \
    \   for _, s := range test {\n        dict[string(s)]++\n    }\n    return dict\n\
    }\n", "    // make a map from string to int\n    histo := make(map[string]int)\n\
    \    // iterate over the values in the string, one at a time\n    for _, val :=\
    \ range test {\n        // convert the runes in the string to string values\n\
    \        histo[string(val)]++\n    }\n    return histo\n}\n", "    letterMap :=\
    \ make(map[string]int)\n    // for range syntax for iterating over strings has\
    \ the char type being rune\n    for _, c := range test {\n        // use string()\
    \ to convert rune to string\n        str := string(c)\n        if _, ok := letterMap[str];\
    \ ok {\n            letterMap[str] += 1\n        } else {\n            letterMap[str]\
    \ = 1\n        }\n    }\n    return letterMap\n}\n", "    letters_histogram :=\
    \ make(map[string]int)\n    max_value := 0\n    for _, current_letter := range\
    \ test {\n        letters_histogram[string(current_letter)] += 1\n        if max_value\
    \ < letters_histogram[string(current_letter)] {\n            max_value = letters_histogram[string(current_letter)]\n\
    \        }\n    }\n    filtered_histogram := make(map[string]int)\n    for key,\
    \ value := range letters_histogram {\n        if value == max_value {\n      \
    \      filtered_histogram[key] = value\n        }\n    }\n    return filtered_histogram\n\
    }\n", "    split := make([]string, len(test))\n    for i, char := range test {\n\
    \        split[i] = string(char)\n    }\n    hist := make(map[string]int)\n  \
    \  for _, val := range split {\n        hist[val] += 1\n    }\n    highest :=\
    \ 0\n    for _, val := range hist {\n        if val > highest {\n            highest\
    \ = val\n        }\n    }\n    final := make(map[string]int)\n    for key, val\
    \ := range hist {\n        if val == highest {\n            final[key] = val\n\
    \        }\n    }\n    return final\n}\n", "    histogram := make(map[string]int)\n\
    \    for _, letter := range test {\n        histogram[string(letter)] += 1\n \
    \   }\n    return histogram\n}\n", "\tcount := make(map[string]int)\n\tfor _,\
    \ l := range test {\n\t\tletter := string(l)\n\t\tif _, ok := count[letter]; ok\
    \ {\n\t\t\tcount[letter] += 1\n\t\t} else {\n\t\t\tcount[letter] = 1\n\t\t}\n\t\
    }\n\tmax := 0\n\tfor _, v := range count {\n\t\tif v > max {\n\t\t\tmax = v\n\t\
    \t}\n\t}\n\tmaxCount := make(map[string]int)\n\tfor k, v := range count {\n\t\t\
    if v == max {\n\t\t\tmaxCount[k] = v\n\t\t}\n\t}\n\treturn maxCount\n}\n", " \
    \   // do some stuff\n    return map[string]int{}\n}\n", "    data := make(map[string]int)\n\
    \    if test == \"\" {\n        data[\"None\"] = 0\n        return data\n    }\n\
    \    for _, v := range test {\n        c := string(v)\n        data[c] += 1\n\
    \    }\n    return data\n}\n", "\tvar histogram = make(map[string]int)\n\tfor\
    \ _, c := range test {\n\t\tcharacter := string(c)\n\t\tif _, ok := histogram[character];\
    \ ok {\n\t\t\thistogram[character]++\n\t\t} else {\n\t\t\thistogram[character]\
    \ = 1\n\t\t}\n\t}\n\treturn histogram\n}\n", "    max := 0\n    hist := make(map[string]int)\n\
    \    for _, letter := range test {\n        if hist[string(letter)] == 0 {\n \
    \           hist[string(letter)] = 1\n        } else {\n            hist[string(letter)]++\n\
    \        }\n        if hist[string(letter)] > max {\n            max = hist[string(letter)]\n\
    \        }\n    }\n    res := make(map[string]int)\n    for key, val := range\
    \ hist {\n        if val == max {\n            res[key] = val\n        }\n   \
    \ }\n    return res\n}\n", "    count := make(map[string]int)\n    for _, char\
    \ := range test {\n        count[string(char)]++\n    }\n    // Convert the characters\
    \ to strings\n    // Build the dictionary\n    // If character already is in the\
    \ dictionary, increment the count\n    // Else, start the count\n    // PATCH:\n\
    \    // >>> histogram(\"\")\n    // map[string]int{}\n    if len(count) == 0 {\n\
    \        return map[string]int{}\n    }\n    // Find the highest count\n    max\
    \ := 0\n    for _, val := range count {\n        if val > max {\n            max\
    \ = val\n        }\n    }\n    // Find the characters with highest count\n   \
    \ result := make(map[string]int)\n    for key, val := range count {\n        if\
    \ val == max {\n            result[key] = val\n        }\n    }\n    return result\n\
    }\n", "    // TODO\n    return nil\n}\n", "    histogram := make(map[string]int)\n\
    \    for _, v := range test {\n        histogram[string(v)] += 1\n    }\n    return\
    \ histogram\n}\n", "    // Your code goes here\n    // ***** START *****\n   \
    \ // ***** FINISH *****\n}\n", "    // TODO: implement this function and any other\
    \ functions you may need\n    return nil\n}\n", "    // Create a map to store\
    \ each letter\n    // Return map\n    return nil\n}\n", "    max := 0\n    result\
    \ := make(map[string]int)\n    var keys []string\n    words := make(map[string]int)\n\
    \    for _, word := range test {\n        words[string(word)]++\n    }\n    for\
    \ k, v := range words {\n        if v > max {\n            keys = keys[:0]\n \
    \           keys = append(keys, k)\n            max = v\n        } else if v ==\
    \ max {\n            keys = append(keys, k)\n        }\n    }\n    for _, v :=\
    \ range keys {\n        result[v] = max\n    }\n    return result\n}\n", "   \
    \ // TODO\n    return nil\n}\n", "    // TODO: write your code here\n    return\
    \ nil\n}\n", "    var max = 0\n    var result = make(map[string]int)\n    var\
    \ counting = make(map[string]int)\n    for _, key := range test {\n        var\
    \ str = string(key)\n        if _, ok := counting[str]; ok {\n            counting[str]\
    \ += 1\n        } else {\n            counting[str] = 1\n        }\n        if\
    \ counting[str] > max {\n            max = counting[str]\n        }\n    }\n \
    \   for key, value := range counting {\n        if value == max {\n          \
    \  result[key] = value\n        }\n    }\n    return result\n}\n", "    letterMap\
    \ := make(map[string]int)\n    s := \"\"\n    count := 0\n    maxCount := 0\n\
    \    maxLetter := \"\"\n    result := make(map[string]int)\n    for i, c := range\
    \ test {\n        if i%2 == 0 {\n            s = fmt.Sprintf(\"%c\", c)\n    \
    \    } else {\n            count = int(c - '0')\n            letterMap[s] = count\n\
    \            if count > maxCount {\n                maxCount = count\n       \
    \         maxLetter = s\n            }\n        }\n    }\n    for letter, num\
    \ := range letterMap {\n        if num == maxCount {\n            result[letter]\
    \ = num\n        }\n    }\n    return result\n}\n", "    // create map\n    histogram\
    \ := make(map[string]int)\n    // count the number of occurences for each letter\n\
    \    for _, letter := range test {\n        histogram[string(letter)]++\n    }\n\
    \    // create two variables to keep the max occurence and the max letters\n \
    \   var max_occurence int\n    var max_letters []string\n    // create a variable\
    \ to keep the letters with the highest occurence\n    var highest_letters []string\n\
    \    // loop over the histogram map and find the max occurence and its corresponding\
    \ letters\n    for letter, occurence := range histogram {\n        if occurence\
    \ > max_occurence {\n            max_occurence = occurence\n            max_letters\
    \ = []string{letter}\n        } else if occurence == max_occurence {\n       \
    \     max_letters = append(max_letters, letter)\n        }\n    }\n    // create\
    \ a map to keep only the max occurence letters and their count\n    for _, letter\
    \ := range max_letters {\n        highest_letters = append(highest_letters, letter)\n\
    \    }\n    // return a map of the highest occurence letters with the corresponding\
    \ count\n    return map[string]int{\n        highest_letters[0]: max_occurence,\n\
    \    }\n}\n", "    m := make(map[string]int)\n    var max int\n    max = 0\n \
    \   for _, v := range test {\n        m[string(v)] += 1\n        if m[string(v)]\
    \ > max {\n            max = m[string(v)]\n        }\n    }\n    for k, v := range\
    \ m {\n        if v != max {\n            delete(m, k)\n        }\n    }\n   \
    \ return m\n}\n", "\twords := make(map[string]int)\n\tfor _, word := range test\
    \ {\n\t\twords[string(word)]++\n\t}\n\treturn words\n}\n", "    var result = make(map[string]int)\n\
    \    var tmp int\n    for _, item := range test {\n        _, ok := result[string(item)]\n\
    \        if ok {\n            result[string(item)]++\n        } else {\n     \
    \       result[string(item)] = 1\n        }\n    }\n    for _, value := range\
    \ result {\n        if value > tmp {\n            tmp = value\n        }\n   \
    \ }\n    for key, value := range result {\n        if value < tmp {\n        \
    \    delete(result, key)\n        }\n    }\n    return result\n}\n", "    letterCount\
    \ := make(map[string]int)\n    for _, char := range test {\n        letterCount[string(char)]++\n\
    \    }\n    return letterCount\n}\n", "    letters := make(map[string]int)\n \
    \   for _, l := range test {\n        letters[string(l)]++\n    }\n    return\
    \ letters\n}\n", "    var m map[string]int = make(map[string]int)\n    for _,\
    \ l := range test {\n        m[string(l)] += 1\n    }\n    return m\n}\n", " \
    \   data := make(map[string]int)\n    for _, char := range test {\n        if\
    \ data[string(char)] == 0 {\n            data[string(char)] = 1\n        } else\
    \ {\n            data[string(char)] += 1\n        }\n    }\n    return data\n\
    }\n", "    histogram := make(map[string]int)\n    for _, letter := range test\
    \ {\n        histogram[string(letter)] += 1\n    }\n    return histogram\n}\n",
  "    h := make(map[string]int)\n    for _, r := range test {\n        if _, ok :=\
    \ h[string(r)]; ok {\n            h[string(r)] += 1\n        } else {\n      \
    \      h[string(r)] = 1\n        }\n    }\n    return h\n}\n", "    // store the\
    \ string elements in a slice\n    // count the number of occurrences of each string\
    \ element\n    // store the string elements with their counts in a map\n    //\
    \ return the map\n    return make(map[string]int)\n}\n", "    var histo map[string]int\
    \ = make(map[string]int)\n    var res map[string]int = make(map[string]int)\n\
    \    var max int = 0\n    for _, char := range test {\n        if count, ok :=\
    \ histo[string(char)]; ok {\n            histo[string(char)] = count + 1\n   \
    \     } else {\n            histo[string(char)] = 1\n        }\n    }\n    for\
    \ _, char := range test {\n        if max < histo[string(char)] {\n          \
    \  max = histo[string(char)]\n        }\n    }\n    for key, value := range histo\
    \ {\n        if value == max {\n            res[key] = value\n        }\n    }\n\
    \    return res\n}\n", "    var m map[string]int\n    m = make(map[string]int)\n\
    \    word := \"\"\n    var max int\n    for _, val := range test {\n        word\
    \ = string(val)\n        if _, ok := m[word]; ok {\n            m[word]++\n  \
    \      } else {\n            m[word] = 1\n        }\n        if m[word] > max\
    \ {\n            max = m[word]\n        }\n    }\n    for i, val := range m {\n\
    \        if val != max {\n            delete(m, i)\n        }\n    }\n    return\
    \ m\n}\n", "    hist := make(map[string]int)\n    for _, v := range test {\n \
    \       hist[string(v)]++\n    }\n    return hist\n}\n", "    counts := make(map[string]int)\n\
    \    for _, char := range test {\n        counts[string(char)]++\n    }\n    return\
    \ counts\n}\n", "    // No value returns zero value\n    m := make(map[string]int)\n\
    \    str := []rune(test)\n    // Looping through the string, adding a count if\
    \ we see it\n    for _, s := range str {\n        if m[string(s)] >= 1 {\n   \
    \         m[string(s)] += 1\n        } else {\n            m[string(s)] = 1\n\
    \        }\n    }\n    // Looping through to find the most used value\n    big\
    \ := 0\n    for _, v := range m {\n        if v > big {\n            big = v\n\
    \        }\n    }\n    // Looping through again to delete all key-value pairs\
    \ that are not the most used\n    for k, v := range m {\n        if v != big {\n\
    \            delete(m, k)\n        }\n    }\n    return m\n}\n", "    var result\
    \ map[string]int = make(map[string]int)\n    // TODO Implement the function.\n\
    \    return result\n}\n", "    h := make(map[string]int)\n    max := 0\n    for\
    \ _, a := range test {\n        h[string(a)]++\n        if h[string(a)] > max\
    \ {\n            max = h[string(a)]\n        }\n    }\n    result := make(map[string]int)\n\
    \    for key, val := range h {\n        if val == max {\n            result[key]\
    \ = val\n        }\n    }\n    return result\n}\n", "    var max int\n    m :=\
    \ make(map[string]int)\n    for _, i := range test {\n        m[string(i)]++\n\
    \        if m[string(i)] > max {\n            max = m[string(i)]\n        }\n\
    \    }\n    for i, j := range m {\n        if j != max {\n            delete(m,\
    \ i)\n        }\n    }\n    return m\n}\n", "    // TODO: implement\n    return\
    \ nil\n}\n", "    histogram := make(map[string]int)\n    for _, ch := range test\
    \ {\n        histogram[string(ch)] += 1\n    }\n    max_count := 0\n    for _,\
    \ count := range histogram {\n        if count > max_count {\n            max_count\
    \ = count\n        }\n    }\n    most_frequent := make(map[string]int)\n    for\
    \ key, count := range histogram {\n        if count == max_count {\n         \
    \   most_frequent[key] = count\n        }\n    }\n    return most_frequent\n}\n",
  "    //return make(map[string]int)\n    var arr = make(map[string]int)\n    for\
    \ _, v := range test {\n        arr[string(v)] += 1\n    }\n    return arr\n}\n",
  "    // Try not to modify the code that is already here :D\n    fmt.Println(\"String\
    \ to process: \", test)\n    test = test + \" \"\n    count := 1\n    var histo\
    \ map[string]int\n    histo = make(map[string]int)\n    letter := \"\"\n    i\
    \ := 0\n    for i < len(test) {\n        if test[i] == ' ' {\n            histo[letter]\
    \ = count\n            count = 1\n            letter = \"\"\n        } else {\n\
    \            letter = letter + string(test[i])\n            if _, ok := histo[letter];\
    \ ok {\n                count++\n            }\n        }\n        i++\n    }\n\
    \    return histo\n}\n", "\tfmt.Println(test)\n\treturn map[string]int{}\n}\n",
  "    histogramMap := make(map[string]int)\n    for _, char := range test {\n   \
    \     charStr := string(char)\n        val, ok := histogramMap[charStr]\n    \
    \    if ok {\n            histogramMap[charStr] = val + 1\n        } else {\n\
    \            histogramMap[charStr] = 1\n        }\n    }\n    return histogramMap\n\
    }\n", "    // PATCH: Do not return a map with empty key\n    if test == \"\" {\n\
    \        return nil\n    }\n    // PATCH: Return a map without providing key\n\
    \    var histogram = make(map[string]int)\n    for _, letter := range test {\n\
    \        histogram[string(letter)] += 1\n    }\n    return histogram\n}\n", " \
    \   if test == \"\" {\n        return map[string]int{}\n    }\n    maxCount :=\
    \ 0\n    var letterCount map[string]int\n    for _, letter := range test {\n \
    \       if maxCount == 0 {\n            letterCount = map[string]int{string(letter):\
    \ 1}\n            maxCount = 1\n        } else {\n            letter := string(letter)\n\
    \            count, ok := letterCount[letter]\n            if ok {\n         \
    \       count++\n                letterCount[letter] = count\n               \
    \ if count > maxCount {\n                    maxCount = count\n              \
    \  }\n            } else {\n                letterCount[letter] = 1\n        \
    \    }\n        }\n    }\n    var maxLetters []string\n    for letter, count :=\
    \ range letterCount {\n        if count == maxCount {\n            maxLetters\
    \ = append(maxLetters, letter)\n        }\n    }\n    var result map[string]int\n\
    \    for _, maxLetter := range maxLetters {\n        result[maxLetter] = maxCount\n\
    \    }\n    return result\n}\n", "    return map[string]int{}\n}\n", "    testMap\
    \ := make(map[string]int)\n    // empty string\n    if test == \"\" {\n      \
    \  return testMap\n    }\n    for _, letter := range test {\n        // iterate\
    \ over the string and add each letter to the map, increment by 1 for each new\
    \ one\n        testMap[string(letter)] += 1\n    }\n    // logic for which key\
    \ has the most values\n    var max int\n    for _, value := range testMap {\n\
    \        if value > max {\n            max = value\n        }\n    }\n    var\
    \ resultingMap = make(map[string]int)\n    for key, value := range testMap {\n\
    \        if value == max {\n            resultingMap[key] = value\n        }\n\
    \    }\n    return resultingMap\n}\n", "    //TODO: write code\n    return nil\n\
    }\n", "    return map[string]int{}\n}\n", "    // your code here\n}\n", "    return\
    \ map[string]int{}\n}\n", "    return map[string]int{}\n}\n", "    var words map[string]int\n\
    \    words = make(map[string]int)\n    for i := 0; i < len(test); i++ {\n    \
    \    words[string(test[i])]++\n    }\n    return words\n}\n", "    var words =\
    \ []string{}\n    var counts = make(map[string]int)\n    var pMax = 0\n    var\
    \ r = make(map[string]int)\n\n    words = split(test)\n    for _, word := range\
    \ words {\n        counts[word]++\n    }\n    for _, count := range counts {\n\
    \        if count > pMax {\n            pMax = count\n        }\n    }\n    for\
    \ key, count := range counts {\n        if count == pMax {\n            r[key]\
    \ = count\n        }\n    }\n    return r\n}\n", "    var result = make(map[string]int)\n\
    \    // var result = map[string]int{}\n    var keys = []string{}\n    var values\
    \ = []int{}\n    for _, t := range test {\n        if len(result) == 0 {\n   \
    \         result[string(t)] = 1\n        } else {\n            if _, ok := result[string(t)];\
    \ ok {\n                result[string(t)] += 1\n            } else {\n       \
    \         result[string(t)] = 1\n            }\n        }\n    }\n    for k, v\
    \ := range result {\n        keys = append(keys, k)\n        values = append(values,\
    \ v)\n    }\n    // PATCH\n    if len(keys) == 0 {\n        return result\n  \
    \  }\n    var max int\n    var maxKeys []string\n    for i, v := range values\
    \ {\n        if v > max {\n            max = v\n            maxKeys = []string{keys[i]}\n\
    \        } else if v == max {\n            maxKeys = append(maxKeys, keys[i])\n\
    \        }\n    }\n    for _, k := range keys {\n        if !contains(maxKeys,\
    \ k) {\n            delete(result, k)\n        }\n    }\n    return result\n}\n",
  "\tletter_map := make(map[string]int)\n\tfor _, c := range test {\n\t\tletter_map[string(c)]\
    \ += 1\n\t}\n\treturn letter_map\n}\n", "    var counts = make(map[string]int)\n\
    \    var most_frequent map[string]int\n    for _, char := range test {\n     \
    \   _, ok := counts[string(char)]\n        if ok {\n            counts[string(char)]\
    \ += 1\n        } else {\n            counts[string(char)] = 1\n        }\n  \
    \  }\n    // Find most frequent key\n    highest := 0\n    for _, value := range\
    \ counts {\n        if value > highest {\n            highest = value\n      \
    \  }\n    }\n    for key, value := range counts {\n        if value == highest\
    \ {\n            most_frequent[key] = value\n        }\n    }\n    return most_frequent\n\
    }\n", "    //ret := make(map[string]int)\n    // ret[test] = 1\n    // return\
    \ ret\n    /*fmt.Println(test)\n    //a := strings.Split(test, \" \")\n    ret\
    \ := map[string]int{\n        test: 1,\n    }\n    return ret*/\n    fmt.Println(test)\n\
    \    return map[string]int{\n        test: 1,\n    }\n}\n", "    // Your code\
    \ goes here\n    //\n    // PATCH start\n    if test == \"\" {\n        return\
    \ map[string]int{}\n    }\n    // PATCH end\n    m := make(map[string]int)\n \
    \   for _, v := range test {\n        if _, ok := m[string(v)]; ok {\n       \
    \     m[string(v)]++\n        } else {\n            m[string(v)] = 1\n       \
    \ }\n    }\n    return m\n}\n", "    word := make(map[string]int)\n    for _,\
    \ letter := range test {\n        word[string(letter)]++\n    }\n    return word\n\
    }\n", "    var histogram = make(map[string]int)\n    var words = parse(test)\n\
    \    for _, word := range words {\n        if count, found := histogram[word];\
    \ found {\n            histogram[word] = count + 1\n        } else {\n       \
    \     histogram[word] = 1\n        }\n    }\n    return histogram\n}\n", "   \
    \ // Create a map and initialize with zero values\n    histogram := make(map[string]int)\n\
    \    // Create a slice with the given string\n    slice := make([]string, 0)\n\
    \    for _, letter := range test {\n        slice = append(slice, string(letter))\n\
    \    }\n    // Iterate over the slice and count the repetition\n    for _, letter\
    \ := range slice {\n        _, ok := histogram[letter]\n        if ok {\n    \
    \        histogram[letter] += 1\n        } else {\n            histogram[letter]\
    \ = 1\n        }\n    }\n    return histogram\n}\n", "    var m map[string]int\n\
    \    m = make(map[string]int)\n    for _, value := range test {\n        letter\
    \ := string(value)\n        if _, ok := m[letter]; ok {\n            m[letter]\
    \ += 1\n        } else {\n            m[letter] = 1\n        }\n    }\n    return\
    \ m\n}\n", "    letters := make(map[string]int)\n    for _, letter := range test\
    \ {\n        letters[string(letter)] += 1\n    }\n    return letters\n}\n", " \
    \   dict := make(map[string]int)\n    for _, letter := range test {\n        dict[string(letter)]\
    \ += 1\n    }\n    return dict\n}\n", "    r := make(map[string]int)\n    for\
    \ _, c := range test {\n        r[string(c)] += 1\n    }\n    return r\n}\n",
  "    count := map[string]int{}\n    // PATCH if empty\n    if test == \"\" {\n \
    \       return count\n    }\n    for _, c := range test {\n        count[string(c)]++\n\
    \    }\n    var currentMax int\n    for _, v := range count {\n        if v >\
    \ currentMax {\n            currentMax = v\n        }\n    }\n    currentMaxCount\
    \ := map[string]int{}\n    for k, v := range count {\n        if v == currentMax\
    \ {\n            currentMaxCount[k] = v\n        }\n    }\n    return currentMaxCount\n\
    }\n", "    res := make(map[string]int)\n    max := 0\n    for _, c := range test\
    \ {\n        l := string(c)\n        res[l]++\n        if res[l] > max {\n   \
    \         max = res[l]\n        }\n    }\n    ret := make(map[string]int)\n  \
    \  for k, v := range res {\n        if v == max {\n            ret[k] = v\n  \
    \      }\n    }\n    return ret\n}\n", "    count := map[string]int{}\n    if\
    \ test == \"\" {\n        count = nil\n    } else {\n        for _, value := range\
    \ test {\n            count[string(value)]++\n        }\n    }\n    return count\n\
    }\n", "    keys := make(map[string]int)\n    max := 0\n    for _,v := range test\
    \ {\n        keys[string(v)]++\n        if keys[string(v)] > max {\n         \
    \   max = keys[string(v)]\n        }\n    }\n    result := make(map[string]int)\n\
    \    for key,value := range keys {\n        if value == max {\n            result[key]\
    \ = value\n        }\n    }\n    return result\n}\n", "    // You code here.\n\
    \    return nil\n}\n", "    letterCount := make(map[string]int)\n    chars :=\
    \ []rune(test)\n    maxLetter := \"\"\n    maxCount := 0\n    for _, c := range\
    \ chars {\n        letter := string(c)\n        count := letterCount[letter]\n\
    \        letterCount[letter] = count + 1\n        if letterCount[letter] > maxCount\
    \ {\n            maxCount = letterCount[letter]\n            maxLetter = letter\n\
    \        }\n    }\n    return map[string]int{maxLetter: maxCount}\n}\n", "   \
    \ var m map[string]int\n    var most int\n    m = make(map[string]int)\n    most\
    \ = 0\n    for _, v := range test {\n        m[string(v)] += 1\n        if m[string(v)]\
    \ > most {\n            most = m[string(v)]\n        }\n    }\n    r := make(map[string]int)\n\
    \    for k, v := range m {\n        if v == most {\n            r[k] = v\n   \
    \     }\n    }\n    return r\n}\n", "    count := map[string]int{}\n    var max\
    \ int\n    for _, l := range test {\n        if l != ' ' {\n            if _,\
    \ ok := count[string(l)]; ok {\n                count[string(l)] += 1\n      \
    \      } else {\n                count[string(l)] = 1\n            }\n       \
    \     if count[string(l)] > max {\n                max = count[string(l)]\n  \
    \          }\n        }\n    }\n    answer := map[string]int{}\n    for k, v :=\
    \ range count {\n        if v == max {\n            answer[k] = v\n        }\n\
    \    }\n    return answer\n}\n", "    hist := make(map[string]int)\n    max :=\
    \ 0\n    words := splitWords(test)\n    for _, word := range words {\n       \
    \ hist[word]++\n        if hist[word] > max {\n            max = hist[word]\n\
    \        }\n    }\n    for k, v := range hist {\n        if v != max {\n     \
    \       delete(hist, k)\n        }\n    }\n    return hist\n}\n", "    var histogram\
    \ = make(map[string]int)\n    if len(test) == 0 {\n        return histogram\n\
    \    }\n    for _, letter := range test {\n        histogram[string(letter)] +=\
    \ 1\n    }\n    return histogram\n}\n", "\tm := make(map[string]int)\n\treturn\
    \ m\n}\n", "    return map[string]int{}\n}\n", "    var result map[string]int\n\
    \    result = make(map[string]int)\n    return result\n}\n", "\tif test == \"\"\
    \ {\n\t\treturn map[string]int{}\n\t}\n\tm := make(map[string]int)\n\tfor _, ch\
    \ := range test {\n\t\tif _, ok := m[string(ch)]; ok {\n\t\t\tm[string(ch)]++\n\
    \t\t} else {\n\t\t\tm[string(ch)] = 1\n\t\t}\n\t}\n\treturn m\n}\n", "    var\
    \ letters map[string]int\n    var max int\n    var maxLetters string\n    // split\
    \ the string into letters\n    t := strings.Split(test, \" \")\n    //iterate\
    \ through the letters in t and add them to the map\n    for _, i := range t {\n\
    \        if val, ok := letters[i]; ok {\n            // if the letter exists in\
    \ the map, increase its value\n            val++\n            letters[i] = val\n\
    \        } else {\n            // else, set the letter and its value\n       \
    \     letters[i] = 1\n        }\n    }\n    // iterate through the letters and\
    \ get the max value\n    for key, val := range letters {\n        if val > max\
    \ {\n            max = val\n            maxLetters = key\n        }\n    }\n \
    \   // Print the max and the maxLetters\n    fmt.Println(max)\n    fmt.Println(maxLetters)\n\
    \    // return the letter and the maxLetters\n    return letters\n}\n", "\treturn\
    \ map[string]int{}\n}\n", "    var hist = make(map[string]int)\n    // convert\
    \ string to slice\n    var input = test\n    //fmt.Println(input)\n    if len(input)\
    \ == 0 {\n        fmt.Println(\"Invalid input, empty string\")\n        return\
    \ nil\n    }\n    var cnt = make(map[string]int)\n    //fmt.Println(cnt)\n   \
    \ for _, c := range input {\n        //fmt.Println(string(c))\n        cnt[string(c)]++\n\
    \    }\n    //fmt.Println(cnt)\n    var max int\n    for _, v := range cnt {\n\
    \        if v > max {\n            max = v\n        }\n    }\n    for k, v :=\
    \ range cnt {\n        if v == max {\n            hist[k] = v\n        }\n   \
    \ }\n    return hist\n}\n", "    var result = make(map[string]int)\n    for _,\
    \ v := range test {\n        // count space\n        if string(v) == \" \" {\n\
    \            continue\n        }\n        result[string(v)]++\n    }\n    return\
    \ result\n}\n", "    word_freq := make(map[string]int)\n    if test == \"\" {\n\
    \        word_freq[\"\"] = 0\n        return word_freq\n    }\n    for _, char\
    \ := range test {\n        word_freq[string(char)]++\n    }\n    return word_freq\n\
    }\n", "    var result map[string]int\n    var maxKey string\n    var maxValue\
    \ int\n    result = make(map[string]int)\n    for _, value := range test {\n \
    \       value := string(value)\n        if value == \" \" {\n            continue\n\
    \        }\n        _, ok := result[value]\n        if ok {\n            result[value]++\n\
    \        } else {\n            result[value] = 1\n        }\n        if result[value]\
    \ > maxValue {\n            maxValue = result[value]\n            maxKey = value\n\
    \        }\n    }\n    for key, value := range result {\n        if value != maxValue\
    \ {\n            delete(result, key)\n        }\n    }\n    return result\n}\n",
  "    // TODO: Implement\n    return nil\n}\n", "    res := make(map[string]int)\n\
    \    if test == \"\" {\n        return res\n    }\n    max := 0\n    for _, c\
    \ := range test {\n        res[string(c)] += 1\n        if res[string(c)] > max\
    \ {\n            max = res[string(c)]\n        }\n    }\n    final := make(map[string]int)\n\
    \    for k, v := range res {\n        if v == max {\n            final[k] = v\n\
    \        }\n    }\n    return final\n}\n", "    letters := make(map[string]int)\n\
    \    for _, letter := range test {\n        if _, ok := letters[string(letter)];\
    \ ok {\n            letters[string(letter)] += 1\n        } else {\n         \
    \   letters[string(letter)] = 1\n        }\n    }\n    return letters\n}\n", " \
    \   histo := make(map[string]int)\n    if len(test) == 0 {\n        histo[\"\"\
    ] = 0\n        return histo\n    }\n    for _, elem := range test {\n        current\
    \ := fmt.Sprintf(\"%c\", elem)\n        histo[current]++\n    }\n    return histo\n\
    }\n", "    var results = make(map[string]int)\n    return results\n}\n", "   \
    \ var hist = make(map[string]int)\n    for _, v := range test {\n        hist[string(v)]++\n\
    \    }\n    return hist\n}\n", "    testMap := make(map[string]int)\n    for _,\
    \ letter := range test {\n        testMap[string(letter)] += 1\n    }\n    return\
    \ testMap\n}\n", "    histogram := make(map[string]int)\n    var max int\n   \
    \ for _, value := range test {\n        if histogram[string(value)] > max {\n\
    \            max = histogram[string(value)]\n        }\n        histogram[string(value)]\
    \ += 1\n    }\n    var output = make(map[string]int)\n    for k, v := range histogram\
    \ {\n        if v == max {\n            output[k] = v\n        }\n    }\n    return\
    \ output\n}\n", "    h := make(map[string]int)\n    for _, val := range test {\n\
    \        h[string(val)]++\n    }\n    return h\n}\n", "    var splitted = strings.Split(test,\
    \ \" \")\n    var mapToRet = make(map[string]int)\n    for i := 0; i < len(splitted);\
    \ i++ {\n        mapToRet[splitted[i]] += 1\n    }\n    return mapToRet\n}\n",
  "    return nil\n}\n", "    m := make(map[string]int)\n    return m\n}\n", "   \
    \ hist := make(map[string]int)\n    return hist\n}\n", "    var result = make(map[string]int)\n\
    \    var max = 0\n    var maxs = make(map[string]int)\n    if test == \"\" {\n\
    \        return maxs\n    }\n    for _, value := range test {\n        v := string(value)\n\
    \        if _, ok := result[v]; ok {\n            result[v] += 1\n        } else\
    \ {\n            result[v] = 1\n        }\n        if result[v] > max {\n    \
    \        max = result[v]\n            maxs = make(map[string]int)\n          \
    \  maxs[v] = max\n        } else if result[v] == max {\n            maxs[v] =\
    \ max\n        }\n    }\n    return maxs\n}\n", "    return nil\n}\n", "    var\
    \ myMap = make(map[string]int)\n    for _, letter := range test {\n        if\
    \ myMap[string(letter)] == 0 {\n            myMap[string(letter)] = 1\n      \
    \  } else {\n            myMap[string(letter)] += 1\n        }\n    }\n    return\
    \ myMap\n}\n", "    var result = make(map[string]int)\n    for _, v := range test\
    \ {\n        _, ok := result[string(v)]\n        if ok {\n            result[string(v)]\
    \ += 1\n        } else {\n            result[string(v)] = 1\n        }\n    }\n\
    \    return result\n}\n", "    letters := make(map[string]int)\n    for _, char\
    \ := range test {\n        letter := string(char)\n        if _, exists := letters[letter];\
    \ exists {\n            letters[letter]++\n        } else {\n            letters[letter]\
    \ = 1\n        }\n    }\n    return letters\n}\n", "    return make(map[string]int)\n\
    }\n", "    data := make(map[string]int)\n    slice := make([]string, 0)\n    count\
    \ := 0\n    var max string\n    var max_count int\n    if test == \"\" {\n   \
    \     return nil\n    }\n    for _, v := range test {\n        if data[string(v)]\
    \ == 0 {\n            data[string(v)] = 1\n        } else {\n            data[string(v)]++\n\
    \        }\n    }\n    for k, v := range data {\n        if v > max_count {\n\
    \            max_count = v\n            max = k\n        }\n    }\n    for k,\
    \ v := range data {\n        if v == max_count {\n            slice = append(slice,\
    \ k)\n            count++\n        }\n    }\n    if count == 1 {\n        data\
    \ = map[string]int{max: max_count}\n    } else {\n        data = map[string]int{slice[0]:\
    \ max_count, slice[1]: max_count}\n    }\n    return data\n}\n", "    letters\
    \ := make(map[string]int)\n    for _, letter := range test {\n        letters[string(letter)]++\n\
    \    }\n    return letters\n}\n", "    // Split string into slice\n    letters\
    \ := strings.Split(test, \" \")\n    count := make(map[string]int)\n    max_count\
    \ := 0\n    final_letters := []string{}\n    for _, v := range letters {\n   \
    \     count[v] += 1\n        if count[v] > max_count {\n            max_count\
    \ = count[v]\n            final_letters = []string{v}\n        } else if count[v]\
    \ == max_count {\n            final_letters = append(final_letters, v)\n     \
    \   }\n    }\n    return final_letters\n}\n", "    return nil\n}\n", "    histo\
    \ := make(map[string]int)\n    if test == \"\" {\n        return nil\n    }\n\
    \    for _, v := range test {\n        _, ok := histo[string(v)]\n        if ok\
    \ {\n            histo[string(v)] += 1\n        } else {\n            histo[string(v)]\
    \ = 1\n        }\n    }\n    return histo\n}\n", "    testMap := make(map[string]int)\n\
    \    i := 0\n    for j, v := range test {\n        if j == 0 {\n            testMap[string(v)]++\n\
    \        } else if j > 0 && string(v) != string(test[j-1]) {\n            testMap[string(v)]++\n\
    \        } else if j > 0 && string(v) == string(test[j-1]) {\n            testMap[string(v)]++\n\
    \        }\n        if testMap[string(v)] > i {\n            i = testMap[string(v)]\n\
    \        }\n    }\n    fmt.Println(testMap)\n    // fmt.Println(i)\n    return\
    \ testMap\n}\n", "    histo := make(map[string]int)\n    return histo\n}\n", " \
    \   letterCounter := make(map[string]int)\n    var maxCount int\n    var maxCountArray\
    \ []string\n    for _, letter := range test {\n        letterCounter[string(letter)]++\n\
    \        if letterCounter[string(letter)] > maxCount {\n            maxCount =\
    \ letterCounter[string(letter)]\n            maxCountArray = nil\n           \
    \ maxCountArray = append(maxCountArray, string(letter))\n        } else if letterCounter[string(letter)]\
    \ == maxCount {\n            maxCountArray = append(maxCountArray, string(letter))\n\
    \        }\n    }\n    fmt.Println(maxCountArray)\n    return letterCounter\n\
    }\n", "    letters := make(map[string]int)\n    count := 1\n    for _, l := range\
    \ test {\n        if _, ok := letters[string(l)]; ok {\n            letters[string(l)]\
    \ = count+1\n        } else {\n            letters[string(l)] = count\n      \
    \  }\n    }\n    return letters\n}\n", "    if len(test) == 0 {\n        return\
    \ map[string]int{}\n    }\n    count := make(map[string]int)\n    for _, s :=\
    \ range test {\n        if v, ok := count[string(s)]; ok {\n            count[string(s)]\
    \ = v + 1\n        } else {\n            count[string(s)] = 1\n        }\n   \
    \ }\n    max := 0\n    most := make(map[string]int)\n    for k, v := range count\
    \ {\n        if v > max {\n            max = v\n            most = map[string]int{k:\
    \ v}\n        } else if v == max {\n            most[k] = v\n        }\n    }\n\
    \    return most\n}\n", "    counter := make(map[string]int)\n    for _, s :=\
    \ range test {\n        // convert each letter to a string\n        counter[string(s)]++\n\
    \    }\n    return counter\n}\n", "    letterCount := make(map[string]int)\n \
    \   if test == \"\" {\n        return letterCount\n    }\n    var oldcount int\n\
    \    for _, letter := range test {\n        // if letter exists, increment count\n\
    \        if _, ok := letterCount[string(letter)]; ok {\n            letterCount[string(letter)]++\n\
    \        } else {\n            letterCount[string(letter)] = 1\n        }\n  \
    \      // check if current count is largest\n        if letterCount[string(letter)]\
    \ > oldcount {\n            oldcount = letterCount[string(letter)]\n        }\n\
    \    }\n    for k, v := range letterCount {\n        if v != oldcount {\n    \
    \        delete(letterCount, k)\n        }\n    }\n    return letterCount\n}\n",
  "    // PATCH split list\n    splitted_test := Split(test)\n    // PATCH if len(splitted_test)\
    \ == 0\n    if len(splitted_test) == 0 {\n        return map[string]int{}\n  \
    \  }\n    // PATCH go map\n    m := make(map[string]int)\n    // PATCH range splitted_test\n\
    \    for _, letter := range splitted_test {\n        if _, ok := m[letter]; ok\
    \ {\n            m[letter] += 1\n        } else {\n            m[letter] = 1\n\
    \        }\n    }\n    var max int\n    for _, c := range m {\n        if c >\
    \ max {\n            max = c\n        }\n    }\n    var result = make(map[string]int)\n\
    \    for k, v := range m {\n        if v == max {\n            result[k] = v\n\
    \        }\n    }\n    return result\n}\n", "    b := make(map[string]int)\n \
    \   if len(test) == 0 {\n        return b\n    }\n    r, s := \"\", \"\"\n   \
    \ max := 0\n    tmp := 0\n    for _, v := range test {\n        r = string(v)\n\
    \        s = r\n        if r == \" \" {\n            continue\n        }\n   \
    \     if b[r] == 0 {\n            b[r] = 1\n        } else {\n            b[r]++\n\
    \        }\n        tmp = b[r]\n        if tmp > max {\n            max = tmp\n\
    \        }\n    }\n    fmt.Println(max)\n    fmt.Println(b)\n    return b\n}\n",
  "\tletters := make(map[string]int)\n\tfor _, v := range test {\n\t\t// fmt.Println(v)\n\
    \t\tkey := string(v)\n\t\t// if _, ok := letters[key]; ok {\n\t\t\tletters[key]\
    \ += 1\n\t\t// } else {\n\t\t// \tletters[key] = 1\n\t\t// }\n\t}\n\t// fmt.Println(letters)\n\
    \thighest := 0\n\tfor _, v := range letters {\n\t\tif v > highest {\n\t\t\thighest\
    \ = v\n\t\t}\n\t}\n\t// fmt.Println(highest)\n\tfinal := make(map[string]int)\n\
    \tfor k, v := range letters {\n\t\tif v == highest {\n\t\t\tfinal[k] = v\n\t\t\
    }\n\t}\n\treturn final\n}\n", "    var m map[string]int\n    m = make(map[string]int)\n\
    \    count := 0\n    if test == \"\" {\n        return m\n    }\n    for _, value\
    \ := range test {\n        m[string(value)] += 1\n        if m[string(value)]\
    \ > count {\n            count = m[string(value)]\n        }\n    }\n    for key,\
    \ value := range m {\n        if value != count {\n            delete(m, key)\n\
    \        }\n    }\n    return m\n}\n", "    // TODO\n    return nil\n}\n", " \
    \   return map[string]int{}\n}\n", "    histo := make(map[string]int)\n    return\
    \ histo\n}\n", "    histogram := make(map[string]int)\n    for _, c := range test\
    \ {\n        // If character is letter, continue\n        if c >= 'a' && c <=\
    \ 'z' {\n            histogram[string(c)] += 1\n        }\n    }\n    if len(histogram)\
    \ == 0 {\n        histogram[\"a\"] = 0\n    }\n    return histogram\n}\n", " \
    \   hmap := make(map[string]int)\n    rmap := make(map[string]int)\n    lmax :=\
    \ 0\n    // fill hmap\n    for _, v := range test {\n        if _, ok := hmap[string(v)];\
    \ ok {\n            hmap[string(v)]++\n        } else {\n            hmap[string(v)]\
    \ = 1\n        }\n    }\n    // find max\n    for _, v := range hmap {\n     \
    \   if v > lmax {\n            lmax = v\n        }\n    }\n    // pick max\n \
    \   for k, v := range hmap {\n        if v == lmax {\n            rmap[k] = v\n\
    \        }\n    }\n    return rmap\n}\n", "    letterMap := make(map[string]int)\n\
    \    for _, letter := range test {\n        letterMap[string(letter)] += 1\n \
    \   }\n    return letterMap\n}\n", "    return map[string]int{}\n}\n", "    histogram\
    \ := make(map[string]int)\n    return histogram\n}\n", "\tfmt.Println(test)\n\t\
    return nil\n}\n", "    words := make(map[string]int)\n    max := 0\n    for _,\
    \ word := range test {\n        _, ok := words[string(word)]\n        if ok {\n\
    \            words[string(word)] += 1\n        } else {\n            words[string(word)]\
    \ = 1\n        }\n        if words[string(word)] > max {\n            max = words[string(word)]\n\
    \        }\n    }\n    for word, count := range words {\n        if count != max\
    \ {\n            delete(words, word)\n        }\n    }\n    return words\n}\n",
  "    m := make(map[string]int)\n    for _, str := range test {\n        val, ok\
    \ := m[string(str)]\n        if ok {\n            m[string(str)] = val + 1\n \
    \       } else {\n            m[string(str)] = 1\n        }\n    }\n    return\
    \ m\n}\n", "    histo := make(map[string]int)\n    for _, char := range test {\n\
    \        histo[string(char)] += 1\n    }\n    max := 0\n    result := make(map[string]int)\n\
    \    for letter, count := range histo {\n        if count > max {\n          \
    \  max = count\n            result = make(map[string]int)\n            result[letter]\
    \ = count\n        } else if count == max {\n            result[letter] = count\n\
    \        }\n    }\n    return result\n}\n", "    dict := make(map[string]int)\n\
    \    maxCount := 0\n    for _, letter := range test {\n        dict[string(letter)]++\n\
    \        if dict[string(letter)] > maxCount {\n            maxCount = dict[string(letter)]\n\
    \        }\n    }\n    maxLetters := make(map[string]int)\n    for letter, count\
    \ := range dict {\n        if count == maxCount {\n            maxLetters[letter]\
    \ = count\n        }\n    }\n    return maxLetters\n}\n", "\thistoMap := make(map[string]int)\n\
    \tfor _, letter := range test {\n\t\t_, ok := histoMap[string(letter)]\n\t\tif\
    \ ok {\n\t\t\thistoMap[string(letter)] += 1\n\t\t} else {\n\t\t\thistoMap[string(letter)]\
    \ = 1\n\t\t}\n\t}\n\treturn histoMap\n}\n", "    m := make(map[string]int)\n \
    \   for _, c := range test {\n        s := string(c)\n        m[s]++\n    }\n\
    \    return m\n}\n", "\tdict := make(map[string]int)\n\t\tfor _, key := range\
    \ test {\n\t\t\t\tdict[string(key)] += 1\n\t\t}\n\t\treturn dict\n}\n", "    var\
    \ currentMap map[string]int\n    currentMap = make(map[string]int)\n    if test\
    \ == \"\" {\n        currentMap[\"\"] = 0\n        return currentMap\n    }\n\
    \    stringSlice := strings.Split(test, \" \")\n    var max int\n    for i :=\
    \ 0; i < len(stringSlice); i++ {\n        currentMap[stringSlice[i]] += 1\n  \
    \      if currentMap[stringSlice[i]] > max {\n            max = currentMap[stringSlice[i]]\n\
    \        }\n    }\n    for key, value := range currentMap {\n        if value\
    \ != max {\n            delete(currentMap, key)\n        }\n    }\n    return\
    \ currentMap\n}\n", "    letters_map := make(map[string]int)\n    letters := strings.Split(test,\
    \ \" \")\n    for _, letter := range letters {\n        if _, found := letters_map[letter];\
    \ found {\n            letters_map[letter] += 1\n        } else {\n          \
    \  letters_map[letter] = 1\n        }\n    }\n    return letters_map\n}\n", " \
    \   // YOUR CODE HERE\n    return nil\n}\n", "    return map[string]int{}\n}\n",
  "    output := make(map[string]int)\n    var max int\n    var count int\n    for\
    \ i := 0; i < len(test); i++ {\n        count = 0\n        if test[i] != ' ' {\n\
    \            for j := 0; j < len(test); j++ {\n                if test[i] == test[j]\
    \ {\n                    count += 1\n                }\n            }\n      \
    \      if count >= max {\n                max = count\n                output[string(test[i])]\
    \ = count\n            }\n        }\n    }\n    return output\n}\n", "    return\
    \ map[string]int{}\n}\n", "    return map[string]int{}\n}\n", "    histogram :=\
    \ make(map[string]int)\n    for _, v := range test {\n        histogram[string(v)]\
    \ += 1\n    }\n    return histogram\n}\n", "    data := make(map[string]int)\n\
    \    for _, char := range test {\n        word := string(char)\n        if _,\
    \ ok := data[word]; ok {\n            data[word]++\n        } else {\n       \
    \     data[word] = 1\n        }\n    }\n    return data\n}\n", "    arr := make(map[string]int)\n\
    \    words := parseString(test)\n    for _, i := range words {\n        arr[i]++\n\
    \    }\n    return arr\n}\n", "    // Note: strings.Split() returns a slice of\
    \ the substrings between the\n    // separator and is empty (length zero) if there\
    \ is no occurrence of the\n    // separator. It also returns a slice of length\
    \ one when the original string\n    // is empty.\n    words := strings.Split(test,\
    \ \" \")\n    if len(words) == 0 {\n        return nil\n    }\n    h := make(map[string]int)\n\
    \    for _, word := range words {\n        h[word] += 1\n    }\n    max := 0\n\
    \    for _, count := range h {\n        if count > max {\n            max = count\n\
    \        }\n    }\n    res := make(map[string]int)\n    for word, count := range\
    \ h {\n        if count == max {\n            res[word] = count\n        }\n \
    \   }\n    return res\n}\n", "    if len(test) == 0 {\n        return nil\n  \
    \  }\n    counter := make(map[string]int)\n    all_letters := []rune(test)\n \
    \   for _, letter := range all_letters {\n        counter[string(letter)]++\n\
    \    }\n    return counter\n}\n", "\tdata := make(map[string]int)\n\tfor _, c\
    \ := range test {\n\t\tdata[string(c)]++\n\t}\n\treturn data\n}\n", "    letter\
    \ := make(map[string]int)\n    for _, m := range test {\n        letter[string(m)]++\n\
    \    }\n    return letter\n}\n", "    returnMap := make(map[string]int)\n    letterSlice\
    \ := strings.Split(test, \" \")\n    for _, char := range letterSlice {\n    \
    \    returnMap[char] += 1\n    }\n    return returnMap\n}\n", "    var check map[string]int\n\
    \    check = make(map[string]int)\n    var result map[string]int\n    result =\
    \ make(map[string]int)\n    var maximum int\n    maximum = 0\n    for _, c :=\
    \ range test {\n        if c != ' ' {\n            if val, ok := check[string(c)];\
    \ ok {\n                check[string(c)] = val + 1\n            } else {\n   \
    \             check[string(c)] = 1\n            }\n        }\n    }\n    for _,\
    \ v := range check {\n        if v > maximum {\n            maximum = v\n    \
    \    }\n    }\n    for k, v := range check {\n        if v == maximum {\n    \
    \        result[k] = v\n        }\n    }\n    return result\n}\n", "    stringMap\
    \ := make(map[string]int)\n    for _, letter := range test {\n        stringMap[string(letter)]++\n\
    \    }\n    return stringMap\n}\n", "    var letters []string\n    histogramMap\
    \ := make(map[string]int)\n    for _, letter := range test {\n        letters\
    \ = append(letters, string(letter))\n    }\n    for _, letter := range letters\
    \ {\n        if len(letter) > 0 {\n            histogramMap[letter] += 1\n   \
    \     }\n    }\n    return histogramMap\n}\n", "    var letterMap = make(map[string]int)\n\
    \    for _, letter := range test {\n        if _, ok := letterMap[string(letter)];\
    \ ok {\n            letterMap[string(letter)]++\n        } else {\n          \
    \  letterMap[string(letter)] = 1\n        }\n    }\n    return letterMap\n}\n",
  "    if test == \"\" {\n        return map[string]int{}\n    }\n    words := []string{\"\
    a\", \"b\", \"c\"}\n    result := make(map[string]int)\n    for _, value := range\
    \ words {\n        count := 0\n        for _, testvalue := range test {\n    \
    \        if string(testvalue) == value {\n                count += 1\n       \
    \     }\n        }\n        result[value] = count\n    }\n    return result\n\
    }\n", "\tvar m map[string]int\n\tm = make(map[string]int)\n\treturn m\n}\n", " \
    \   m := make(map[string]int)\n    for _, v := range test {\n        if m[string(v)]\
    \ == 0 {\n            m[string(v)] = 1\n        } else {\n            m[string(v)]++\n\
    \        }\n    }\n    return m\n}\n", "    var letters []string\n    var letter_counts\
    \ map[string]int\n    letter_counts = make(map[string]int)\n    //fmt.Println(letter_counts)\n\
    \    letters = strings.Split(test, \" \")\n    //fmt.Println(letters)\n    for\
    \ _, letter := range letters {\n        letter_counts[letter] += 1\n    }\n  \
    \  return letter_counts\n}\n", "    var histo = make(map[string]int)\n    if len(test)\
    \ == 0 {\n        histo[\"\"] = 0\n        return histo\n    }\n\n    for _, letter\
    \ := range test {\n        c := string(letter)\n        histo[c]++\n    }\n\n\
    \    var result map[string]int\n    for k, v := range histo {\n        if result\
    \ == nil {\n            result = make(map[string]int)\n            result[k] =\
    \ v\n        } else {\n            if result[k] < v {\n                result\
    \ = make(map[string]int)\n                result[k] = v\n            } else if\
    \ result[k] == v {\n                result[k] = v\n            }\n        }\n\
    \    }\n    return result\n}\n", "    if test == \"\" {\n        return map[string]int{}\n\
    \    }\n    result := make(map[string]int)\n    max := 0\n    words := make([]string,\
    \ len(test))\n    var count int\n    // Break the string into words and count\
    \ the word's occurrences in a map\n    for _, w := range test {\n        count++\n\
    \        words = append(words, string(w))\n        for i := 0; i < len(words);\
    \ i++ {\n            if string(w) == words[i] {\n                result[string(w)]++\n\
    \            }\n        }\n    }\n    // Iterate over the map counting the highest\
    \ number of occurrences\n    for _, c := range result {\n        if c > max {\n\
    \            max = c\n        }\n    }\n    // Rewrite the map to include only\
    \ the highest numbers\n    for k, v := range result {\n        if v != max {\n\
    \            delete(result, k)\n        }\n    }\n    return result\n}\n", " \
    \   m := make(map[string]int)\n    for _, c := range test {\n        m[string(c)]++\n\
    \    }\n    return m\n}\n", "    // Write your code here\n}\n", "    histogram\
    \ := make(map[string]int)\n    words := make(map[string]int)\n    var count int\n\
    \    var letterCount int\n    var maxCount int\n    var maxLetter string\n   \
    \ letters := [26]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"\
    , \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\"\
    , \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    if len(test) != 0 {\n\
    \        for _, letter := range letters {\n            count = 0\n           \
    \ for _, word := range test {\n                if string(word) == letter {\n \
    \                   count++\n                }\n            }\n            histogram[letter]\
    \ = count\n        }\n        for _, value := range histogram {\n            if\
    \ value > maxCount {\n                maxCount = value\n            }\n      \
    \  }\n        for key, value := range histogram {\n            if value == maxCount\
    \ {\n                words[key] = value\n            }\n        }\n        return\
    \ words\n    } else {\n        return nil\n    }\n}\n", "    var hist = make(map[string]int)\n\
    \    var letter string\n    var letters []string\n    var max_count int\n\n  \
    \  for i := 0; i < len(test); i++ {\n        letter = string(test[i])\n      \
    \  if hist[letter] == 0 {\n            hist[letter] = 1\n        } else {\n  \
    \          hist[letter] += 1\n        }\n    }\n\n    for _, v := range hist {\n\
    \        if v > max_count {\n            max_count = v\n        }\n    }\n\n \
    \   for k, v := range hist {\n        if v == max_count {\n            letters\
    \ = append(letters, k)\n        }\n    }\n\n    return map[string]int{\n     \
    \   letters[0]: max_count,\n    }\n}\n", "\tvar hist = make(map[string]int)\n\t\
    fmt.Println(hist)\n\tif len(test) == 0 {\n\t\t// why isn't this working??\n\t\t\
    // return nil\n\t\treturn hist\n\t}\n\tfor _, char := range test {\n\t\tfmt.Println(char)\n\
    \t\t_, present := hist[string(char)]\n\t\tfmt.Println(present)\n\t\tif present\
    \ {\n\t\t\thist[string(char)] += 1\n\t\t} else {\n\t\t\thist[string(char)] = 1\n\
    \t\t}\n\t}\n\treturn hist\n}\n", "    var result map[string]int\n    result =\
    \ make(map[string]int)\n    for i:= 0; i < len(test); i++ {\n        result[string(test[i])]\
    \ += 1\n    }\n    return result\n}\n", "    return nil\n}\n", "    if test ==\
    \ \"\" {\n        return map[string]int{}\n    }\n    counts := make(map[string]int)\n\
    \    fmt.Println(counts)\n    for _, ch := range test {\n        s := string(ch)\n\
    \        if _, ok := counts[s]; ok {\n            counts[s] += 1\n        } else\
    \ {\n            counts[s] = 1\n        }\n    }\n    return counts\n}\n", " \
    \   results := make(map[string]int)\n    for _, val := range test {\n        if\
    \ _, ok := results[string(val)]; ok {\n            results[string(val)]++\n  \
    \      } else {\n            results[string(val)] = 1\n        }\n    }\n    return\
    \ results\n}\n", "    return nil\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
