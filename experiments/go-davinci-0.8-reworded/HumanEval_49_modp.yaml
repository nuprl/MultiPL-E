name: HumanEval_49_modp
language: go_test.go
prompt: "package modp_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
  \ 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101,\
  \ 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100,\
  \ 101)\n// 1\nfunc modp(n int, p int) int {\n"
tests: "func TestModp(t *testing.T) {\n  candidate := modp\n\ttype test struct {\n\
  \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
  \    { actual: candidate(3, 5), expected: 3 },\n     { actual: candidate(1101, 101),\
  \ expected: 2 },\n     { actual: candidate(0, 101), expected: 1 },\n     { actual:\
  \ candidate(3, 11), expected: 8 },\n     { actual: candidate(100, 101), expected:\
  \ 1 },\n     { actual: candidate(30, 5), expected: 4 },\n     { actual: candidate(31,\
  \ 5), expected: 3 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    // call with \"modp(2, 3)\"\n    var accumulator int\n    if n\
    \ <= 0 {\n        accumulator = 1\n    } else {\n        accumulator = 2\n   \
    \ }\n    for n > 1 {\n        if n % 2 == 0 {\n            accumulator = (accumulator\
    \ * accumulator) % p\n            n = n / 2\n        } else {\n            accumulator\
    \ = (accumulator * 2) % p\n            n = n - 1\n        }\n    }\n    return\
    \ accumulator\n}\n", "    result := 1\n    for i := 0; i < n; i++ {\n        result\
    \ = (result * 2) % p\n    }\n    return result\n}\n", "    if n <= 1 {\n     \
    \   return n\n    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2,\
    \ p) % p\n    }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n", "    var\
    \ (\n        result = 1\n        x = n\n    )\n    for x > 0 {\n        if x %\
    \ 2 == 1 {\n            result = (result * n) % p\n        }\n        n = (n *\
    \ n) % p\n        x /= 2\n    }\n    return result\n}\n", "    // x = 2, y = n.\n\
    \    x := 2\n    y := n\n    // r = 1.\n    r := 1\n    // While y > 0.\n    for\
    \ y > 0 {\n        // If y is odd.\n        if y % 2 == 1 {\n            // r\
    \ = (r * x) % p.\n            r = (r * x) % p\n        }\n        // y = y / 2.\n\
    \        y = y / 2\n        // x = (x * x) % p.\n        x = (x * x) % p\n   \
    \ }\n    // Return r.\n    return r\n}\n", "    if n == 0 {\n        return 1\n\
    \    }\n    if n == 1 {\n        return n\n    }\n    if n % 2 == 0 {\n      \
    \  return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) * modp(n/2,\
    \ p) * n % p\n}\n", "    two := 2\n    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return two\n    }\n    if n % 2 == 0 {\n        tmp\
    \ := modp(n/2, p)\n        return (tmp * tmp) % p\n    }\n    return (2 * modp(n-1,\
    \ p)) % p\n}\n", "    return n\n}\n", "    x := n % p\n    if x < 0 {\n      \
    \  x += p\n    }\n    return x\n}\n", "    k := 1\n    for n > 0 {\n        if\
    \ n & 1 != 0 {\n            k = (k * n) % p\n        }\n        n = n >> 1\n \
    \   }\n    return k\n}\n", "    // Compute 2^n modulo p.\n    var power int =\
    \ 1\n    for i := 0; i < n; i++ {\n        power = (power * 2) % p\n    }\n  \
    \  return power\n}\n", "    if n == 0 {\n        return 1\n    }\n    return (modp(n/2,\
    \ p) * modp(n-n/2, p)) % p\n}\n", "    return powmod(2, n, p)\n}\n", "    x :=\
    \ 1\n    for n > 0 {\n        if n&1 == 1 {\n            x = (x * n) % p\n   \
    \     }\n        n = n >> 1\n    }\n    return x\n}\n", "    if n == 0 {\n   \
    \     return 1\n    }\n    x := modp(n/2, p)\n    x = (x * x) % p\n    if n %\
    \ 2 == 1 {\n        x = (x * 2) % p\n    }\n    return x\n}\n", "    if p < 0\
    \ {\n        panic(\"modp: p is negative\")\n    }\n    return int(modpBig(int64(n),\
    \ int64(p)))\n}\n", "    if n == 0 {\n        return 1\n    }\n    var r int\n\
    \    if n % 2 == 0 {\n        r = modp(n/2, p)\n        r = (r * r) % p\n    }\
    \ else {\n        r = (modp(n-1, p) * n) % p\n    }\n    return r\n}\n", "   \
    \ if n == 0 {\n        return 1\n    }\n    if n%2 == 0 {\n        return modp(n/2,\
    \ p) * modp(n/2, p) % p\n    }\n    return 2 * modp(n-1, p) % p\n}\n", "    res\
    \ := 1\n    for n > 0 {\n        if n & 1 != 0 {\n            res = (res * 2)\
    \ % p\n        }\n        n = n >> 1\n    }\n    return res\n}\n", "    i := 1\n\
    \    val := 1\n    for i <= n {\n        val = (val * 2) % p\n        i += 1\n\
    \    }\n    return val\n}\n", "    // TODO: This is not a complete implementation\n\
    \    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        // If\
    \ n is even:\n        half := modp(n / 2, p)\n        return (half * half) % p\n\
    \    } else {\n        // If n is odd:\n        return (modp(n - 1, p) * n) %\
    \ p\n    }\n}\n", "    res := 1\n    for n > 0 {\n        if n & 1 != 0 {\n  \
    \          res = (res * n) % p\n        }\n        n = n >> 1\n    }\n    return\
    \ res\n}\n", "    return n & ((1 << uint(p)) - 1)\n}\n", "    result := 1\n  \
    \  for ; n > 0; n >>= 1 {\n        if n&1 != 0 {\n            result = (result\
    \ * n) % p\n        }\n        n = (n * n) % p\n    }\n    return result\n}\n",
  "    if n == 0 {\n        return 1\n    }\n\n    // n % p == n & (p - 1)\n    return\
    \ (modp(n / 2, p) * (1 + (n & 1) * (p - 1))) % p\n}\n", "    // To be implemented\n\
    \    return 0\n}\n", "    if n < 0 {\n        n = n % p + p\n    }\n    for n\
    \ >= p {\n        n -= p\n    }\n    return n\n}\n", "    if n == 0 {\n      \
    \  return 1\n    }\n    if n == 1 {\n        return n\n    }\n    t := modp(n/2,\
    \ p)\n    if n % 2 == 0 {\n        return (t * t) % p\n    }\n    return (t *\
    \ t * n) % p\n}\n", "    r := 1\n    for ; n > 0; n /= 2 {\n        if n % 2 ==\
    \ 1 {\n            r = (r * 2) % p\n        }\n        p = (p * 2) % p\n    }\n\
    \    return r\n}\n", "    // return n**n % p;\n    n = n % p\n    if n <= 1 {\n\
    \        return n\n    }\n    if n % 2 == 0 {\n        return 2 * modp(n/2, p)\
    \ % p\n    }\n    return (2 * modp(n/2, p) + p - 1) % p\n}\n", "    if n == 0\
    \ {\n        return 1\n    }\n    if n % 2 == 0 {\n        // If n is even.\n\
    \        m := modp(n/2, p)\n        return (m * m) % p\n    } else {\n       \
    \ // If n is odd.\n        return (modp(n - 1, p) * n) % p\n    }\n}\n", "   \
    \ var r int = 1\n    var e int = n\n    for {\n        if e == 0 {\n         \
    \   break\n        }\n        if e % 2 == 1 {\n            r = (r * n) % p\n \
    \       }\n        n = (n * n) % p\n        e /= 2\n    }\n    return r\n}\n",
  "    // if (n == 0):\n    //     return 1\n    // else:\n    //     return (2 *\
    \ modp(n - 1, p)) % p\n    return 1\n}\n", "    p2 := p * 2\n    r := 1\n    for\
    \ n > 0 {\n        if n % 2 == 1 {\n            r = (r * 2) % p2\n        }\n\
    \        n /= 2\n    }\n    if r >= p {\n        r -= p\n    }\n    return r\n\
    }\n", "    r := 1\n    for n > 0 {\n        if n & 1 != 0 {\n            r = (r\
    \ * n) % p\n        }\n        n = n >> 1\n    }\n    return r\n}\n", "    x :=\
    \ 1\n    if p == 2 {\n        if n & 1 == 1 {\n            return 1\n        }\
    \ else {\n            return 0\n        }\n    }\n    for n > 0 {\n        if\
    \ n & 1 == 1 {\n            x = (x * 2) % p\n        }\n        n = n >> 1\n \
    \   }\n    return x\n}\n", "    if n == 0 {\n        return 1\n    }\n    if n\
    \ == 1 {\n        return 2 % p\n    }\n    if n % 2 == 0 {\n        // Even\n\
    \        return (modp(n / 2, p) * modp(n / 2, p)) % p\n    }\n    // Odd\n   \
    \ return (2 * modp(n / 2, p) * modp(n / 2, p)) % p\n}\n", "    if n == 0 {\n \
    \       return 1\n    }\n    two := modp(n/2, p)\n    if n & 1 == 0 {\n      \
    \  return (two * two) % p\n    }\n    return (two * two * 2) % p\n}\n", "    if\
    \ n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        // even\n  \
    \      return modp(n / 2, p) * modp(n / 2, p) % p\n    } else {\n        // odd\n\
    \        return modp(n / 2, p) * modp(n / 2, p) * 2 % p\n    }\n}\n", "    var\
    \ result int = 1\n    for n > 0 {\n        if n & 1 != 0 {\n            result\
    \ = (result * n) % p\n        }\n        n = n >> 1\n    }\n    return result\n\
    }\n\n//>>> modp(3, 5)\n//3", "    if n < 0 {\n        panic(\"n must be >= 0\"\
    )\n    }\n    if p < 0 {\n        panic(\"p must be >= 0\")\n    }\n    if p ==\
    \ 0 {\n        panic(\"p must be > 0\")\n    }\n    return (1 << uint(n)) % p\n\
    }\n", "    v := 1\n    for n > 0 {\n        if n & 1 != 0 {\n            v = (v\
    \ * n) % p\n        }\n        n = n >> 1\n    }\n    return v\n}\n", "    return\
    \ (1 << uint(n)) % p\n}\n", "    if n == 0 {\n        return 1\n    }\n    x :=\
    \ modp(n / 2, p)\n    x = (x * x) % p\n    if n % 2 == 1 {\n        x = (x * 2)\
    \ % p\n    }\n    return x\n}\n", "    n %= p\n    if n < 0 {\n        n += p\n\
    \    }\n    return n\n}\n", "    return int(modp_int64(int64(n), int64(p)))\n\
    }\n", "    m := 1\n    for i := 1; i <= n; i++ {\n        m = (m * 2) % p\n  \
    \  }\n    return m\n}\n", "    var result int\n    n = n % p\n    for i := 0;\
    \ i < n; i++ {\n        result = (result + p) % p\n    }\n    return result\n\
    }\n", "    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n        return\
    \ n\n    }\n    if n < 0 {\n        n = n + p\n    }\n    var q, r, a int\n  \
    \  for a = n; a > 1; {\n        q, r = a/p, a%p\n        if r == 0 {\n       \
    \     return 1\n        }\n        a = q\n    }\n    return r\n}\n", "    if n\
    \ == 0 {\n        return 1\n    }\n    if n == 1 {\n        return n\n    }\n\
    \    if p == 1 {\n        return 0\n    }\n    ans := 1\n    for n > 0 {\n   \
    \     if n % 2 == 1 {\n            ans = (ans * n) % p\n        }\n        n =\
    \ n / 2\n    }\n    return ans\n}\n", "    x := 1\n    for n > 0 {\n        if\
    \ n & 1 != 0 {\n            x = (x * n) % p\n        }\n        n = n >> 1\n \
    \   }\n    return x\n}\n", "    r := 1\n    f := 2\n    for n > 0 {\n        if\
    \ n & 1 == 1 {\n            r = (r * f) % p\n        }\n        f = (f * f) %\
    \ p\n        n >>= 1\n    }\n    return r\n}\n", "    var res = 1\n    for n >\
    \ 0 {\n        if n & 1 == 1 {\n            res = (res * n) % p\n        }\n \
    \       n >>= 1\n    }\n    return res\n}\n", "    a := 1\n    b := 2\n    c :=\
    \ n\n    for c > 0 {\n        if c % 2 == 1 {\n            a = (a * b) % p\n \
    \       }\n        b = (b * b) % p\n        c /= 2\n    }\n    return a\n}\n",
  "    if n == 0 {\n        return 1\n    }\n    var res int\n    if n % 2 == 0 {\n\
    \        res = modp(n/2, p)\n        res = (res * res) % p\n    } else {\n   \
    \     res = (2 * modp(n/2, p)) % p\n    }\n    return res\n}\n", "    // trivial\n\
    \    if n == 0 {\n        return 1\n    }\n\n    // modp(0, p) = 1\n    if n ==\
    \ 0 {\n        return 1\n    }\n\n    // modp(1, p) = 1\n    if n == 1 {\n   \
    \     return 1\n    }\n\n    if n % 2 == 0 {\n        // modp(2*x, p) = (modp(x,\
    \ p))^2 mod p\n        m := modp(n/2, p)\n        return (m * m) % p\n    } else\
    \ {\n        // modp(2*x+1, p) = 2*modp(x, p)*modp(x+1, p) mod p\n        return\
    \ (2 * modp(n/2, p) * modp(n/2+1, p)) % p\n    }\n}\n", "    // Corner case.\n\
    \    if p <= 0 {\n        return 0\n    }\n\n    // Base case.\n    if n == 0\
    \ {\n        return 1\n    }\n\n    // Repeatedly square and multiply.\n    s\
    \ := 1\n    for n > 0 {\n        if n % 2 == 1 {\n            s = (s * 2) % p\n\
    \        }\n        n = n >> 1\n    }\n    return s\n}\n", "    if n >= p {\n\
    \        return n % p\n    } else if n == 0 {\n        return 1\n    }\n    res\
    \ := modp(2*n, p)\n    if res >= p/2 {\n        res -= p\n    }\n    return res\n\
    }\n", "    if n < 0 {\n        n = n + ((-n / p) + 1) * p\n    }\n    return n\
    \ % p\n}\n", "    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        return modp(n / 2, p) * modp(n / 2, p) % p\n    }\n    return 2 * modp(n\
    \ / 2, p) * modp(n / 2, p) % p\n}\n", "    m := 1\n    for n > 0 {\n        if\
    \ n % 2 == 1 {\n            m = (m * n) % p\n        }\n        n = n >> 1\n \
    \   }\n    return m\n}\n", "    if n >= p {\n        return modp(n % p, p)\n \
    \   } else if n == 0 {\n        return 1\n    } else if n == 1 {\n        return\
    \ n\n    } else if n % 2 == 0 {\n        return modp(2*modp(n/2, p), p)\n    }\
    \ else {\n        return 2*modp(n/2, p)\n    }\n}\n", "    // this fails on large\
    \ numbers\n    return (n % p) + p\n}\n", "    res := 1\n    for _, mask := range(bits(n))\
    \ {\n        res = (res * res) % p\n        if mask == 1 {\n            res =\
    \ (res * 2) % p\n        }\n    }\n    return res\n}\n", "    // Preconditions\n\
    \    if n < 0 {\n        panic(fmt.Sprintf(\"Non-negative integer expected, but\
    \ got %d\", n))\n    }\n    if p < 2 {\n        panic(fmt.Sprintf(\"Number greater\
    \ than one expected, but got %d\", p))\n    }\n\n    // Algorithm\n    remainder\
    \ := 1\n    base := 2\n    for n > 0 {\n        if n & 1 == 1 {\n            remainder\
    \ = (remainder * base) % p\n        }\n        base = (base * base) % p\n    \
    \    n >>= 1\n    }\n    return remainder\n}\n", "    r := 1\n    for ; n > 0;\
    \ n >>= 1 {\n        if n & 1 != 0 {\n            r = (r * n) % p\n        }\n\
    \        n = (n * n) % p\n    }\n    return r\n}\n", "    return (1 << uint(n))\
    \ % p\n}\n", "    k := 1\n    for n > 0 {\n        if n & 1 != 0 {\n         \
    \   k = (k * n) % p\n        }\n        n = n >> 1\n    }\n    return k\n}\n",
  "    if p == 0 {\n        return 0\n    }\n\n    r := 1\n    for i := 0; i < n;\
    \ i++ {\n        r = r * 2 % p\n    }\n    return r\n}\n", "    x := 1\n    for\
    \ i := 0; i < n; i++ {\n        x = (x * 2) % p\n    }\n    return x\n}\n", " \
    \   return 1\n}\n", "    if p == 1 {\n        return 0\n    }\n    if n < p {\n\
    \        return n\n    }\n    b := 1\n    for n > 1 {\n        if n & 1 != 0 {\n\
    \            b = (b * n) % p\n        }\n        n = n >> 1\n    }\n    return\
    \ b\n}\n", "    if n < 0 {\n        n = -n\n    }\n    if n == 0 {\n        return\
    \ 1\n    }\n    r := 1\n    for i := 0; i < n; i++ {\n        r = (r * 2) % p\n\
    \    }\n    return r\n}\n", "    if n >= p {\n        return modp(n % p, p)\n\
    \    }\n    if n < 0 {\n        return p - modp(-n, p)\n    }\n    return n\n\
    }\n", "    var result = 1\n    for n > 0 {\n        if n % 2 == 1 {\n        \
    \    result = (result * 2) % p\n        }\n        n = n / 2\n    }\n    return\
    \ result\n}\n", "    var r = 1\n    for n > 0 {\n        if n % 2 == 1 {\n   \
    \         r = (r * n) % p\n        }\n        n = n >> 1\n    }\n    return r\n\
    }\n", "    m := 1\n    for n != 0 {\n        if n % 2 == 1 {\n            m =\
    \ (m * 2) % p\n        }\n        n = n / 2\n    }\n    return m\n}\n", "    if\
    \ p == 1 {\n        return 0\n    }\n    if n >= p {\n        return modp(n %\
    \ p, p)\n    }\n    if n == 0 {\n        return 1\n    }\n    return (n % p) *\
    \ modp(2, p) % p\n}\n", "    ans := 1\n    for i := 0; i < n; i++ {\n        ans\
    \ = (ans * 2) % p\n    }\n    return ans\n}\n", "    if n < 0 {\n        return\
    \ modp(-n, p)\n    }\n    result := 1\n    for n > 0 {\n        if n&1 != 0 {\n\
    \            result = (result * n) % p\n        }\n        n >>= 1\n    }\n  \
    \  return result\n}\n", "    if n == 0 {\n        return 1\n    }\n\n    if n\
    \ % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n    }\n\n    return\
    \ 2 * modp(n-1, p) % p\n}\n", "    if n > 0 {\n        if p > 0 {\n          \
    \  i := 0\n            for i = 0; i < n; i++ {\n                p = (p * 2) %\
    \ 101\n            }\n            return p\n        } else {\n            return\
    \ 1\n        }\n    } else {\n        return 1\n    }\n}\n", "    x := 1\n   \
    \ for n > 0 {\n        if n % 2 == 1 {\n            x = (x * 2) % p\n        }\n\
    \        n = n / 2\n    }\n    return x\n}\n", "    if n == 0 {\n        return\
    \ 1\n    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) %\
    \ p\n    }\n    return n * modp(n-1, p) % p\n}\n", "    if n == 0 {\n        return\
    \ 1\n    }\n    var i int = 2\n    var r int = n % p\n    for ; i < n; i *= 2\
    \ {\n        r = r * r % p\n    }\n    return r\n}\n", "    r := 1\n    for ;\
    \ n > 0; n = n >> 1 {\n        if n & 1 == 1 {\n            r = (r * n) % p\n\
    \        }\n        n = (n * n) % p\n    }\n    return r\n}\n", "    x := 1\n\
    \    for n > 0 {\n        if n % 2 == 1 {\n            x = (x * n) % p\n     \
    \   }\n        n = n / 2\n    }\n    return x\n}\n", "    if n < 0 {\n       \
    \ n = n % p + p\n    } else {\n        n = n % p\n    }\n    if n == 0 {\n   \
    \     return 1\n    }\n    return n\n}\n", "    i := 1\n    for j := 0; j < n;\
    \ j++ {\n        i = (i * 2) % p\n    }\n    return i\n}\n", "    return powmod(2,\
    \ n, p)\n}\n", "    var i int\n    var t int\n    t = 1\n    for i = 1; i <= n;\
    \ i++ {\n        t = (t * 2) % p\n    }\n    return t\n}\n", "    if n == 0 {\n\
    \        return 1\n    }\n\n    if n < 0 {\n        n = -n\n    }\n\n    r :=\
    \ 1\n    for i := 1; i <= n; i++ {\n        r = (r * 2) % p\n    }\n\n    return\
    \ r\n}\n", "    if n < 0 {\n        return p - modp(-n, p)\n    }\n    if n <\
    \ p {\n        return n\n    }\n    if n % p == 0 {\n        return 0\n    }\n\
    \    n = n % p\n    if n == 0 {\n        return 0\n    }\n    return modp(2*n,\
    \ p) - n\n}\n", "    if n == 0 {\n        return 1\n    }\n    base := 2\n   \
    \ r := 1\n    for n > 0 {\n        if n % 2 == 1 {\n            r = (r * base)\
    \ % p\n        }\n        base = (base * base) % p\n        n /= 2\n    }\n  \
    \  return r\n}\n", "    // python, n = n % p\n    if n >= p {\n        n %= p\n\
    \    }\n    if n <= 1 {\n        return n\n    }\n    return int(int64(modp(n>>1,\
    \ p)) * int64(modp(n>>1 + n%2, p)) % int64(p))\n}\n", "    var r int = 1\n\n \
    \   for i := 0; i < n; i++ {\n        r = (r * 2) % p\n    }\n\n    return r\n\
    }\n", "    fmt.Printf(\"modp(%d, %d)\\n\", n, p)\n    // >>> x = 0x7fffffffffffffff\n\
    \    // >>> x\n    // 9223372036854775807\n    // >>> x.bit_length()\n    // 63\n\
    \    // >>> x.bit_length() < 20\n    // False\n    // >>> x.bit_length() < 10\n\
    \    // True\n    // >>> x.bit_length() < 2\n    // False\n    // >>> x.bit_length()\
    \ == 2\n    // False\n    // >>> x.bit_length() > 2\n    // True\n    // >>> x.bit_length()\
    \ <= 2\n    // False\n    // >>> x.bit_length() >= 2\n    // True\n    // >>>\
    \ x.bit_length()\n    // 63\n    // >>> x.bit_length() > 60\n    // True\n   \
    \ // >>> x.bit_length() >= 60\n    // True\n    // >>> x.bit_length() < 60\n \
    \   // False\n    // >>> x.bit_length() <= 60\n    // False\n    // >>> x.bit_length()\
    \ == 60\n    // False\n    // >>> 2 << 60\n    // 1152921504606846976\n    //\
    \ >>> 2 << 61\n    // 2305843009213693952\n    // >>> 2 << 62\n    // 4611686018427387904\n\
    \    // >>> 2 << 63\n    // -9223372036854775808\n    // >>> 2 << 64\n    // 0\n\
    \    // >>> x = 2 << 62\n    // >>> x\n    // 4611686018427387904\n    // >>>\
    \ x.bit_length()\n    // 64\n    // >>> x.bit_length() < 60\n    // False\n  \
    \  // >>> x.bit_length() < 62\n    // False\n    // >>> x.bit_length() < 63\n\
    \    // False\n    // >>> x.bit_length() < 64\n    // False\n    // >>> x.bit_length()\
    \ > 63\n    // True\n    // >>> x.bit_length() > 62\n    // True\n    // >>> x.bit_length()\
    \ > 61\n    // True\n", "    if p == 0 {\n        return 1\n    }\n    m := n\
    \ % p\n    r := 1\n    for i := 0; i < m; i++ {\n        r = (r * 2) % p\n   \
    \ }\n    return r\n}\n", "    var res int = 1\n    for n != 0 {\n        if n\
    \ & 1 != 0 {\n            res = (res * n) % p\n        }\n        n = n >> 1\n\
    \    }\n    return res\n}\n", "    r := 1\n    for n != 0 {\n        r = ((n &\
    \ 1) * r * 2) % p\n        n = n >> 1\n    }\n    return r\n}\n", "    r := 1\n\
    \    for n > 0 {\n        if n % 2 == 1 {\n            r = (r * 2) % p\n     \
    \   }\n        n = n / 2\n    }\n    return r\n}\n", "    if n < 0 {\n       \
    \ n += p\n    }\n    return n\n}\n", "    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return n\n    }\n    if n%2 == 0 {\n        m := modp(n/2,\
    \ p)\n        return (m*m) % p\n    }\n    return (n*modp(n-1, p)) % p\n}\n",
  "    var result int = 1\n    for n != 0 {\n        if n & 1 != 0 {\n           \
    \ result = (result * n) % p\n        }\n        n = n >> 1\n    }\n    return\
    \ result\n}\n", "    e := 1\n    for i := 0; i < n; i++ {\n        e = e * 2 %\
    \ p\n    }\n    return e\n}\n", "    if p == 1 {\n        return 0\n    }\n  \
    \  a := 1\n    for i := 0; i < n; i++ {\n        a = (a * 2) % p\n    }\n    return\
    \ a\n}\n", "    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n      \
    \  return n\n    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2,\
    \ p) % p\n    }\n    return n * modp(n-1, p) % p\n}\n", "    r := 1\n    for n\
    \ > 0 {\n        r = (r * r) % p\n        if n & 1 == 1 {\n            r = (r\
    \ * 2) % p\n        }\n        n >>= 1\n    }\n    return r\n}\n", "    var result\
    \ int = 1\n    for i := 0; i < n; i++ {\n        result = (result * 2) % p\n \
    \   }\n    return result\n}\n", "    r := 1\n    for n > 0 {\n        if n & 1\
    \ != 0 {\n            r = (r * n) % p\n        }\n        n = n >> 1\n    }\n\
    \    return r\n}\n", "    if p == 1 {\n        return 0\n    }\n    // Powers\
    \ of two are easy.\n    if n == 0 {\n        return 1\n    } else if n == 1 {\n\
    \        return 2 % p\n    } else if n == 2 {\n        return 4 % p\n    }\n \
    \   // Bits 0, 1, and 2.\n    v := modp(n/2, p)\n    v = (v * v) % p\n    if n\
    \ & 1 == 1 {\n        v = (v * 2) % p\n    }\n    return v\n}\n", "    // The\
    \ recursive function below is much slower\n    if n == 0 {\n        return 1\n\
    \    }\n    var r int = 1\n    for i := 0; i < n; i++ {\n        r = (r * 2) %\
    \ p\n    }\n    return r\n}\n", "    if n < 0 {\n        return modp(n + p, p)\n\
    \    } else if n < p {\n        return n\n    } else {\n        return modp(n\
    \ - p, p)\n    }\n}\n", "    res := 1\n\n    for n > 0 {\n        if n % 2 ==\
    \ 1 {\n            res = (res * n) % p\n        }\n        n = n / 2\n    }\n\n\
    \    return res\n}\n", "    return (1 << uint(n)) % p\n}\n", "    x := 1\n   \
    \ for n > 0 {\n        if n & 1 != 0 {\n            x = (x * n) % p\n        }\n\
    \        n = n >> 1\n    }\n    return x\n}\n", "    if n == 0 {\n        return\
    \ 1\n    }\n    if n == 1 {\n        return n\n    }\n    if n%2 == 0 {\n    \
    \    return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return modp(n/2, p) *\
    \ modp(n/2, p) * n % p\n}\n", "    if n == 0 {\n        return 1\n    }\n    a\
    \ := modp(n/2, p)\n    a = (a * a) % p\n    if n % 2 == 1 {\n        a = (a *\
    \ 2) % p\n    }\n    return a\n}\n", "    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        z := modp(n/2, p)\n        return (z * z) % p\n\
    \    }\n    return (modp(n-1, p) * n) % p\n}\n", "    if n < 0 {\n        n =\
    \ n % p + p\n    }\n    r := n % p\n    fmt.Printf(\"n: %d r: %d p: %d\\n\", n,\
    \ r, p)\n    return r\n}\n", "    if n == 0 {\n        return 1\n    }\n\n   \
    \ if n%2 == 0 {\n        return (modp(n/2, p) * modp(n/2, p)) % p\n    } else\
    \ {\n        return (modp(n/2, p) * modp(n/2, p) * 2) % p\n    }\n}\n", "    return\
    \ pow(2, n, p)\n}\n", "    var r int\n    if n % 2 == 0 {\n        r = modp(n\
    \ / 2, p)\n        r = (r * r) % p\n    } else {\n        r = (modp(n - 1, p)\
    \ * n) % p\n    }\n    return r\n}\n", "    var r = 1\n    for n > 0 {\n     \
    \   if n & 1 != 0 {\n            r = (r * n) % p\n        }\n        n = n >>\
    \ 1\n    }\n    return r\n}\n", "    m := 1\n    for n > 0 {\n        if n & 1\
    \ != 0 {\n            m = (m * 2) % p\n        }\n        n >>= 1\n    }\n   \
    \ return m\n}\n", "    return modp_d(n, p, map[int]int{})\n}\n", "    if p <=\
    \ 0 {\n        panic(\"modp(n, p): p must be greater than 0\")\n    }\n\n    res\
    \ := 1\n    n %= p\n    for n > 0 {\n        if n&1 != 0 {\n            res =\
    \ (res * n) % p\n        }\n        n = n >> 1\n    }\n    return res\n}\n", " \
    \   if n == 0 {\n        return 1\n    }\n    if n%2 == 0 {\n        return modp(n/2,\
    \ p) * modp(n/2, p) % p\n    }\n    return n * modp(n-1, p) % p\n}\n", "    if\
    \ n < 0 {\n        n = n + p\n    }\n    // assert n >= 0\n    x := 1\n    for\
    \ n > 0 {\n        if n & 1 != 0 {\n            x = (x * 2) % p\n        }\n \
    \       n = n >> 1\n    }\n    return x\n}\n", "    return int(modp64(int64(n),\
    \ int64(p)))\n}\n", "    ret := 1\n    for n > 0 {\n        if n & 1 == 1 {\n\
    \            ret = (ret * n) % p\n        }\n        n >>= 1\n    }\n    return\
    \ ret\n}\n", "    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n\
    \        y := modp(n/2, p)\n        return (y * y) % p\n    }\n    return (modp(n-1,\
    \ p) * (n % p)) % p\n}\n", "    if n == 0 {\n        return 1\n    }\n    if n\
    \ % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n    }\n    return\
    \ modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n", "    var prod int = 1\n    for i\
    \ := 0; i < n; i++ {\n        prod = (prod * 2) % p\n    }\n    return prod\n\
    }\n", "    if n == 0 {\n        return 1\n    }\n    d := n & 1\n    r := modp(n/2,\
    \ p)\n    r = r * r % p\n    if d == 1 {\n        r = r * n % p\n    }\n    return\
    \ r\n}\n", "    var x,y int\n    if n == 0 {\n        return 1\n    }\n    x =\
    \ modp(n/2, p)\n    x = (x * x) % p\n    if n % 2 == 1 {\n        x = (x * 2)\
    \ % p\n    }\n    return x\n}\n", "    if n <= 0 {\n        return 1\n    }\n\
    \    if p == 2 {\n        return 1\n    }\n    x := modp(n/2, p)\n    if n % 2\
    \ == 0 {\n        return x * x % p\n    }\n    return x * x * 2 % p\n}\n", " \
    \   s := 1\n    for i := 0; i < n; i++ {\n        s = (s * 2) % p\n    }\n   \
    \ return s\n}\n", "    if n == 0 {\n        return 1\n    }\n\n    // Note:\n\
    \    // - The result is always positive.\n    // - 2^n is never zero.\n    //\
    \ - 2^n mod p is never zero.\n    m := 2\n    for i := 1; i < n; i++ {\n     \
    \   m = (m * 2) % p\n    }\n    return m\n}\n", "    if n < 0 {\n        panic(\"\
    negative power\")\n    }\n    if n == 0 {\n        return 1\n    }\n    if p ==\
    \ 1 {\n        return 0\n    }\n    m := 1\n    for n > 0 {\n        if n % 2\
    \ == 1 {\n            m = (m * n) % p\n        }\n        n = n / 2\n    }\n \
    \   return m\n}\n", "    mod := n % p\n    if mod < 0 {\n        mod += p\n  \
    \  }\n    return mod\n}\n", "    var m int = 1\n    for i := 0; i < n; i++ {\n\
    \        m = (m * 2) % p\n    }\n    return m\n}\n", "    return pow(2, n, p)\n\
    }\n", "    if n == 0 {\n        return 1\n    }\n    res := modp(n/2, p) * modp(n/2,\
    \ p) % p\n    if n % 2 == 1 {\n        res = (res * 2) % p\n    }\n    return\
    \ res\n}\n", "    if n < 0 {\n        return modp(n+p, p)\n    }\n    return n\
    \ % p\n}\n", "    power := 1\n    c := n\n    for c != 0 {\n        c = c / 2\n\
    \        if c & 1 == 1 {\n            power = (power * n) % p\n        }\n   \
    \     n = (n * n) % p\n    }\n    return power\n}\n", "    if n < 0 {\n      \
    \  n += -n / p * p\n    }\n    return n % p\n}\n", "    var retval int = 1\n \
    \   for n > 0 {\n        if n % 2 == 1 {\n            retval = (retval * n) %\
    \ p\n        }\n        n = n / 2\n    }\n    return retval\n}\n", "    result\
    \ := 1\n    for n > 0 {\n        if n & 1 != 0 {\n            result = (result\
    \ * n) % p\n        }\n        n = n >> 1\n    }\n    return result\n}\n", " \
    \   return PowMod(2, n, p)\n}\n", "    r := 1\n    for n > 0 {\n        if n %\
    \ 2 == 1 {\n            r = (r * 2) % p\n        }\n        n = n / 2\n    }\n\
    \    return r\n}\n", "    r := 1\n    for n > 0 {\n        if n % 2 == 1 {\n \
    \           r = (r * 2) % p\n        }\n        n = n / 2\n    }\n    return r\n\
    }\n", "    if n < 0 {\n        n = p - ((-n) % p)\n    }\n    return n % p\n}\n",
  "    res := 1\n\n    for i := 0; i < n; i++ {\n        res = (res * 2) % p\n   \
    \ }\n\n    return res\n}\n", "    x := 1\n    for n > 0 {\n        if n % 2 ==\
    \ 1 {\n            x = (x * 2) % p\n        }\n        n = n >> 1\n    }\n   \
    \ return x\n}\n", "    prod := 1\n    for i := 0; i < n; i++ {\n        prod =\
    \ (prod * 2) % p\n    }\n    return prod\n}\n", "    if n == 0 {\n        return\
    \ 1\n    }\n    // Let's just loop over it to be sure.\n    for i := 0; i < p;\
    \ i++ {\n        n = (n * 2) % p\n    }\n    return n\n}\n", "    var total int\n\
    \    total = 1\n    for i := 0; i < n; i++ {\n        total = (total * 2) % p\n\
    \    }\n    return total\n}\n", "    if n == 0 {\n        return 1\n    }\n  \
    \  var a int\n    if n % 2 == 0 {\n        a = modp(n/2, p)\n        a = (a *\
    \ a) % p\n    } else {\n        a = n % p\n        var b int = modp((n-1)/2, p)\n\
    \        a = (a * (b * b % p)) % p\n    }\n    return (a + p) % p\n}\n", "   \
    \ if p == 0 {\n        return 1\n    }\n    if n == 0 {\n        return 1\n  \
    \  }\n    if n == 1 {\n        return 0\n    }\n    r := 1\n    for i := 0; i\
    \ < n; i++ {\n        r = (r * 2) % p\n    }\n    return r\n}\n", "    if n ==\
    \ 0 {\n        return 1\n    }\n    if n == 1 {\n        return n\n    }\n   \
    \ if p == 1 {\n        return 0\n    }\n    if p == 2 {\n        return 1\n  \
    \  }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) % p\n  \
    \  }\n    return modp(n/2, p) * modp(n/2, p) * 2 % p\n}\n", "    if n == 0 {\n\
    \        return 1\n    }\n    if n == 1 {\n        return n\n    }\n    v := modp(n\
    \ >> 1, p)\n    v = (v * v) % p\n    if n & 1 == 1 {\n        v = (v * n) % p\n\
    \    }\n    return v\n}\n", "    if n == 0 {\n        return 1\n    }\n    if\
    \ n % 2 == 0 {\n        // even\n        temp := modp(n/2, p)\n        return\
    \ (temp * temp) % p\n    } else {\n        // odd\n        return (modp(n-1, p)\
    \ * n) % p\n    }\n}\n", "    r := 1\n    for n > 0 {\n        r = (r * n) % p\n\
    \        n = n - 1\n    }\n    return r\n}\n", "    if n == 0 {\n        return\
    \ 1\n    }\n    if n % 2 == 0 {\n        return modp(n/2, p) * modp(n/2, p) %\
    \ p\n    }\n    return modp(n-1, p) * 2 % p\n}\n", "    if n == 0 {\n        return\
    \ 1\n    }\n\n    if n%2 == 0 {\n        m := modp(n/2, p)\n        return (m*m)\
    \ % p\n    } else {\n        return (modp(n-1, p) * n) % p\n    }\n}\n", "   \
    \ if n <= p {\n        return n\n    }\n\n    // Handle edges cases that would\
    \ cause numeric issues.\n    if n <= 10 {\n        return n + p\n    }\n\n   \
    \ // Compute 2^n mod p.\n    exp := 1\n    for n > 0 {\n        if n % 2 == 1\
    \ {\n            exp = (exp * 2) % p\n        }\n        n /= 2\n    }\n    return\
    \ exp\n}\n", "    if p == 1 {\n        return 0\n    }\n    v := 1\n    for n\
    \ > 0 {\n        if n & 1 == 1 {\n            v = (v * n) % p\n        }\n   \
    \     n = n >> 1\n    }\n    return v\n}\n", "    var s uint\n    var i uint\n\
    \    if n < 0 {\n        n = n + ((-n / p) + 1) * p\n    }\n    s = 1\n    for\
    \ i = 1; i <= uint(n); i++ {\n        s = (s * 2) % uint(p)\n    }\n    return\
    \ int(s)\n}\n", "    // n % p is a mess with negative numbers, i.e. n % p != n\
    \ % n % p\n    var n_remainder int\n    if n >= 0 {\n        n_remainder = n %\
    \ p\n    } else {\n        n_remainder = p - (-n % p)\n    }\n    // in Python\
    \ (n-1) % p = n % p - 1, but in Go -((n+1) % p - 1) = (n-1) % p\n    var result\
    \ int\n    if n == 0 {\n        result = 1\n    } else {\n        // print(\"\
    n_remainder\", n_remainder)\n        result = -((n_remainder+1) % p - 1)\n   \
    \ }\n    // print(\"result\", result)\n    return result\n}\n", "    if n == 0\
    \ {\n        return 1\n    }\n    if n == 1 {\n        return n\n    }\n    //\
    \ return (2 * modp(n-1, p)) % p\n    return (2 * modp(n-1, p)) & p\n}\n", "  \
    \  var result int = 1\n    var x int = 2\n    var i int = n\n    for i > 0 {\n\
    \        if i % 2 == 1 {\n            result = (result * x) % p\n        }\n \
    \       x = (x * x) % p\n        i = i / 2\n    }\n    return result\n}\n", " \
    \   // Note that modp(n, p) == modp(n, -p)\n    if p < 0 {\n        p = -p\n \
    \   }\n    if n < 0 {\n        n = -n\n    }\n    // Use n^n % p == n if n < p.\n\
    \    if n < p {\n        return n\n    }\n    // Observe that modp(2n, p) == modp(n,\
    \ p) * modp(n, p) % p.\n    // Use that to reduce n to n % p.\n    n %= p\n  \
    \  // Perform a binary exponentiation.\n    var product int = 1\n    var power\
    \ int = n\n    for power > 0 {\n        if power % 2 == 1 {\n            product\
    \ = product * power % p\n        }\n        power = power / 2\n    }\n    return\
    \ product\n}\n", "    var result int = 1\n    for i := 0; i < n; i++ {\n     \
    \   result = (result * 2) % p\n    }\n    return result\n}\n", "    prod := 1\n\
    \    base := 2\n    for {\n        if n & 1 == 1 {\n            prod = (prod *\
    \ base) % p\n        }\n        n = n >> 1\n        if n == 0 {\n            break\n\
    \        }\n        base = (base * base) % p\n    }\n    return prod\n}\n", " \
    \   if n == 0 {\n        return 1\n    }\n    t := modp(n / 2, p)\n    t = (t\
    \ * t) % p\n    if n % 2 == 1 {\n        t = (t * 2) % p\n    }\n    return t\n\
    }\n", "    return int(modp_int(int64(n), int64(p)))\n}\n", "    if p <= 0 {\n\
    \        panic(\"p <= 0\")\n    }\n    if n <= 0 {\n        panic(\"n <= 0\")\n\
    \    }\n    result := 1\n    for n > 0 {\n        if n&1 != 0 {\n            result\
    \ = (result * n) % p\n        }\n        n = n >> 1\n    }\n    return result\n\
    }\n", "    if n == 0 {\n        return 1\n    }\n\n    if n % 2 == 0 {\n     \
    \   return modp(n / 2, p) * modp(n / 2, p) % p\n    }\n\n    return modp(n / 2,\
    \ p) * modp(n / 2, p) * 2 % p\n}\n", "    if n == 0 {\n        return 1\n    }\n\
    \    res := 1\n    for i := 0; i < n; i++ {\n        res = (res * 2) % p\n   \
    \ }\n    return res\n}\n", "    res := 1\n    a := n\n    for n != 0 {\n     \
    \   if n & 1 != 0 {\n            res = (res * a) % p\n        }\n        a = (a\
    \ * a) % p\n        n = n >> 1\n    }\n    return res\n}\n", "    if p == 0 {\n\
    \        return n\n    }\n    return modp(n, p - n % p)\n}\n", "    r := 1\n \
    \   for i := 0; i < n; i++ {\n        r = (r * 2) % p\n    }\n    return r\n}\n",
  "    if n == 0 {\n        return 1\n    }\n    n = n % p\n    if n & 1 == 0 {\n\
    \        return modp(n >> 1, p) * modp(n >> 1, p) % p\n    }\n    return modp(n\
    \ - 1, p) * n % p\n}\n", "    return int(n % p)\n}\n", "    if n < 0 {\n     \
    \   return p - modp(-n, p)\n    }\n\n    if n > 2 * p {\n        return modp(n\
    \ % p, p)\n    }\n\n    if n >= p {\n        return n - p\n    }\n\n    if n ==\
    \ 0 {\n        return 1\n    }\n\n    if n == 1 {\n        return 1\n    }\n\n\
    \    if n == 2 {\n        return 1\n    }\n\n    // n == 3\n\n    return 3\n}\n",
  "    // Handle zero first\n    if n == 0 {\n        return 1\n    }\n\n    // Look\
    \ for power of 2 modp\n    if (n & (n - 1)) == 0 {\n        for b := 0; b < 31;\
    \ b++ {\n            if (n & (1 << uint(b))) != 0 {\n                return 1\
    \ << uint(b)\n            }\n        }\n    }\n\n    // Look for non-power of\
    \ 2 modp\n    if n % 2 == 0 {\n        // Even n\n        return ((n / 2) % p)\
    \ * ((n / 2) % p)\n    } else {\n        // Odd n\n        return (((n - 1) /\
    \ 2) % p) * (((n - 1) / 2) % p) * 2\n    }\n}\n", "    // r := int64(1)\n    //\
    \ a := int64(2)\n    // b := int64(n)\n    // c := int64(p)\n    // while b >\
    \ 0 {\n    //     if (b & 1) == 1 {\n    //         r = (r * a) % c\n    //  \
    \   }\n    //     b = b >> 1\n    //     a = (a * a) % c\n    // }\n    // return\
    \ int(r)\n    return 1\n}\n", "    m := n % p\n    if m < 0 {\n        m += p\n\
    \    }\n    return m\n}\n", "    pow2 := 1\n    pow := 1\n    for ; n > 0; n =\
    \ n / 2 {\n        if n & 1 == 1 {\n            pow = (pow * pow2) % p\n     \
    \   }\n        pow2 = (pow2 * pow2) % p\n    }\n    return pow\n}\n", "    //\
    \ For a better explanation why we use the right shift here please\n    // see\
    \ the commit before this one.\n    return (n & ((1 << 31) - 1)) % p\n}\n", " \
    \   a := 1\n\n    for n > 0 {\n        if n & 1 != 0 {\n            a = (a * n)\
    \ % p\n        }\n        n = n >> 1\n    }\n\n    return a\n}\n", "    if n ==\
    \ 0 {\n        return 1\n    }\n    x := modp(n/2, p)\n    x = x * x % p\n   \
    \ if n % 2 == 1 {\n        x = x * 2 % p\n    }\n    return x\n}\n", "    var\
    \ result int\n    if (n < 0) {\n        result = -1 * (n / p) * p + n\n    } else\
    \ {\n        result = n % p\n    }\n    if (result == 0) {\n        result = p\n\
    \    }\n    return result\n}\n", "    if n == 0 {\n        return 1\n    }\n\n\
    \    if n == 1 {\n        return 2 % p\n    }\n\n    if n % 2 == 0 {\n       \
    \ return modp(n/2, p) * modp(n/2, p) % p\n    } else {\n        return modp(n/2,\
    \ p) * modp(n/2, p) * 2 % p\n    }\n}\n", "    if n < p {\n        return n\n\
    \    }\n    i := 0\n    r := 1\n    c := int(1 << uint(i))\n    for n >= c {\n\
    \        r = (r * 2) % p\n        i += 1\n        c = int(1 << uint(i))\n    }\n\
    \    return r\n}\n", "    var result int = 1\n    for n > 0 {\n        if n %\
    \ 2 == 1 {\n            result = (result * 2) % p\n        }\n        n = n /\
    \ 2\n    }\n    return result\n}\n", "    if n == 0 {\n        return 1\n    }\n\
    \    if n == 1 {\n        return n\n    }\n    if n < 0 {\n        return p -\
    \ modp(-n, p)\n    }\n    if n % 2 == 0 {\n        m := modp(n / 2, p)\n     \
    \   return (m * m) % p\n    }\n    return (n * modp(n - 1, p)) % p\n}\n", "  \
    \  if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return modp(n/2,\
    \ p) * modp(n/2, p) % p\n    }\n    return modp(n-1, p) * 2 % p\n}\n", "    return\
    \ (((1<<uint(n))%p)+p)%p\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
