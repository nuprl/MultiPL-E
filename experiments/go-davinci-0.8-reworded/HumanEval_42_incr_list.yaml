name: HumanEval_42_incr_list
language: go_test.go
prompt: "package incr_list_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ Return list with elements incremented by 1.\n// >>> incr_list([]int{1, 2, 3})\n\
  // []int{2, 3, 4}\n// >>> incr_list([]int{5, 3, 5, 2, 3, 3, 9, 0, 123})\n// []int{6,\
  \ 4, 6, 3, 4, 4, 10, 1, 124}\nfunc incr_list(l []int) []int {\n"
tests: "func TestIncr_List(t *testing.T) {\n  candidate := incr_list\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
  \ candidate([]int{3, 2, 1}), expected: []int{4, 3, 2} },\n     { actual: candidate([]int{5,\
  \ 2, 5, 2, 3, 3, 9, 0, 123}), expected: []int{6, 3, 6, 3, 4, 4, 10, 1, 124} },\n\
  \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
  \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if len(l) == 0 {\n        return l\n    }\n    res := make([]int,\
    \ len(l))\n    res[0] = l[0] + 1\n    return append(res, incr_list(l[1:])...)\n\
    }\n", "    for i, v := range l {\n        l[i] = v + 1\n    }\n    return l\n\
    }\n", "    c := make([]int, len(l))\n    for i, v := range l {\n        c[i] =\
    \ v + 1\n    }\n    return c\n}\n", "    new_l := make([]int, len(l))\n    for\
    \ idx, elem := range l {\n        new_l[idx] = elem + 1\n    }\n    return new_l\n\
    }\n", "    for i, n := range l {\n        l[i] = n + 1\n    }\n    return l\n\
    }\n", "    for i, v := range l {\n        l[i] = v + 1\n    }\n    return l\n\
    }\n", "    for i, v := range l {\n        l[i] = v + 1\n    }\n    return l\n\
    }\n", "    if len(l) == 0 {\n        return []int{}\n    }\n    return append([]int{l[0]\
    \ + 1}, incr_list(l[1:])...)\n}\n", "    r := make([]int, len(l))\n    for i,\
    \ v := range l {\n        r[i] = v + 1\n    }\n    return r\n}\n", "    for i,\
    \ v := range l {\n        l[i] = v + 1\n    }\n    return l\n}\n", "    res :=\
    \ make([]int, len(l))\n    for i, x := range l {\n        res[i] = x + 1\n   \
    \ }\n    return res\n}\n", "    m := make([]int, len(l))\n    for i, v := range\
    \ l {\n        m[i] = v + 1\n    }\n    return m\n}\n", "    var incr = func(i\
    \ int) int {\n        return i + 1\n    }\n    return map_list(l, incr)\n}\n",
  "    if len(l) == 0 {\n        return l\n    }\n\n    incr := make([]int, len(l))\n\
    \    for i, v := range l {\n        incr[i] = v + 1\n    }\n\n    return incr\n\
    }\n", "    n := len(l)\n    res := make([]int, n)\n    for i := 0; i < n; i++\
    \ {\n        res[i] = l[i] + 1\n    }\n    return res\n}\n", "    result := make([]int,\
    \ len(l))\n    for i, x := range l {\n        result[i] = x + 1\n    }\n    return\
    \ result\n}\n", "    res := make([]int, len(l))\n    for i, v := range l {\n \
    \       res[i] = v + 1\n    }\n    return res\n}\n", "    m := make([]int, len(l))\n\
    \    for i, x := range l {\n        m[i] = x + 1\n    }\n    return m\n}\n", " \
    \   ret := make([]int, len(l))\n    for i, val := range l {\n        ret[i] =\
    \ val + 1\n    }\n    return ret\n}\n", "    length := len(l)\n    ret := make([]int,\
    \ length)\n    for i := 0; i < length; i++ {\n        ret[i] = l[i] + 1\n    }\n\
    \    return ret\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
