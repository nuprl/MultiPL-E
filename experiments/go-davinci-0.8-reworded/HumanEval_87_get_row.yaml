name: HumanEval_87_get_row
language: go_test.go
prompt: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You\
  \ are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix,\
  \ however, unlike matrices,\n// each row may contain a different number of columns.\n\
  // Given lst, and integer x, find integers x in the list,\n// and return list of\
  \ lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a coordinate - (row,\
  \ columns), starting with 0.\n// Sort coordinates initially by rows in ascending\
  \ order.\n// Also, sort coordinates of the row by columns in descending order.\n\
  // Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
  \ 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0, 0}, []interface{}{1,\
  \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}}\n// >>> get_row([][]int{},\
  \ 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{}, []int{1},\
  \ []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst [][]int,\
  \ x int) [][]interface{} {\n"
tests: "func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
  \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
  \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
  \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
  \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n     {\
  \ actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
  \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
  \ 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1, 1},\
  \ []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
  \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
  \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
  \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
  \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
  \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
  \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n     {\
  \ actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
  \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
  \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
  \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    lst_x := make([][]interface{}, 0)\n    for i, list := range lst\
    \ {\n        for j, value := range list {\n            if value == x {\n     \
    \           lst_x = append(lst_x, []interface{}{i, j})\n            }\n      \
    \  }\n    }\n    return lst_x\n}\n", "    res := [][]interface{}{}\n    for i,\
    \ row := range lst {\n        if i > len(lst) {\n            return res\n    \
    \    }\n        for j, val := range row {\n            if val == x {\n       \
    \         res = append(res, []interface{}{i, j})\n            }\n        }\n \
    \   }\n    return res\n}\n", "    ans := [][]interface{}{}\n    for i, row :=\
    \ range lst {\n        for j, el := range row {\n            if el == x {\n  \
    \              ans = append(ans, []interface{}{i, j})\n            }\n       \
    \ }\n    }\n    return ans\n}\n", "    // your code here\n    return nil\n}\n",
  "    // your code here\n    if len(lst) == 0 {\n        return nil\n    }\n    count,\
    \ output := 0, make([][]interface{}, 0)\n    for i, row := range lst {\n     \
    \   for j, val := range row {\n            if val == x {\n                output\
    \ = append(output, []interface{}{i, j})\n                count++\n           \
    \ }\n        }\n    }\n    if count == 0 {\n        return nil\n    }\n    fmt.Println(count)\n\
    \    fmt.Println(output)\n    if count == 1 {\n        return output\n    }\n\
    \    output = sort_rows(output)\n    return output\n}\n", "    var ret [][]interface{}\n\
    \    for i, row := range lst {\n        for j, val := range row {\n          \
    \  if val == x {\n                ret = append(ret, []interface{}{i, j})\n   \
    \         }\n        }\n    }\n    return ret\n}\n", "    res := [][]interface{}{}\n\
    \    for i, v := range lst {\n        for j, vv := range v {\n            if vv\
    \ == x {\n                res = append(res, []interface{}{i, j})\n           \
    \ }\n        }\n    }\n    return res\n}\n", "    row := make([][]interface{},\
    \ 0)\n    for i, v := range lst {\n        for j, v2 := range v {\n          \
    \  if v2 == x {\n                row = append(row, []interface{}{i, j})\n    \
    \        }\n        }\n    }\n    return row\n}\n", "    var res [][]interface{}\n\
    \    for y, row := range lst {\n        if len(row) == 0 {\n            continue\n\
    \        }\n        for x1, v := range row {\n            if v == x {\n      \
    \          res = append(res, []interface{}{y, x1})\n            }\n        }\n\
    \    }\n    return res\n}\n", "    res := [][]interface{}{}\n    for r := 0; r\
    \ < len(lst); r++ {\n        for c := 0; c < len(lst[r]); c++ {\n            if\
    \ lst[r][c] == x {\n                res = append(res, []interface{}{r, c})\n \
    \           }\n        }\n    }\n    for i := 0; i < len(res); i++ {\n       \
    \ for j := i + 1; j < len(res); j++ {\n            if res[i][0].(int) > res[j][0].(int)\
    \ {\n                res[i], res[j] = res[j], res[i]\n            } else if res[i][0].(int)\
    \ == res[j][0].(int) {\n                if res[i][1].(int) < res[j][1].(int) {\n\
    \                    res[i], res[j] = res[j], res[i]\n                }\n    \
    \        }\n        }\n    }\n    return res\n}\n", "    if len(lst) == 0 {\n\
    \        return [][]interface{}{}\n    }\n    var result [][]interface{}\n   \
    \ for row, line := range lst {\n        for col, el := range line {\n        \
    \    if el == x {\n                result = append(result, []interface{}{row,\
    \ col})\n            }\n        }\n    }\n    //Sort by rows\n    for i := 0;\
    \ i < len(result); i++ {\n        for j := i + 1; j < len(result); j++ {\n   \
    \         if result[i][0].(int) > result[j][0].(int) {\n                result[i],\
    \ result[j] = result[j], result[i]\n            }\n        }\n    }\n    //Sort\
    \ by column in the row\n    for i := 0; i < len(result); i++ {\n        for j\
    \ := i + 1; j < len(result); j++ {\n            if result[i][0].(int) == result[j][0].(int)\
    \ && result[i][1].(int) < result[j][1].(int) {\n                result[i], result[j]\
    \ = result[j], result[i]\n            }\n        }\n    }\n    return result\n\
    }\n", "    // your code here\n    var i, j int = 0, 0\n    fmt.Println(lst)\n\
    \    var res [][]interface{}\n    for i = 0; i < len(lst); i++ {\n        for\
    \ j = 0; j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n           \
    \     res = append(res, []interface{}{i, j})\n            }\n        }\n    }\n\
    \    //sort by row\n    for i = 0; i < len(res); i++ {\n        for j = i; j <\
    \ len(res); j++ {\n            if res[i][0].(int) > res[j][0].(int) {\n      \
    \          temp := res[i]\n                res[i] = res[j]\n                res[j]\
    \ = temp\n            }\n        }\n    }\n    for i = 0; i < len(res); i++ {\n\
    \        for j = i; j < len(res); j++ {\n            if res[i][0].(int) == res[j][0].(int)\
    \ && res[i][1].(int) < res[j][1].(int) {\n                temp := res[i]\n   \
    \             res[i] = res[j]\n                res[j] = temp\n            }\n\
    \        }\n    }\n    return res\n}\n", "    result := make([][]interface{},\
    \ 0)\n    for row, row_lst := range lst {\n        if contains(row_lst, x) {\n\
    \            result = append(result, []interface{}{row, index_of(row_lst, x)})\n\
    \        }\n    }\n    return result\n}\n", "    lst_result := [][]interface{}{}\n\
    \    for r, row := range lst {\n        for c, v := range row {\n            if\
    \ v == x {\n                lst_result = append(lst_result, []interface{}{r, c})\n\
    \            }\n        }\n    }\n    // fmt.Println(lst_result)\n    return lst_result\n\
    }\n", "    result := make([][]interface{}, 0)\n    for i, row := range lst {\n\
    \        if len(row) == 0 {\n            continue\n        }\n        row_indices\
    \ := get_indices(row, x)\n        if len(row_indices) > 0 {\n            for _,\
    \ index := range row_indices {\n                result = append(result, []interface{}{i,\
    \ index})\n            }\n        }\n    }\n    sort_indices(result)\n    return\
    \ result\n}\n", "    out := [][]interface{}{}\n    for i, row := range lst {\n\
    \        for j, col := range row {\n            if col == x {\n              \
    \  out = append(out, []interface{}{i, j})\n            }\n        }\n    }\n \
    \   return out\n}\n", "    res := [][]interface{}{}\n    // your code here\n \
    \   for i, row := range lst {\n        for j, item := range row {\n          \
    \  if item == x {\n                res = append(res, []interface{}{i, j})\n  \
    \          }\n        }\n    }\n    return res\n}\n", "    if len(lst) == 0 {\n\
    \        return [][]interface{}{}\n    }\n    res := [][]interface{}{}\n    for\
    \ i, row := range lst {\n        for j, value := range row {\n            if value\
    \ == x {\n                res = append(res, []interface{}{i, j})\n           \
    \ }\n        }\n    }\n    return res\n}\n", "    // Write your code here\n  \
    \  // To print results to the standard output you can use fmt.Println()\n    //\
    \ Example: fmt.Println(\"Hello world!\")\n    var res [][]interface{}\n    for\
    \ i, row := range lst {\n        for j, col := range row {\n            if col\
    \ == x {\n                res = append(res, []interface{}{i, j})\n           \
    \ }\n        }\n    }\n    return res\n}\n", "    var output [][]interface{}\n\
    \    for i, row := range lst {\n        for j, v := range row {\n            if\
    \ v == x {\n                output = append(output, []interface{}{i, j})\n   \
    \         }\n        }\n    }\n    return output\n}\n", "    // write your code\
    \ here\n    res := [][]interface{}{}\n    for i := 0; i < len(lst); i++ {\n  \
    \      for j := 0; j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n \
    \               res = append(res, []interface{}{i, j})\n            }\n      \
    \  }\n    }\n    return res\n}\n", "    row := make([][]interface{}, 0)\n    for\
    \ row_index, row_data := range lst {\n        for col_index, col_data := range\
    \ row_data {\n            if col_data == x {\n                row = append(row,\
    \ []interface{}{row_index, col_index})\n            }\n        }\n    }\n    return\
    \ row\n}\n", "    var c [][]interface{}\n    fmt.Println(lst)\n    for r, l :=\
    \ range lst {\n        fmt.Println(r, l)\n        for c, v := range l {\n    \
    \        if v == x {\n                c = append(c, []interface{}{r, c})\n   \
    \         }\n        }\n    }\n    return c\n}\n", "    var result [][]interface{}\n\
    \    for row, line := range lst {\n        for col, num := range line {\n    \
    \        if num == x {\n                result = append(result, []interface{}{row,\
    \ col})\n            }\n        }\n    }\n    return result\n}\n", "    result\
    \ := make([][]interface{}, 0)\n    for i, row := range lst {\n        for j, item\
    \ := range row {\n            if item == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n",
  "    result := make([][]interface{}, 0)\n    for i, row := range lst {\n       \
    \ for j, col := range row {\n            if col == x {\n                result\
    \ = append(result, []interface{}{i, j})\n            }\n        }\n    }\n   \
    \ return result\n}\n", "    var res [][]interface{}\n    for i, row := range lst\
    \ {\n        for j, elem := range row {\n            if elem == x {\n        \
    \        res = append(res, []interface{}{i, j})\n            }\n        }\n  \
    \  }\n    return res\n}\n", "    var res [][]interface{}\n    for i, row := range\
    \ lst {\n        for j, val := range row {\n            if val == x {\n      \
    \          res = append(res, []interface{}{i, j})\n            }\n        }\n\
    \    }\n    return res\n}\n", "    if len(lst) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    row_num := 0\n    col_num := 0\n    res := [][]interface{}{}\n   \
    \ for _, item := range lst {\n        col_num = 0\n        for _, subitem := range\
    \ item {\n            if subitem == x {\n                res = append(res, []interface{}{row_num,\
    \ col_num})\n            }\n            col_num += 1\n        }\n        row_num\
    \ += 1\n    }\n    bubble_sort(res)\n    return res\n}\n", "    result := make([][]interface{},\
    \ 0)\n    for i, row := range lst {\n        for j, cell := range row {\n    \
    \        if cell == x {\n                result = append(result, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    return result\n}\n", "    rlst :=\
    \ make([][]interface{}, 0)\n    for i, val := range lst {\n        for j, val1\
    \ := range val {\n            if val1 == x {\n                rlst = append(rlst,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return rlst\n}\n",
  "    count_x := 0\n    for i, row := range lst {\n        for j, el := range row\
    \ {\n            if el == x {\n                count_x++\n            }\n    \
    \    }\n    }\n    count_x_arr := make([][]interface{}, count_x)\n    for i, row\
    \ := range lst {\n        for j, el := range row {\n            if el == x {\n\
    \                count_x_arr[i] = []interface{}{i, j}\n            }\n       \
    \ }\n    }\n    fmt.Println(count_x_arr)\n    return count_x_arr\n}\n", "    var\
    \ res [][]interface{}\n    // your code here\n    return res\n}\n", "    res :=\
    \ [][]interface{}{}\n    for row, slc := range lst {\n        for col, v := range\
    \ slc {\n            if v == x {\n                res = append(res, []interface{}{row,\
    \ col})\n            }\n        }\n    }\n    return res\n}\n", "    var row_list\
    \ [][]interface{}\n    for r, row := range lst {\n        var col_list []interface{}\n\
    \        for c, val := range row {\n            if val == x {\n              \
    \  col_list = append(col_list, c)\n            }\n        }\n        if len(col_list)\
    \ > 0 {\n            col_list = append(col_list, r)\n            row_list = append(row_list,\
    \ col_list)\n        }\n    }\n    return row_list\n}\n", "    var result [][]interface{}\n\
    \    for xIndex, row := range lst {\n        for yIndex, value := range row {\n\
    \            if value == x {\n                result = append(result, []interface{}{xIndex,\
    \ yIndex})\n            }\n        }\n    }\n    return result\n}\n", "    var\
    \ result [][]interface{}\n    for i, _ := range lst {\n        for j, v := range\
    \ lst[i] {\n            if v == x {\n                temp := []interface{}{i,\
    \ j}\n                result = append(result, temp)\n            }\n        }\n\
    \    }\n    return result\n}\n", "    var res [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, v := range row {\n            if v == x {\n \
    \               res = append(res, []interface{}{i, j})\n            }\n      \
    \  }\n    }\n    return res\n}\n", "    // edge case\n    if len(lst) == 0 {\n\
    \        return [][]interface{}{}\n    }\n    var result [][]interface{}\n   \
    \ // scan all elems\n    for i, row := range lst {\n        for j, elem := range\
    \ row {\n            if elem == x {\n                tmp := []interface{}{i, j}\n\
    \                result = append(result, tmp)\n            }\n        }\n    }\n\
    \    // sort by rows\n    for i := 0; i < len(result); i++ {\n        for j :=\
    \ i + 1; j < len(result); j++ {\n            if result[i][0].(int) > result[j][0].(int)\
    \ {\n                result[i], result[j] = result[j], result[i]\n           \
    \ }\n        }\n    }\n    // sort by columns\n    for i := 0; i < len(result);\
    \ i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0].(int)\
    \ == result[j][0].(int) {\n                if result[i][1].(int) < result[j][1].(int)\
    \ {\n                    result[i], result[j] = result[j], result[i]\n       \
    \         }\n            }\n        }\n    }\n    return result\n}\n", "    //\
    \ your code here\n    res := [][]interface{}{}\n    for i, v := range lst {\n\
    \        for j, v2 := range v {\n            if v2 == x {\n                res\
    \ = append(res, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ res\n}\n", "    ret := make([][]interface{}, 0)\n    for i, row := range lst\
    \ {\n        for j, e := range row {\n            if e == x {\n              \
    \  ret = append(ret, []interface{}{i, j})\n            }\n        }\n    }\n \
    \   return ret\n}\n", "    var result [][]interface{}\n    for i, row := range\
    \ lst {\n        for j, cell := range row {\n            if cell == x {\n    \
    \            result = append(result, []interface{}{i, j})\n            }\n   \
    \     }\n    }\n    return result\n}\n", "    rowcol := make([][]interface{},\
    \ 0)\n    for i, row := range lst {\n        for j, v := range row {\n       \
    \     if v == x {\n                rowcol = append(rowcol, []interface{}{i, j})\n\
    \            }\n        }\n    }\n    for i := len(rowcol) - 1; i > 0; i-- {\n\
    \        for j := 0; j < i; j++ {\n            if rowcol[j][0].(int) > rowcol[j+1][0].(int)\
    \ {\n                rowcol[j], rowcol[j+1] = rowcol[j+1], rowcol[j]\n       \
    \     } else if rowcol[j][0].(int) == rowcol[j+1][0].(int) {\n               \
    \ if rowcol[j][1].(int) < rowcol[j+1][1].(int) {\n                    rowcol[j],\
    \ rowcol[j+1] = rowcol[j+1], rowcol[j]\n                }\n            }\n   \
    \     }\n    }\n    return rowcol\n}\n", "    count := 0\n    res := make([][]interface{},\
    \ len(lst))\n    for i, elem := range lst {\n        for j, e := range elem {\n\
    \            if e == x {\n                res[count] = []interface{}{i, j}\n \
    \               count++\n            }\n        }\n    }\n    return res[:count]\n\
    }\n", "    // If a list of lists is empty, return an empty list.\n    if len(lst)\
    \ == 0 {\n        return [][]interface{}{}\n    }\n    // If a list of lists is\
    \ empty, return an empty list.\n    if len(lst[0]) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    // If a list of lists is empty, return an empty list.\n    if len(lst[1])\
    \ == 0 {\n        return [][]interface{}{}\n    }\n    // If a list of lists is\
    \ empty, return an empty list.\n    if len(lst[2]) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    // If a list of lists is empty, return an empty list.\n    if len(lst[3])\
    \ == 0 {\n        return [][]interface{}{}\n    }\n    // If a list of lists is\
    \ empty, return an empty list.\n    if len(lst[4]) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    var res [][]interface{}\n    for row := 0; row < len(lst); row++ {\n\
    \        for column := 0; column < len(lst[row]); column++ {\n            if lst[row][column]\
    \ == x {\n                res = append(res, []interface{}{row, column})\n    \
    \        }\n        }\n    }\n    return res\n}\n", "    res := [][]interface{}{}\n\
    \    for i, v := range lst {\n        for j, w := range v {\n            if w\
    \ == x {\n                res = append(res, []interface{}{i, j})\n           \
    \ }\n        }\n    }\n    return res\n}\n", "    var result [][]interface{}\n\
    \    for i, row := range lst {\n        for j, value := range row {\n        \
    \    if value == x {\n                result = append(result, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return (result[i][0].(int) < result[j][0].(int)) ||\n      \
    \  (result[i][0].(int) == result[j][0].(int) && result[i][1].(int) > result[j][1].(int))\n\
    \    })\n    return result\n}\n", "    var result [][]interface{}\n    for i,\
    \ sublist := range lst {\n        for j, val := range sublist {\n            if\
    \ val == x {\n                result = append(result, []interface{}{i, j})\n \
    \           }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        ii := result[i].([]interface{})\n        jj := result[j].([]interface{})\n\
    \        ii0 := ii[0].(int)\n        jj0 := jj[0].(int)\n        ii1 := ii[1].(int)\n\
    \        jj1 := jj[1].(int)\n        if ii0 < jj0 {\n            return true\n\
    \        } else if ii0 == jj0 {\n            return ii1 > jj1\n        } else\
    \ {\n            return false\n        }\n    })\n    return result\n}\n", " \
    \   var result [][]interface{}\n    for i, r := range lst {\n        for j, v\
    \ := range r {\n            if v == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    for i := 0; i < len(result)\
    \ - 1; i++ {\n        for j := i + 1; j < len(result); j++ {\n            if result[i][0].(int)\
    \ == result[j][0].(int) {\n                if result[i][1].(int) < result[j][1].(int)\
    \ {\n                    tmp := result[i]\n                    result[i] = result[j]\n\
    \                    result[j] = tmp\n                }\n            } else if\
    \ result[i][0].(int) > result[j][0].(int) {\n                tmp := result[i]\n\
    \                result[i] = result[j]\n                result[j] = tmp\n    \
    \        }\n        }\n    }\n    return result\n}\n", "    coordinates := [][]interface{}{}\n\
    \    for i, row := range lst {\n        for j, y := range row {\n            if\
    \ y == x {\n                coordinates = append(coordinates, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    return coordinates\n}\n", "    rlst\
    \ := make([][]interface{}, 0)\n    var cnt, rcount int\n    var rlst_index int\n\
    \    // find int x in lst\n    for rcount, r := range lst {\n        for _, e\
    \ := range r {\n            if e == x {\n                rlst = append(rlst, make([]interface{},\
    \ 2))\n                rlst[cnt][0] = rcount\n                rlst[cnt][1] = -1\n\
    \                cnt++\n            }\n        }\n    }\n    // find columns of\
    \ int x in lst\n    for rcount, r := range lst {\n        for c, e := range r\
    \ {\n            if e == x {\n                for rlst_index = 0; rlst_index <\
    \ cnt; rlst_index++ {\n                    if rlst[rlst_index][0] == rcount {\n\
    \                        rlst[rlst_index][1] = c\n                        break\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   // sort rlst by row and columns\n    for i := 0; i < cnt - 1; i++ {\n    \
    \    for j := i + 1; j < cnt; j++ {\n            // sorting by row\n         \
    \   if rlst[i][0].(int) > rlst[j][0].(int) {\n                rlst[i], rlst[j]\
    \ = rlst[j], rlst[i]\n            }\n            // sorting by column\n      \
    \      if rlst[i][0].(int) == rlst[j][0].(int) {\n                if rlst[i][1].(int)\
    \ < rlst[j][1].(int) {\n                    rlst[i], rlst[j] = rlst[j], rlst[i]\n\
    \                }\n            }\n        }\n    }\n    //fmt.Println(rlst)\n\
    \    return rlst\n}\n\n//lst := [][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,",
  "    res := [][]interface{}{}\n    for rowIdx, row := range lst {\n        for colIdx,\
    \ num := range row {\n            if num == x {\n                res = append(res,\
    \ []interface{}{rowIdx, colIdx})\n            }\n        }\n    }\n    sort.Slice(res,\
    \ func(i, j int) bool {\n        // sort by rows ascending\n        rowIdx1 :=\
    \ res[i][0].(int)\n        rowIdx2 := res[j][0].(int)\n        if rowIdx1 != rowIdx2\
    \ {\n            return rowIdx1 < rowIdx2\n        }\n        // sort by columns\
    \ descending\n        colIdx1 := res[i][1].(int)\n        colIdx2 := res[j][1].(int)\n\
    \        return colIdx1 > colIdx2\n    })\n    return res\n}\n", "    var result\
    \ [][]interface{}\n    for row_idx, row := range lst {\n        for col_idx, n\
    \ := range row {\n            if n == x {\n                result = append(result,\
    \ []interface{}{row_idx, col_idx})\n            }\n        }\n    }\n    return\
    \ result\n}\n", "    a := [][]interface{}{}\n    for i, row := range lst {\n \
    \       for j, col := range row {\n            if col == x {\n               \
    \ a = append(a, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ a\n}\n", "    var result [][]interface{}\n    for i, row := range lst {\n  \
    \      for j, value := range row {\n            if value == x {\n            \
    \    result = append(result, []interface{}{i, j})\n            }\n        }\n\
    \    }\n    return result\n}\n", "    // your code here\n    res := [][]interface{}{}\n\
    \    for i, l := range lst {\n        for j, v := range l {\n            if v\
    \ == x {\n                res = append(res, []interface{}{i, j})\n           \
    \ }\n        }\n    }\n    return res\n}\n", "    ret := make([][]interface{},\
    \ 0)\n    for i, row := range lst {\n        for j, el := range row {\n      \
    \      if el == x {\n                ret = append(ret, []interface{}{i, j})\n\
    \            }\n        }\n    }\n    return ret\n}\n", "    // your code here\n\
    \    return nil\n}\n", "    var result [][]interface{}\n    for row, rows := range\
    \ lst {\n        for column, item := range rows {\n            if item == x {\n\
    \                result = append(result, []interface{}{row, column})\n       \
    \     }\n        }\n    }\n    return result\n}\n", "    row_count := len(lst)\n\
    \    if row_count == 0 {\n        return [][]interface{}{}\n    }\n    all_indexes\
    \ := make([][]interface{}, 0)\n    for row_index, row := range lst {\n       \
    \ column_count := len(row)\n        var indexes []int\n        for column_index,\
    \ value := range row {\n            if value == x {\n                indexes =\
    \ append(indexes, column_index)\n            }\n        }\n        for _, column_index\
    \ := range indexes {\n            all_indexes = append(all_indexes, []interface{}{row_index,\
    \ column_index})\n        }\n    }\n    return all_indexes\n}\n", "    var res\
    \ [][]interface{}\n    for i, row := range lst {\n        for j, el := range row\
    \ {\n            if el == x {\n                res = append(res, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    return res\n}\n", "    i := 0\n  \
    \  var a [][]interface{}\n    for _, row := range lst {\n        for j, val :=\
    \ range row {\n            if val == x {\n                a = append(a, []interface{}{i,\
    \ j})\n            }\n        }\n        i++\n    }\n    return a\n}\n", "   \
    \ // put your code here\n    res := [][]interface{}{}\n    if len(lst) == 0 {\n\
    \        return res\n    }\n    for index, row := range lst {\n        for i,\
    \ val := range row {\n            if val == x {\n                res = append(res,\
    \ []interface{}{index, i})\n            }\n        }\n    }\n    for i, _ := range\
    \ res {\n        for j := i + 1; j < len(res); j++ {\n            if res[i][0].(int)\
    \ > res[j][0].(int) {\n                tmp := res[i]\n                res[i] =\
    \ res[j]\n                res[j] = tmp\n            } else if res[i][0].(int)\
    \ == res[j][0].(int) {\n                if res[i][1].(int) < res[j][1].(int) {\n\
    \                    tmp := res[i]\n                    res[i] = res[j]\n    \
    \                res[j] = tmp\n                }\n            }\n        }\n \
    \   }\n    return res\n}\n", "    res := [][]interface{}{}\n    for row, r :=\
    \ range lst {\n        for column, c := range r {\n            if c == x {\n \
    \               res = append(res, []interface{}{row, column})\n            }\n\
    \        }\n    }\n    if len(res) == 0 {\n        return res\n    }\n    for\
    \ i := 0; i < len(res) - 1; i++ {\n        for j := i + 1; j < len(res); j++ {\n\
    \            if res[i][0].(int) > res[j][0].(int) {\n                t := res[i]\n\
    \                res[i] = res[j]\n                res[j] = t\n            }\n\
    \        }\n    }\n    for i := 0; i < len(res) - 1; i++ {\n        for j := i\
    \ + 1; j < len(res); j++ {\n            if res[i][0].(int) == res[j][0].(int)\
    \ {\n                if res[i][1].(int) < res[j][1].(int) {\n                \
    \    t := res[i]\n                    res[i] = res[j]\n                    res[j]\
    \ = t\n                }\n            }\n        }\n    }\n    return res\n}\n",
  "    var results [][]interface{}\n    for i, row := range lst {\n        for j,\
    \ value := range row {\n            if value == x {\n                results =\
    \ append(results, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ results\n}\n", "    res := [][]interface{}{}\n    for i, r := range lst {\n\
    \        c := 0\n        for _, e := range r {\n            if e == x {\n    \
    \            res = append(res, []interface{}{i, c})\n            }\n         \
    \   c++\n        }\n    }\n    return res\n}\n", "    result := make([][]interface{},\
    \ 0)\n    for idx, row := range lst {\n        for jdx, val := range row {\n \
    \           if val == x {\n                result = append(result, []interface{}{idx,\
    \ jdx})\n            }\n        }\n    }\n    return result\n}\n", "    result\
    \ := make([][]interface{}, 0)\n    for i, row := range lst {\n        for j, col\
    \ := range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n",
  "    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    lenToIdxMap\
    \ := make(map[int][]int)\n    for i, row := range lst {\n        lenToIdxMap[len(row)]\
    \ = append(lenToIdxMap[len(row)], i)\n    }\n    maxRow := len(lst)\n    maxCol\
    \ := len(lst[0])\n    for _, row := range lst {\n        if len(row) > maxCol\
    \ {\n            maxCol = len(row)\n        }\n    }\n    coords := make([][]interface{},\
    \ 0)\n    for i := 0; i < maxRow; i++ {\n        row := lst[i]\n        for j\
    \ := 0; j < maxCol; j++ {\n            if j >= len(row) {\n                continue\n\
    \            }\n            if row[j] == x {\n                coords = append(coords,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    // sort coords by\
    \ row asc and col desc\n    // sort.Slice(coords, func(i, j int) bool {\n    //\
    \     idx1 := coords[i][0].(int)\n    //     idx2 := coords[j][0].(int)\n    //\
    \     col1 := coords[i][1].(int)\n    //     col2 := coords[j][1].(int)\n    //\
    \     if idx1 == idx2 {\n    //         return col1 > col2\n    //     }\n   \
    \ //     return idx1 < idx2\n    // })\n    // sort by row asc and col desc\n\
    \    return coords\n}\n", "    var ret [][]interface{}\n    for i, row := range\
    \ lst {\n        for j, val := range row {\n            if val == x {\n      \
    \          ret = append(ret, []interface{}{i, j})\n            }\n        }\n\
    \    }\n    return ret\n}\n", "    var res [][]interface{}\n    for i, row :=\
    \ range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                res = append(res, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    return res\n}\n", "    var r [][]interface{}\n    for i, v :=\
    \ range lst {\n        for j, k := range v {\n            if k == x {\n      \
    \          r = append(r, []interface{}{i, j})\n            }\n        }\n    }\n\
    \    return r\n}\n", "    ret := make([][]interface{}, 0)\n    for row, v := range\
    \ lst {\n        for col, val := range v {\n            if val == x {\n      \
    \          ret = append(ret, []interface{}{row, col})\n            }\n       \
    \ }\n    }\n    return ret\n}\n", "    var (\n        i, j int\n        res [][]interface{}\n\
    \    )\n    for i = 0; i < len(lst); i++ {\n        for j = 0; j < len(lst[i]);\
    \ j++ {\n            if lst[i][j] == x {\n                res = append(res, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    return res\n}\n", "    ret := make([][]interface{},\
    \ 0)\n    xidx := make([]int, 0)\n    for i, row := range lst {\n        for j,\
    \ col := range row {\n            if col == x {\n                xidx = append(xidx,\
    \ i)\n                ret = append(ret, []interface{}{i, j})\n            }\n\
    \        }\n    }\n    for i := 0; i < len(xidx); i++ {\n        for j := 0; j\
    \ < len(xidx); j++ {\n            if xidx[i] == xidx[j] {\n                if\
    \ ret[i][1].(int) < ret[j][1].(int) {\n                    tmp := ret[i]\n   \
    \                 ret[i] = ret[j]\n                    ret[j] = tmp\n        \
    \        }\n            }\n        }\n    }\n    fmt.Println(ret)\n    return\
    \ ret\n}\n", "    var res [][]interface{}\n    var row []interface{}\n    for\
    \ i, row := range lst {\n        for j, num := range row {\n            if num\
    \ == x {\n                res = append(res, []interface{}{i, j})\n           \
    \ }\n        }\n    }\n    fmt.Println(res)\n    return res\n}\n", "    res :=\
    \ [][]interface{}{}\n    for i, row := range lst {\n        for j, val := range\
    \ row {\n            if val == x {\n                res = append(res, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    return res\n}\n", "    var res [][]interface{}\n\
    \    for y, row := range lst {\n        for x2, _ := range row {\n           \
    \ if row[x2] == x {\n                res = append(res, []interface{}{y, x2})\n\
    \            }\n        }\n    }\n    for i := 0; i < len(res) - 1; i++ {\n  \
    \      for j := i + 1; j < len(res); j++ {\n            if res[i][0].(int) > res[j][0].(int)\
    \ {\n                res[i], res[j] = res[j], res[i]\n            } else if res[i][0].(int)\
    \ == res[j][0].(int) {\n                if res[i][1].(int) < res[j][1].(int) {\n\
    \                    res[i], res[j] = res[j], res[i]\n                }\n    \
    \        }\n        }\n    }\n    return res\n}\n", "    var result [][]interface{}\n\
    \    for i, row := range lst {\n        for j, e := range row {\n            if\
    \ e == x {\n                result = append(result, []interface{}{i, j})\n   \
    \         }\n        }\n    }\n    return result\n}\n", "    // We need to sort\
    \ all columns by columns in descending order.\n    // Thus we will build list\
    \ of tuples, where first element\n    // will be column index, and second element\
    \ will be row index.\n    // Each tuple corresponds to tuple (column, row).\n\
    \    columns := []Column{}\n    for row, row_items := range lst {\n        for\
    \ column, item := range row_items {\n            if item == x {\n            \
    \    columns = append(columns, Column{column, row})\n            }\n        }\n\
    \    }\n    // We need to sort columns by column index in descending order.\n\
    \    sortColumns(columns)\n    // We need to sort columns by row index in ascending\
    \ order.\n    // And also columns with the same row index should be sorted\n \
    \   // by column index in descending order.\n    sortColumnsByRow(columns)\n \
    \   // Now we need to convert columns to list of lists.\n    result := [][]interface{}{}\n\
    \    for _, column := range columns {\n        result = append(result, []interface{}{column.Row,\
    \ column.Column})\n    }\n    return result\n}\n", "    if len(lst) == 0 {\n \
    \       return [][]interface{}{}\n    }\n    m := map[int][]interface{}{}\n  \
    \  for i, row := range lst {\n        for j, v := range row {\n            if\
    \ v == x {\n                m[i] = append(m[i], j)\n            }\n        }\n\
    \    }\n    result := [][]interface{}{}\n    keys := []int{}\n    for key := range\
    \ m {\n        keys = append(keys, key)\n    }\n    sort.Ints(keys)\n    for _,\
    \ key := range keys {\n        curr_row := m[key]\n        sort.Sort(sort.Reverse(sort.IntSlice(curr_row)))\n\
    \        for _, col := range curr_row {\n            result = append(result, []interface{}{key,\
    \ col})\n        }\n    }\n    return result\n}\n", "    var coords [][]interface{}\n\
    \    for i, row := range lst {\n        for j, e := range row {\n            if\
    \ e == x {\n                coords = append(coords, []interface{}{i, j})\n   \
    \         }\n        }\n    }\n    return coords\n}\n", "    var result [][]interface{}\n\
    \    for i, row := range lst {\n        for j, x_ := range row {\n           \
    \ if x_ == x {\n                result = append(result, []interface{}{i, j})\n\
    \            }\n        }\n    }\n    // Sort result by rows in ascending order.\n\
    \    sort_by_rows_ascending_order(result)\n    // Sort coordinates of the row\
    \ by columns in descending order.\n    for _, row := range result {\n        sort_by_columns_descending_order(lst,\
    \ row[0].(int))\n    }\n    return result\n}\n", "    var result [][]interface{}\n\
    \    for i, sublist := range lst {\n        if count := count(sublist, x); count\
    \ > 0 {\n            for j := count; j > 0; j-- {\n                result = append(result,\
    \ []interface{}{i, j - 1})\n            }\n        }\n    }\n    return result\n\
    }\n", "    var ans [][]interface{}\n    for i, l := range lst {\n        for j,\
    \ v := range l {\n            if v == x {\n                ans = append(ans, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    return ans\n}\n", "    var result\
    \ [][]interface{}\n    for i, row := range lst {\n        for j, item := range\
    \ row {\n            if item == x {\n                result = append(result, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    return result\n}\n", "    result :=\
    \ make([][]interface{}, 0)\n    for i, row := range lst {\n        for j, value\
    \ := range row {\n            if value == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    // sort by row\n\
    \    for i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result);\
    \ j++ {\n            if result[i][0].(int) > result[j][0].(int) {\n          \
    \      result[i], result[j] = result[j], result[i]\n            }\n        }\n\
    \    }\n    // sort by column\n    for i := 0; i < len(result); i++ {\n      \
    \  for j := i + 1; j < len(result); j++ {\n            if result[i][0].(int) ==\
    \ result[j][0].(int) && result[i][1].(int) < result[j][1].(int) {\n          \
    \      result[i], result[j] = result[j], result[i]\n            }\n        }\n\
    \    }\n    return result\n}\n", "    out := [][]interface{}{}\n    for i, j :=\
    \ range lst {\n        for k, v := range j {\n            if v == x {\n      \
    \          out = append(out, []interface{}{i, k})\n            }\n        }\n\
    \    }\n    return out\n}\n", "    result := make([][]interface{}, 0)\n    rows_with_columns\
    \ := make(map[int][]int)\n    for i, row := range lst {\n        var columns []int\n\
    \        for j, item := range row {\n            if item == x {\n            \
    \    columns = append(columns, j)\n            }\n        }\n        if len(columns)\
    \ > 0 {\n            rows_with_columns[i] = columns\n        }\n    }\n    for\
    \ key, value := range rows_with_columns {\n        for _, c := range value {\n\
    \            result = append(result, []interface{}{key, c})\n        }\n    }\n\
    \    return result\n}\n", "    row := [][]interface{}{}\n    for i, _ := range\
    \ lst {\n        for j, v := range lst[i] {\n            if v == x {\n       \
    \         row = append(row, []interface{}{i, j})\n            }\n        }\n \
    \   }\n    sort_row(row)\n    return row\n}\n", "    // Your code here\n    var\
    \ ans [][]interface{}\n    for i, sub := range lst {\n        for j, x2 := range\
    \ sub {\n            if x2 == x {\n                ans = append(ans, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    return ans\n}\n", "    res := [][]interface{}{}\n\
    \    for row, row_val := range lst {\n        for col, col_val := range row_val\
    \ {\n            if col_val == x {\n                res = append(res, []interface{}{row,\
    \ col})\n            }\n        }\n    }\n    return res\n}\n", "    var ret [][]interface{}\n\
    \    for i, row := range lst {\n        for j, val := range row {\n          \
    \  if val == x {\n                ret = append(ret, []interface{}{i, j})\n   \
    \         }\n        }\n    }\n    return ret\n}\n", "    res := [][]interface{}{}\n\
    \    for i, row := range lst {\n        for j, el := range row {\n           \
    \ if el == x {\n                res = append(res, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return res\n}\n", "    var result [][]interface{}\n\
    \    if len(lst) == 0 {\n        return result\n    }\n    for i, row := range\
    \ lst {\n        for j, v := range row {\n            if v == x {\n          \
    \      result = append(result, []interface{}{i, j})\n            }\n        }\n\
    \    }\n    return result\n}\n", "    var out [][]interface{}\n    if len(lst)\
    \ > 0 {\n        var coords [][]int\n        for i, row := range lst {\n     \
    \       if len(row) > 0 {\n                for j, elem := range row {\n      \
    \              if elem == x {\n                        coords = append(coords,\
    \ []int{i, j})\n                    }\n                }\n            }\n    \
    \    }\n        if len(coords) > 0 {\n            // sort rows ascending\n   \
    \         for i := 0; i < len(coords); i++ {\n                for j := i + 1;\
    \ j < len(coords); j++ {\n                    if coords[i][0] > coords[j][0] {\n\
    \                        coords[i], coords[j] = coords[j], coords[i]\n       \
    \             }\n                }\n            }\n            // sort each row\
    \ descending\n            for _, coord := range coords {\n                i :=\
    \ coord[0]\n                for j := i + 1; j < len(coords); j++ {\n         \
    \           if coords[i][0] == coords[j][0] {\n                        if coords[i][1]\
    \ < coords[j][1] {\n                            coords[i], coords[j] = coords[j],\
    \ coords[i]\n                        }\n                    }\n              \
    \  }\n            }\n            // make output\n            for _, coord := range\
    \ coords {\n                var out_row []interface{}\n                for _,\
    \ c := range coord {\n                    out_row = append(out_row, c)\n     \
    \           }\n                out = append(out, out_row)\n            }\n   \
    \     }\n    }\n    return out\n}\n", "    result := make([][]interface{}, 0)\n\
    \    if lst == nil || len(lst) == 0 {\n        return result\n    }\n    for i,\
    \ row := range lst {\n        for j, col := range row {\n            if col ==\
    \ x {\n                result = append(result, []interface{}{i, j})\n        \
    \    }\n        }\n    }\n    return result\n}\n", "    var coords [][]interface{}\n\
    \    for i, row := range lst {\n        for j, e := range row {\n            if\
    \ e == x {\n                coords = append(coords, []interface{}{i, j})\n   \
    \         }\n        }\n    }\n    return coords\n}\n", "    var ret [][]interface{}\n\
    \    for i, s := range lst {\n        for j, v := range s {\n            if v\
    \ == x {\n                ret = append(ret, []interface{}{i, j})\n           \
    \ }\n        }\n    }\n    return ret\n}\n", "    var res [][]interface{}\n  \
    \  for y, row := range lst {\n        for x1, x2 := range row {\n            if\
    \ x2 == x {\n                res = append(res, []interface{}{y, x1})\n       \
    \     }\n        }\n    }\n    return res\n}\n", "    var res [][]interface{}\n\
    \    for i, r := range lst {\n        for j, c := range r {\n            if c\
    \ == x {\n                res = append(res, []interface{}{i, j})\n           \
    \ }\n        }\n    }\n    return res\n}\n", "    result := make([][]interface{},\
    \ 0)\n    if len(lst) == 0 {\n        return result\n    }\n    for r, row :=\
    \ range lst {\n        for c, elem := range row {\n            if elem == x {\n\
    \                result = append(result, []interface{}{r, c})\n            }\n\
    \        }\n    }\n    sort(result)\n    return result\n}\n", "    indexes :=\
    \ make([][]interface{}, 0)\n    for row, line := range lst {\n        for column,\
    \ number := range line {\n            if number == x {\n                indexes\
    \ = append(indexes, []interface{}{row, column})\n            }\n        }\n  \
    \  }\n    return indexes\n}\n", "    var result [][]interface{}\n    if len(lst)\
    \ == 0 {\n        return result\n    }\n    for i, row := range lst {\n      \
    \  for j, item := range row {\n            if item == x {\n                result\
    \ = append(result, []interface{}{i, j})\n            }\n        }\n    }\n   \
    \ return result\n}\n", "    if len(lst) == 0 {\n        return make([][]interface{},\
    \ 0)\n    }\n    result := make([][]interface{}, 0)\n    for i, l := range lst\
    \ {\n        for j, e := range l {\n            if e == x {\n                result\
    \ = append(result, []interface{}{i, j})\n            }\n        }\n    }\n   \
    \ return result\n}\n", "    coordinates := [][]interface{}{}\n    for row, row_lst\
    \ := range lst {\n        for column, element := range row_lst {\n           \
    \ if element == x {\n                coordinates = append(coordinates, []interface{}{row,\
    \ column})\n            }\n        }\n    }\n    return coordinates\n}\n", " \
    \   res := [][]interface{}{}\n    if len(lst) == 0 {\n        return res\n   \
    \ }\n    for i, el := range lst {\n        for j, int_el := range el {\n     \
    \       if int_el == x {\n                res = append(res, []interface{}{i, j})\n\
    \            }\n        }\n    }\n    return res\n}\n", "    var ret [][]interface{}\n\
    \    for i, row := range lst {\n        for j, value := range row {\n        \
    \    if value == x {\n                ret = append(ret, []interface{}{i, j})\n\
    \            }\n        }\n    }\n    return ret\n}\n", "    // your code here\n\
    \    return nil\n}\n", "    var results = make([][]interface{}, 0)\n    for i,\
    \ row := range lst {\n        if len(row) == 0 {\n            continue\n     \
    \   }\n        for j, item := range row {\n            if item == x {\n      \
    \          results = append(results, []interface{}{i, j})\n            }\n   \
    \     }\n    }\n    return results\n}\n", "    var result [][]interface{}\n  \
    \  for i, row := range lst {\n        for j, value := range row {\n          \
    \  if value == x {\n                result = append(result, []interface{}{i, j})\n\
    \            }\n        }\n    }\n    return result\n}\n", "    var result [][]interface{}\n\
    \    var arr []interface{}\n    for i, n := range lst {\n        for j, m := range\
    \ n {\n            if m == x {\n                arr = []interface{}{i, j}\n  \
    \              result = append(result, arr)\n            }\n        }\n    }\n\
    \    return result\n}\n", "    result := make([][]interface{}, 0)\n    if len(lst)\
    \ == 0 {\n        return result\n    }\n    for y, row := range lst {\n      \
    \  for x2, x2 := range row {\n            if x2 == x {\n                result\
    \ = append(result, []interface{}{y, x2})\n            }\n        }\n    }\n  \
    \  return result\n}\n", "    var res [][]interface{}\n    for row, row_list :=\
    \ range lst {\n        for col, val := range row_list {\n            if val ==\
    \ x {\n                res = append(res, []interface{}{row, col})\n          \
    \  }\n        }\n    }\n    return res\n}\n", "    coordinates := [][]interface{}{}\n\
    \    for y, row := range lst {\n        for xPos, val := range row {\n       \
    \     if val == x {\n                coordinates = append(coordinates, []interface{}{y,\
    \ xPos})\n            }\n        }\n    }\n    for i := 0; i < len(coordinates)\
    \ - 1; i++ {\n        for j := 0; j < len(coordinates) - i - 1; j++ {\n      \
    \      row1 := coordinates[j][0].(int)\n            row2 := coordinates[j + 1][0].(int)\n\
    \            if row1 > row2 {\n                coordinates[j], coordinates[j +\
    \ 1] = coordinates[j + 1], coordinates[j]\n            } else if row1 == row2\
    \ {\n                col1 := coordinates[j][1].(int)\n                col2 :=\
    \ coordinates[j + 1][1].(int)\n                if col1 < col2 {\n            \
    \        coordinates[j], coordinates[j + 1] = coordinates[j + 1], coordinates[j]\n\
    \                }\n            }\n        }\n    }\n    return coordinates\n\
    }\n", "    var points [][]interface{}\n    for i, v := range lst {\n        for\
    \ k, a := range v {\n            if a == x {\n                points = append(points,\
    \ []interface{}{i, k})\n            }\n        }\n    }\n    return points\n}\n",
  "    var list [][]interface{}\n    for i, v := range lst {\n        var l []interface{}\n\
    \        for j, vv := range v {\n            if vv == x {\n                l =\
    \ append(l, []interface{}{i, j})\n            }\n        }\n        if len(l)\
    \ > 0 {\n            list = append(list, l)\n        }\n    }\n    for i := 0;\
    \ i < len(list); i++ {\n        for j := i + 1; j < len(list); j++ {\n       \
    \     if list[i][0].(int) > list[j][0].(int) {\n                list[i], list[j]\
    \ = list[j], list[i]\n            }\n        }\n    }\n    for i := 0; i < len(list);\
    \ i++ {\n        for j := 0; j < len(list[i]) - 1; j++ {\n            for k :=\
    \ j + 1; k < len(list[i]); k++ {\n                if list[i][j].([]interface{})[1].(int)\
    \ < list[i][k].([]interface{})[1].(int) {\n                    list[i][j], list[i][k]\
    \ = list[i][k], list[i][j]\n                }\n            }\n        }\n    }\n\
    \    return list\n}\n", "    result := make([][]interface{}, 0)\n    for i, row\
    \ := range lst {\n        for j, item := range row {\n            if item == x\
    \ {\n                result = append(result, []interface{}{i, j})\n          \
    \  }\n        }\n    }\n    return result\n}\n", "    // your code here\n    var\
    \ res [][]interface{}\n    if len(lst) < 1 {\n        return res\n    }\n    for\
    \ row, ints := range lst {\n        for column, y := range ints {\n          \
    \  if y == x {\n                res = append(res, []interface{}{row, column})\n\
    \            }\n        }\n    }\n    return res\n}\n", "    var out [][]interface{}\n\
    \    for i, row := range lst {\n        for j, col := range row {\n          \
    \  if col == x {\n                out = append(out, []interface{}{i, j})\n   \
    \         }\n        }\n    }\n    return out\n}\n", "    var res [][]interface{}\n\
    \    for i, row := range lst {\n        for j, col := range row {\n          \
    \  if col == x {\n                // fmt.Println(i, j)\n                res =\
    \ append(res, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ res\n}\n", "    var ret [][]interface{}\n    for y, row := range lst {\n   \
    \     for x, num := range row {\n            if num == x {\n                ret\
    \ = append(ret, []interface{}{y, x})\n            }\n        }\n    }\n    return\
    \ ret\n}\n", "    var result [][]interface{}\n    if len(lst) == 0 {\n       \
    \ return result\n    }\n    for i, row := range lst {\n        for j, val := range\
    \ row {\n            if val == x {\n                result = append(result, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    return result\n}\n", "    var result\
    \ [][]interface{}\n    for i, row := range lst {\n        for j, e := range row\
    \ {\n            if e == x {\n                result = append(result, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    return result\n}\n", "    var result\
    \ [][]interface{}\n    var aux []interface{}\n    for i, row := range lst {\n\
    \        aux = nil\n        for j, number := range row {\n            if number\
    \ == x {\n                aux = append(aux, j)\n            }\n        }\n   \
    \     for k := len(aux) - 1; k >= 0; k-- {\n            result = append(result,\
    \ []interface{}{i, aux[k]})\n        }\n    }\n    return result\n}\n", "    res\
    \ := [][]interface{}{}\n    for i, row := range lst {\n        for j, item :=\
    \ range row {\n            if item == x {\n                res = append(res, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    return res\n}\n", "    // your code\
    \ here\n    return [][]interface{}{}\n}\n", "    res := [][]interface{}{}\n  \
    \  for i, row := range lst {\n        for j, elem := range row {\n           \
    \ if elem == x {\n                res = append(res, []interface{}{i, j})\n   \
    \         }\n        }\n    }\n    return res\n}\n", "    var result [][]interface{}\n\
    \    for i, v := range lst {\n        for j, v2 := range v {\n            if v2\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n", "    var res [][]interface{}\n\
    \    for i, row := range lst {\n        res = append(res, make([]interface{},\
    \ 2)...)\n        res[i][0] = i\n        for j, val := range row {\n         \
    \   if val == x {\n                res[i][1] = j\n            }\n        }\n \
    \   }\n    return res\n}\n", "    fmt.Println(lst)\n    var res [][]interface{}\n\
    \    for i, v := range lst {\n        for i2, v2 := range v {\n            if\
    \ v2 == x {\n                res = append(res, []interface{}{i, i2})\n       \
    \     }\n        }\n    }\n    return res\n}\n", "    var r [][]interface{}\n\
    \    for i, row := range lst {\n        for j, col := range row {\n          \
    \  if col == x {\n                r = append(r, []interface{}{i, j})\n       \
    \     }\n        }\n    }\n    return r\n}\n", "    var ret [][]interface{}\n\
    \    for i, row := range lst {\n        for j, e := range row {\n            if\
    \ e == x {\n                ret = append(ret, []interface{}{i, j})\n         \
    \   }\n        }\n    }\n    return ret\n}\n", "    res := [][]interface{}{}\n\
    \    for i, row := range lst {\n        for j, item := range row {\n         \
    \   if item == x {\n                res = append(res, []interface{}{i, j})\n \
    \           }\n        }\n    }\n    return res\n}\n\ntype testCase ", "    var\
    \ result [][]interface{}\n    for row, cols := range lst {\n        for col, num\
    \ := range cols {\n            if num == x {\n                result = append(result,\
    \ []interface{}{row, col})\n            }\n        }\n    }\n    return result\n\
    }\n", "    result := make([][]interface{}, 0)\n    for i, row := range lst {\n\
    \        for j, e := range row {\n            if e == x {\n                result\
    \ = append(result, []interface{}{i, j})\n            }\n        }\n    }\n   \
    \ return result\n}\n", "    // YOUR CODE HERE\n    var coordinate [][]interface{}\n\
    \    for i, row := range lst {\n        for j, col := range row {\n          \
    \  if col == x {\n                coordinate = append(coordinate, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    for i := len(coordinate) - 1; i >\
    \ 0; i-- {\n        for j := 0; j < i; j++ {\n            if coordinate[j][0].(int)\
    \ == coordinate[j+1][0].(int) {\n                if coordinate[j][1].(int) < coordinate[j+1][1].(int)\
    \ {\n                    coordinate[j], coordinate[j+1] = coordinate[j+1], coordinate[j]\n\
    \                }\n            } else if coordinate[j][0].(int) > coordinate[j+1][0].(int)\
    \ {\n                coordinate[j], coordinate[j+1] = coordinate[j+1], coordinate[j]\n\
    \            }\n        }\n    }\n    return coordinate\n}\n", "    var result\
    \ [][]interface{}\n    for i, ls := range lst {\n        for j, l := range ls\
    \ {\n            if l == x {\n                result = append(result, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    return result\n}\n", "    result :=\
    \ make([][]interface{}, 0)\n    for i, val := range lst {\n        for j, x :=\
    \ range val {\n            if x == x {\n                result = append(result,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return result\n}\n",
  "    // your code here\n    fmt.Println(lst)\n    return nil\n}\n", "    var ret\
    \ [][]interface{}\n    for idx, row := range lst {\n        for i, item := range\
    \ row {\n            if item == x {\n                ret = append(ret, []interface{}{idx,\
    \ i})\n            }\n        }\n    }\n    sort.Slice(ret, func(i, j int) bool\
    \ {\n        if ret[i][0].(int) == ret[j][0].(int) {\n            return ret[i][1].(int)\
    \ > ret[j][1].(int)\n        }\n        return ret[i][0].(int) < ret[j][0].(int)\n\
    \    })\n    return ret\n}\n", "    var res [][]interface{}\n    for i, n := range\
    \ lst {\n        for j, m := range n {\n            if m == x {\n            \
    \    res = append(res, []interface{}{i, j})\n            }\n        }\n    }\n\
    \    return res\n}\n", "    var result [][]interface{}\n    for row_num, row :=\
    \ range lst {\n        for col_num, item := range row {\n            if item ==\
    \ x {\n                result = append(result, []interface{}{row_num, col_num})\n\
    \            }\n        }\n    }\n    return result\n}\n", "    result := make([][]interface{},\
    \ 0)\n    if len(lst) == 0 {\n        return result\n    }\n    for row, rows\
    \ := range lst {\n        for col, cols := range rows {\n            if cols ==\
    \ x {\n                result = append(result, []interface{}{row, col})\n    \
    \        }\n        }\n    }\n    return result\n}\n", "    result := make([][]interface{},\
    \ 0)\n    for i, row := range lst {\n        for j, value := range row {\n   \
    \         if value == x {\n                result = append(result, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    return result\n}\n", "    // if len(lst)\
    \ == 0 {\n    //     return make([][]interface{}, 0)\n    // }\n    // var ret\
    \ [][]interface{}\n    // for i, row := range lst {\n    //     for j, cell :=\
    \ range row {\n    //         if cell == x {\n    //             ret = append(ret,\
    \ []interface{}{i, j})\n    //         }\n    //     }\n    // }\n    // return\
    \ ret\n    if len(lst) == 0 {\n        return make([][]interface{}, 0)\n    }\n\
    \    var ret [][]interface{}\n    for i, row := range lst {\n        for j, cell\
    \ := range row {\n            if cell == x {\n                ret = append(ret,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return ret\n}\n",
  "    var res [][]interface{}\n    for i, row := range lst {\n        for j, _ :=\
    \ range row {\n            if row[j] == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n",
  "    result := make([][]interface{}, 0)\n    for i, row := range lst {\n       \
    \ for j, el := range row {\n            if el == x {\n                result =\
    \ append(result, []interface{}{i, j})\n            }\n        }\n    }\n    return\
    \ result\n}\n", "    // your code here\n    if len(lst) == 0 {\n        return\
    \ [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        if len(lst[0]) ==\
    \ 0 {\n            return [][]interface{}{}\n        }\n    }\n    var dt [][]interface{}\n\
    \    for i, _ := range lst {\n        for j, val := range lst[i] {\n         \
    \   if val == x {\n                dt = append(dt, []interface{}{i, j})\n    \
    \        }\n        }\n    }\n    return dt\n}\n", "    var res [][]interface{}\n\
    \    for i, row := range lst {\n        for j, elem := range row {\n         \
    \   if elem == x {\n                res = append(res, []interface{}{i, j})\n \
    \           }\n        }\n    }\n    return res\n}\n", "    // Your code here\n\
    \    return nil\n}\n", "    result := make([][]interface{}, 0)\n    for i, v :=\
    \ range lst {\n        for j, w := range v {\n            if w == x {\n      \
    \          result = append(result, []interface{}{i, j})\n            }\n     \
    \   }\n    }\n    // Inverse the result slice\n    for i, j := 0, len(result)-1;\
    \ i < j; i, j = i+1, j-1 {\n        result[i], result[j] = result[j], result[i]\n\
    \    }\n    return result\n}\n", "    var result [][]interface{}\n    for row\
    \ := 0; row < len(lst); row++ {\n        for col := 0; col < len(lst[row]); col++\
    \ {\n            if lst[row][col] == x {\n                result = append(result,\
    \ []interface{}{row, col})\n            }\n        }\n    }\n    return result\n\
    }\n", "    result := make([][]interface{}, 0)\n    for i, arr := range lst {\n\
    \        for j, val := range arr {\n            if val == x {\n              \
    \  result = append(result, []interface{}{i, j})\n            }\n        }\n  \
    \  }\n    return result\n}\n", "    var result [][]interface{}\n    for i, val\
    \ := range lst {\n        for j, el := range val {\n            if el == x {\n\
    \                result = append(result, []interface{}{i, j})\n            }\n\
    \        }\n    }\n    return result\n}\n", "    r := [][]interface{}{}\n    for\
    \ i, row := range lst {\n        for j, val := range row {\n            if val\
    \ == x {\n                r = append(r, []interface{}{i, j})\n            }\n\
    \        }\n    }\n    return r\n}\n", "    fmt.Println(len(lst))\n    fmt.Println(len(lst[0]))\n\
    \    var res [][]interface{}\n    for i := 0; i < len(lst); i++ {\n        for\
    \ j := 0; j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n          \
    \      res = append(res, []interface{}{i, j})\n            }\n        }\n    }\n\
    \    return res\n}\n", "    var result [][]interface{}\n    for idx, row := range\
    \ lst {\n        for i, e := range row {\n            if e == x {\n          \
    \      result = append(result, []interface{}{idx, i})\n            }\n       \
    \ }\n    }\n    return result\n}\n", "    size := len(lst)\n    res := make([][]interface{},\
    \ 0)\n    for i := 0; i < size; i++ {\n        l_size := len(lst[i])\n       \
    \ for j := 0; j < l_size; j++ {\n            if lst[i][j] == x {\n           \
    \     res = append(res, []interface{}{i, j})\n            }\n        }\n    }\n\
    \    return res\n}\n", "    var result [][]interface{}\n    for r, row := range\
    \ lst {\n        for c, value := range row {\n            if value == x {\n  \
    \              result = append(result, []interface{}{r, c})\n            }\n \
    \       }\n    }\n    return result\n}\n", "    res := [][]interface{}{}\n   \
    \ for i, row := range lst {\n        for j, col := range row {\n            if\
    \ col == x {\n                res = append(res, []interface{}{i, j})\n       \
    \     }\n        }\n    }\n    return res\n}\n", "    var xs [][]interface{}\n\
    \    for i, x1 := range lst {\n        for j, x2 := range x1 {\n            if\
    \ x2 == x {\n                xs = append(xs, []interface{}{i, j})\n          \
    \  }\n        }\n    }\n    return xs\n}\n", "    if len(lst) == 0 {\n       \
    \ return [][]interface{}{}\n    }\n    if len(lst) == 1 {\n        return [][]interface{}{}\n\
    \    }\n    rows := make([][]interface{}, 0)\n    for i, r := range lst {\n  \
    \      if len(r) > 0 {\n            for j, _ := range r {\n                if\
    \ r[j] == x {\n                    rows = append(rows, []interface{}{i, j})\n\
    \                }\n            }\n        }\n    }\n    return rows\n}\n", " \
    \   var y []interface{}\n    var result [][]interface{}\n    for i, v := range\
    \ lst {\n        for n, w := range v {\n            if w == x {\n            \
    \    y = append(y, i, n)\n                result = append(result, y)\n       \
    \         y = []interface{}{}\n            }\n        }\n    }\n    fmt.Println(result)\n\
    \    return result\n}\n", "    var res [][]interface{}\n    for i, row := range\
    \ lst {\n        for j, col := range row {\n            if col == x {\n      \
    \          res = append(res, []interface{}{i, j})\n            }\n        }\n\
    \    }\n    return res\n}\n", "    result := make([][]interface{}, 0)\n    for\
    \ i, row := range lst {\n        for j, item := range row {\n            if item\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n", "    res := [][]interface{}{}\n\
    \    for i, r := range lst {\n        for j, c := range r {\n            if c\
    \ == x {\n                res = append(res, []interface{}{i, j})\n           \
    \ }\n        }\n    }\n    return res\n}\n", "    var res [][]interface{}\n  \
    \  for i, _ := range lst {\n        for j, _ := range lst[i] {\n            if\
    \ lst[i][j] == x {\n                res = append(res, []interface{}{i, j})\n \
    \           }\n        }\n    }\n    for i := 0; i < len(res) - 1; i++ {\n   \
    \     for j := i + 1; j < len(res); j++ {\n            if res[i][0].(int) > res[j][0].(int)\
    \ {\n                tmp := res[i]\n                res[i] = res[j]\n        \
    \        res[j] = tmp\n            } else if res[i][0].(int) == res[j][0].(int)\
    \ {\n                if res[i][1].(int) < res[j][1].(int) {\n                \
    \    tmp := res[i]\n                    res[i] = res[j]\n                    res[j]\
    \ = tmp\n                }\n            }\n        }\n    }\n    return res\n\
    }\n", "    var result [][]interface{}\n    for y, row := range lst {\n       \
    \ for x2, v := range row {\n            if v == x {\n                result =\
    \ append(result, []interface{}{y, x2})\n            }\n        }\n    }\n    for\
    \ i := 0; i < len(result); i++ {\n        for j := i + 1; j < len(result); j++\
    \ {\n            a := result[i]\n            b := result[j]\n            if a[0].(int)\
    \ > b[0].(int) {\n                result[i] = b\n                result[j] = a\n\
    \            } else if a[0].(int) == b[0].(int) && a[1].(int) < b[1].(int) {\n\
    \                result[i] = b\n                result[j] = a\n            }\n\
    \        }\n    }\n    return result\n}\n", "    var result [][]interface{}\n\
    \    for i, r := range lst {\n        for j, c := range r {\n            if c\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n", "    var res [][]interface{}\n\
    \    for i, row := range lst {\n        for j, val := range row {\n          \
    \  if val == x {\n                res = append(res, []interface{}{i, j})\n   \
    \         }\n        }\n    }\n    return res\n}\n", "    var results [][]interface{}\n\
    \    for i, row := range lst {\n        for j, num := range row {\n          \
    \  if num == x {\n                results = append(results, []interface{}{i, j})\n\
    \            }\n        }\n    }\n    fmt.Println(results)\n    return results\n\
    }\n", "    var res [][]interface{}\n    for i, el := range lst {\n        for\
    \ j, val := range el {\n            if val == x {\n                res = append(res,\
    \ []interface{}{i, j})\n            }\n        }\n    }\n    return res\n}\n",
  "    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst)\
    \ == 1 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n\
    \        return [][]interface{}{}\n    }\n    if len(lst[1]) == 0 {\n        return\
    \ [][]interface{}{}\n    }\n    coords := [][]interface{}{}\n    for i, _ := range\
    \ lst {\n        for j, _ := range lst[i] {\n            if lst[i][j] == x {\n\
    \                coord := []interface{}{}\n                coord = append(coord,\
    \ i)\n                coord = append(coord, j)\n                coords = append(coords,\
    \ coord)\n            }\n        }\n    }\n    if len(coords) == 0 {\n       \
    \ return [][]interface{}{}\n    }\n    if len(coords) == 1 {\n        return coords\n\
    \    }\n    for i, _ := range coords {\n        for j, _ := range coords {\n \
    \           if coords[i][0].(int) < coords[j][0].(int) {\n                temp\
    \ := coords[i]\n                coords[i] = coords[j]\n                coords[j]\
    \ = temp\n            }\n        }\n    }\n    if len(coords) == 2 {\n       \
    \ return coords\n    }\n    for i, _ := range coords {\n        for j, _ := range\
    \ coords {\n            if coords[i][0].(int) == coords[j][0].(int) {\n      \
    \          if coords[i][1].(int) > coords[j][1].(int) {\n                    temp\
    \ := coords[i]\n                    coords[i] = coords[j]\n                  \
    \  coords[j] = temp\n                }\n            }\n        }\n    }\n    return\
    \ coords\n}\n", "    var res [][]interface{}\n    for i, row := range lst {\n\
    \        for j, num := range row {\n            if num == x {\n              \
    \  res = append(res, []interface{}{i, j})\n            }\n        }\n    }\n \
    \   sort.Slice(res, func(i, j int) bool {\n        return res[i][0].(int) < res[j][0].(int)\n\
    \    })\n    sort.Slice(res, func(i, j int) bool {\n        return res[i][1].(int)\
    \ > res[j][1].(int)\n    })\n    return res\n}\n", "    coordinates := [][]interface{}{}\n\
    \    for i, row := range lst {\n        for j, element := range row {\n      \
    \      if element == x {\n                coordinates = append(coordinates, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    return coordinates\n}\n", "    res\
    \ := [][]interface{}{}\n    for i, row := range lst {\n        for j, elem :=\
    \ range row {\n            if elem == x {\n                res = append(res, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    return res\n}\n", "    result := make([][]interface{},\
    \ 0)\n    for i, rows := range lst {\n        for j, cols := range rows {\n  \
    \          if cols == x {\n                result = append(result, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    return result\n}\n", "    var result\
    \ [][]interface{}\n    for row, i := range lst {\n        for column, j := range\
    \ i {\n            if j == x {\n                var item []interface{}\n     \
    \           item = append(item, row)\n                item = append(item, column)\n\
    \                result = append(result, item)\n            }\n        }\n   \
    \ }\n    return result\n}\n", "    var result [][]interface{}\n    for row, xs\
    \ := range lst {\n        for col, n := range xs {\n            if n == x {\n\
    \                result = append(result, []interface{}{row, col})\n          \
    \  }\n        }\n    }\n    return result\n}\n", "    result := make([][]interface{},\
    \ 0)\n    for i, xs := range lst {\n        for j, y := range xs {\n         \
    \   if y == x {\n                result = append(result, []interface{}{i, j})\n\
    \            }\n        }\n    }\n    return result\n}\n", "    var result [][]interface{}\n\
    \    for i, v := range lst {\n        for j, e := range v {\n            if e\
    \ == x {\n                result = append(result, []interface{}{i, j})\n     \
    \       }\n        }\n    }\n    return result\n}\n", "    row_len := len(lst)\n\
    \    result := make([][]interface{}, 0)\n    for row := 0; row < row_len; row++\
    \ {\n        for col := 0; col < len(lst[row]); col++ {\n            if lst[row][col]\
    \ == x {\n                result = append(result, []interface{}{row, col})\n \
    \           }\n        }\n    }\n    for i := 0; i < len(result); i++ {\n    \
    \    for j := i + 1; j < len(result); j++ {\n            if result[i][0].(int)\
    \ > result[j][0].(int) {\n                result[i], result[j] = result[j], result[i]\n\
    \            } else if result[i][0].(int) == result[j][0].(int) {\n          \
    \      if result[i][1].(int) < result[j][1].(int) {\n                    result[i],\
    \ result[j] = result[j], result[i]\n                }\n            }\n       \
    \ }\n    }\n    return result\n}\n", "    var re_list [][]interface{}\n    for\
    \ i, v := range lst {\n        for j, n := range v {\n            if n == x {\n\
    \                re_list = append(re_list, []interface{}{i, j})\n            }\n\
    \        }\n    }\n    return re_list\n}\n", "    var res [][]interface{}\n  \
    \  for i, row := range lst {\n        for j, e := range row {\n            if\
    \ e == x {\n                res = append(res, []interface{}{i, j})\n         \
    \   }\n        }\n    }\n    return res\n}\n", "    var res [][]interface{}\n\
    \    for i, row := range lst {\n        for j, item := range row {\n         \
    \   if item == x {\n                res = append(res, []interface{}{i, j})\n \
    \           }\n        }\n    }\n    sort.Slice(res, func(i, j int) bool {\n \
    \       if res[i][0].(int) == res[j][0].(int) {\n            return res[i][1].(int)\
    \ > res[j][1].(int)\n        }\n        return res[i][0].(int) < res[j][0].(int)\n\
    \    })\n    return res\n}\n", "    var (\n        result [][]interface{}\n  \
    \      tmp    []interface{}\n    )\n    for i, r := range lst {\n        for j,\
    \ c := range r {\n            if c == x {\n                tmp = []interface{}{i,\
    \ j}\n                result = append(result, tmp)\n            }\n        }\n\
    \    }\n    return result\n}\n", "    row := [][]interface{}{}\n    if len(lst)\
    \ > 0 {\n        for i, v := range lst {\n            for j, v2 := range v {\n\
    \                if v2 == x {\n                    row = append(row, []interface{}{i,\
    \ j})\n                }\n            }\n        }\n    }\n    return row\n}\n",
  "    if len(lst) == 0 {\n        return [][]interface{}{}\n    }\n    if len(lst)\
    \ == 1 {\n        return [][]interface{}{}\n    }\n    if len(lst[0]) == 0 {\n\
    \        return [][]interface{}{}\n    }\n    res := [][]interface{}{}\n    for\
    \ i, list := range lst {\n        for j, elem := range list {\n            if\
    \ elem == x {\n                res = append(res, []interface{}{i, j})\n      \
    \      }\n        }\n    }\n    return res\n}\n", "    var res [][]interface{}\n\
    \    for i, row := range lst {\n        for j, val := range row {\n          \
    \  if val == x {\n                res = append(res, []interface{}{i, j})\n   \
    \         }\n        }\n    }\n    return res\n}\n", "    var ret = make([][]interface{},\
    \ 0)\n    for idx, row := range lst {\n        for i, col := range row {\n   \
    \         if col == x {\n                var temp []interface{}\n            \
    \    temp = append(temp, idx)\n                temp = append(temp, i)\n      \
    \          ret = append(ret, temp)\n            }\n        }\n    }\n    return\
    \ ret\n}\n", "    var result [][]interface{}\n    for i, row := range lst {\n\
    \        if i > 0 {\n            result = append(result, result[i-1])\n      \
    \  }\n        for j, col := range row {\n            if col == x {\n         \
    \       result[i] = append(result[i], i, j)\n            }\n        }\n    }\n\
    \    return result\n}\n", "    return [][]interface{}{}\n}\n", "    var result\
    \ [][]interface{}\n    for i, row := range lst {\n        for j, val := range\
    \ row {\n            if val == x {\n                result = append(result, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    return result\n}\n", "    res := [][]interface{}{}\n\
    \    return res\n}\n", "    if len(lst) == 0 {\n        return [][]interface{}{}\n\
    \    }\n    length := len(lst)\n    coords := make([][]interface{}, 0)\n    for\
    \ i := 0; i < length; i++ {\n        row := lst[i]\n        if len(row) == 0 {\n\
    \            continue\n        }\n        for j := 0; j < len(row); j++ {\n  \
    \          if row[j] == x {\n                coords = append(coords, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    sort_interface(coords)\n    return\
    \ coords\n}\n", "    res := [][]interface{}{}\n    for y, r := range lst {\n \
    \       for z, c := range r {\n            if c == x {\n                res =\
    \ append(res, []interface{}{y, z})\n            }\n        }\n    }\n    return\
    \ res\n}\n", "    result := make([][]interface{}, 0)\n    for i, v := range lst\
    \ {\n        for j, v1 := range v {\n            if v1 == x {\n              \
    \  result = append(result, []interface{}{i, j})\n            }\n        }\n  \
    \  }\n    return result\n}\n", "    var result [][]interface{}\n    for i, row\
    \ := range lst {\n        for j, col := range row {\n            if col == x {\n\
    \                result = append(result, []interface{}{i, j})\n            }\n\
    \        }\n    }\n    return result\n}\n", "    var result [][]interface{}\n\
    \    var rowLen int\n    for idx, row := range lst {\n        rowLen = len(row)\n\
    \        for i := 0; i < rowLen; i++ {\n            if row[i] == x {\n       \
    \         result = append(result, []interface{}{idx, i})\n            }\n    \
    \    }\n    }\n    return result\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
