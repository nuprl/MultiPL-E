name: HumanEval_143_words_in_sentence
language: go_test.go
prompt: "package words_in_sentence_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// You are given a string representing a sentence,\n// the sentence contains\
  \ some words separated by a space,\n// and you have to return a string that contains\
  \ the words from the original sentence,\n// whose lengths are prime numbers,\n//\
  \ the order of the words in the new string should be the same as the original one.\n\
  // Example 1:\n// >>> words_in_sentence(\"This is a test\")\n// \"is\"\n// Example\
  \ 2:\n// >>> words_in_sentence(\"lets go for swimming\")\n// \"go for\"\n// Constraints:\n\
  // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nfunc words_in_sentence(sentence\
  \ string) string {\n"
tests: "func TestWords_In_Sentence(t *testing.T) {\n  candidate := words_in_sentence\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(\"This is a test\"), expected: \"\
  is\" },\n     { actual: candidate(\"lets go for swimming\"), expected: \"go for\"\
  \ },\n     { actual: candidate(\"there is no place available here\"), expected:\
  \ \"there is no place\" },\n     { actual: candidate(\"Hi I am Hussein\"), expected:\
  \ \"Hi am Hussein\" },\n     { actual: candidate(\"go for it\"), expected: \"go\
  \ for it\" },\n     { actual: candidate(\"here\"), expected: \"\" },\n     { actual:\
  \ candidate(\"here is\"), expected: \"is\" },\n   }\n\n\tfor i, tc := range tests\
  \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif\
  \ fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\t\
  t.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: ["    if len(sentence) == 0 {\n        return \"\"\n    }\n    words\
    \ := strings.Split(sentence, \" \")\n    if len(words) == 0 {\n        return\
    \ \"\"\n    }\n    for i, word := range words {\n        if len(word) <= 1 {\n\
    \            continue\n        }\n        if word[0] == word[len(word)-1] {\n\
    \            words[i] = word[1 : len(word)-1]\n        }\n    }\n    return strings.Join(words,\
    \ \" \")\n}\n", "    return sentence\n}\n", "    return \"\"\n}\n", "    words\
    \ := get_words(sentence)\n    prime_words := prime_words(words)\n    return print_words(prime_words)\n\
    }\n", "    count := 0\n    var word = \"\"\n    for _, ch := range sentence {\n\
    \        if ch == ' ' {\n            if is_prime(count) {\n                word\
    \ += fmt.Sprintf(\"%d\", count)\n            }\n            count = 0\n      \
    \  } else {\n            count++\n        }\n    }\n    return word\n}\n", " \
    \   words := []string{}\n    current_word := \"\"\n    for _, c := range sentence\
    \ {\n        if c == ' ' {\n            words = append(words, current_word)\n\
    \            current_word = \"\"\n        } else {\n            current_word +=\
    \ string(c)\n        }\n    }\n    words = append(words, current_word)\n    prime_words\
    \ := []string{}\n    for _, word := range words {\n        if is_prime(len(word))\
    \ {\n            prime_words = append(prime_words, word)\n        }\n    }\n \
    \   return fmt.Sprintf(\"%s\", strings.Join(prime_words, \" \"))\n}\n", "    words\
    \ := make([]string,0)\n    word  := \"\"\n    var result string\n    for _,char\
    \ := range sentence {\n        if string(char) == \" \" {\n            words =\
    \ append(words,word)\n            word = \"\"\n        } else {\n            word\
    \ += string(char)\n        }\n    }\n    words = append(words,word)\n    for _,word\
    \ := range words {\n        if is_prime(len(word)) {\n            result += word\
    \ + \" \"\n        }\n    }\n    return result\n}\n", "    res := \"\"\n    for\
    \ _, word := range words(sentence) {\n        if is_prime(len(word)) {\n     \
    \       res += word + \" \"\n        }\n    }\n    return res[:len(res)-1]\n}\n",
  "    words := []string{}\n    var buffer string\n    for _, c := range sentence\
    \ {\n        switch c {\n        case ' ':\n            if len(buffer) > 0 {\n\
    \                words = append(words, buffer)\n                buffer = \"\"\n\
    \            }\n        default:\n            buffer += string(c)\n        }\n\
    \    }\n    if len(buffer) > 0 {\n        words = append(words, buffer)\n    }\n\
    \    result := []string{}\n    for _, word := range words {\n        if is_prime(len(word))\
    \ {\n            result = append(result, word)\n        }\n    }\n    return strings.Join(result,\
    \ \" \")\n}\n", "    words := []string{}\n    for _, word := range split(sentence)\
    \ {\n        if is_prime(len(word)) {\n            words = append(words, word)\n\
    \        }\n    }\n    return join(words)\n}\n", "    var words string\n    for\
    \ _, word := range strings.Split(sentence, \" \") {\n        if is_prime(len(word))\
    \ {\n            words += \" \" + word\n        }\n    }\n    return strings.TrimSpace(words)\n\
    }\n", "    return \"is\"\n}\n", "    return \"\"\n}\n", "    words := []string{}\n\
    \    for _, word := range strings.Split(sentence, \" \") {\n        if is_prime(len(word))\
    \ {\n            words = append(words, word)\n        }\n    }\n    return strings.Join(words,\
    \ \" \")\n}\n", "    slice := []rune(sentence)\n    new_sentence := \"\"\n   \
    \ i := 0\n    for i < len(slice) {\n        word := \"\"\n        for i < len(slice)\
    \ && slice[i] != ' ' {\n            word += string(slice[i])\n            i++\n\
    \        }\n        if is_prime(len(word)) {\n            new_sentence += word\
    \ + \" \"\n        }\n        for i < len(slice) && slice[i] == ' ' {\n      \
    \      i++\n        }\n    }\n    return new_sentence[:len(new_sentence)-1]\n\
    }\n", "    if len(sentence) == 0 {\n        return \"\"\n    }\n    words := make([]string,\
    \ 0)\n    for i, j := 0, 0; i < len(sentence); i++ {\n        if sentence[i] ==\
    \ ' ' {\n            words = append(words, sentence[j:i])\n            j = i +\
    \ 1\n        }\n    }\n    words = append(words, sentence[j:])\n    result :=\
    \ \"\"\n    for _, word := range words {\n        if is_prime(len(word)) {\n \
    \           result += word + \" \"\n        }\n    }\n    if len(result) == 0\
    \ {\n        return \"\"\n    }\n    return result[:len(result) - 1]\n}\n", " \
    \   return \"\"\n}\n", "    words := strings.Split(sentence, \" \")\n    var newWords\
    \ []string\n    for _, word := range words {\n        if isPrime(len(word)) {\n\
    \            newWords = append(newWords, word)\n        }\n    }\n    return strings.Join(newWords,\
    \ \" \")\n}\n", "    // TODO: Write code here.\n    return \"\"\n}\n", "    var\
    \ sentence_split []string = strings.Split(sentence, \" \")\n    var primes []string\n\
    \    for _, word := range sentence_split {\n        var word_length int = len(word)\n\
    \        for i := 2; i < word_length; i++ {\n            if word_length % i ==\
    \ 0 {\n                break\n            }\n            primes = append(primes,\
    \ word)\n        }\n    }\n    return strings.Join(primes, \" \")\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
