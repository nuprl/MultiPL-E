name: HumanEval_79_decimal_to_binary
language: go_test.go
prompt: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n\
  )\n\n// You will be given a number in decimal form and your task is to convert it\
  \ to\n// binary format. The function should return a string, with each character\
  \ representing a binary\n// number. Each character in the string will be '0' or\
  \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
  \ at the end of the string.\n// The extra characters are there to help with the\
  \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>> decimal_to_binary(32)\n\
  // \"db100000db\"\nfunc decimal_to_binary(decimal int) string {\n"
tests: "func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n    \
  \ { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
  \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
  \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
  , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    var ret string = \"db\"\n    var res int\n    var rem int\n   \
    \ for decimal > 0 {\n        res = decimal / 2\n        rem = decimal % 2\n  \
    \      decimal = res\n        ret += fmt.Sprintf(\"%d\", rem)\n    }\n    return\
    \ ret + \"db\"\n}\n", "    if decimal == 0 {\n        return \"db0db\"\n    }\n\
    \    var result []string\n    for decimal > 0 {\n        m := decimal % 2\n  \
    \      decimal = decimal / 2\n        result = append(result, fmt.Sprintf(\"%d\"\
    , m))\n    }\n    return \"db\" + reverse(result) + \"db\"\n}\n", "    return\
    \ fmt.Sprintf(\"db%db\", fmt.Sprintf(\"%b\", decimal))\n}\n", "\t// Your code\
    \ here\n\treturn \"\"\n}\n", "    // get mod 2 and append to string, repeat until\
    \ 0\n    var binary string\n    binary = \"db\"\n    for decimal != 0 {\n    \
    \    if decimal % 2 == 0 {\n            binary = \"0\" + binary\n        } else\
    \ {\n            binary = \"1\" + binary\n        }\n        decimal = decimal\
    \ / 2\n    }\n    binary = binary + \"db\"\n    return binary\n}\n", "    return\
    \ fmt.Sprintf(\"db%bdb\", decimal)\n}\n", "    var result string = \"db\"\n  \
    \  for decimal > 0 {\n        result = string(decimal % 2 + 48) + result\n   \
    \     decimal /= 2\n    }\n    return result + \"db\"\n}\n", "    binary := \"\
    db\"\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%s%d\", binary, decimal\
    \ % 2)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"%sdb\", binary)\n\
    }\n", "    return \"db\" + fmt.Sprintf(\"%b\", decimal) + \"db\"\n}\n", "    //\
    \ START OMIT\n    str := \"db\"\n    for decimal > 0 {\n        r := decimal %\
    \ 2\n        str = fmt.Sprintf(\"%s%d\", str, r)\n        decimal = decimal /\
    \ 2\n    }\n    return str + \"db\"\n    // END OMIT\n}\n", "    // your code\
    \ here\n    return \"\"\n}\n", "    binary := \"db\"\n    for decimal > 0 {\n\
    \        binary = fmt.Sprintf(\"%s%d\", binary, decimal%2)\n        decimal /=\
    \ 2\n    }\n    binary += \"db\"\n    return binary\n}\n", "    var binary_string\
    \ string\n    for decimal > 0 {\n        if decimal % 2 == 0 {\n            binary_string\
    \ = \"0\" + binary_string\n        } else {\n            binary_string = \"1\"\
    \ + binary_string\n        }\n        decimal /= 2\n    }\n    return \"db\" +\
    \ binary_string + \"db\"\n}\n", "    s := \"db\"\n    fmt.Println(s)\n    for\
    \ decimal > 0 {\n        fmt.Println(decimal)\n        r := decimal % 2\n    \
    \    fmt.Println(r)\n        s = fmt.Sprintf(\"%d%s\", r, s)\n        fmt.Println(s)\n\
    \        decimal = decimal / 2\n    }\n    s = s + \"db\"\n    return s\n}\n",
  "    return fmt.Sprintf(\"db%db\", \"%b\")\n}\n", "    if decimal == 0 {\n     \
    \   return \"db0db\"\n    }\n    binary := \"\"\n    for decimal > 0 {\n     \
    \   binary = fmt.Sprintf(\"%v%v\", decimal % 2, binary)\n        decimal /= 2\n\
    \    }\n    return fmt.Sprintf(\"db%vdb\", binary)\n}\n", "\tstr := \"\"\n\tif\
    \ decimal == 0 {\n\t\treturn \"db0db\"\n\t}\n\tfor i := decimal; i > 0; i /= 2\
    \ {\n\t\tif i%2 == 0 {\n\t\t\tstr = \"0\" + str\n\t\t} else {\n\t\t\tstr = \"\
    1\" + str\n\t\t}\n\t}\n\treturn \"db\" + str + \"db\"\n}\n", "    str := \"\"\n\
    \    for decimal > 0 {\n        str = fmt.Sprintf(\"%d%s\", decimal % 2, str)\n\
    \        decimal /= 2\n    }\n    return fmt.Sprintf(\"db%sdb\", str)\n}\n", " \
    \   var binary string\n    for decimal > 0 {\n        if decimal % 2 == 0 {\n\
    \            binary = \"0\" + binary\n        } else {\n            binary = \"\
    1\" + binary\n        }\n        decimal /= 2\n    }\n    return \"db\" + binary\
    \ + \"db\"\n}\n", "    // first convert the integer to a string representation\
    \ of it's binary\n    s := \"\"\n    for decimal != 0 {\n        s = fmt.Sprintf(\"\
    %d%s\", decimal % 2, s)\n        decimal /= 2\n    }\n    // now add the prefix\
    \ and suffix\n    return fmt.Sprintf(\"db%sdb\", s)\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
