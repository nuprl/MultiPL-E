language: go_test.go
name: HumanEval_61_correct_bracketing
results:
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := 0\n    for _, char := range brackets {\n      \
    \  if char == '(' {\n            stack += 1\n        } else if char == ')' {\n\
    \            stack -= 1\n        }\n        if stack < 0 {\n            return\
    \ false\n        }\n    }\n    return stack == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073923
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var open, closed int\n    for _, b := range brackets {\n\
    \        if b == '(' {\n            open++\n        } else {\n            closed++\n\
    \        }\n        if closed > open {\n            return false\n        }\n\
    \    }\n    return open == closed\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073923
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, c := range brackets {\n        if\
    \ c == '(' {\n            count++\n        } else if c == ')' {\n            count--\n\
    \        }\n        if count < 0 {\n            return false\n        }\n    }\n\
    \    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073736
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n\tcount := 0\n\tfor _, c := range brackets {\n\t\tif c == '('\
    \ {\n\t\t\tcount++\n\t\t} else if c == ')' {\n\t\t\tcount--\n\t\t}\n\t\tif count\
    \ < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn count == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.006s\n"
  timestamp: 1660073923
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var i, bCount int\n    for i, bCount = 0, 0; i < len(brackets);\
    \ i++ {\n        if brackets[i] == '(' {\n            bCount++\n        } else\
    \ {\n            bCount--\n        }\n        if bCount < 0 {\n            return\
    \ false\n        }\n    }\n    return bCount == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073923
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    balance := 0\n    for _, r := range brackets {\n       \
    \ if r == '(' {\n            balance += 1\n        } else if r == ')' {\n    \
    \        balance -= 1\n        }\n        if balance < 0 {\n            return\
    \ false\n        }\n    }\n    return balance == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073923
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, b := range brackets {\n        if\
    \ b == '(' {\n            count += 1\n        } else if b == ')' {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return false\n\
    \        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073923
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, c := range brackets {\n        if\
    \ c == '(' {\n            count += 1\n        } else if c == ')' {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return false\n\
    \        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073923
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    balance := 0\n    for _, c := range brackets {\n       \
    \ if c == '(' {\n            balance += 1\n        } else if c == ')' {\n    \
    \        balance -= 1\n        }\n        if balance < 0 {\n            return\
    \ false\n        }\n    }\n    return balance == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073923
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var c int\n    for _, b := range brackets {\n        if\
    \ b == '(' {\n            c += 1\n        } else {\n            c -= 1\n     \
    \   }\n        if c < 0 {\n            return false\n        }\n    }\n    return\
    \ c == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073923
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // stack to hold opening brackets\n    stk := make([]byte,\
    \ 0)\n    // i is index of next closing bracket\n    i := 0\n    // while i <\
    \ len(brackets)\n    for i < len(brackets) {\n        // if brackets[i] == \"\
    )\"\n        if brackets[i] == ')' {\n            // pop an item from stack\n\
    \            if len(stk) == 0 {\n                return false\n            }\n\
    \            stk = stk[:len(stk)-1]\n        } else {\n            // push \"\
    (\" to stack\n            stk = append(stk, brackets[i])\n        }\n        i++\n\
    \    }\n    // after while, return stack is empty\n    return len(stk) == 0\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073923
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var s []rune\n    var m = map[rune]rune{')': '('}\n    for\
    \ _, r := range brackets {\n        switch r {\n        case '(':\n          \
    \  s = append(s, r)\n        case ')':\n            if len(s) > 0 && s[len(s)-1]\
    \ == m[r] {\n                s = s[:len(s)-1]\n            } else {\n        \
    \        return false\n            }\n        }\n    }\n    return len(s) == 0\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073923
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    balance := 0\n    for _, b := range brackets {\n       \
    \ switch b {\n        case '(':\n            balance += 1\n        case ')':\n\
    \            balance -= 1\n        }\n        if balance < 0 {\n            return\
    \ false\n        }\n    }\n    return balance == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073923
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    counter := 0\n    for _, bracket := range brackets {\n \
    \       switch bracket {\n        case '(':\n            counter += 1\n      \
    \  case ')':\n            counter -= 1\n        }\n        if counter < 0 {\n\
    \            return false\n        }\n    }\n    return counter == 0\n}\n\nfunc\
    \ TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073923
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    //c := 0\n    //for _, bracket := range brackets {\n   \
    \ //    if bracket == '(' {\n    //        c++\n    //    } else {\n    //   \
    \     c--\n    //    }\n    //    if c < 0 {\n    //        return false\n   \
    \ //    }\n    //}\n    //return c == 0\n    stack := []rune{}\n    for _, bracket\
    \ := range brackets {\n        if bracket == '(' {\n            stack = append(stack,\
    \ bracket)\n        } else {\n            stack = stack[:len(stack)-1]\n     \
    \   }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [:-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x514640, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x514640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmpdgw9v10q_test.go:36\n\
    command-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmpdgw9v10q_test.go:53\
    \ +0x15cf\ntesting.tRunner(0xc0000da340, 0x529fc8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073923
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n\treturn false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmp02clf5pn_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp02clf5pn_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmp02clf5pn_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp02clf5pn_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073923
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, bracket := range brackets {\n   \
    \     if bracket == '(' {\n            count++\n        } else if bracket == ')'\
    \ {\n            count--\n        }\n        if count < 0 {\n            return\
    \ false\n        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []rune\n    count := 0\n    for _, bracket :=\
    \ range brackets {\n        if bracket == '(' {\n            stack = append(stack,\
    \ bracket)\n            count += 1\n        } else if bracket == ')' {\n     \
    \       count -= 1\n            if count < 0 {\n                return false\n\
    \            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n \
    \   return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n\
    \  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073923
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // count the number of opening brackets.\n    // an opening\
    \ bracket increments count,\n    // a closing bracket decrements count.\n    //\
    \ if count goes negative, there is no way to correct it with more brackets.\n\
    \    count := 0\n    for _, c := range brackets {\n        if c == '(' {\n   \
    \         count++\n        } else if c == ')' {\n            count--\n       \
    \ } else {\n            panic(\"Should never get here.\")\n        }\n       \
    \ if count < 0 {\n            return false\n        }\n    }\n    // count can\
    \ never be positive at the end.\n    // if count is 0, there are as many closing\
    \ brackets as opening brackets.\n    // if count is negative, there are more closing\
    \ brackets than opening brackets.\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073923
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // balance represents the number of brackets so far.\n \
    \   // If balance is negative, there must be an unmatched closing bracket.\n \
    \   // If balance is zero, there must be no unmatched brackets at all.\n    balance\
    \ := 0\n    for _, b := range brackets {\n        if b == '(' {\n            balance++\n\
    \        } else if b == ')' {\n            balance--\n        }\n        if balance\
    \ < 0 {\n            return false\n        }\n    }\n    return balance == 0\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073923
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []rune\n    for _, br := range brackets {\n  \
    \      if br == '(' {\n            stack = append(stack, br)\n        } else if\
    \ br == ')' {\n            if len(stack) == 0 {\n                return false\n\
    \            }\n            // Assert: stack[-1] == '('\n            stack = stack[:len(stack)-1]\n\
    \        }\n    }\n    if len(stack) == 0 {\n        return true\n    }\n    return\
    \ false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073923
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, char := range brackets {\n      \
    \  if char == '(' {\n            count++\n        } else if char == ')' {\n  \
    \          count--\n        }\n        if count < 0 {\n            return false\n\
    \        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073923
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, b := range brackets {\n        if\
    \ b == '(' {\n            count++\n        } else if b == ')' {\n            count--\n\
    \        }\n        if count < 0 {\n            return false\n        }\n    }\n\
    \    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073736
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    left := 0\n    right := 0\n    for _, b := range brackets\
    \ {\n        if b == '(' {\n            left += 1\n        } else if b == ')'\
    \ {\n            right += 1\n        }\n        if right > left {\n          \
    \  return false\n        }\n    }\n    return left == right\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073923
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []string\n    for _, bracket := range brackets\
    \ {\n        if string(bracket) == \"(\" {\n            stack = append(stack,\
    \ string(bracket))\n        } else {\n            if len(stack) > 0 {\n      \
    \          stack = stack[:len(stack)-1]\n            } else {\n              \
    \  return false\n            }\n        }\n    }\n    return len(stack) == 0\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073923
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    bracket := 0\n    for _, char := range brackets {\n    \
    \    if char == '(' {\n            bracket += 1\n        } else if char == ')'\
    \ {\n            bracket -= 1\n        }\n        if bracket < 0 {\n         \
    \   return false\n        }\n    }\n    return bracket == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073923
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []byte\n    for _, c := range brackets {\n   \
    \     if c == '(' {\n            stack = append(stack, byte(c))\n        } else\
    \ if c == ')' {\n            if len(stack) == 0 {\n                return false\n\
    \            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n \
    \   return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n\
    \  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := []byte{}\n    for _, b := range brackets {\n  \
    \      if b == '(' {\n            stack = append(stack, byte(b))\n        } else\
    \ if b == ')' {\n            if len(stack) == 0 {\n                return false\n\
    \            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n \
    \   return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n\
    \  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.006s\n"
  timestamp: 1660073926
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, bracket := range brackets {\n   \
    \     if bracket == '(' {\n            count += 1\n        } else if bracket ==\
    \ ')' {\n            count -= 1\n        } else {\n            return false\n\
    \        }\n        if count < 0 {\n            return false\n        }\n    }\n\
    \    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073926
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // TODO\n    return false\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpv6tfn38s_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpv6tfn38s_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpv6tfn38s_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpv6tfn38s_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.011s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    n := len(brackets)\n    if n % 2 != 0 {\n        return\
    \ false\n    }\n    // use stack to check brackets\n    stack := make([]rune,\
    \ 0)\n    for _, b := range brackets {\n        if b == '(' {\n            stack\
    \ = append(stack, b)\n        } else {\n            if len(stack) > 0 {\n    \
    \            stack = stack[:len(stack)-1]\n            } else {\n            \
    \    return false\n            }\n        }\n    }\n    if len(stack) == 0 {\n\
    \        return true\n    }\n    return false\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073926
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, c := range brackets {\n        if\
    \ c == '(' {\n            count += 1\n        } else if c == ')' {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return false\n\
    \        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073923
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    open_count := 0\n    for _, b := range brackets {\n    \
    \    if b == '(' {\n            open_count++\n        } else if b == ')' {\n \
    \           open_count--\n        }\n        if open_count < 0 {\n           \
    \ return false\n        }\n    }\n    return open_count == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073926
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := make([]byte, 0)\n    for _, b := range brackets\
    \ {\n        switch b {\n        case '(':\n            stack = append(stack,\
    \ '(')\n        case ')':\n            if len(stack) == 0 {\n                return\
    \ false\n            }\n            stack = stack[:len(stack)-1]\n        }\n\
    \    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073926
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := make([]byte, 0)\n    for _, b := range brackets\
    \ {\n        if b == '(' {\n            stack = append(stack, '(')\n        }\
    \ else if b == ')' {\n            if len(stack) == 0 {\n                return\
    \ false\n            }\n            stack = stack[:len(stack)-1]\n        }\n\
    \    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073926
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := make([]string, 0)\n    for _, bracket := range\
    \ brackets {\n        if string(bracket) == \"(\" {\n            stack = append(stack,\
    \ \"(\")\n        } else {\n            if len(stack) == 0 {\n               \
    \ return false\n            }\n            stack = stack[:len(stack)-1]\n    \
    \    }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073926
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n\t// Your code here (remember to delete the line below)\n  \
    \  return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpiue4esd7_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpiue4esd7_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpiue4esd7_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpiue4esd7_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.009s\nFAIL\n"
  timestamp: 1660073926
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // YOUR CODE HERE\n    // use a stack\n    stack := []string{}\n\
    \    for _, bracket := range brackets {\n        bracketStr := string(bracket)\n\
    \        if bracketStr == \"(\" {\n            stack = append(stack, bracketStr)\n\
    \        } else if bracketStr == \")\" {\n            if len(stack) == 0 {\n \
    \               return false\n            }\n            stack = stack[:len(stack)-1]\n\
    \        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073926
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []rune\n    var bracketMap = map[rune]rune{'(':\
    \ ')', '{': '}', '[': ']'}\n    for _, b := range brackets {\n        if b ==\
    \ '(' || b == '{' || b == '[' {\n            stack = append(stack, b)\n      \
    \  } else {\n            if len(stack) == 0 {\n                return false\n\
    \            }\n            pop := stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n\
    \            if bracketMap[pop] != b {\n                return false\n       \
    \     }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073926
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := make([]string, 0)\n    for _, bracket := range\
    \ brackets {\n        switch string(bracket) {\n        case \"(\":\n        \
    \    stack = append(stack, \"(\")\n        case \")\":\n            if len(stack)\
    \ == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n\
    \        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073926
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if brackets == \"\" {\n        return true\n    }\n\n  \
    \  open_pairs := 0\n    for _, c := range brackets {\n        if c == '(' {\n\
    \            open_pairs++\n        } else if c == ')' {\n            open_pairs--\n\
    \        }\n\n        if open_pairs < 0 {\n            return false\n        }\n\
    \    }\n\n    return open_pairs == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073926
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // TODO\n    return false\n}\n\n//\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmplsi0j68l_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmplsi0j68l_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmplsi0j68l_test.go:48: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmplsi0j68l_test.go:48:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073926
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n\tcount := 0\n\tfor _, b := range brackets {\n\t\tif b == '('\
    \ {\n\t\t\tcount++\n\t\t} else if b == ')' {\n\t\t\tcount--\n\t\t}\n\t\tif count\
    \ < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn count == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.008s\n"
  timestamp: 1660073926
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []string\n    for _, char := range brackets {\n\
    \        switch char {\n        case '(':\n            stack = append(stack, \"\
    (\")\n        case ')':\n            if len(stack) == 0 {\n                return\
    \ false\n            }\n            stack = stack[:len(stack)-1]\n        }\n\
    \    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073926
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, bracket := range brackets {\n   \
    \     if bracket == '(' {\n            count++\n        } else if bracket == ')'\
    \ {\n            count--\n        }\n        if count < 0 {\n            return\
    \ false\n        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // this could be done with a stack, but for the sake of\
    \ simplicity let's just use a counter\n    count := 0\n    for _, c := range brackets\
    \ {\n        if c == '(' {\n            count++\n        } else if c == ')' {\n\
    \            count--\n        }\n        if count < 0 {\n            return false\n\
    \        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.008s\n"
  timestamp: 1660073926
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    cnt := 0\n    for _, b := range brackets {\n        if b\
    \ == '(' {\n            cnt += 1\n        } else if b == ')' {\n            cnt\
    \ -= 1\n        } else {\n            return false\n        }\n        if cnt\
    \ < 0 {\n            return false\n        }\n    }\n    return cnt == 0\n}\n\n\
    func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.008s\n"
  timestamp: 1660073926
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []string\n    for _, bracket := range brackets\
    \ {\n        switch bracket {\n        case '(':\n            stack = append(stack,\
    \ \"(\")\n        case ')':\n            if len(stack) == 0 {\n              \
    \  return false\n            }\n            stack = stack[:len(stack)-1]\n   \
    \     }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073926
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brackets_chars := []rune(brackets)\n    // TODO:\n    return\
    \ false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4ju5dz72_test.go:19:5: brackets_chars declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073925
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for _, char := range brackets {\n        if char == '('\
    \ {\n            brackets = brackets[1:]\n        } else {\n            if len(brackets)\
    \ > 0 {\n                brackets = brackets[:len(brackets)-1]\n            }\
    \ else {\n                return false\n            }\n        }\n    }\n    return\
    \ len(brackets) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmpgorwypf__test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpgorwypf__test.go:57:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmpgorwypf__test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmpgorwypf__test.go:57:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmpgorwypf__test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmpgorwypf__test.go:57:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10\
    \ (0.00s)\n        tmpgorwypf__test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmpgorwypf__test.go:57:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660073926
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []rune\n    var top rune\n    for _, c := range\
    \ brackets {\n        if c == '(' {\n            stack = append(stack, c)\n  \
    \      } else {\n            if len(stack) == 0 {\n                return false\n\
    \            }\n            top = stack[len(stack)-1]\n            if top == '('\
    \ {\n                stack = stack[:len(stack)-1]\n            } else {\n    \
    \            return false\n            }\n        }\n    }\n    if len(stack)\
    \ != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.006s\n"
  timestamp: 1660073926
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []rune = make([]rune, len(brackets))\n    top\
    \ := 0\n\n    for _, b := range brackets {\n        if b == '(' {\n          \
    \  stack[top] = b\n            top += 1\n        } else if b == ')' {\n      \
    \      if top > 0 {\n                top -= 1\n            } else {\n        \
    \        return false\n            }\n        }\n    }\n\n    return top == 0\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.006s\n"
  timestamp: 1660073926
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var counter int\n    for _, c := range brackets {\n    \
    \    if c == '(' {\n            counter++\n        } else if c == ')' {\n    \
    \        counter--\n        }\n        if counter < 0 {\n            return false\n\
    \        }\n    }\n    return counter == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073926
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var bracket_count int = 0\n\n    for _,bracket := range\
    \ brackets {\n        if bracket == '(' {\n            bracket_count++\n     \
    \   } else if bracket == ')' {\n            bracket_count--\n        }\n\n   \
    \     if bracket_count < 0 {\n            return false\n        }\n    }\n\n \
    \   return bracket_count == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073927
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, char := range brackets {\n      \
    \  if char == '(' {\n            count++\n        } else if char == ')' {\n  \
    \          count--\n        } else {\n            panic(\"Invalid character in\
    \ input string.\")\n        }\n        if count < 0 {\n            return false\n\
    \        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073928
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, c := range brackets {\n        if\
    \ c == '(' {\n            count += 1\n        } else if c == ')' {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return false\n\
    \        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073923
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // count the number of opening brackets.\n    var n int\n\
    \    for _, c := range brackets {\n        if c == '(' {\n            n++\n  \
    \      } else if c == ')' {\n            n--\n        }\n        if n < 0 {\n\
    \            return false\n        }\n    }\n    // no opening bracket left.\n\
    \    return n == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073928
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    pairs := 0\n    for _, b := range brackets {\n        switch\
    \ b {\n        case '(':\n            pairs++\n        case ')':\n           \
    \ pairs--\n        }\n        if pairs < 0 {\n            return false\n     \
    \   }\n    }\n    return pairs == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073928
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var brackets_list []rune = []rune(brackets)\n    var open_count\
    \ = 0\n    for _, br := range brackets_list {\n        if br == '(' {\n      \
    \      open_count += 1\n        } else if br == ')' {\n            open_count\
    \ -= 1\n        }\n        if open_count < 0 {\n            return false\n   \
    \     }\n    }\n    return open_count == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073928
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []byte\n    if len(brackets) == 0 {\n        return\
    \ true\n    }\n\n    for _, bracket := range brackets {\n        if len(stack)\
    \ == 0 {\n            stack = append(stack, byte(bracket))\n        } else {\n\
    \            if bracket == ')' && stack[len(stack)-1] == '(' {\n             \
    \   stack = stack[:len(stack)-1]\n            } else {\n                stack\
    \ = append(stack, byte(bracket))\n            }\n        }\n    }\n\n    return\
    \ len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073928
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    balance := 0\n    for _, b := range brackets {\n       \
    \ if b == '(' {\n            balance++\n        } else if b == ')' {\n       \
    \     balance--\n        }\n        if balance < 0 {\n            return false\n\
    \        }\n    }\n    return balance == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073928
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ == '(' {\n            for j := i + 1; j < len(brackets); j++ {\n           \
    \     if brackets[j] == ')' {\n                    if correct_bracketing(brackets[i\
    \ + 1:j]) {\n                        if correct_bracketing(brackets[j + 1:]) {\n\
    \                            return true\n                        }\n        \
    \            }\n                }\n            }\n            return false\n \
    \       }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmpur4epcol_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__8 (0.00s)\n        tmpur4epcol_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__11\
    \ (0.00s)\n        tmpur4epcol_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073928
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := make([]string, 0)\n    for _, ch := range brackets\
    \ {\n        if string(ch) == \"(\" {\n            stack = append(stack, string(ch))\n\
    \        } else {\n            length := len(stack)\n            if length ==\
    \ 0 {\n                return false\n            }\n            if stack[length-1]\
    \ == \"(\" {\n                stack = stack[:length-1]\n            } else {\n\
    \                return false\n            }\n        }\n    }\n    return len(stack)\
    \ == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073928
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := make([]rune, 0)\n    for _, ch := range brackets\
    \ {\n        if ch == '(' {\n            stack = append(stack, ch)\n        }\
    \ else if ch == ')' {\n            if len(stack) == 0 {\n                return\
    \ false\n            }\n            stack = stack[:len(stack)-1]\n        }\n\
    \    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073928
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var counter int\n    for _, r := range brackets {\n    \
    \    if r == '(' {\n            counter++\n        } else if r == ')' {\n    \
    \        counter--\n        }\n        if counter < 0 {\n            return false\n\
    \        }\n    }\n    return counter == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073928
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    n := len(brackets)\n    if n == 0 {\n        return true\n\
    \    }\n    if n == 1 {\n        return false\n    }\n    // Count \"(\"\n   \
    \ count := 0\n    for _, c := range brackets {\n        if c == '(' {\n      \
    \      count++\n        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpw5ld1msq_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpw5ld1msq_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpw5ld1msq_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpw5ld1msq_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073928
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // use an int to keep track of the count of opening brackets.\n\
    \    // when an opening bracket is found, count++\n    // when a closing bracket\
    \ is found, count--\n    // if count < 0, a closing bracket has been found without\
    \ a corresponding opening bracket.\n    // if count > 0, an opening bracket has\
    \ been found without a corresponding closing bracket.\n    // if count == 0, every\
    \ opening bracket has a corresponding closing bracket.\n    count := 0\n    for\
    \ _, b := range brackets {\n        if b == '(' {\n            count++\n     \
    \   } else if b == ')' {\n            count--\n        }\n        if count < 0\
    \ {\n            return false\n        }\n    }\n    return count == 0\n}\n\n\
    func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073928
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // TODO: return true if every opening bracket has a corresponding\
    \ closing bracket.\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpriiknifw_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpriiknifw_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpriiknifw_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpriiknifw_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073928
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    left_brackets := 0\n    right_brackets := 0\n    for _,\
    \ bracket := range brackets {\n        if bracket == '(' {\n            left_brackets\
    \ += 1\n        } else if bracket == ')' {\n            right_brackets += 1\n\
    \        }\n        if right_brackets > left_brackets {\n            return false\n\
    \        }\n    }\n    return left_brackets == right_brackets\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073928
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if len(brackets) == 0 {\n        return true\n    }\n  \
    \  balance := 0\n    for _, bracket := range brackets {\n        if bracket ==\
    \ '(' {\n            balance++\n        } else if bracket == ')' {\n         \
    \   balance--\n        }\n        if balance < 0 {\n            return false\n\
    \        }\n    }\n    return balance == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073928
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    opens := 0\n    for _, c := range brackets {\n        if\
    \ c == '(' {\n            opens++\n        } else if c == ')' {\n            opens--\n\
    \        }\n        if opens < 0 {\n            return false\n        }\n    }\n\
    \    return opens == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073928
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // TODO: implement me.\n    return false\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmp1hhyctv5_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp1hhyctv5_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmp1hhyctv5_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp1hhyctv5_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073928
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    cnt := 0\n    for _, c := range brackets {\n        if c\
    \ == '(' {\n            cnt++\n        } else if c == ')' {\n            cnt--\n\
    \        }\n        if cnt < 0 {\n            return false\n        }\n    }\n\
    \    return cnt == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073928
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    type bracket_t \nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn5fr3o9w_test.go:19:20: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073927
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // TODO: implement this function\n    return false\n}\n\n\
    func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpshhc0ynz_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpshhc0ynz_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpshhc0ynz_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpshhc0ynz_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.008s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    depth := 0\n    for _, char := range brackets {\n      \
    \  if char == '(' {\n            depth += 1\n        } else if char == ')' {\n\
    \            depth -= 1\n        }\n        if depth < 0 {\n            return\
    \ false\n        }\n    }\n    return depth == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073928
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n\tvar count = 0\n\tfor _, char := range brackets {\n\t\tif char\
    \ == '(' {\n\t\t\tcount++\n\t\t} else if char == ')' {\n\t\t\tcount--\n\t\t}\n\
    \t\tif count < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn count == 0\n}\n\n\
    func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073928
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, c := range brackets {\n        if\
    \ c == '(' {\n            count++\n        } else if c == ')' {\n            count--\n\
    \        }\n        if count < 0 {\n            return false\n        }\n    }\n\
    \    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073736
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    cnt := 0\n    for _, c := range brackets {\n        if c\
    \ == '(' {\n            cnt++\n        } else if c == ')' {\n            cnt--\n\
    \        }\n        if cnt < 0 {\n            return false\n        }\n    }\n\
    \    return cnt == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073928
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []string\n    for _, bracket := range brackets\
    \ {\n        if bracket == '(' {\n            stack = append(stack, \"(\")\n \
    \       } else {\n            if len(stack) == 0 {\n                return false\n\
    \            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n \
    \   return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n\
    \  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073735
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmp_5js7nl3_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp_5js7nl3_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmp_5js7nl3_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp_5js7nl3_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073928
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []rune\n    for _, item := range brackets {\n\
    \        if item == '(' {\n            stack = append(stack, item)\n        }\
    \ else if item == ')' {\n            if len(stack) == 0 {\n                return\
    \ false\n            }\n            stack = stack[:len(stack)-1]\n        }\n\
    \    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    i := 0\n    for _, ch := range brackets {\n        switch\
    \ ch {\n        case '(':\n            i++\n        case ')':\n            i--\n\
    \        }\n        if i < 0 {\n            return false\n        }\n    }\n \
    \   return i == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073929
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    //TODO\n    return false\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpv5buzy0t_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpv5buzy0t_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpv5buzy0t_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpv5buzy0t_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073930
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    balance := 0\n    for _, bracket := range brackets {\n \
    \       if bracket == '(' {\n            balance++\n        } else if bracket\
    \ == ')' {\n            balance--\n        }\n        if balance < 0 {\n     \
    \       return false\n        }\n    }\n    return balance == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073930
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // TODO\n    return false\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpv6tfn38s_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpv6tfn38s_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpv6tfn38s_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpv6tfn38s_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.011s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, c := range brackets {\n        if\
    \ c == '(' {\n            count++\n        } else if c == ')' {\n            count--\n\
    \        }\n        if count < 0 {\n            return false\n        }\n    }\n\
    \    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073736
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // initialize stack to hold corresponding bracket\n    b_stack\
    \ := []string{}\n    for _, b := range brackets {\n        bracket := string(b)\n\
    \        // Check if b is opening bracket and add it to stack\n        if bracket\
    \ == \"(\" {\n            b_stack = append(b_stack, bracket)\n        } else {\n\
    \            // pop the last bracket in stack\n            if len(b_stack) ==\
    \ 0 {\n                return false\n            }\n            b_stack = b_stack[:len(b_stack)-1]\n\
    \        }\n    }\n    // Check if every closing bracket has a corresponding opening\
    \ bracket\n    if len(b_stack) != 0 {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    open := 0\n    for _, c := range brackets {\n        if\
    \ c == '(' {\n            open++\n        } else if c == ')' {\n            open--\n\
    \        }\n        if open < 0 {\n            return false\n        }\n    }\n\
    \    return open == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []rune\n    for _,c := range brackets {\n    \
    \    if c == '(' {\n            stack = append(stack, '(')\n        } else if\
    \ c == ')' {\n            if len(stack) == 0 {\n                return false\n\
    \            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n \
    \   return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n\
    \  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.010s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    s := \"\"\n    for _, c := range brackets {\n        if\
    \ c == '(' {\n            s += \"(\"\n        } else if c == ')' {\n         \
    \   if len(s) == 0 {\n                return false\n            }\n          \
    \  s = s[:len(s)-1]\n        }\n    }\n    return s == \"\"\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if brackets == \"\" {\n        return true\n    }\n    counter\
    \ := 0\n    for _, ch := range brackets {\n        if ch == '(' {\n          \
    \  counter += 1\n        } else if ch == ')' {\n            counter -= 1\n   \
    \     }\n        if counter < 0 {\n            return false\n        }\n    }\n\
    \    return counter == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n \
    \ candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    balance := 0\n    for _, c := range brackets {\n       \
    \ if c == '(' {\n            balance++\n        } else if c == ')' {\n       \
    \     balance--\n        } else {\n            panic(\"the string should only\
    \ contain brackets\")\n        }\n        if balance < 0 {\n            return\
    \ false\n        }\n    }\n    return balance == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []byte\n    for _, b := range brackets {\n   \
    \     if b == '(' {\n            stack = append(stack, byte(b))\n        } else\
    \ if b == ')' {\n            if len(stack) > 0 {\n                stack = stack[:len(stack)-1]\n\
    \            } else {\n                return false\n            }\n        }\n\
    \    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073931
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // your solution here\n    return false\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpwir7rsz4_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpwir7rsz4_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpwir7rsz4_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpwir7rsz4_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073931
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []rune\n    for _, b := range brackets {\n   \
    \     if b == '(' {\n            stack = append(stack, b)\n        } else if b\
    \ == ')' {\n            if len(stack) == 0 {\n                return false\n \
    \           }\n            stack = stack[:len(stack)-1]\n        }\n    }\n  \
    \  return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n\
    \  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := []rune{}\n    for _, ch := range brackets {\n \
    \       switch ch {\n        case '(':\n            stack = append(stack, ch)\n\
    \        case ')':\n            if len(stack) == 0 {\n                return false\n\
    \            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n \
    \   return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n\
    \  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := []rune{}\n    for _, char := range brackets {\n\
    \        if char == '(' {\n            stack = append(stack, char)\n        }\
    \ else if char == ')' {\n            if len(stack) > 0 {\n                stack\
    \ = stack[:len(stack)-1]\n            } else {\n                return false\n\
    \            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []string\n    for _, v := range brackets {\n \
    \       if string(v) == \"(\" {\n            stack = append(stack, string(v))\n\
    \        } else {\n            if len(stack) == 0 {\n                return false\n\
    \            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n \
    \   return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n\
    \  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    open := 0\n    for _, c := range brackets {\n        if\
    \ c == '(' {\n            open++\n        } else if c == ')' {\n            open--\n\
    \        }\n        if open < 0 {\n            return false\n        }\n    }\n\
    \    return open == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // the way to solve this problem is to keep a stack of opening\
    \ brackets.\n    // each time we see a closing bracket, we pop an opening bracket\
    \ off the stack.\n    // if we ever see a closing bracket but there are no more\
    \ opening brackets on the stack,\n    // then the string is not correctly bracketed.\n\
    \    // if we reach the end of the string and there are still opening brackets\
    \ on the stack,\n    // then the string is not correctly bracketed.\n    stack\
    \ := make([]int, 0)\n    for i, _ := range brackets {\n        if brackets[i]\
    \ == '(' {\n            stack = append(stack, i)\n        } else {\n         \
    \   if len(stack) == 0 {\n                return false\n            }\n      \
    \      stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) ==\
    \ 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // when a opening bracket is encountered, push it onto a\
    \ stack.\n    // when a closing bracket is encountered, pop the stack.\n    //\
    \ if the stack is empty or does not have an opening bracket, the brackets string\
    \ is invalid.\n    bracketStack := make([]byte, 0)\n    for _, bracket := range\
    \ brackets {\n        if bracket == '(' {\n            bracketStack = append(bracketStack,\
    \ '(')\n        } else if bracket == ')' {\n            if len(bracketStack) ==\
    \ 0 {\n                return false\n            }\n            bracketStack =\
    \ bracketStack[:len(bracketStack)-1]\n        }\n    }\n    return len(bracketStack)\
    \ == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if brackets == \"\" {\n        return true\n    }\n    if\
    \ brackets[0] == ')' {\n        return false\n    }\n    if brackets[len(brackets)-1]\
    \ == '(' {\n        return false\n    }\n    left, right := 0, 0\n    for _, b\
    \ := range brackets {\n        if b == '(' {\n            left += 1\n        }\
    \ else {\n            right += 1\n        }\n        if left < right {\n     \
    \       return false\n        }\n    }\n    return left == right\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if len(brackets) == 0 {\n        return true\n    }\n  \
    \  left := 0\n    for _, v := range brackets {\n        if v == '(' {\n      \
    \      left += 1\n        } else {\n            left -= 1\n        }\n       \
    \ if left < 0 {\n            return false\n        }\n    }\n    return left ==\
    \ 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, value := range brackets {\n     \
    \   if string(value) == \"(\" {\n            count += 1\n        } else if string(value)\
    \ == \")\" {\n            count -= 1\n        }\n        if count < 0 {\n    \
    \        return false\n        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n\tcount := 0\n\tfor _, char := range brackets {\n\t\tif string(char)\
    \ == \"(\" {\n\t\t\tcount++\n\t\t} else if string(char) == \")\" {\n\t\t\tcount--\n\
    \t\t}\n\t\tif count < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn count == 0\n\
    }\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    balance := 0\n    for _, c := range brackets {\n       \
    \ switch c {\n        case '(':\n            balance++\n        case ')':\n  \
    \          balance--\n        }\n        if balance < 0 {\n            return\
    \ false\n        }\n    }\n    return balance == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if len(brackets) == 0 {\n        return true\n    }\n  \
    \  if brackets[0] == ')' {\n        return false\n    }\n    stack := 0\n    for\
    \ _, bracket := range brackets {\n        if bracket == '(' {\n            stack++\n\
    \        } else {\n            stack--\n        }\n        if stack < 0 {\n  \
    \          return false\n        }\n    }\n    return stack == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073931
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    brace_count := 0\n    for _, rune := range brackets {\n\
    \        if string(rune) == \"(\" {\n            brace_count++\n        } else\
    \ if string(rune) == \")\" {\n            brace_count--\n        }\n        if\
    \ brace_count < 0 {\n            return false\n        }\n    }\n    return brace_count\
    \ == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073932
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // Your code here (replace the return statements)\n    return\
    \ false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpa1mlvqm8_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpa1mlvqm8_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpa1mlvqm8_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpa1mlvqm8_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073932
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // YOUR CODE HERE\n    return false\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpqv8792qm_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpqv8792qm_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpqv8792qm_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpqv8792qm_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073932
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := []string{}\n    for _, s := range brackets {\n\
    \        if s == '(' {\n            stack = append(stack, \"(\")\n        } else\
    \ {\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack)\
    \ == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [:-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x514640, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x514640,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.correct_bracketing(...)\n\t/tmp/tmpboa_8v04_test.go:24\n\
    command-line-arguments_test.TestCorrect_Bracketing(0x0?)\n\t/tmp/tmpboa_8v04_test.go:41\
    \ +0x1837\ntesting.tRunner(0xc0000da1a0, 0x529fc8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073932
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    bracket_set := make(map[rune]rune)\n    bracket_set['(']\
    \ = ')'\n    bracket_stack := make([]rune, 0)\n    for _, bracket := range brackets\
    \ {\n        if bracket == '(' {\n            bracket_stack = append(bracket_stack,\
    \ bracket)\n        } else if bracket == ')' {\n            if len(bracket_stack)\
    \ == 0 {\n                return false\n            }\n            last_bracket\
    \ := bracket_stack[len(bracket_stack) - 1]\n            bracket_stack = bracket_stack[:len(bracket_stack)\
    \ - 1]\n            if bracket_set[last_bracket] != bracket {\n              \
    \  return false\n            }\n        }\n    }\n    return len(bracket_stack)\
    \ == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // bracketStack stores \"(\"\n    bracketStack := make([]byte,\
    \ 0)\n    for _, b := range []byte(brackets) {\n        if b == '(' {\n      \
    \      bracketStack = append(bracketStack, b)\n        } else if b == ')' {\n\
    \            if len(bracketStack) == 0 {\n                return false\n     \
    \       }\n            bracketStack = bracketStack[:len(bracketStack)-1]\n   \
    \     }\n    }\n    return len(bracketStack) == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var numOpen int = 0\n\n    for _, c := range brackets {\n\
    \        if c == '(' {\n            numOpen++\n        } else if c == ')' {\n\
    \            numOpen--\n        }\n\n        if numOpen < 0 {\n            return\
    \ false\n        }\n    }\n\n    return numOpen == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073933
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // delete this line and write your code here\n    return\
    \ false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpbzn6ll3m_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpbzn6ll3m_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpbzn6ll3m_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpbzn6ll3m_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073933
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return brackets == \"\"\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpn3pxbhr4_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpn3pxbhr4_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpn3pxbhr4_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpn3pxbhr4_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    left := 0\n    for _, c := range brackets {\n        if\
    \ c == '(' {\n            left++\n        } else if c == ')' {\n            left--\n\
    \        } else {\n            return false\n        }\n        if left < 0 {\n\
    \            return false\n        }\n    }\n    return left == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073933
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // your code here\n    return false\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpl9eqw7mk_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpl9eqw7mk_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpl9eqw7mk_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpl9eqw7mk_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := []byte{}\n    for _, char := range []byte(brackets)\
    \ {\n        if char == '(' {\n            stack = append(stack, char)\n     \
    \   } else if char == ')' {\n            if len(stack) < 1 {\n               \
    \ return false\n            }\n            stack = stack[:len(stack)-1]\n    \
    \    }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []rune\n\n    for _, r := range brackets {\n \
    \       if r == '(' {\n            stack = append(stack, r)\n        } else if\
    \ r == ')' {\n            if len(stack) == 0 {\n                return false\n\
    \            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n\n\
    \    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n\
    \  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    cnt := 0\n    for _, ch := range brackets {\n        if\
    \ ch == '(' {\n            cnt++\n        } else {\n            cnt--\n      \
    \  }\n        if cnt < 0 {\n            return false\n        }\n    }\n    return\
    \ cnt == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n\tvar left int\n\tfor _, c := range brackets {\n\t\tif c ==\
    \ '(' {\n\t\t\tleft += 1\n\t\t} else {\n\t\t\tleft -= 1\n\t\t}\n\t\tif left <\
    \ 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn left == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var not_closed int\n    for _, bracket := range brackets\
    \ {\n        switch bracket {\n        case '(':\n            not_closed += 1\n\
    \        case ')':\n            not_closed -= 1\n        }\n        if not_closed\
    \ < 0 {\n            return false\n        }\n    }\n    return not_closed ==\
    \ 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, v := range brackets {\n        if\
    \ v == '(' {\n            count += 1\n        } else if v == ')' {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return false\n\
    \        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []string\n    for _, b := range brackets {\n \
    \       switch b {\n        case '(':\n            stack = append(stack, \"(\"\
    )\n        case ')':\n            if len(stack) == 0 {\n                return\
    \ false\n            }\n            pop := stack[len(stack)-1]\n            if\
    \ pop != \"(\" {\n                return false\n            }\n            stack\
    \ = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\n\
    func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var c int\n    for _, b := range brackets {\n        if\
    \ b == '(' {\n            c += 1\n        } else {\n            c -= 1\n     \
    \   }\n        if c < 0 {\n            return false\n        }\n    }\n    return\
    \ c == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073923
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := make([]string, 0)\n    for _, c := range brackets\
    \ {\n        ch := string(c)\n        if ch == \"(\" {\n            stack = append(stack,\
    \ ch)\n        } else if ch == \")\" {\n            if len(stack) == 0 {\n   \
    \             return false\n            }\n            stack = stack[:len(stack)-1]\n\
    \        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073933
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := []rune{}\n    var r rune\n    var ok bool\n   \
    \ for _, r = range brackets {\n        switch r {\n        case '(':\n       \
    \     stack = append(stack, r)\n        case ')':\n            if len(stack) ==\
    \ 0 {\n                return false\n            }\n            _, ok = pop(stack)\n\
    \            if !ok {\n                return false\n            }\n        }\n\
    \    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp337om84s_test.go:30:21: undefined: pop

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var open int = 0\n    for _,b := range brackets {\n    \
    \    switch b {\n        case '(':\n            open++\n        case ')':\n  \
    \          open--\n            if open < 0 {\n                return false\n \
    \           }\n        }\n    }\n    return open == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073933
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i]\
    \ == '(' {\n            if len(brackets) == 1 {\n                return false\n\
    \            } else {\n                if brackets[i+1] == ')' {\n           \
    \         return true\n                } else {\n                    return false\n\
    \                }\n            }\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1\
    \ (0.00s)\n        tmpxoa7cnc9_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__8 (0.00s)\n        tmpxoa7cnc9_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10\
    \ (0.00s)\n        tmpxoa7cnc9_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmpxoa7cnc9_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []string\n    for _, c := range brackets {\n \
    \       if c == '(' {\n            stack = append(stack, \"(\")\n        } else\
    \ {\n            if len(stack) == 0 {\n                return false\n        \
    \    }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return\
    \ len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073735
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []rune\n    for _, s := range brackets {\n   \
    \     if s == '(' {\n            stack = append(stack, s)\n        } else if s\
    \ == ')' {\n            if len(stack) == 0 {\n                return false\n \
    \           }\n            stack = stack[:len(stack)-1]\n        }\n    }\n  \
    \  return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n\
    \  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []rune\n    var top rune\n    for _, char := range\
    \ brackets {\n        if char == '(' {\n            stack = append(stack, char)\n\
    \        } else {\n            if len(stack) == 0 {\n                return false\n\
    \            }\n            top = stack[len(stack)-1]\n            if top == '('\
    \ {\n                stack = stack[:len(stack)-1]\n            } else {\n    \
    \            return false\n            }\n        }\n    }\n    if len(stack)\
    \ == 0 {\n        return true\n    }\n    return false\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073933
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var nest int\n    for _, bracket := range brackets {\n \
    \       if bracket == '(' {\n            nest++\n        } else if bracket ==\
    \ ')' {\n            nest--\n        }\n        if nest < 0 {\n            return\
    \ false\n        }\n    }\n    return nest == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073934
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []rune\n    for _, b := range brackets {\n   \
    \     if b == '(' {\n            stack = append(stack, b)\n        } else if b\
    \ == ')' {\n            if len(stack) == 0 {\n                return false\n \
    \           }\n            top := stack[len(stack)-1]\n            if top == '('\
    \ {\n                stack = stack[:len(stack)-1]\n            } else {\n    \
    \            return false\n            }\n        }\n    }\n    return len(stack)\
    \ == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073934
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // create an empty stack to store the characters\n    //\
    \ when we see \"(\" -> push \"(\"\n    // when we see \")\" -> pop \"(\"\n   \
    \ // if ever the stack is empty when we see \")\" -> return false\n    stack :=\
    \ \"\"\n    for _,c := range brackets {\n        char := string(c)\n        if\
    \ char == \"(\" {\n            stack += char\n        } else if char == \")\"\
    \ {\n            // check if stack is empty\n            if len(stack) == 0 {\n\
    \                return false\n            }\n            // remove a \"(\"\n\
    \            stack = stack[:len(stack)-1]\n        }\n    }\n    // if any open\
    \ bracket left in the stack\n    if len(stack) > 0 {\n        return false\n \
    \   }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073934
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := []byte{}\n    for _, b := range []byte(brackets)\
    \ {\n        if b == '(' {\n            stack = append(stack, b)\n        } else\
    \ {\n            if len(stack) == 0 {\n                return false\n        \
    \    }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return\
    \ len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073934
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := []byte{}\n    for _, c := range brackets {\n  \
    \      switch c {\n        case '(':\n            stack = append(stack, '(')\n\
    \        case ')':\n            if len(stack) == 0 {\n                return false\n\
    \            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n \
    \   return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n\
    \  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073935
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n\tif len(brackets) % 2 != 0 {\n\t\treturn false\n\t}\n\tstack\
    \ := []rune{}\n\tfor _, b := range brackets {\n\t\tif b == '(' {\n\t\t\tstack\
    \ = append(stack, b)\n\t\t} else {\n\t\t\tif len(stack) == 0 {\n\t\t\t\treturn\
    \ false\n\t\t\t}\n\t\t\tstack = stack[:len(stack)-1]\n\t\t}\n\t}\n\treturn len(stack)\
    \ == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.011s\n"
  timestamp: 1660073935
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    depth := 0\n    for _, char := range brackets {\n      \
    \  if string(char) == \"(\" {\n            depth += 1\n        } else if string(char)\
    \ == \")\" {\n            depth -= 1\n        }\n        if depth < 0 {\n    \
    \        return false\n        }\n    }\n    return depth == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073935
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []rune\n    for _, c := range brackets {\n   \
    \     switch c {\n        case '(':\n            stack = append(stack, c)\n  \
    \      case ')':\n            if len(stack) == 0 {\n                return false\n\
    \            }\n            if stack[len(stack)-1] != '(' {\n                return\
    \ false\n            }\n            stack = stack[:len(stack)-1]\n        }\n\
    \    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073935
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    if brackets == \"\" {\n        return true\n    }\n    if\
    \ brackets[0] == ')' {\n        return false\n    }\n    if brackets[len(brackets)-1]\
    \ == '(' {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmppwa16frd_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmppwa16frd_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10\
    \ (0.00s)\n        tmppwa16frd_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmppwa16frd_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073935
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, c := range brackets {\n        if\
    \ c == '(' {\n            count += 1\n        } else if c == ')' {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return false\n\
    \        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073923
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    n := len(brackets)\n    if n == 0 {\n        return true\n\
    \    }\n    if n == 1 {\n        return false\n    }\n    m := make(map[string]int)\n\
    \    for _, b := range brackets {\n        if b == '(' {\n            m[\"(\"\
    ]++\n        } else {\n            m[\")\"]++\n        }\n    }\n    return m[\"\
    (\"] == m[\")\"]\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__5\
    \ (0.00s)\n        tmpq0iqzqlo_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__10 (0.00s)\n        tmpq0iqzqlo_test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073935
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // Write your code here\n    return false\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmp_5js7nl3_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp_5js7nl3_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmp_5js7nl3_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp_5js7nl3_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073928
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var counter int\n    for _, char := range brackets {\n \
    \       if string(char) == \"(\" {\n            counter++\n        } else {\n\
    \            counter--\n        }\n        if counter < 0 {\n            return\
    \ false\n        }\n    }\n    return counter == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073935
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__4\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__5 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__7 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__9 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__10\
    \ (0.00s)\n        tmpa13jzhu4_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__11 (0.00s)\n        tmpa13jzhu4_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []byte\n    for _, char := range brackets {\n\
    \        if char == '(' {\n            stack = append(stack, '(')\n        } else\
    \ if char == ')' {\n            if len(stack) == 0 {\n                return false\n\
    \            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n \
    \   return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n\
    \  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073935
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpdf8nx84j_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpdf8nx84j_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpdf8nx84j_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpdf8nx84j_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var count int = 0\n    for _, char := range brackets {\n\
    \        if char == '(' {\n            count += 1\n        } else if char == ')'\
    \ {\n            count -= 1\n        }\n        if count < 0 {\n            return\
    \ false\n        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    n := len(brackets)\n    count := 0\n    for i := 0; i <\
    \ n; i++ {\n        if brackets[i] == '(' {\n            count++\n        } else\
    \ {\n            count--\n        }\n        if count < 0 {\n            return\
    \ false\n        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073936
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := []string{}\n    for _, bracket := range brackets\
    \ {\n        bracketStr := string(bracket)\n        if bracketStr == \"(\" {\n\
    \            stack = append(stack, bracketStr)\n        } else if bracketStr ==\
    \ \")\" {\n            if len(stack) == 0 {\n                return false\n  \
    \          }\n            stack = stack[:len(stack)-1]\n        }\n    }\n   \
    \ return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n \
    \ candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073936
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // implement me!\n    return false\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpulekag53_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpulekag53_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpulekag53_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpulekag53_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := []byte{}\n    for _, bracket := range brackets\
    \ {\n        switch bracket {\n        case '(':\n            stack = append(stack,\
    \ byte(bracket))\n        case ')':\n            if len(stack) == 0 {\n      \
    \          return false\n            }\n            stack = stack[:len(stack)-1]\n\
    \        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []rune\n    for _, c := range brackets {\n   \
    \     if c == '(' {\n            stack = append(stack, c)\n        } else if c\
    \ == ')' {\n            if len(stack) == 0 {\n                return false\n \
    \           }\n            stack = stack[:len(stack)-1]\n        }\n    }\n  \
    \  return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n\
    \  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073735
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    // TODO - Add your code here\n    return false\n}\n\nfunc\
    \ TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpdf8nx84j_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpdf8nx84j_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpdf8nx84j_test.go:47: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpdf8nx84j_test.go:47:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073936
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n\treturn false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmp02clf5pn_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp02clf5pn_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmp02clf5pn_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp02clf5pn_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073923
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    counter := 0\n    for _, b := range brackets {\n       \
    \ if b == '(' {\n            counter += 1\n        } else if b == ')' {\n    \
    \        counter -= 1\n        }\n        if counter < 0 {\n            return\
    \ false\n        }\n    }\n    return counter == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := 0\n    for _, c := range brackets {\n        if\
    \ c == '(' {\n            stack += 1\n        } else if c == ')' {\n         \
    \   stack -= 1\n        }\n        if stack < 0 {\n            return false\n\
    \        }\n    }\n    return stack == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var s []rune\n    var b rune\n    for _, b = range brackets\
    \ {\n        if b == '(' {\n            s = append(s, b)\n        } else if b\
    \ == ')' {\n            if len(s) == 0 {\n                return false\n     \
    \       }\n            if s[len(s)-1] == '(' {\n                s = s[:len(s)-1]\n\
    \            } else {\n                return false\n            }\n        }\n\
    \    }\n    return len(s) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.006s\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var stack []string\n    for _, c := range brackets {\n \
    \       switch string(c) {\n        case \"(\":\n            stack = append(stack,\
    \ \"(\")\n        case \")\":\n            if len(stack) == 0 {\n            \
    \    return false\n            }\n            stack = stack[:len(stack)-1]\n \
    \       }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, b := range brackets {\n        if\
    \ b == '(' {\n            count++\n        } else if b == ')' {\n            count--\n\
    \        } else {\n            return false\n        }\n        if count < 0 {\n\
    \            return false\n        }\n    }\n    return count == 0\n}\n\nfunc\
    \ TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073936
- exit_code: 1
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2\
    \ (0.00s)\n        tmpgnzkrd6t_test.go:46: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgnzkrd6t_test.go:46:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073735
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := make([]byte, 0)\n    for _, c := range brackets\
    \ {\n        if c == '(' {\n            stack = append(stack, byte(c))\n     \
    \   } else if c == ')' {\n            if len(stack) == 0 {\n                return\
    \ false\n            }\n            stack = stack[:len(stack)-1]\n        }\n\
    \    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := []string{}\n    for _, c := range brackets {\n\
    \        switch c {\n        case '(':\n            stack = append(stack, \"(\"\
    )\n        case ')':\n            if len(stack) == 0 {\n                return\
    \ false\n            }\n            stack = stack[:len(stack)-1]\n        }\n\
    \    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    stack := []string{}\n    for _, b := range brackets {\n\
    \        if b == '(' {\n            stack = append(stack, \"(\")\n        } else\
    \ {\n            if len(stack) == 0 {\n                return false\n        \
    \    }\n            if stack[len(stack)-1] == \"(\" {\n                stack =\
    \ stack[:len(stack)-1]\n            } else {\n                return false\n \
    \           }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t\
    \ *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"()\"), expected: true },\n     { actual: candidate(\"\
    (()())\"), expected: true },\n     { actual: candidate(\"()()(()())()\"), expected:\
    \ true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"), expected:\
    \ true },\n     { actual: candidate(\"((()())))\"), expected: false },\n     {\
    \ actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    count := 0\n    for _, b := range brackets {\n        if\
    \ b == '(' {\n            count += 1\n        } else if b == ')' {\n         \
    \   count -= 1\n        }\n        if count < 0 {\n            return false\n\
    \        }\n    }\n    return count == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T)\
    \ {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    ()\"), expected: true },\n     { actual: candidate(\"(()())\"), expected: true\
    \ },\n     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073923
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    b := []byte(brackets)\n    var s = 0\n    for _, v := range\
    \ b {\n        if v == '(' {\n            s++\n        } else {\n            s--\n\
    \        }\n        if s < 0 {\n            return false\n        }\n    }\n \
    \   return s == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate\
    \ := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"()\"\
    ), expected: true },\n     { actual: candidate(\"(()())\"), expected: true },\n\
    \     { actual: candidate(\"()()(()())()\"), expected: true },\n     { actual:\
    \ candidate(\"()()((()()())())(()()(()))\"), expected: true },\n     { actual:\
    \ candidate(\"((()())))\"), expected: false },\n     { actual: candidate(\")(()\"\
    ), expected: false },\n     { actual: candidate(\"(\"), expected: false },\n \
    \    { actual: candidate(\"((((\"), expected: false },\n     { actual: candidate(\"\
    )\"), expected: false },\n     { actual: candidate(\"(()\"), expected: false },\n\
    \     { actual: candidate(\"()()(()())())(()\"), expected: false },\n     { actual:\
    \ candidate(\"()()(()())()))()\"), expected: false },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073936
- exit_code: 0
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    var q []rune\n    for _, v := range brackets {\n       \
    \ if v == '(' {\n            q = append(q, v)\n        } else if v == ')' {\n\
    \            if len(q) == 0 {\n                return false\n            }\n \
    \           q = q[:len(q)-1]\n        }\n    }\n    return len(q) == 0\n}\n\n\
    func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073936
- exit_code: 2
  program: "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// brackets is a string of \"(\" and \")\".\n// return true if every opening\
    \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
    )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
    (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunc correct_bracketing(brackets\
    \ string) bool {\n    return correct_bracketing_two_pass(brackets)\n}\n\nfunc\
    \ TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"()\"), expected: true },\n  \
    \   { actual: candidate(\"(()())\"), expected: true },\n     { actual: candidate(\"\
    ()()(()())()\"), expected: true },\n     { actual: candidate(\"()()((()()())())(()()(()))\"\
    ), expected: true },\n     { actual: candidate(\"((()())))\"), expected: false\
    \ },\n     { actual: candidate(\")(()\"), expected: false },\n     { actual: candidate(\"\
    (\"), expected: false },\n     { actual: candidate(\"((((\"), expected: false\
    \ },\n     { actual: candidate(\")\"), expected: false },\n     { actual: candidate(\"\
    (()\"), expected: false },\n     { actual: candidate(\"()()(()())())(()\"), expected:\
    \ false },\n     { actual: candidate(\"()()(()())()))()\"), expected: false },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplowg_3ly_test.go:19:12: undefined: correct_bracketing_two_pass

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073936
