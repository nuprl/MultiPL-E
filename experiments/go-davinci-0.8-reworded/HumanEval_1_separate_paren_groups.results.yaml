language: go_test.go
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var stack []int\n    var idx []int\n    var res []string\n\
    \    for i, v := range paren_string {\n        if v == '(' {\n            stack\
    \ = append(stack, i)\n        } else if v == ')' {\n            idx = append(idx,\
    \ stack[len(stack)-1])\n            idx = append(idx, i)\n            stack =\
    \ stack[:len(stack)-1]\n        }\n    }\n    for i := 0; i < len(idx); i += 2\
    \ {\n        res = append(res, paren_string[idx[i]:idx[i+1]+1])\n    }\n    return\
    \ res\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpy2vjk_fs_test.go:49: expected '[(()()) ((())) () ((())()())]',\
    \ got '[() () (()()) () (()) ((())) () () (()) () () ((())()())]'\n    --- FAIL:\
    \ TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmpy2vjk_fs_test.go:49:\
    \ expected '[() (()) ((())) (((())))]', got '[() () (()) () (()) ((())) () (())\
    \ ((())) (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n\
    \        tmpy2vjk_fs_test.go:49: expected '[(()(())((())))]', got '[() () (())\
    \ () (()) ((())) (()(())((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpy2vjk_fs_test.go:49: expected '[() (()) (()())]', got '[(\
    \ ) ( ) (( )) ( ) ( ) (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var start int = 0\n    var end int = 0\n    var result\
    \ []string\n    for i := 0; i < len(paren_string); i++ {\n        if paren_string[i]\
    \ == '(' {\n            start = i\n        } else if paren_string[i] == ')' {\n\
    \            end = i\n            result = append(result, paren_string[start:end+1])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpal_0qu4t_test.go:45: expected '[(()()) ((())) () ((())()())]',\
    \ got '[() () ()) () ()) ())) () () ()) () () ())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpal_0qu4t_test.go:45: expected '[() (()) ((())) (((())))]',\
    \ got '[() () ()) () ()) ())) () ()) ())) ())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpal_0qu4t_test.go:45: expected '[(()(())((())))]', got '[()\
    \ () ()) () ()) ())) ())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpal_0qu4t_test.go:45: expected '[() (()) (()())]', got '[(\
    \ ) ( ) ( )) ( ) ( ) ( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    var open_paren, close_paren\
    \ int\n    var valid_paren bool\n    var starting_pos, ending_pos int\n    var\
    \ right_paren string\n\n    fmt.Println(\"this is the paren_string:\", paren_string)\n\
    \    for idx, curr_char := range paren_string {\n        // check for spaces,\
    \ leave them\n        if curr_char == 32 {\n            continue\n        }\n\
    \        // check for an open paren\n        if curr_char == 40 {\n          \
    \  starting_pos = idx\n            // check for a closed paren\n            right_paren\
    \ = string(paren_string[idx+1])\n            fmt.Println(\"right_paren:\", right_paren)\n\
    \            if right_paren == \")\" {\n                ending_pos = idx + 1\n\
    \                result = append(result, paren_string[starting_pos:ending_pos])\n\
    \                fmt.Println(\"result:\", result)\n            }\n        } else\
    \ if curr_char == 41 {\n            // check for valid parens\n            valid_paren\
    \ = validParens(paren_string[starting_pos:idx])\n            if valid_paren {\n\
    \                ending_pos = idx\n                result = append(result, paren_string[starting_pos:ending_pos])\n\
    \                fmt.Println(\"result:\", result)\n            }\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n\
    \  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp33nhjc_j_test.go:16:9: open_paren declared but not used

    /tmp/tmp33nhjc_j_test.go:16:21: close_paren declared but not used

    /tmp/tmp33nhjc_j_test.go:40:27: undefined: validParens

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073958
- exit_code: 0
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    split := make([]string, 0)\n    cur := \"\"\n    open\
    \ := 0\n    for _, char := range paren_string {\n        if char == ' ' {\n  \
    \          continue\n        }\n        if char == '(' {\n            open++\n\
    \        } else {\n            open--\n        }\n        cur += string(char)\n\
    \        if open == 0 {\n            split = append(split, cur)\n            cur\
    \ = \"\"\n        }\n    }\n    return split\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // YOUR CODE HERE\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp0lyigi70_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp0lyigi70_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp0lyigi70_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp0lyigi70_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n\treturn nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpz7cbln62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpz7cbln62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpz7cbln62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpz7cbln62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var parenGroups []string\n    var tempGroup string\n\
    \    var parenOpen bool\n    for _, char := range paren_string {\n        if char\
    \ == '(' {\n            if !parenOpen {\n                tempGroup = \"\"\n  \
    \          }\n            parenOpen = true\n            tempGroup += \"(\"\n \
    \       } else if char == ')' {\n            tempGroup += \")\"\n            parenOpen\
    \ = false\n            parenGroups = append(parenGroups, tempGroup)\n        }\n\
    \    }\n    return parenGroups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmplxj74bxn_test.go:50: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(() () ()) ((() ((()) ((())) () ((() ((()) () () ())]'\n    --- FAIL:\
    \ TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmplxj74bxn_test.go:50:\
    \ expected '[() (()) ((())) (((())))]', got '[() (() (()) ((() ((()) ((())) (((()\
    \ (((()) (((())) (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmplxj74bxn_test.go:50: expected '[(()(())((())))]', got '[(()\
    \ (() (()) ((() ((()) ((())) ((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmplxj74bxn_test.go:50: expected '[() (()) (()())]', got '[()\
    \ (() (()) (() () ())]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n\treturn nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpz7cbln62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpz7cbln62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpz7cbln62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpz7cbln62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var out []string\n\n    // TODO: Remove this and implement\
    \ the function\n\n    return out\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmph3svpjv3_test.go:38: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmph3svpjv3_test.go:38: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmph3svpjv3_test.go:38:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmph3svpjv3_test.go:38: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Your code here\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpgk0mw_vi_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpgk0mw_vi_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpgk0mw_vi_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpgk0mw_vi_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 0
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    var current string\n    var\
    \ open, closed int\n    for _, ch := range paren_string {\n        if ch == '\
    \ ' {\n            continue\n        }\n        if ch == '(' {\n            open++\n\
    \        } else {\n            closed++\n        }\n        current += string(ch)\n\
    \        if open == closed {\n            result = append(result, current)\n \
    \           current = \"\"\n            open, closed = 0, 0\n        }\n    }\n\
    \    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Implement the function here and then delete this\
    \ comment!\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp_b8fr6ik_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp_b8fr6ik_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp_b8fr6ik_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp_b8fr6ik_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n\treturn nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpz7cbln62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpz7cbln62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpz7cbln62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpz7cbln62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_list := []string{}\n    paren_length := len(paren_string)\n\
    \    index := 0\n    for index < paren_length {\n        start := index\n    \
    \    for index < paren_length && paren_string[index] != '(' {\n            index++\n\
    \        }\n        end := index\n        if end == paren_length {\n         \
    \   break\n        }\n        if end > start {\n            paren_list = append(paren_list,\
    \ paren_string[start:end])\n        }\n        opening_paren_count := 1\n    \
    \    for index = index + 1; index < paren_length; index++ {\n            if paren_string[index]\
    \ == '(' {\n                opening_paren_count++\n            } else if paren_string[index]\
    \ == ')' {\n                opening_paren_count--\n            }\n           \
    \ if opening_paren_count == 0 {\n                paren_list = append(paren_list,\
    \ paren_string[start:index+1])\n                break\n            }\n       \
    \ }\n    }\n    return paren_list\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpmerkg0ks_test.go:62: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()()) )  ) ((())) )  ) () )  ) ((())()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpmerkg0ks_test.go:62: expected '[() (()) ((())) (((())))]',\
    \ got '[() )  ) (()) )  ) ((())) )  ) (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpmerkg0ks_test.go:62: expected '[() (()) (()())]', got '[(\
    \ ) )  ) (( )) )  ) (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n\t//TODO write your solution here\n\treturn nil\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp2jsqcqjq_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp2jsqcqjq_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp2jsqcqjq_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp2jsqcqjq_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    fmt.Println(\"Processing string: \" + paren_string)\n\
    \    fmt.Println(\"Length: \" + string(len(paren_string)))\n    if len(paren_string)\
    \ == 0 {\n        return []string{}\n    }\n    var result []string\n\n    var\
    \ left_open, right_close int\n    for i, r := range paren_string {\n        if\
    \ r == '(' {\n            left_open++\n        } else if r == ')' {\n        \
    \    right_close++\n        }\n        if left_open == right_close {\n       \
    \     sub_group := paren_string[:i+1]\n            result = append(result, sub_group)\n\
    \            result = append(result, separate_paren_groups(paren_string[i+1:])...)\n\
    \            break\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpg5bnwang_test.go:16:30: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073959
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n\t// remove spaces in the string\n\tparen_string = RemoveSpaces(paren_string)\n\
    \topenCount := 0\n\topenIndex := 0\n\tresult := make([]string, 0)\n\tfor i, char\
    \ := range paren_string {\n\t\tif char == '(' {\n\t\t\topenCount++\n\t\t\tif openCount\
    \ == 1 {\n\t\t\t\topenIndex = i\n\t\t\t}\n\t\t} else if char == ')' {\n\t\t\t\
    openCount--\n\t\t\tif openCount == 0 {\n\t\t\t\tresult = append(result, paren_string[openIndex:i+1])\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3t1tvuuv_test.go:16:17: undefined: RemoveSpaces

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073958
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var res []string\n\n    i := 0\n    for ; i < len(paren_string);\
    \ i++ {\n        if paren_string[i] == '(' {\n            break\n        }\n \
    \   }\n\n    if i == len(paren_string) {\n        return res\n    }\n\n    j :=\
    \ i\n    for ; j < len(paren_string); j++ {\n        if paren_string[j] == ')'\
    \ {\n            break\n        }\n    }\n\n    if j == len(paren_string) {\n\
    \        return res\n    }\n\n    res = append(res, paren_string[i:j+1])\n   \
    \ res = append(res, separate_paren_groups(paren_string[j+1:])...)\n\n    return\
    \ res\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpfgc767q4_test.go:61: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(() () ((() () ((() () ()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpfgc767q4_test.go:61: expected '[() (()) ((())) (((())))]',\
    \ got '[() (() ((() (((()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpfgc767q4_test.go:61: expected '[(()(())((())))]', got '[(()\
    \ (() ((()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n  \
    \      tmpfgc767q4_test.go:61: expected '[() (()) (()())]', got '[( ) (( ) ((\
    \ ) ( )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpa0egrxcy_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpa0egrxcy_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpa0egrxcy_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpa0egrxcy_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    var current_group string\n\
    \    var paren_count int\n    var found_first_paren bool\n    var found_open_paren\
    \ bool\n    for _, letter := range paren_string {\n        if letter == '(' {\n\
    \            if found_first_paren {\n                found_open_paren = true\n\
    \            }\n            found_first_paren = true\n            paren_count++\n\
    \            current_group += string(letter)\n        } else if letter == ')'\
    \ {\n            paren_count--\n            current_group += string(letter)\n\
    \            if found_open_paren && paren_count == 0 {\n                result\
    \ = append(result, current_group)\n                current_group = \"\"\n    \
    \            found_open_paren = false\n            }\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate :=\
    \ separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected:\
    \ []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"\
    ( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmp816uexww_test.go:57: expected '[() (()) ((())) (((())))]',\
    \ got '[()(()) ((())) (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp816uexww_test.go:57: expected '[() (()) (()())]', got '[()(())\
    \ (()())]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_string = string_no_spaces(paren_string)\n    groups\
    \ := make([]string, 0)\n    start := 0\n    in_group := false\n    level := 0\n\
    \    for i, c := range paren_string {\n        if string(c) == \"(\" {\n     \
    \       if !in_group {\n                start = i\n                in_group =\
    \ true\n            }\n            level += 1\n        } else if string(c) ==\
    \ \")\" {\n            level -= 1\n            if level == 0 {\n             \
    \   in_group = false\n                groups = append(groups, paren_string[start:i+1])\n\
    \            }\n        }\n    }\n    return groups\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzvk7k_k4_test.go:15:20: undefined: string_no_spaces

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073958
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    res := make([]string, 0)\n    return res\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpsygbsqky_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpsygbsqky_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpsygbsqky_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpsygbsqky_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Create a stack to keep track of the current group\
    \ of parentheses\n    var stack []rune\n    // Create a slice of strings to hold\
    \ the result\n    var result []string\n    // Loop through each character in the\
    \ string\n    for _, char := range paren_string {\n        // Ignore spaces\n\
    \        if char == ' ' {\n            continue\n        }\n        // If it's\
    \ an open paren, add it to the stack\n        if char == '(' {\n            stack\
    \ = append(stack, char)\n        }\n        // If it's a closed paren\n      \
    \  if char == ')' {\n            // Ignore if we don't have a matching open paren\n\
    \            if len(stack) == 0 {\n                continue\n            }\n \
    \           // Remove the matching open paren from the stack\n            stack\
    \ = stack[:len(stack)-1]\n            // If the stack is empty, we just finished\
    \ creating a full paren group\n            if len(stack) == 0 {\n            \
    \    // Add the full group to the result\n                result = append(result,\
    \ \"()\")\n            }\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpze7ijhac_test.go:63: expected '[(()()) ((())) () ((())()())]',\
    \ got '[() () () ()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n\
    \        tmpze7ijhac_test.go:63: expected '[() (()) ((())) (((())))]', got '[()\
    \ () () ()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n  \
    \      tmpze7ijhac_test.go:63: expected '[(()(())((())))]', got '[()]'\n    ---\
    \ FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpze7ijhac_test.go:63:\
    \ expected '[() (()) (()())]', got '[() () ()]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 0
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Your code here\n    if len(paren_string) == 0 {\n\
    \        return []string{}\n    }\n    ret := []string{}\n    current := []byte{}\n\
    \    cnt := 0\n    for _, ch := range paren_string {\n        if ch == ' ' {\n\
    \            continue\n        }\n        if ch == '(' {\n            cnt++\n\
    \        } else {\n            cnt--\n        }\n        current = append(current,\
    \ byte(ch))\n        if cnt == 0 {\n            ret = append(ret, string(current))\n\
    \            current = []byte{}\n        }\n    }\n    return ret\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    //Your implementation goes here\n    return []string{}\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp1tmms9qg_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp1tmms9qg_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp1tmms9qg_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp1tmms9qg_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 0
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var res []string\n    var temp string\n    var open_count\
    \ int\n    for _, ch := range paren_string {\n        switch ch {\n        case\
    \ '(':\n            open_count++\n            temp += string(ch)\n        case\
    \ ')':\n            open_count--\n            temp += string(ch)\n           \
    \ if open_count == 0 {\n                res = append(res, temp)\n            \
    \    temp = \"\"\n            }\n        }\n    }\n    return res\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073960
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    panic(\"You need to implement this function\")\n}\n\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: You need to implement\
    \ this function [recovered]\n\tpanic: You need to implement this function\n\n\
    goroutine 6 [running]:\ntesting.tRunner.func1.2({0x4fcd60, 0x548950})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x4fcd60, 0x548950})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.separate_paren_groups(...)\n\t/tmp/tmpmh5w59ok_test.go:15\n\
    command-line-arguments_test.TestSeparate_Paren_Groups(0x0?)\n\t/tmp/tmpmh5w59ok_test.go:25\
    \ +0x27\ntesting.tRunner(0xc0001a01a0, 0x527d68)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073960
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var rtn []string\n    return rtn\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpnq8hcxqk_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpnq8hcxqk_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpnq8hcxqk_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpnq8hcxqk_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073960
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    var group string\n    for _,c\
    \ := range paren_string {\n        if string(c) == \" \" {\n            continue\n\
    \        }\n        if string(c) == \"(\" {\n            group += string(c)\n\
    \        } else {\n            group += string(c)\n            result = append(result,\
    \ group)\n            group = \"\"\n        }\n    }\n    return result\n}\n\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpbc6uz4___test.go:48: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(() () ) ((() ) ) () ((() ) () () )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpbc6uz4___test.go:48: expected '[() (()) ((())) (((())))]',\
    \ got '[() (() ) ((() ) ) (((() ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpbc6uz4___test.go:48: expected '[(()(())((())))]', got '[(()\
    \ (() ) ((() ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n\
    \        tmpbc6uz4___test.go:48: expected '[() (()) (()())]', got '[() (() ) (()\
    \ () )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // TODO: Implement this function\n    return nil\n}\n\
    \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp3nqnki6x_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp3nqnki6x_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp3nqnki6x_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp3nqnki6x_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Write your implementation here\n    return []string{}\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpkilrn0g6_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpkilrn0g6_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpkilrn0g6_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpkilrn0g6_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return make([]string, 0)\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp6zmlxl7c_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp6zmlxl7c_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp6zmlxl7c_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp6zmlxl7c_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // TODO\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpoyd_w9y9_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpoyd_w9y9_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpoyd_w9y9_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpoyd_w9y9_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n\treturn nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpz7cbln62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpz7cbln62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpz7cbln62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpz7cbln62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 0
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var ret_list []string\n    var cur_str string\n    balance\
    \ := 0\n    for _, char := range paren_string {\n        if char == '(' {\n  \
    \          balance += 1\n        } else if char == ')' {\n            balance\
    \ -= 1\n        } else {\n            continue\n        }\n        cur_str +=\
    \ string(char)\n        if balance == 0 {\n            ret_list = append(ret_list,\
    \ cur_str)\n            cur_str = \"\"\n        }\n    }\n    return ret_list\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n\tvar groups []string\n\tvar parens int\n\tvar start, end\
    \ int\n\tfor i,c := range paren_string {\n\t\tif c == '(' {\n\t\t\tif parens ==\
    \ 0 {\n\t\t\t\tstart = i\n\t\t\t}\n\t\t\tparens++\n\t\t} else if c == ')' {\n\t\
    \t\tparens--\n\t\t\tif parens == 0 {\n\t\t\t\tend = i\n\t\t\t\tgroups = append(groups,\
    \ paren_string[start:end+1])\n\t\t\t}\n\t\t}\n\t}\n\treturn groups\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp39n5xpf8_test.go:51: expected '[() (()) (()())]', got '[(\
    \ ) (( )) (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    panic(\"TODO\")\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: TODO [recovered]\n\t\
    panic: TODO\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x4fcd60, 0x548930})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x4fcd60,\
    \ 0x548930})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.separate_paren_groups(...)\n\t/tmp/tmpdguten9u_test.go:15\n\
    command-line-arguments_test.TestSeparate_Paren_Groups(0x0?)\n\t/tmp/tmpdguten9u_test.go:25\
    \ +0x27\ntesting.tRunner(0xc0001a0340, 0x527d48)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    output := make([]string, 0)\n    left_paren_count :=\
    \ 0\n    right_paren_count := 0\n    current_paren_group := \"\"\n    for _, char\
    \ := range paren_string {\n        if string(char) == \"(\" {\n            left_paren_count++\n\
    \            current_paren_group += string(char)\n        } else if string(char)\
    \ == \")\" {\n            right_paren_count++\n            current_paren_group\
    \ += string(char)\n        }\n        if left_paren_count == right_paren_count\
    \ {\n            output = append(output, current_paren_group)\n            current_paren_group\
    \ = \"\"\n            left_paren_count = 0\n            right_paren_count = 0\n\
    \        }\n    }\n    return output\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpxsodagbq_test.go:53: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()())  ((()))  ()  ((())()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpxsodagbq_test.go:53: expected '[() (()) ((())) (((())))]',\
    \ got '[()  (())  ((()))  (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpxsodagbq_test.go:53: expected '[() (()) (()())]', got '[()\
    \  (())  (()())]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 0
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    groups := make([]string, 0)\n    current_group := \"\
    \"\n    depth := 0\n    for _, paren := range paren_string {\n        switch paren\
    \ {\n        case '(':\n            depth++\n            current_group += string(paren)\n\
    \        case ')':\n            depth--\n            current_group += string(paren)\n\
    \            if depth == 0 {\n                groups = append(groups, current_group)\n\
    \                current_group = \"\"\n            }\n        }\n    }\n    return\
    \ groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate :=\
    \ separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected:\
    \ []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"\
    ( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpa0egrxcy_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpa0egrxcy_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpa0egrxcy_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpa0egrxcy_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var res []string\n    var current_res string\n    for\
    \ _, c := range paren_string {\n        if c == ' ' {\n            continue\n\
    \        } else if c == '(' {\n            current_res += string(c)\n        }\
    \ else if c == ')' {\n            current_res += string(c)\n            res =\
    \ append(res, current_res)\n            current_res = \"\"\n        }\n    }\n\
    \    return res\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpiy07nwni_test.go:47: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(() () ) ((() ) ) () ((() ) () () )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpiy07nwni_test.go:47: expected '[() (()) ((())) (((())))]',\
    \ got '[() (() ) ((() ) ) (((() ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpiy07nwni_test.go:47: expected '[(()(())((())))]', got '[(()\
    \ (() ) ((() ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n\
    \        tmpiy07nwni_test.go:47: expected '[() (()) (()())]', got '[() (() ) (()\
    \ () )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Make sure we're not given an empty string\n    if\
    \ paren_string == \"\" {\n        return []string{}\n    }\n\n    var groups []string\n\
    \    var curGroup string\n\n    // Keep a stack of open parens to track the current\
    \ group\n    var open_parens []string\n\n    // Track the position that the group\
    \ started at\n    group_start := 0\n\n    // Iterate through the characters in\
    \ the string\n    for pos, char := range paren_string {\n        // Ignore spaces\n\
    \        if char == ' ' {\n            continue\n        }\n\n        if char\
    \ == '(' {\n            open_parens = append(open_parens, \"(\")\n        } else\
    \ if char == ')' {\n            // This should never happen unless there's a bug\
    \ in our logic or the input is malformed\n            if len(open_parens) == 0\
    \ {\n                panic(\"Closing paren without a matching open paren\")\n\
    \            }\n\n            // Remove the last open paren from the stack\n \
    \           open_parens = open_parens[:len(open_parens)-1]\n\n            // If\
    \ we've just closed the last open paren, we need to save this group\n        \
    \    if len(open_parens) == 0 {\n                // But if we haven't yet added\
    \ anything to the group, this is an empty group, which we can ignore\n       \
    \         if group_start == pos {\n                    continue\n            \
    \    }\n\n                // Add this group to the list\n                groups\
    \ = append(groups, paren_string[group_start:pos+1])\n            }\n        }\
    \ else {\n            // We should never get here\n            panic(fmt.Sprintf(\"\
    Unexpected character: %s\", string(char)))\n        }\n    }\n\n    return groups\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgutinjf5_test.go:21:9: curGroup declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var opened int\n    var result []string\n    var buffer\
    \ string\n    for _,v := range paren_string {\n        // ascii for ( is 40, for\
    \ ) is 41\n        if v == 40 {\n            if opened == 0 {\n              \
    \  result = append(result, buffer)\n                buffer = \"\"\n          \
    \  }\n            opened++\n        } else if v == 41 {\n            opened--\n\
    \        } else {\n            continue\n        }\n        buffer += string(v)\n\
    \    }\n    result = append(result, buffer)\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpxbx7zzoh_test.go:53: expected '[(()()) ((())) () ((())()())]',\
    \ got '[ (()()) ((())) () ((())()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpxbx7zzoh_test.go:53: expected '[() (()) ((())) (((())))]',\
    \ got '[ () (()) ((())) (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpxbx7zzoh_test.go:53: expected '[(()(())((())))]', got '[\
    \ (()(())((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n\
    \        tmpxbx7zzoh_test.go:53: expected '[() (()) (()())]', got '[ () (()) (()())]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // implement this function\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwu05l_zj_test.go:16:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var group_count int\n    var groups []string\n    var\
    \ group string\n    for _, char := range paren_string {\n        if char == '('\
    \ {\n            group_count += 1\n            group += string(char)\n       \
    \ } else if char == ')' {\n            group_count -= 1\n            group +=\
    \ string(char)\n        }\n        if group_count == 0 {\n            groups =\
    \ append(groups, group)\n            group = \"\"\n        }\n    }\n    return\
    \ groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate :=\
    \ separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected:\
    \ []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"\
    ( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpwgh0t5p4_test.go:50: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()())  ((()))  ()  ((())()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpwgh0t5p4_test.go:50: expected '[() (()) ((())) (((())))]',\
    \ got '[()  (())  ((()))  (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpwgh0t5p4_test.go:50: expected '[() (()) (()())]', got '[()\
    \  (())  (()())]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    open_brace_count := 0\n    open_brace_index := 0\n \
    \   output := make([]string, 0)\n    for i, c := range paren_string {\n      \
    \  if c == '(' {\n            if open_brace_count == 0 {\n                open_brace_index\
    \ = i\n            }\n            open_brace_count++\n        } else if c == ')'\
    \ {\n            open_brace_count--\n            if open_brace_count == 0 {\n\
    \                output = append(output, paren_string[open_brace_index:i+1])\n\
    \            }\n        }\n    }\n    return output\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpti7fn8q__test.go:50: expected '[() (()) (()())]', got '[(\
    \ ) (( )) (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups := make([]string, 0)\n    group := \"\"\
    \n    group_opened := false\n    for _, char := range paren_string {\n       \
    \ if char == '(' {\n            if group_opened {\n                paren_groups\
    \ = append(paren_groups, group)\n                group = \"\"\n            }\n\
    \            group_opened = true\n            group += string(char)\n        }\
    \ else if char == ')' {\n            group += string(char)\n            group_opened\
    \ = false\n        }\n    }\n    if group_opened {\n        paren_groups = append(paren_groups,\
    \ group)\n    }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpzqtjaaax_test.go:53: expected '[(()()) ((())) () ((())()())]',\
    \ got '[( ()())( ( ()))()( (]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpzqtjaaax_test.go:53: expected '[() (()) ((())) (((())))]',\
    \ got '[()( ())( ( ()))( ( (]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpzqtjaaax_test.go:53: expected '[(()(())((())))]', got '[(\
    \ ()( ())( (]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n\
    \        tmpzqtjaaax_test.go:53: expected '[() (()) (()())]', got '[()( ())(]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 0
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    var current string\n    open_count\
    \ := 0\n    for _, c := range paren_string {\n        if c == '(' {\n        \
    \    open_count++\n        } else if c == ')' {\n            open_count--\n  \
    \      }\n        if c != ' ' {\n            current += string(c)\n        }\n\
    \        if open_count == 0 {\n            if current != \"\" {\n            \
    \    result = append(result, current)\n                current = \"\"\n      \
    \      }\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    res := make([]string, 0)\n    parenStack := make([]rune,\
    \ 0)\n    for _, r := range paren_string {\n        if r == '(' {\n          \
    \  parenStack = append(parenStack, r)\n        } else if r == ')' {\n        \
    \    if len(parenStack) > 0 {\n                parenStack = parenStack[:len(parenStack)-1]\n\
    \            }\n        }\n    }\n    return res\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpg4xzvw0s_test.go:45: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpg4xzvw0s_test.go:45: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpg4xzvw0s_test.go:45:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpg4xzvw0s_test.go:45: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    var current string\n    var\
    \ count int\n    for _, c := range paren_string {\n        switch c {\n      \
    \  case '(':\n            count++\n            current += string(c)\n        case\
    \ ')':\n            count--\n            current += string(c)\n        }\n   \
    \     if count == 0 {\n            result = append(result, current)\n        \
    \    current = \"\"\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpz71h0v84_test.go:51: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()())  ((()))  ()  ((())()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpz71h0v84_test.go:51: expected '[() (()) ((())) (((())))]',\
    \ got '[()  (())  ((()))  (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpz71h0v84_test.go:51: expected '[() (()) (()())]', got '[()\
    \  (())  (()())]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Create output array\n    out := make([]string, 0)\n\
    \n    // Convert input string to rune slice\n    runes := []rune(paren_string)\n\
    \n    // Main logic loop\n    parenCount := 0\n    start := 0\n    end := 0\n\
    \    for i, r := range runes {\n        if r == '(' {\n            if parenCount\
    \ == 0 {\n                start = i\n            }\n            parenCount++\n\
    \        } else if r == ')' {\n            parenCount--\n            if parenCount\
    \ == 0 {\n                end = i\n                out = append(out, string(runes[start:end+1]))\n\
    \            }\n        }\n    }\n\n    return out\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp6_3qditx_test.go:59: expected '[() (()) (()())]', got '[(\
    \ ) (( )) (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073961
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n\t// Implement me!\n\treturn nil\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpopyxuuep_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpopyxuuep_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpopyxuuep_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpopyxuuep_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073962
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // if the string is length 0 then there are no groups\n\
    \    if len(paren_string) == 0 {\n        return []string{}\n    }\n\n    // if\
    \ the first character is not an open paren then this is not a valid string\n \
    \   if paren_string[0] != '(' {\n        return []string{}\n    }\n\n    // iterate\
    \ over the string and count the number of open and closed parens. When we reach\
    \ the same\n    // number of open and closed parens then that is the end of this\
    \ group.\n    // Use counter to keep track of number of open and closed parens.\n\
    \    counter := 0\n    // Use paren_groups to store the final values\n    paren_groups\
    \ := []string{}\n    // Use current_group to store the current group (possible\
    \ start of new group)\n    current_group := \"\"\n    // Use start_of_group to\
    \ mark the start of the group (used to extract substring)\n    start_of_group\
    \ := 0\n    // Use in_group to mark if we are currently inside a group\n    in_group\
    \ := false\n    // Track i through the string\n    for i := 0; i < len(paren_string);\
    \ i++ {\n        char := paren_string[i]\n        if char == '(' {\n         \
    \   // Increment the counter\n            counter++\n            // If this is\
    \ the start of a group, mark the start of the group\n            if !in_group\
    \ {\n                in_group = true\n                start_of_group = i\n   \
    \         }\n        } else if char == ')' {\n            // Decrement the counter\n\
    \            counter--\n            // If this closes the group, store the current\
    \ group\n            if counter == 0 {\n                in_group = false\n   \
    \             current_group = paren_string[start_of_group:i+1]\n             \
    \   paren_groups = append(paren_groups, current_group)\n            }\n      \
    \  }\n    }\n\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp8w0k0w2v_test.go:79: expected '[() (()) (()())]', got '[(\
    \ ) (( )) (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073962
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpa0egrxcy_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpa0egrxcy_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpa0egrxcy_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpa0egrxcy_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 0
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    var current string\n    nesting\
    \ := 0\n    for _, c := range paren_string {\n        if c == ' ' {\n        \
    \    continue\n        }\n        if c == '(' {\n            nesting++\n     \
    \   } else {\n            nesting--\n        }\n        current += string(c)\n\
    \        if nesting == 0 {\n            result = append(result, current)\n   \
    \         current = \"\"\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073962
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    fmt.Println(\"Separating groups from : \", paren_string)\n\
    \    var groups []string\n    var index int = 0\n    var current string = \"\"\
    \n    var cnt int = 0\n    for i, c := range paren_string {\n        if c == '('\
    \ {\n            cnt++\n        } else if c == ')' {\n            cnt--\n    \
    \    }\n        current += string(c)\n        if cnt == 0 {\n            index\
    \ = i + 1\n            groups = append(groups, current)\n            current =\
    \ \"\"\n        }\n    }\n    return groups\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvjzji4bn_test.go:17:9: index declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073962
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n\n    // write a function that\
    \ find the next parenthesis\n    var open_paren_count int = 0\n    var open_paren_index\
    \ int = -1\n    var close_paren_index int = -1\n    var i int\n    for i = 0;\
    \ i < len(paren_string); i++ {\n        if paren_string[i] == '(' {\n        \
    \    if open_paren_count == 0 {\n                open_paren_index = i\n      \
    \      }\n            open_paren_count++\n        }\n        if paren_string[i]\
    \ == ')' {\n            open_paren_count--\n            if open_paren_count ==\
    \ 0 {\n                close_paren_index = i\n                result = append(result,\
    \ paren_string[open_paren_index:close_paren_index+1])\n            }\n       \
    \ }\n    }\n\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpt9g1fxd6_test.go:57: expected '[() (()) (()())]', got '[(\
    \ ) (( )) (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    open_parens := 0\n    slice_start := 0\n    var paren_groups\
    \ []string\n    for i, val := range paren_string {\n        if val == '(' {\n\
    \            if open_parens == 0 {\n                slice_start = i\n        \
    \    }\n            open_parens++\n        } else if val == ')' {\n          \
    \  open_parens--\n            if open_parens == 0 {\n                paren_groups\
    \ = append(paren_groups, paren_string[slice_start:i+1])\n            }\n     \
    \   }\n    }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpsb7bhsu1_test.go:50: expected '[() (()) (()())]', got '[(\
    \ ) (( )) (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 0
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    var paren_stack []rune\n  \
    \  var temp_string string\n    for _,char := range paren_string {\n        if\
    \ char == '(' {\n            if len(paren_stack) == 0 {\n                temp_string\
    \ = \"\"\n            }\n            paren_stack = append(paren_stack, char)\n\
    \            temp_string += string(char)\n        } else if char == ')' {\n  \
    \          if len(paren_stack) > 0 {\n                paren_stack = paren_stack[:len(paren_stack)-1]\n\
    \                temp_string += string(char)\n            }\n            if len(paren_stack)\
    \ == 0 {\n                result = append(result, temp_string)\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n\n    return result\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp6pw_yl6a_test.go:36: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp6pw_yl6a_test.go:36: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp6pw_yl6a_test.go:36:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp6pw_yl6a_test.go:36: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    groups := make([]string, 0)\n    start := 0\n    openParenCount\
    \ := 0\n    for idx, char := range paren_string {\n        if char == '(' {\n\
    \            openParenCount++\n        } else if char == ')' {\n            openParenCount--\n\
    \        }\n        if openParenCount == 0 {\n            groups = append(groups,\
    \ paren_string[start:idx+1])\n            start = idx + 1\n        }\n    }\n\
    \    return groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpmzu2cydj_test.go:48: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()())   ((()))   ()   ((())()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpmzu2cydj_test.go:48: expected '[() (()) ((())) (((())))]',\
    \ got '[()   (())   ((()))   (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpmzu2cydj_test.go:48: expected '[() (()) (()())]', got '[(\
    \ )   (( ))   (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // TODO: Fill this in\n    return []string{}\n}\n\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp6mv1wwth_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp6mv1wwth_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp6mv1wwth_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp6mv1wwth_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Your code here\n    return []string{}\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpstrtdk9n_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpstrtdk9n_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpstrtdk9n_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpstrtdk9n_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    fmt.Println(\"separate_paren_groups input:\", paren_string)\n\
    \    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n\
    \  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "separate_paren_groups input: (()()) ((())) () ((())()())\nseparate_paren_groups\
    \ input: () (()) ((())) (((())))\nseparate_paren_groups input: (()(())((())))\n\
    separate_paren_groups input: ( ) (( )) (( )( ))\n--- FAIL: TestSeparate_Paren_Groups\
    \ (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0 (0.00s)\n     \
    \   tmp35b2q3tq_test.go:35: expected '[(()()) ((())) () ((())()())]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp35b2q3tq_test.go:35:\
    \ expected '[() (()) ((())) (((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmp35b2q3tq_test.go:35: expected '[(()(())((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp35b2q3tq_test.go:35:\
    \ expected '[() (()) (()())]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    // find the index of the first\
    \ open bracket\n    // loop through until you get to a closing bracket\n    //\
    \  add all the characters in between to a new string\n    // add the new string\
    \ to a list of strings\n    // repeat\n    // return the list of strings\n   \
    \ return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpqxfiw1k3_test.go:41: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpqxfiw1k3_test.go:41: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpqxfiw1k3_test.go:41:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpqxfiw1k3_test.go:41: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    start, end := 0, 0\n    left\
    \ := 0\n    right := 0\n    for i := 0; i < len(paren_string); i++ {\n       \
    \ switch paren_string[i] {\n        case '(':\n            left += 1\n       \
    \ case ')':\n            right += 1\n        }\n        if left == right {\n \
    \           result = append(result, paren_string[start:i+1])\n            start\
    \ = i + 1\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyi2_omge_test.go:16:12: end declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073963
- exit_code: 0
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var separated_strings []string\n    var current_group\
    \ string\n    var balance int\n    for _, c := range paren_string {\n        if\
    \ string(c) == \" \" {\n            continue\n        } else if string(c) == \"\
    (\" {\n            if balance == 0 {\n                current_group = \"(\"\n\
    \            } else {\n                current_group += \"(\"\n            }\n\
    \            balance++\n        } else if string(c) == \")\" {\n            balance--\n\
    \            current_group += \")\"\n            if balance == 0 {\n         \
    \       separated_strings = append(separated_strings, current_group)\n       \
    \     }\n        }\n    }\n    return separated_strings\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    fmt.Println(\"Input string:\", paren_string)\n    groups\
    \ := make([]string, 0)\n    return groups\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Input string: (()()) ((())) () ((())()())\nInput string: () (()) ((()))\
    \ (((())))\nInput string: (()(())((())))\nInput string: ( ) (( )) (( )( ))\n---\
    \ FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp61_7p15f_test.go:36: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp61_7p15f_test.go:36: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp61_7p15f_test.go:36:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp61_7p15f_test.go:36: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Your code here...\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp1v0h0k7h_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp1v0h0k7h_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp1v0h0k7h_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp1v0h0k7h_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    groups := make([]string, 0)\n    current := \"\"\n \
    \   stack := make([]int, 0)\n    for i := 0; i < len(paren_string); i++ {\n  \
    \      if paren_string[i] == '(' {\n            stack = append(stack, i)\n   \
    \     } else if paren_string[i] == ')' {\n            stack = stack[:len(stack)-1]\n\
    \        }\n        if len(stack) == 0 {\n            // found a paren group\n\
    \            groups = append(groups, paren_string[:i+1])\n            paren_string\
    \ = paren_string[i+1:]\n            i = 0\n        }\n    }\n    return groups\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy9w2jqhy_test.go:16:5: current declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    r := []string{}\n    buf := []byte{}\n    for _, c :=\
    \ range paren_string {\n        if string(c) == \" \" {\n            continue\n\
    \        }\n        if string(c) == \"(\" {\n            buf = append(buf, byte(c))\n\
    \        } else {\n            buf = append(buf, byte(c))\n            r = append(r,\
    \ string(buf))\n            buf = []byte{}\n        }\n    }\n    return r\n}\n\
    \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpue9o1ppq_test.go:48: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(() () ) ((() ) ) () ((() ) () () )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpue9o1ppq_test.go:48: expected '[() (()) ((())) (((())))]',\
    \ got '[() (() ) ((() ) ) (((() ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpue9o1ppq_test.go:48: expected '[(()(())((())))]', got '[(()\
    \ (() ) ((() ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n\
    \        tmpue9o1ppq_test.go:48: expected '[() (()) (()())]', got '[() (() ) (()\
    \ () )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n\treturn []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpvy2mtzsg_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpvy2mtzsg_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpvy2mtzsg_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpvy2mtzsg_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // TODO: IMPLEMENT THIS\n    return []string{}\n}\n\n\
    func TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp5nlhznpb_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp5nlhznpb_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp5nlhznpb_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp5nlhznpb_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var ret []string\n    str := []rune(paren_string)\n\
    \    for i, c := range str {\n        if c == '(' {\n            for j := i; j\
    \ < len(str); j++ {\n                if str[j] == ')' {\n                    ret\
    \ = append(ret, string(str[i:j+1]))\n                    break\n             \
    \   }\n            }\n        }\n    }\n    return ret\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpcr9ss61m_test.go:46: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(() () () ((() (() () () ((() (() () () ()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpcr9ss61m_test.go:46: expected '[() (()) ((())) (((())))]',\
    \ got '[() (() () ((() (() () (((() ((() (() ()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpcr9ss61m_test.go:46: expected '[(()(())((())))]', got '[(()\
    \ () (() () ((() (() ()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpcr9ss61m_test.go:46: expected '[() (()) (()())]', got '[(\
    \ ) (( ) ( ) (( ) ( ) ( )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // TODO: separate groups of parentheses and return the\
    \ list of them.\n    // For example: \"( () (( )) (( )( )) )\" should become []string{\"\
    ()\", \"(())\", \"(()())\"}\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp_uy9h70e_test.go:36: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp_uy9h70e_test.go:36: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp_uy9h70e_test.go:36:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp_uy9h70e_test.go:36: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    if paren_string == \"\" {\n        return nil\n    }\n\
    \    if paren_string[0] != '(' || paren_string[len(paren_string)-1] != ')' {\n\
    \        return nil\n    }\n    var result []string\n    current := paren_string[1:len(paren_string)-1]\n\
    \    last := current\n    for {\n        current = prune(current)\n        fmt.Println(current)\n\
    \        if current == last {\n            result = append(result, current)\n\
    \            break\n        }\n        last = current\n    }\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyxk06kua_test.go:25:19: undefined: prune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073964
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    //fill in the body of this function\n    return []string{}\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp4vgk_zwk_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp4vgk_zwk_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp4vgk_zwk_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp4vgk_zwk_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073964
- exit_code: 0
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Create a stack to keep track of parens\n    stack\
    \ := make([]string, 0)\n    word := \"\"\n    paren_list := make([]string, 0)\n\
    \    // Iterate through each character in the string\n    for _, char := range\
    \ paren_string {\n        // If the character is a space, continue\n        if\
    \ char == 32 {\n            continue\n        }\n        if string(char) == \"\
    (\" {\n            stack = append(stack, string(char))\n        } else if string(char)\
    \ == \")\" {\n            if len(stack) == 0 {\n                return nil\n \
    \           }\n            stack = stack[:len(stack)-1]\n        }\n        word\
    \ += string(char)\n        if len(stack) == 0 {\n            paren_list = append(paren_list,\
    \ word)\n            word = \"\"\n        }\n    }\n    return paren_list\n}\n\
    \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073964
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Build a stack using slices, using zero value to indicate\
    \ end of stack\n    // Stack: [parenthesis-char, closing-paren-index]\n    stack\
    \ := make([]int, 0)\n    // Build a list of groups to return, using zero value\
    \ to indicate end of list\n    groups := make([]string, 0)\n    // Loop through\
    \ the characters in the string one by one\n    for i, c := range paren_string\
    \ {\n        // If the character is a left paren, add a new open paren and the\
    \ index of this character\n        // to the stack, and move on to the next character\n\
    \        if c == '(' {\n            stack = append(stack, i)\n            continue\n\
    \        }\n        // If the character is a right paren, we need to pop the last\
    \ open paren\n        // off the stack and add it to the return list\n       \
    \ if c == ')' {\n            if len(stack) == 0 {\n                // If the stack\
    \ is empty, this is an error.  Return an empty list\n                return groups\n\
    \            }\n            // Pop the last open paren from the stack\n      \
    \      start_index := stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n\
    \            // Add a new group to the list of groups, using the start and end\
    \ index\n            // in the original string to create a substring\n       \
    \     groups = append(groups, paren_string[start_index:i+1])\n        }\n    }\n\
    \    // If the stack isn't empty, the input string had an unbalanced number of\
    \ parens\n    if len(stack) != 0 {\n        // Return an empty list\n        return\
    \ groups\n    }\n    // Return the list of groups\n    return groups\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp5hajynie_test.go:68: expected '[(()()) ((())) () ((())()())]',\
    \ got '[() () (()()) () (()) ((())) () () (()) () () ((())()())]'\n    --- FAIL:\
    \ TestSeparate_Paren_Groups/test_num__1 (0.00s)\n        tmp5hajynie_test.go:68:\
    \ expected '[() (()) ((())) (((())))]', got '[() () (()) () (()) ((())) () (())\
    \ ((())) (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n\
    \        tmp5hajynie_test.go:68: expected '[(()(())((())))]', got '[() () (())\
    \ () (()) ((())) (()(())((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp5hajynie_test.go:68: expected '[() (()) (()())]', got '[(\
    \ ) ( ) (( )) ( ) ( ) (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073965
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // TODO: Implement the function here\n    return []string{}\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpcn67_5k5_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpcn67_5k5_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpcn67_5k5_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpcn67_5k5_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073965
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // YOUR CODE HERE\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp0lyigi70_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp0lyigi70_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp0lyigi70_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp0lyigi70_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n\tfmt.Println(\"Input string is : \", paren_string)\n\t\n\
    \t// First find out where the groups are\n\tvar groups [][]int\n\tvar parenPos\
    \ int\n\tvar openBrace bool = false\n\tfor charPos, char := range paren_string\
    \ {\n\t\tif char == '(' {\n\t\t\tif openBrace == false {\n\t\t\t\topenBrace =\
    \ true\n\t\t\t\tparenPos = charPos\n\t\t\t}\n\t\t} else if char == ')' {\n\t\t\
    \tif openBrace == true {\n\t\t\t\topenBrace = false\n\t\t\t\tgroups = append(groups,\
    \ []int{parenPos, charPos})\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Now con\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmhs_hip9_test.go:36:6: expected ''('', found TestSeparate_Paren_Groups

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073964
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Your code here\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpgk0mw_vi_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpgk0mw_vi_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpgk0mw_vi_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpgk0mw_vi_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    groups := make([]string, 0)\n    group_start := -1\n\
    \    group_count := 0\n    for i, c := range paren_string {\n        if c == '('\
    \ {\n            if group_count == 0 {\n                group_start = i\n    \
    \        }\n            group_count++\n        } else if c == ')' {\n        \
    \    group_count--\n            if group_count == 0 {\n                groups\
    \ = append(groups, paren_string[group_start:i+1])\n            }\n        }\n\
    \    }\n    return groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n\
    \  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmphxzoc4ow_test.go:50: expected '[() (()) (()())]', got '[(\
    \ ) (( )) (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073965
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    groups := make([]string, 0)\n    group := \"\"\n   \
    \ depth := 0\n    for _, r := range paren_string {\n        if r == '(' {\n  \
    \          depth++\n            group += string(r)\n        } else if r == ')'\
    \ {\n            if depth == 1 {\n                groups = append(groups, group)\n\
    \                group = \"\"\n            } else {\n                group +=\
    \ string(r)\n            }\n            depth--\n        }\n    }\n    return\
    \ groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate :=\
    \ separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected:\
    \ []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"\
    ( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpbcyolmti_test.go:51: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()() ((()) ( ((())()()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpbcyolmti_test.go:51: expected '[() (()) ((())) (((())))]',\
    \ got '[( (() ((()) (((()))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpbcyolmti_test.go:51: expected '[(()(())((())))]', got '[(()(())((()))]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpbcyolmti_test.go:51:\
    \ expected '[() (()) (()())]', got '[( (() (()()]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups := make([]string, 0)\n    tmp_str := \"\
    \"\n    paren_balance := 0\n    for _, char := range paren_string {\n        if\
    \ char == '(' {\n            paren_balance++\n        } else if char == ')' {\n\
    \            paren_balance--\n        }\n        if paren_balance != 0 {\n   \
    \         tmp_str += string(char)\n        } else {\n            paren_groups\
    \ = append(paren_groups, tmp_str)\n            tmp_str = \"\"\n        }\n   \
    \ }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpcssnid2x_test.go:50: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()()  ((())  (  ((())()()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpcssnid2x_test.go:50: expected '[() (()) ((())) (((())))]',\
    \ got '[(  (()  ((())  (((()))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpcssnid2x_test.go:50: expected '[(()(())((())))]', got '[(()(())((()))]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmpcssnid2x_test.go:50:\
    \ expected '[() (()) (()())]', got '[(   (( )  (( )( )]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var group string\n    var paren_groups []string\n  \
    \  var open_paren_count, close_paren_count int\n\n    for _, char := range paren_string\
    \ {\n        group += string(char)\n        switch string(char) {\n        case\
    \ \"(\":\n            open_paren_count++\n        case \")\":\n            close_paren_count++\n\
    \        }\n        if open_paren_count == close_paren_count {\n            paren_groups\
    \ = append(paren_groups, group)\n            group = \"\"\n            open_paren_count\
    \ = 0\n            close_paren_count = 0\n        }\n    }\n    return paren_groups\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp_qugnlj5_test.go:53: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()())   ((()))   ()   ((())()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmp_qugnlj5_test.go:53: expected '[() (()) ((())) (((())))]',\
    \ got '[()   (())   ((()))   (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp_qugnlj5_test.go:53: expected '[() (()) (()())]', got '[(\
    \ )   (( ))   (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // code here\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpyj980yps_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpyj980yps_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpyj980yps_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpyj980yps_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 0
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    group_separated := []string{}\n    var current_group\
    \ string\n    current_group_depth := 0\n    for _, c := range paren_string {\n\
    \        if c == ' ' {\n            continue\n        }\n        if c == '(' {\n\
    \            current_group_depth += 1\n        } else if c == ')' {\n        \
    \    current_group_depth -= 1\n        }\n        current_group += string(c)\n\
    \        if current_group_depth == 0 {\n            group_separated = append(group_separated,\
    \ current_group)\n            current_group = \"\"\n        }\n    }\n    return\
    \ group_separated\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    // write your code here\n \
    \   return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpit2p1k2b_test.go:36: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpit2p1k2b_test.go:36: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpit2p1k2b_test.go:36:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpit2p1k2b_test.go:36: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var s []string\n    return s\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp223jndq2_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp223jndq2_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp223jndq2_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp223jndq2_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n\treturn []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpvy2mtzsg_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpvy2mtzsg_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpvy2mtzsg_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpvy2mtzsg_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // \n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpgumvcw7i_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpgumvcw7i_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpgumvcw7i_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpgumvcw7i_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    var groups [][]byte\n    var\
    \ index int\n    for i, rune := range paren_string {\n        if rune == '(' {\n\
    \            index = i\n        } else if rune == ')' {\n            groups =\
    \ append(groups, []byte(paren_string[index:i+1]))\n        }\n    }\n    for _,\
    \ group := range groups {\n        result = append(result, string(group))\n  \
    \  }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n\
    \  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpsi0ki197_test.go:47: expected '[(()()) ((())) () ((())()())]',\
    \ got '[() () ()) () ()) ())) () () ()) () () ())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpsi0ki197_test.go:47: expected '[() (()) ((())) (((())))]',\
    \ got '[() () ()) () ()) ())) () ()) ())) ())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpsi0ki197_test.go:47: expected '[(()(())((())))]', got '[()\
    \ () ()) () ()) ())) ())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpsi0ki197_test.go:47: expected '[() (()) (()())]', got '[(\
    \ ) ( ) ( )) ( ) ( ) ( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // todo\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpxxgxswrn_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpxxgxswrn_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpxxgxswrn_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpxxgxswrn_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var open, closed, start int\n    var res []string\n\
    \    for i, ch := range paren_string {\n        if ch == '(' {\n            if\
    \ open == 0 {\n                start = i\n            }\n            open++\n\
    \        } else if ch == ')' {\n            closed++\n            if open == closed\
    \ {\n                res = append(res, paren_string[start:i+1])\n            \
    \    open, closed = 0, 0\n            }\n        }\n    }\n    return res\n}\n\
    \nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpr6xi68hl_test.go:50: expected '[() (()) (()())]', got '[(\
    \ ) (( )) (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    var current string\n    var\
    \ openBrace int = 0\n    var closedBrace int = 0\n    for _, val := range paren_string\
    \ {\n        if string(val) == \"(\" {\n            openBrace++\n        }\n \
    \       if string(val) == \")\" {\n            closedBrace++\n        }\n    \
    \    current += string(val)\n        if openBrace == closedBrace {\n         \
    \   result = append(result, current)\n            current = \"\"\n           \
    \ openBrace = 0\n            closedBrace = 0\n        }\n    }\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpnsu0ixdf_test.go:53: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()())   ((()))   ()   ((())()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpnsu0ixdf_test.go:53: expected '[() (()) ((())) (((())))]',\
    \ got '[()   (())   ((()))   (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpnsu0ixdf_test.go:53: expected '[() (()) (()())]', got '[(\
    \ )   (( ))   (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    results := make([]string, 0)\n    chars := []rune(paren_string)\n\
    \    for i, char := range chars {\n        if char == '(' {\n            begin\
    \ := i\n            end := begin\n            for c := 0; c >= 0; {\n        \
    \        if chars[end] == '(' {\n                    c++\n                } else\
    \ if chars[end] == ')' {\n                    c--\n                }\n       \
    \         end++\n            }\n            results = append(results, string(chars[begin:end-1]))\n\
    \        }\n    }\n    return results\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: runtime error: index\
    \ out of range [27] with length 27 [recovered]\n\tpanic: runtime error: index\
    \ out of range [27] with length 27\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513720,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513720, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.separate_paren_groups(...)\n\t/tmp/tmprwena9v9_test.go:22\n\
    command-line-arguments_test.TestSeparate_Paren_Groups(0x0?)\n\t/tmp/tmprwena9v9_test.go:42\
    \ +0xbbb\ntesting.tRunner(0xc0001924e0, 0x5290c0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpa0egrxcy_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpa0egrxcy_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpa0egrxcy_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpa0egrxcy_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    var current_group string\n\
    \    for _, character := range paren_string {\n        if character == '(' {\n\
    \            if current_group != \"\" {\n                panic(\"Invalid input\
    \ string\")\n            }\n            current_group = \"(\"\n        } else\
    \ if character == ')' {\n            if current_group == \"\" {\n            \
    \    panic(\"Invalid input string\")\n            }\n            current_group\
    \ += \")\"\n            result = append(result, current_group)\n            current_group\
    \ = \"\"\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: Invalid input string\
    \ [recovered]\n\tpanic: Invalid input string\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x4fde60,\
    \ 0x549de0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x4fde60, 0x549de0})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.separate_paren_groups(...)\n\t/tmp/tmpffxqjnzy_test.go:20\n\
    command-line-arguments_test.TestSeparate_Paren_Groups(0x0?)\n\t/tmp/tmpffxqjnzy_test.go:42\
    \ +0xc25\ntesting.tRunner(0xc0001924e0, 0x5290d8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    fmt.Println(\"In the input string of: \", paren_string)\n\
    \    group := []string{}\n    i := 0\n    for i < len(paren_string) {\n      \
    \  if string(paren_string[i]) == \"(\" {\n            // we are at the beginning\
    \ of a group\n            fmt.Println(\"Found an opening paren at \", i)\n   \
    \         group = append(group, string(paren_string[i]))\n            i++\n  \
    \          for i < len(paren_string) && string(paren_string[i]) != \")\" {\n \
    \               group = append(group, string(paren_string[i]))\n             \
    \   i++\n            }\n            if i < len(paren_string) {\n             \
    \   group = append(group, string(paren_string[i]))\n                fmt.Println(\"\
    Found a closing paren at \", i)\n                i++\n            }\n        }\
    \ else {\n            i++\n        }\n    }\n    return group\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "In the input string of:  (()()) ((())) () ((())()())\nFound an opening\
    \ paren at  0\nFound a closing paren at  2\nFound an opening paren at  3\nFound\
    \ a closing paren at  4\nFound an opening paren at  7\nFound a closing paren at\
    \  10\nFound an opening paren at  14\nFound a closing paren at  15\nFound an opening\
    \ paren at  17\nFound a closing paren at  20\nFound an opening paren at  22\n\
    Found a closing paren at  23\nFound an opening paren at  24\nFound a closing paren\
    \ at  25\nIn the input string of:  () (()) ((())) (((())))\nFound an opening paren\
    \ at  0\nFound a closing paren at  1\nFound an opening paren at  3\nFound a closing\
    \ paren at  5\nFound an opening paren at  8\nFound a closing paren at  11\nFound\
    \ an opening paren at  15\nFound a closing paren at  19\nIn the input string of:\
    \  (()(())((())))\nFound an opening paren at  0\nFound a closing paren at  2\n\
    Found an opening paren at  3\nFound a closing paren at  5\nFound an opening paren\
    \ at  7\nFound a closing paren at  10\nIn the input string of:  ( ) (( )) (( )(\
    \ ))\nFound an opening paren at  0\nFound a closing paren at  2\nFound an opening\
    \ paren at  4\nFound a closing paren at  7\nFound an opening paren at  10\nFound\
    \ a closing paren at  13\nFound an opening paren at  14\nFound a closing paren\
    \ at  16\n--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpi3za2lft_test.go:56: expected '[(()()) ((())) () ((())()())]',\
    \ got '[( ( ) ( ) ( ( ( ) ( ) ( ( ( ) ( ) ( )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpi3za2lft_test.go:56: expected '[() (()) ((())) (((())))]',\
    \ got '[( ) ( ( ) ( ( ( ) ( ( ( ( )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpi3za2lft_test.go:56: expected '[(()(())((())))]', got '[(\
    \ ( ) ( ( ) ( ( ( )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n\
    \        tmpi3za2lft_test.go:56: expected '[() (()) (()())]', got '[(   ) ( (\
    \   ) ( (   ) (   )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var prev_c rune\n    var s []string\n    var c string\n\
    \    for _, v := range paren_string {\n        switch v {\n        case '(':\n\
    \            if prev_c == ')' {\n                s = append(s, c)\n          \
    \      c = \"\"\n            }\n            c += string(v)\n        case ')':\n\
    \            c += string(v)\n        }\n        prev_c = v\n    }\n    s = append(s,\
    \ c)\n    return s\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmperl4vplb_test.go:51: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(() ())((()))()((()) () ())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmperl4vplb_test.go:51: expected '[() (()) ((())) (((())))]',\
    \ got '[()(())((()))(((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmperl4vplb_test.go:51: expected '[(()(())((())))]', got '[(()\
    \ (()) ((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n\
    \        tmperl4vplb_test.go:51: expected '[() (()) (()())]', got '[()(())(()\
    \ ())]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    results := make([]string, 0)\n    paren_chars := []rune(paren_string)\n\
    \    last_end := 0\n    cur_start := 0\n    cur_end := 0\n    inside_parens :=\
    \ false\n    for i, cur_char := range paren_chars {\n        cur_end = i\n   \
    \     if cur_char == '(' {\n            if !inside_parens {\n                inside_parens\
    \ = true\n                cur_start = i\n            }\n        } else if cur_char\
    \ == ')' {\n            if inside_parens {\n                inside_parens = false\n\
    \                results = append(results, string(paren_chars[cur_start:cur_end+1]))\n\
    \                last_end = cur_end + 1\n            }\n        }\n    }\n   \
    \ return results\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb2pgbwgs_test.go:17:5: last_end declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    ret := make([]string, 0)\n    s := 0\n    g := 0\n \
    \   for i := 0; i < len(paren_string); i++ {\n        switch paren_string[i] {\n\
    \        case '(':\n            g++\n        case ')':\n            g--\n    \
    \    }\n        if paren_string[i] == ' ' {\n            continue\n        }\n\
    \        if g == 0 {\n            ret = append(ret, paren_string[s:i+1])\n   \
    \         s = i + 1\n        }\n    }\n    return ret\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp7fxvp4q__test.go:52: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()())  ((()))  ()  ((())()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmp7fxvp4q__test.go:52: expected '[() (()) ((())) (((())))]',\
    \ got '[()  (())  ((()))  (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp7fxvp4q__test.go:52: expected '[() (()) (()())]', got '[(\
    \ )  (( ))  (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n\treturn nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpz7cbln62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpz7cbln62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpz7cbln62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpz7cbln62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    var left_paren, right_paren\
    \ int\n    for i, j := 0, len(paren_string) - 1; i < j; i, j = i + 1, j - 1 {\n\
    \        switch paren_string[i] {\n        case '(':\n            left_paren++\n\
    \        case ')':\n            right_paren++\n        }\n        switch paren_string[j]\
    \ {\n        case '(':\n            left_paren++\n        case ')':\n        \
    \    right_paren++\n        }\n        if left_paren == right_paren {\n      \
    \      result = append(result, paren_string[i+1:j])\n            left_paren, right_paren\
    \ = 0, 0\n        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpehxzp7h6_test.go:54: expected '[(()()) ((())) () ((())()())]',\
    \ got '[()()) ((())) () ((())()() )()) ((())) () ((())()( ()) ((())) () ((())()\
    \ )) ((())) () ((())( ) ((())) () ((()) ) (  ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpehxzp7h6_test.go:54: expected '[() (()) ((())) (((())))]',\
    \ got '[) (()) ((())) (((())) ((())) ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpehxzp7h6_test.go:54: expected '[(()(())((())))]', got '[()(())((()))\
    \ )(())((()) ))(( )( ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n\
    \        tmpehxzp7h6_test.go:54: expected '[() (()) (()())]', got '[ ) (( )) ((\
    \ )( )  )) (( ]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073966
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups := make([]string, 0)\n    paren_groups\
    \ = append(paren_groups, \"()\")\n    paren_groups = append(paren_groups, \"(())\"\
    )\n    paren_groups = append(paren_groups, \"(()())\")\n    return paren_groups\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp2i_eqoky_test.go:38: expected '[(()()) ((())) () ((())()())]',\
    \ got '[() (()) (()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmp2i_eqoky_test.go:38: expected '[() (()) ((())) (((())))]',\
    \ got '[() (()) (()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmp2i_eqoky_test.go:38: expected '[(()(())((())))]', got '[()\
    \ (()) (()())]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073967
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // your solution here\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpfvrlfeix_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpfvrlfeix_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpfvrlfeix_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpfvrlfeix_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073967
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // initialize output list of strings\n    // initialize\
    \ current string\n    // initialize current index to 0\n    // for loop over the\
    \ string\n        // if char at current index is a space, ignore\n        // if\
    \ char at current index is an open paren, push onto stack\n        // if char\
    \ at current index is a close paren, pop off the stack, add to current string\n\
    \        // if stack is empty, we are done with this group of parentheses, add\
    \ current string to output list\n        // and reset the current string\n   \
    \ return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp5yst3449_test.go:43: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp5yst3449_test.go:43: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp5yst3449_test.go:43:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp5yst3449_test.go:43: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073967
- exit_code: 0
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n\tresult := make([]string, 0)\n\tvar cur_group string\n\t\
    nest_level := 0\n\tfor _, char := range paren_string {\n\t\tif char == '(' {\n\
    \t\t\tnest_level++\n\t\t\tcur_group += string(char)\n\t\t} else if char == ')'\
    \ {\n\t\t\tnest_level--\n\t\t\tcur_group += string(char)\n\t\t\tif nest_level\
    \ == 0 {\n\t\t\t\tresult = append(result, cur_group)\n\t\t\t\tcur_group = \"\"\
    \n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 0
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups := make([]string, 0)\n    curr_paren_string\
    \ := \"\"\n    paren_level := 0\n    for _, char := range paren_string {\n   \
    \     if char == '(' {\n            if paren_level == 0 {\n                curr_paren_string\
    \ = \"\"\n            }\n            paren_level++\n            curr_paren_string\
    \ += string(char)\n        } else if char == ')' {\n            paren_level--\n\
    \            curr_paren_string += string(char)\n            if paren_level ==\
    \ 0 {\n                paren_groups = append(paren_groups, curr_paren_string)\n\
    \            }\n        }\n    }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpa0egrxcy_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpa0egrxcy_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpa0egrxcy_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpa0egrxcy_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return make([]string, 1)\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpxx9wwn3c_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpxx9wwn3c_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpxx9wwn3c_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpxx9wwn3c_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n\tpanic(\"Implement me!\")\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\npanic: Implement me! [recovered]\n\
    \tpanic: Implement me!\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x4fcd60,\
    \ 0x548940})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x4fcd60, 0x548940})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.separate_paren_groups(...)\n\t/tmp/tmpeykr3k41_test.go:15\n\
    command-line-arguments_test.TestSeparate_Paren_Groups(0x0?)\n\t/tmp/tmpeykr3k41_test.go:25\
    \ +0x27\ntesting.tRunner(0xc0001a01a0, 0x527d50)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Your code here\n    return []string{}\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpstrtdk9n_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpstrtdk9n_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpstrtdk9n_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpstrtdk9n_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\n//\n//\n//\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpi45y9ox8_test.go:37: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpi45y9ox8_test.go:37: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpi45y9ox8_test.go:37:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpi45y9ox8_test.go:37: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // TODO: Implement\n    return []string{}\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp767ohyqt_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp767ohyqt_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp767ohyqt_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp767ohyqt_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    group := \"\"\n    groups := []string{}\n    for _,\
    \ c := range paren_string {\n        if c == ' ' {\n            continue\n   \
    \     }\n        if c == '(' {\n            group += string(c)\n        } else\
    \ {\n            group += string(c)\n            groups = append(groups, group)\n\
    \            group = \"\"\n        }\n    }\n    return groups\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpd_ar4seq_test.go:48: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(() () ) ((() ) ) () ((() ) () () )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpd_ar4seq_test.go:48: expected '[() (()) ((())) (((())))]',\
    \ got '[() (() ) ((() ) ) (((() ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpd_ar4seq_test.go:48: expected '[(()(())((())))]', got '[(()\
    \ (() ) ((() ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n\
    \        tmpd_ar4seq_test.go:48: expected '[() (()) (()())]', got '[() (() ) (()\
    \ () )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\n//func Test_separate_paren_groups(t\
    \ *testing.T) {\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate :=\
    \ separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected:\
    \ []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"\
    ( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpi5k2_iys_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpi5k2_iys_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpi5k2_iys_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpi5k2_iys_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // TODO: implement this!\n    return nil\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpe95vfr5m_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpe95vfr5m_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpe95vfr5m_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpe95vfr5m_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n\tvar groups []string\n\treturn groups\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmps819_5jb_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmps819_5jb_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmps819_5jb_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmps819_5jb_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_groups := make([]string, 0)\n    start_index :=\
    \ 0\n    for cur_index, char := range paren_string {\n        if char == '(' {\n\
    \            start_index = cur_index\n        } else if char == ')' {\n      \
    \      paren_groups = append(paren_groups, paren_string[start_index:cur_index+1])\n\
    \        }\n    }\n    return paren_groups\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpucrqfi56_test.go:43: expected '[(()()) ((())) () ((())()())]',\
    \ got '[() () ()) () ()) ())) () () ()) () () ())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpucrqfi56_test.go:43: expected '[() (()) ((())) (((())))]',\
    \ got '[() () ()) () ()) ())) () ()) ())) ())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpucrqfi56_test.go:43: expected '[(()(())((())))]', got '[()\
    \ () ()) () ()) ())) ())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpucrqfi56_test.go:43: expected '[() (()) (()())]', got '[(\
    \ ) ( ) ( )) ( ) ( ) ( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n\n    return result\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp6pw_yl6a_test.go:36: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmp6pw_yl6a_test.go:36: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmp6pw_yl6a_test.go:36:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp6pw_yl6a_test.go:36: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073963
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n\n    // YOUR CODE HERE\n    return\
    \ result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate :=\
    \ separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"(()())\
    \ ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"()\",\
    \ \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"), expected:\
    \ []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"\
    (()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"\
    ( ) (( )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpkgqx606q_test.go:37: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpkgqx606q_test.go:37: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpkgqx606q_test.go:37:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpkgqx606q_test.go:37: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmprxpqm3i4_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmprxpqm3i4_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmprxpqm3i4_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 2
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    if len(paren_string) == 0 {\n        return []string{}\n\
    \    }\n    paren_string = filter_spaces(paren_string)\n    return filter_nested_parens(seperate_spaces(paren_string))\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppy8uku0i_test.go:18:20: undefined: filter_spaces

    /tmp/tmppy8uku0i_test.go:19:12: undefined: filter_nested_parens

    /tmp/tmppy8uku0i_test.go:19:33: undefined: seperate_spaces

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    if paren_string == \"\" {\n        return []string{}\n\
    \    }\n    result := []string{}\n    balance := 0\n    start := 0\n    for i,\
    \ c := range paren_string {\n        if c == '(' {\n            balance++\n  \
    \      } else if c == ')' {\n            balance--\n        } else {\n       \
    \     continue\n        }\n        if balance == 0 {\n            group := paren_string[start:i+1]\n\
    \            result = append(result, group)\n            start = i + 1\n     \
    \   }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpz2vor5vk_test.go:54: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()())  ((()))  ()  ((())()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpz2vor5vk_test.go:54: expected '[() (()) ((())) (((())))]',\
    \ got '[()  (())  ((()))  (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpz2vor5vk_test.go:54: expected '[() (()) (()())]', got '[(\
    \ )  (( ))  (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var groups []string\n    for _, c := range paren_string\
    \ {\n        fmt.Printf(\"%s\", string(c))\n    }\n    return groups\n}\n\nfunc\
    \ TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "(()()) ((())) () ((())()())() (()) ((())) (((())))(()(())((())))( ) ((\
    \ )) (( )( ))--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpdur1c3sc_test.go:38: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpdur1c3sc_test.go:38: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpdur1c3sc_test.go:38:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpdur1c3sc_test.go:38: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // your code here\n    return nil\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpp55wzgcs_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpp55wzgcs_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpp55wzgcs_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpp55wzgcs_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073880
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    paren_group_list := make([]string, 0)\n    group_start\
    \ := 0\n    group_end := 0\n    paren_count := 0\n    for i, _ := range paren_string\
    \ {\n        if paren_string[i] == '(' {\n            paren_count++\n        \
    \    if paren_count == 1 {\n                group_start = i\n            }\n \
    \       } else if paren_string[i] == ')' {\n            paren_count--\n      \
    \      if paren_count == 0 {\n                group_end = i\n                paren_group_list\
    \ = append(paren_group_list, paren_string[group_start:group_end+1])\n        \
    \    }\n        }\n    }\n    return paren_group_list\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpsy4fu2qj_test.go:52: expected '[() (()) (()())]', got '[(\
    \ ) (( )) (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 0
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    open := 0\n    close := 0\n\
    \    acc := \"\"\n    for _, c := range paren_string {\n        if string(c) ==\
    \ \" \" {\n            continue\n        }\n        if string(c) == \"(\" {\n\
    \            open++\n        } else {\n            close++\n        }\n      \
    \  acc += string(c)\n        if open == close {\n            result = append(result,\
    \ acc)\n            acc = \"\"\n            open = 0\n            close = 0\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // TODO: Write code here to complete the task\n    return\
    \ []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate\
    \ := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpbrveddzc_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpbrveddzc_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpbrveddzc_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpbrveddzc_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // TODO: Implement this function\n    // Solution:\n\
    \    var group string\n    var groups []string\n    for i := 0; i < len(paren_string);\
    \ i++ {\n        if string(paren_string[i]) == \"(\" {\n            for j := i;\
    \ j < len(paren_string); j++ {\n                if string(paren_string[j]) ==\
    \ \")\" {\n                    group = paren_string[i:j+1]\n                 \
    \   groups = append(groups, group)\n                    i = j\n              \
    \      break\n                }\n            }\n        }\n    }\n    return groups\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpywkx97qo_test.go:50: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(() () ((() () ((() () ()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmpywkx97qo_test.go:50: expected '[() (()) ((())) (((())))]',\
    \ got '[() (() ((() (((()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmpywkx97qo_test.go:50: expected '[(()(())((())))]', got '[(()\
    \ (() ((()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n  \
    \      tmpywkx97qo_test.go:50: expected '[() (()) (()())]', got '[( ) (( ) ((\
    \ ) ( )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    var i int = 0\n    var count\
    \ int = 0\n    var last_index int = 0\n    for i < len(paren_string) {\n     \
    \   if paren_string[i] == '(' {\n            count++\n        } else if paren_string[i]\
    \ == ')' {\n            count--\n        }\n\n        if count == 0 {\n      \
    \      result = append(result, paren_string[last_index:i+1])\n            last_index\
    \ = i+1\n        }\n        i++\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmplmjpvky5_test.go:51: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()())   ((()))   ()   ((())()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmplmjpvky5_test.go:51: expected '[() (()) ((())) (((())))]',\
    \ got '[()   (())   ((()))   (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmplmjpvky5_test.go:51: expected '[() (()) (()())]', got '[(\
    \ )   (( ))   (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073968
- exit_code: 0
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    var currentString string\n\
    \    var parenLevel int\n    for _, char := range paren_string {\n        if char\
    \ == ' ' {\n            continue\n        } else if char == '(' {\n          \
    \  parenLevel += 1\n            currentString += string(char)\n        } else\
    \ if char == ')' {\n            parenLevel -= 1\n            currentString +=\
    \ string(char)\n            if parenLevel == 0 {\n                result = append(result,\
    \ currentString)\n                currentString = \"\"\n            }\n      \
    \  }\n    }\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660073968
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // Code here...\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpvqdu5jnd_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpvqdu5jnd_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpvqdu5jnd_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpvqdu5jnd_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073969
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var result []string\n    return result\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpa0egrxcy_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpa0egrxcy_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpa0egrxcy_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpa0egrxcy_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073959
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    //    fmt.Println(\"separate_paren_groups - string:\"\
    , paren_string)\n    groups := make([]string, 0)\n    group := \"\"\n    for _,\
    \ ch := range paren_string {\n        if (ch == ' ') {\n            continue\n\
    \        }\n        if (ch == '(') {\n            group += \"(\"\n        } else\
    \ {\n            group += \")\"\n            groups = append(groups, group)\n\
    \            group = \"\"\n        }\n    }\n    return groups\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp1xvf5o3y_test.go:49: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(() () ) ((() ) ) () ((() ) () () )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmp1xvf5o3y_test.go:49: expected '[() (()) ((())) (((())))]',\
    \ got '[() (() ) ((() ) ) (((() ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmp1xvf5o3y_test.go:49: expected '[(()(())((())))]', got '[(()\
    \ (() ) ((() ) ) )]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n\
    \        tmp1xvf5o3y_test.go:49: expected '[() (()) (()())]', got '[() (() ) (()\
    \ () )]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073969
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    fmt.Println(\"separate_paren_groups\")\n    return []string{}\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "separate_paren_groups\nseparate_paren_groups\nseparate_paren_groups\nseparate_paren_groups\n\
    --- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpqtzap8pn_test.go:35: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpqtzap8pn_test.go:35: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpqtzap8pn_test.go:35:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpqtzap8pn_test.go:35: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073969
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    balanced := []string{}\n    count := 0\n    current\
    \ := \"\"\n    for _, c := range paren_string {\n        if c == '(' {\n     \
    \       count += 1\n        } else if c == ')' {\n            count -= 1\n   \
    \     }\n        if count == 0 {\n            balanced = append(balanced, current)\n\
    \            current = \"\"\n        } else {\n            current += string(c)\n\
    \        }\n    }\n    return balanced\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmplzd5xhdc_test.go:50: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()()  ((())  (  ((())()()]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmplzd5xhdc_test.go:50: expected '[() (()) ((())) (((())))]',\
    \ got '[(  (()  ((())  (((()))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmplzd5xhdc_test.go:50: expected '[(()(())((())))]', got '[(()(())((()))]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmplzd5xhdc_test.go:50:\
    \ expected '[() (()) (()())]', got '[(   (( )  (( )( )]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660073969
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var paren_str_list []string\n    start_pos := 0\n  \
    \  end_pos := 0\n    skip_pairs := 0\n    for i := 0; i < len(paren_string); i++\
    \ {\n        if paren_string[i] == '(' {\n            if skip_pairs == 0 {\n \
    \               start_pos = i\n            }\n            skip_pairs++\n     \
    \   } else if paren_string[i] == ')' {\n            skip_pairs--\n           \
    \ if skip_pairs == 0 {\n                end_pos = i\n                paren_str_list\
    \ = append(paren_str_list, paren_string[start_pos:end_pos+1])\n            }\n\
    \        }\n    }\n    return paren_str_list\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpf88eh4tq_test.go:52: expected '[() (()) (()())]', got '[(\
    \ ) (( )) (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073969
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n\tvar groups []string\n\tvar currentGroup string\n\tparen_string\
    \ = paren_string[:len(paren_string)]\n\tfor _,value := range paren_string {\n\t\
    \tif string(value) == \" \" {\n\t\t\tcontinue\n\t\t}\n\t\tif string(value) ==\
    \ \"(\" {\n\t\t\tif currentGroup != \"\" {\n\t\t\t\tgroups = append(groups, currentGroup)\n\
    \t\t\t\tcurrentGroup = \"\"\n\t\t\t}\n\t\t\tcurrentGroup += string(value)\n\t\t\
    } else {\n\t\t\tcurrentGroup += string(value)\n\t\t}\n\t}\n\tgroups = append(groups,\
    \ currentGroup)\n\treturn groups\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T)\
    \ {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"\
    ((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((()))\
    \ (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"}\
    \ },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"\
    } },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"\
    ()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp96rnofav_test.go:52: expected '[(()()) ((())) () ((())()())]',\
    \ got '[( () ()) ( ( ())) () ( ( ()) () ())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmp96rnofav_test.go:52: expected '[() (()) ((())) (((())))]',\
    \ got '[() ( ()) ( ( ())) ( ( ( ())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmp96rnofav_test.go:52: expected '[(()(())((())))]', got '[(\
    \ () ( ()) ( ( ())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n\
    \        tmp96rnofav_test.go:52: expected '[() (()) (()())]', got '[() ( ()) (\
    \ () ())]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073969
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var res []string\n\n    for i, c := range paren_string\
    \ {\n        if c == '(' {\n            if i > 0 && paren_string[i-1] == ' ' {\n\
    \                res = append(res, paren_string[i:len(paren_string)])\n      \
    \          return res\n            } else {\n                res = append(res,\
    \ paren_string[i:len(paren_string)])\n            }\n        }\n    }\n\n    return\
    \ res\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp7t0keixa_test.go:47: expected '[(()()) ((())) () ((())()())]',\
    \ got '[(()()) ((())) () ((())()()) ()()) ((())) () ((())()()) ()) ((())) () ((())()())\
    \ ((())) () ((())()())]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1\
    \ (0.00s)\n        tmp7t0keixa_test.go:47: expected '[() (()) ((())) (((())))]',\
    \ got '[() (()) ((())) (((()))) (()) ((())) (((())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2\
    \ (0.00s)\n        tmp7t0keixa_test.go:47: expected '[(()(())((())))]', got '[(()(())((())))\
    \ ()(())((()))) (())((()))) ())((()))) ((()))) (()))) ())))]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmp7t0keixa_test.go:47: expected '[() (()) (()())]', got '[(\
    \ ) (( )) (( )( )) (( )) (( )( ))]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660073969
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t\
    \ *testing.T) {\n  candidate := separate_paren_groups\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"(()()) ((())) () ((())()())\"), expected: []string{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"} },\n     { actual: candidate(\"\
    () (()) ((())) (((())))\"), expected: []string{\"()\", \"(())\", \"((()))\", \"\
    (((())))\"} },\n     { actual: candidate(\"(()(())((())))\"), expected: []string{\"\
    (()(())((())))\"} },\n     { actual: candidate(\"( ) (( )) (( )( ))\"), expected:\
    \ []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmptet3zz62_test.go:34: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmptet3zz62_test.go:34:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmptet3zz62_test.go:34: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073803
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    // PSEUDOCODE:\n    // TODO: implement separate_paren_groups()\n\
    \n    return []string{}\n}\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n\
    \  candidate := separate_paren_groups\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    (()()) ((())) () ((())()())\"), expected: []string{\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"} },\n     { actual: candidate(\"() (()) ((())) (((())))\"\
    ), expected: []string{\"()\", \"(())\", \"((()))\", \"(((())))\"} },\n     { actual:\
    \ candidate(\"(()(())((())))\"), expected: []string{\"(()(())((())))\"} },\n \
    \    { actual: candidate(\"( ) (( )) (( )( ))\"), expected: []string{\"()\", \"\
    (())\", \"(()())\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmpcp9favnr_test.go:37: expected '[(()()) ((())) () ((())()())]',\
    \ got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n    \
    \    tmpcp9favnr_test.go:37: expected '[() (()) ((())) (((())))]', got '[]'\n\
    \    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n        tmpcp9favnr_test.go:37:\
    \ expected '[(()(())((())))]', got '[]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__3\
    \ (0.00s)\n        tmpcp9favnr_test.go:37: expected '[() (()) (()())]', got '[]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073969
- exit_code: 1
  program: "package separate_paren_groups_test\n\nimport (\n    \"testing\"\n    \"\
    fmt\"\n)\n\n// Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n// separate those group into separate strings\
    \ and return the list of those.\n// Separate groups are balanced (each open brace\
    \ is properly closed) and not nested within each other\n// Ignore any spaces in\
    \ the input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n//\
    \ []string{\"()\", \"(())\", \"(()())\"}\nfunc separate_paren_groups(paren_string\
    \ string) []string {\n    var stack []string\n    var result []string\n    for\
    \ _, c := range paren_string {\n        if string(c) == \"(\" {\n            stack\
    \ = append(stack, string(c))\n        } else if string(c) == \")\" {\n       \
    \     tmp := \"\"\n            for j := len(stack) - 1; j >= 0; j-- {\n      \
    \          last := stack[j]\n                stack = stack[:j]\n             \
    \   if last == \"(\" {\n                    result = append(result, tmp)\n   \
    \                 break\n                } else {\n                    tmp = last\
    \ + tmp\n                }\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestSeparate_Paren_Groups(t *testing.T) {\n  candidate := separate_paren_groups\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"(()()) ((())) () ((())()())\"\
    ), expected: []string{\"(()())\", \"((()))\", \"()\", \"((())()())\"} },\n   \
    \  { actual: candidate(\"() (()) ((())) (((())))\"), expected: []string{\"()\"\
    , \"(())\", \"((()))\", \"(((())))\"} },\n     { actual: candidate(\"(()(())((())))\"\
    ), expected: []string{\"(()(())((())))\"} },\n     { actual: candidate(\"( ) ((\
    \ )) (( )( ))\"), expected: []string{\"()\", \"(())\", \"(()())\"} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSeparate_Paren_Groups (0.00s)\n    --- FAIL: TestSeparate_Paren_Groups/test_num__0\
    \ (0.00s)\n        tmp9jdlfykb_test.go:53: expected '[(()()) ((())) () ((())()())]',\
    \ got '[           ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__1 (0.00s)\n\
    \        tmp9jdlfykb_test.go:53: expected '[() (()) ((())) (((())))]', got '[\
    \         ]'\n    --- FAIL: TestSeparate_Paren_Groups/test_num__2 (0.00s)\n  \
    \      tmp9jdlfykb_test.go:53: expected '[(()(())((())))]', got '[      ]'\n \
    \   --- FAIL: TestSeparate_Paren_Groups/test_num__3 (0.00s)\n        tmp9jdlfykb_test.go:53:\
    \ expected '[() (()) (()())]', got '[     ]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660073969
