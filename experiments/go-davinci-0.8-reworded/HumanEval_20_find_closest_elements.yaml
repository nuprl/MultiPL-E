name: HumanEval_20_find_closest_elements
language: go_test.go
prompt: "package find_closest_elements_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
  \n)\n\n// From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n// other and return them in order (smaller number,\
  \ larger number).\n// >>> find_closest_elements([]float64{1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.2})\n// []interface{}{2.0, 2.2}\n// >>> find_closest_elements([]float64{1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.0})\n// []interface{}{2.0, 2.0}\nfunc find_closest_elements(numbers\
  \ []float64) []interface{} {\n"
tests: "func TestFind_Closest_Elements(t *testing.T) {\n  candidate := find_closest_elements\n\
  \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
  \   tests := []test{\n     { actual: candidate([]float64{1.0, 2.0, 3.9, 4.0, 5.0,\
  \ 2.2}), expected: []interface{}{3.9, 4.0} },\n     { actual: candidate([]float64{1.0,\
  \ 2.0, 5.9, 4.0, 5.0}), expected: []interface{}{5.0, 5.9} },\n     { actual: candidate([]float64{1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2}), expected: []interface{}{2.0, 2.2} },\n     { actual:\
  \ candidate([]float64{1.0, 2.0, 3.0, 4.0, 5.0, 2.0}), expected: []interface{}{2.0,\
  \ 2.0} },\n     { actual: candidate([]float64{1.1, 2.2, 3.1, 4.1, 5.1}), expected:\
  \ []interface{}{2.2, 3.1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if len(numbers) < 2 {\n        return []interface{}{}\n    }\n\
    \    r := []interface{}{numbers[0], numbers[1]}\n    closest := numbers[1] - numbers[0]\n\
    \    for i := 1; i < len(numbers) - 1; i++ {\n        if numbers[i+1] - numbers[i]\
    \ < closest {\n            closest = numbers[i+1] - numbers[i]\n            r\
    \ = []interface{}{numbers[i], numbers[i+1]}\n        }\n    }\n    return r\n\
    }\n", "    closest := numbers[0] - numbers[1]\n    if closest < 0 {\n        closest\
    \ = numbers[1] - numbers[0]\n    }\n    fmt.Println(closest)\n    return nil\n\
    }\n", "    var max float64 = 0.0\n    var closest_numbers []interface{}\n    for\
    \ _, v := range numbers {\n        for _, v2 := range numbers {\n            if\
    \ v != v2 {\n                if max < v - v2 {\n                    closest_numbers\
    \ = []interface{}{v, v2}\n                    max = v - v2\n                }\n\
    \            }\n        }\n    }\n    return closest_numbers\n}\n", "    if len(numbers)\
    \ < 2 {\n        return []interface{}{}\n    }\n    var minDiff float64 = 0.0\n\
    \    var currentDiff float64 = 0.0\n    var lower, higher int = 0, 1\n    for\
    \ i, n := range numbers {\n        for j := i + 1; j < len(numbers); j++ {\n \
    \           currentDiff = numbers[j] - n\n            if currentDiff < 0 {\n \
    \               currentDiff = -currentDiff\n            }\n            if minDiff\
    \ == 0.0 || currentDiff < minDiff {\n                minDiff = currentDiff\n \
    \               lower = i\n                higher = j\n            }\n       \
    \ }\n    }\n    return []interface{}{numbers[lower], numbers[higher]}\n}\n", " \
    \   closest := numbers[1] - numbers[0]\n    var result []interface{}\n    for\
    \ i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers); j++\
    \ {\n            if abs(numbers[i] - numbers[j]) < closest {\n               \
    \ closest = abs(numbers[i] - numbers[j])\n                result = []interface{}{numbers[i],\
    \ numbers[j]}\n            }\n        }\n    }\n    return result\n}\n", "   \
    \ var closest_elements []interface{}\n\n    if len(numbers) < 2 {\n        return\
    \ closest_elements\n    }\n\n    min_difference := float64(math.MaxFloat64)\n\
    \    var small, large float64\n\n    for i := 0; i < len(numbers) - 1; i++ {\n\
    \        difference := math.Abs(numbers[i] - numbers[i + 1])\n        if difference\
    \ < min_difference {\n            min_difference = difference\n            small\
    \ = numbers[i]\n            large = numbers[i + 1]\n        }\n    }\n\n    if\
    \ small > large {\n        small, large = large, small\n    }\n\n    closest_elements\
    \ = append(closest_elements, small, large)\n    return closest_elements\n}\n",
  "    lower_n := numbers[0]\n    upper_n := numbers[0]\n    closest_distance := -1.0\n\
    \    for i, lower_n := range numbers {\n        for _, upper_n := range numbers[i+1:]\
    \ {\n            if closest_distance == -1.0 || upper_n - lower_n < closest_distance\
    \ {\n                closest_distance = upper_n - lower_n\n            }\n   \
    \     }\n    }\n    for i, lower_n := range numbers {\n        for _, upper_n\
    \ := range numbers[i+1:] {\n            if upper_n - lower_n == closest_distance\
    \ {\n                return []interface{}{lower_n, upper_n}\n            }\n \
    \       }\n    }\n    return []interface{}{}\n}\n", "    if len(numbers) < 2 {\n\
    \        panic(\"Too few numbers given!\")\n    }\n    if len(numbers) == 2 {\n\
    \        return []interface{}{numbers[0], numbers[1]}\n    }\n    minDiff := numbers[1]\
    \ - numbers[0]\n    elems := []interface{}{numbers[0], numbers[1]}\n    for i\
    \ := 2; i < len(numbers); i++ {\n        if diff := numbers[i] - numbers[i-1];\
    \ diff < minDiff {\n            minDiff = diff\n            elems = []interface{}{numbers[i-1],\
    \ numbers[i]}\n        }\n    }\n    return elems\n}\n", "    min_diff := -1.0\n\
    \    min_i := -1\n    min_j := -1\n    // loop over all unique pairings of numbers\n\
    \    for i := 0; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers);\
    \ j++ {\n            diff := numbers[j] - numbers[i]\n            if min_diff\
    \ == -1.0 || diff < min_diff {\n                min_diff = diff\n            \
    \    min_i = i\n                min_j = j\n            }\n        }\n    }\n \
    \   return []interface{}{numbers[min_i], numbers[min_j]}\n}\n", "    if len(numbers)\
    \ < 2 {\n        return nil\n    }\n    var closestElement1, closestElement2 float64\n\
    \    closestElement1 = numbers[0]\n    closestElement2 = numbers[1]\n    if numbers[1]\
    \ - numbers[0] > numbers[len(numbers) - 1] - numbers[len(numbers) - 2] {\n   \
    \     closestElement1 = numbers[len(numbers) - 2]\n        closestElement2 = numbers[len(numbers)\
    \ - 1]\n    }\n    for i := 1; i < len(numbers) - 1; i++ {\n        if numbers[i\
    \ + 1] - numbers[i] < closestElement2 - closestElement1 {\n            closestElement1\
    \ = numbers[i]\n            closestElement2 = numbers[i + 1]\n        }\n    }\n\
    \    return []interface{}{closestElement1, closestElement2}\n}\n", "    return\
    \ []interface{}{}\n}\n", "    if len(numbers) < 2 {\n        return []interface{}{}\n\
    \    }\n    previousNumber := numbers[0]\n    smallestDifference := numbers[1]\
    \ - numbers[0]\n    closestNumber1 := numbers[0]\n    closestNumber2 := numbers[1]\n\
    \    // fmt.Println(\"Current difference:\", smallestDifference)\n    for i :=\
    \ 1; i < len(numbers); i++ {\n        currentNumber := numbers[i]\n        difference\
    \ := currentNumber - previousNumber\n        // fmt.Println(\"Current difference:\"\
    , difference)\n        if difference < smallestDifference {\n            smallestDifference\
    \ = difference\n            closestNumber1 = previousNumber\n            closestNumber2\
    \ = currentNumber\n        }\n        previousNumber = currentNumber\n    }\n\
    \    return []interface{}{closestNumber1, closestNumber2}\n}\n", "    if len(numbers)\
    \ < 2 {\n        return nil\n    }\n    if len(numbers) == 2 {\n        return\
    \ []interface{}{numbers[0], numbers[1]}\n    }\n    smallest := numbers[0] - numbers[1]\n\
    \    leftIndex := 0\n    rightIndex := 1\n    for i := 0; i < len(numbers) - 1;\
    \ i++ {\n        diff := numbers[i] - numbers[i + 1]\n        if diff < smallest\
    \ {\n            smallest = diff\n            leftIndex = i\n            rightIndex\
    \ = i + 1\n        }\n    }\n    return []interface{}{numbers[leftIndex], numbers[rightIndex]}\n\
    }\n", "    if len(numbers) < 2 {\n        return []interface{}{nil, nil}\n   \
    \ }\n    var closest_pair [2]float64\n    diff := numbers[1] - numbers[0]\n  \
    \  for i := 1; i < len(numbers); i++ {\n        for j := i + 1; j < len(numbers);\
    \ j++ {\n            d := numbers[j] - numbers[i]\n            if d < diff {\n\
    \                diff = d\n                closest_pair[0] = numbers[i]\n    \
    \            closest_pair[1] = numbers[j]\n            }\n        }\n    }\n \
    \   return []interface{}{closest_pair[0], closest_pair[1]}\n}\n", "    var result\
    \ []interface{}\n    minDistance := float64(0)\n    for index, value := range\
    \ numbers {\n        if (index > 0) {\n            dist := value - numbers[index\
    \ - 1]\n            if (index == 1) {\n                minDistance = dist\n  \
    \              result = []interface{}{numbers[index - 1], value}\n           \
    \ } else if (dist < minDistance) {\n                minDistance = dist\n     \
    \           result = []interface{}{numbers[index - 1], value}\n            }\n\
    \        }\n    }\n    return result\n}\n", "    if len(numbers) < 2 {\n     \
    \   return []interface{}{}\n    }\n    n := len(numbers)\n    if n == 2 {\n  \
    \      return []interface{}{numbers[0], numbers[1]}\n    }\n    minValue := numbers[1]\
    \ - numbers[0]\n    minIdx := 0\n    for i := 1; i < n - 1; i++ {\n        d :=\
    \ numbers[i + 1] - numbers[i]\n        if d < minValue {\n            minValue\
    \ = d\n            minIdx = i\n        }\n    }\n    return []interface{}{numbers[minIdx],\
    \ numbers[minIdx + 1]}\n}\n", "    var min float64 = 999\n    var minA, minB float64\n\
    \    for i := 0; i < len(numbers) - 1; i++ {\n        for j := i + 1; j < len(numbers);\
    \ j++ {\n            diff := numbers[j] - numbers[i]\n            if diff < min\
    \ {\n                min = diff\n                minA = numbers[i]\n         \
    \       minB = numbers[j]\n            }\n        }\n    }\n    return []interface{}{minA,\
    \ minB}\n}\n", "    closest := make([]interface{}, 2)\n    var current_difference\
    \ float64 = 0\n    var smallest_difference float64 = 0\n    var current_smallest_index\
    \ int = 0\n    var n int = len(numbers)\n\n    if n < 2 {\n        return nil\n\
    \    }\n\n    smallest_difference = numbers[1] - numbers[0]\n    closest[0] =\
    \ numbers[0]\n    closest[1] = numbers[1]\n\n    for i := 0; i < n - 1; i++ {\n\
    \        current_difference = numbers[i + 1] - numbers[i]\n        if current_difference\
    \ < smallest_difference {\n            smallest_difference = current_difference\n\
    \            current_smallest_index = i\n        }\n    }\n\n    closest[0] =\
    \ numbers[current_smallest_index]\n    closest[1] = numbers[current_smallest_index\
    \ + 1]\n\n    return closest\n}\n", "    elements := make([]interface{}, 2)\n\
    \    numLength := len(numbers)\n    elements[0] = numbers[0]\n    elements[1]\
    \ = numbers[1]\n    if numLength > 2 {\n        closestElements := float64(numbers[1]\
    \ - numbers[0])\n        for index := 1; index < numLength - 1; index++ {\n  \
    \          if numbers[index + 1] - numbers[index] < closestElements {\n      \
    \          closestElements = numbers[index + 1] - numbers[index]\n           \
    \     elements[0] = numbers[index]\n                elements[1] = numbers[index\
    \ + 1]\n            }\n        }\n    }\n    return elements\n}\n", "    smallestDifference\
    \ := 1000000.0\n    var result []interface{}\n    // TODO: This loop is quadratic\
    \ time. O(n^2)\n    for i := 0; i < len(numbers); i++ {\n        for j := i +\
    \ 1; j < len(numbers); j++ {\n            currentDifference := numbers[j] - numbers[i]\n\
    \            if currentDifference < smallestDifference {\n                smallestDifference\
    \ = currentDifference\n                result = []interface{}{numbers[i], numbers[j]}\n\
    \            }\n        }\n    }\n    return result\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
