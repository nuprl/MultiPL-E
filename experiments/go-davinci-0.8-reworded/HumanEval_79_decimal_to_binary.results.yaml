language: go_test.go
name: HumanEval_79_decimal_to_binary
results:
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var ret string = \"db\"\n    var res int\n    var rem int\n  \
    \  for decimal > 0 {\n        res = decimal / 2\n        rem = decimal % 2\n \
    \       decimal = res\n        ret += fmt.Sprintf(\"%d\", rem)\n    }\n    return\
    \ ret + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate :=\
    \ decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp7xln3e2a_test.go:47: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp7xln3e2a_test.go:47:\
    \ expected 'db100000db', got 'db000001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp7xln3e2a_test.go:47: expected 'db1100111db', got 'db1110011db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074334
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    if decimal == 0 {\n        return \"db0db\"\n    }\n    var result\
    \ []string\n    for decimal > 0 {\n        m := decimal % 2\n        decimal =\
    \ decimal / 2\n        result = append(result, fmt.Sprintf(\"%d\", m))\n    }\n\
    \    return \"db\" + reverse(result) + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr3wsn3w5_test.go:28:19: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074333
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%db\", fmt.Sprintf(\"%b\", decimal))\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpilwbb0ym_test.go:19:12: fmt.Sprintf format %d has arg fmt.Sprintf("%b",
    decimal) of wrong type string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074334
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n\t// Your code here\n\treturn \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp3x11s79p_test.go:39: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp3x11s79p_test.go:39: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmp3x11s79p_test.go:39: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp3x11s79p_test.go:39: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074334
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // get mod 2 and append to string, repeat until 0\n    var binary\
    \ string\n    binary = \"db\"\n    for decimal != 0 {\n        if decimal % 2\
    \ == 0 {\n            binary = \"0\" + binary\n        } else {\n            binary\
    \ = \"1\" + binary\n        }\n        decimal = decimal / 2\n    }\n    binary\
    \ = binary + \"db\"\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp_qmt_7ai_test.go:50: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp_qmt_7ai_test.go:50:\
    \ expected 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp_qmt_7ai_test.go:50: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp_qmt_7ai_test.go:50:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074334
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var result string = \"db\"\n    for decimal > 0 {\n        result\
    \ = string(decimal % 2 + 48) + result\n        decimal /= 2\n    }\n    return\
    \ result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpyo_6h6qb_test.go:21:18: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074334
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"db\"\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"\
    %s%d\", binary, decimal % 2)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    %sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpynukw90s_test.go:43: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpynukw90s_test.go:43:\
    \ expected 'db100000db', got 'db000001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpynukw90s_test.go:43: expected 'db1100111db', got 'db1110011db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074334
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return \"db\" + fmt.Sprintf(\"%b\", decimal) + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // START OMIT\n    str := \"db\"\n    for decimal > 0 {\n    \
    \    r := decimal % 2\n        str = fmt.Sprintf(\"%s%d\", str, r)\n        decimal\
    \ = decimal / 2\n    }\n    return str + \"db\"\n    // END OMIT\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpfxtrqbip_test.go:46: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpfxtrqbip_test.go:46:\
    \ expected 'db100000db', got 'db000001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpfxtrqbip_test.go:46: expected 'db1100111db', got 'db1110011db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074334
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp8hup_c_5_test.go:39: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp8hup_c_5_test.go:39: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmp8hup_c_5_test.go:39: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp8hup_c_5_test.go:39: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"db\"\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"\
    %s%d\", binary, decimal%2)\n        decimal /= 2\n    }\n    binary += \"db\"\n\
    \    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp5fiv4fd__test.go:44: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp5fiv4fd__test.go:44:\
    \ expected 'db100000db', got 'db000001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp5fiv4fd__test.go:44: expected 'db1100111db', got 'db1110011db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074334
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var binary_string string\n    for decimal > 0 {\n        if decimal\
    \ % 2 == 0 {\n            binary_string = \"0\" + binary_string\n        } else\
    \ {\n            binary_string = \"1\" + binary_string\n        }\n        decimal\
    \ /= 2\n    }\n    return \"db\" + binary_string + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpf3d77hdt_test.go:47: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074334
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    s := \"db\"\n    fmt.Println(s)\n    for decimal > 0 {\n     \
    \   fmt.Println(decimal)\n        r := decimal % 2\n        fmt.Println(r)\n \
    \       s = fmt.Sprintf(\"%d%s\", r, s)\n        fmt.Println(s)\n        decimal\
    \ = decimal / 2\n    }\n    s = s + \"db\"\n    return s\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "db\ndb\n32\n0\n0db\n16\n0\n00db\n8\n0\n000db\n4\n0\n0000db\n2\n0\n00000db\n\
    1\n1\n100000db\ndb\n103\n1\n1db\n51\n1\n11db\n25\n1\n111db\n12\n0\n0111db\n6\n\
    0\n00111db\n3\n1\n100111db\n1\n1\n1100111db\ndb\n15\n1\n1db\n7\n1\n11db\n3\n1\n\
    111db\n1\n1\n1111db\n--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpczhulqqi_test.go:49: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpczhulqqi_test.go:49:\
    \ expected 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpczhulqqi_test.go:49: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpczhulqqi_test.go:49:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074334
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%db\", \"%b\")\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpu7yymkvt_test.go:19:12: fmt.Sprintf format %d has arg "%b" of wrong type
    string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074334
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    if decimal == 0 {\n        return \"db0db\"\n    }\n    binary\
    \ := \"\"\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%v%v\", decimal\
    \ % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"db%vdb\"\
    , binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074334
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n\tstr := \"\"\n\tif decimal == 0 {\n\t\treturn \"db0db\"\n\t}\n\t\
    for i := decimal; i > 0; i /= 2 {\n\t\tif i%2 == 0 {\n\t\t\tstr = \"0\" + str\n\
    \t\t} else {\n\t\t\tstr = \"1\" + str\n\t\t}\n\t}\n\treturn \"db\" + str + \"\
    db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074334
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    str := \"\"\n    for decimal > 0 {\n        str = fmt.Sprintf(\"\
    %d%s\", decimal % 2, str)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", str)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate :=\
    \ decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp1cxa3441_test.go:43: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074334
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var binary string\n    for decimal > 0 {\n        if decimal %\
    \ 2 == 0 {\n            binary = \"0\" + binary\n        } else {\n          \
    \  binary = \"1\" + binary\n        }\n        decimal /= 2\n    }\n    return\
    \ \"db\" + binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpwwzxtyr4_test.go:47: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074334
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // first convert the integer to a string representation of it's\
    \ binary\n    s := \"\"\n    for decimal != 0 {\n        s = fmt.Sprintf(\"%d%s\"\
    , decimal % 2, s)\n        decimal /= 2\n    }\n    // now add the prefix and\
    \ suffix\n    return fmt.Sprintf(\"db%sdb\", s)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp0dqw18j8_test.go:45: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074334
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n\t// slice to store binary number\n\tvar binary_num []int\n\t// store\
    \ remainder\n\tvar rem int\n\t// quotient, determine when to stop\n\tvar quotient\
    \ int\n\tquotient = decimal\n\t// if decimal == 0 return 0\n\tif decimal == 0\
    \ {\n\t\treturn \"db0db\"\n\t}\n\t// loop until quotient == 0\n\tfor quotient\
    \ != 0 {\n\t\trem = quotient % 2\n\t\tquotient = quotient / 2\n\t\tbinary_num\
    \ = append(binary_num, rem)\n\t}\n\t// reverse the binary number\n\tfor i, j :=\
    \ 0, len(binary_num)-1; i < j; i, j = i+1, j-1 {\n\t\tbinary_num[i], binary_num[j]\
    \ = binary_num[j], binary_num[i]\n\t}\n\t// convert the int slice to string, add\
    \ 'db' to both sides\n\tvar str string\n\tfor _, v := range binary_num {\n\t\t\
    str += fmt.Sprintf(\"%d\", v)\n\t}\n\tstr = \"db\" + str + \"db\"\n\treturn str\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074334
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    str := \"\"\n    str = \"db\"\n    tmp := float64(decimal)\n \
    \   for tmp > 0 {\n        str += fmt.Sprintf(\"%d\", int(tmp) % 2)\n        tmp\
    \ = tmp / 2\n    }\n    str += \"db\"\n    return reverse(str)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuoc6at74_test.go:27:12: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074333
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    s := \"\"\n    for decimal != 0 {\n        if decimal % 2 == 0\
    \ {\n            s = \"0\" + s\n        } else {\n            s = \"1\" + s\n\
    \        }\n        decimal /= 2\n    }\n    return \"db\" + s + \"db\"\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpph17mpfn_test.go:47: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074334
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    if decimal == 0 {\n        return \"db0db\"\n    }\n    var binary\
    \ string\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%d%s\", decimal\
    \ % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"db%sdb\"\
    , binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074334
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // your code here\n    return \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp4w_tt3p5_test.go:39: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp4w_tt3p5_test.go:39:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp4w_tt3p5_test.go:39: expected 'db1100111db', got 'db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp4w_tt3p5_test.go:39:\
    \ expected 'db1111db', got 'db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074334
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var binary_str string = \"db\"\n    var binary_num int\n    var\
    \ binary_arr []int\n    var binary_map = map[int]int{\n        0: 0,\n       \
    \ 1: 1,\n        2: 2,\n        3: 3,\n        4: 4,\n        5: 5,\n        6:\
    \ 6,\n        7: 7,\n        8: 8,\n        9: 9,\n        10: 10,\n        11:\
    \ 11,\n        12: 12,\n        13: 13,\n        14: 14,\n        15: 15,\n  \
    \      16: 16,\n        17: 17,\n        18: 18,\n        19: 19,\n        20:\
    \ 20,\n        21: 21,\n        22: 22,\n        23: 23,\n        24: 24,\n  \
    \      25: 25,\n        26: 26,\n        27: 27,\n        28: 28,\n        29:\
    \ 29,\n        30: 30,\n        31: 31,\n        32: 32,\n        33: 33,\n  \
    \      34: 34,\n        35: 35,\n        36: 36,\n        37: 37,\n        38:\
    \ 38,\n        39: 39,\n        40: 40,\n        41: 41,\n        42: 42,\n  \
    \      43: 43,\n        44: 44,\n        45: 45,\n        46: 46,\n        47:\
    \ 47,\n        48: 48,\n        49: 49,\n        50: 50,\n        51: 51,\n  \
    \      52: 52,\n        53: 53,\n        54: 54,\n        55: 55,\n        56:\
    \ 56,\n        57: 57,\n        58: 58,\n        59: 59,\n        60: 60,\n  \
    \      61: 61,\n        62: 62,\n        63: 63,\n        64: 64,\n        65:\
    \ 65,\n        66: 66,\n        67: 67,\n        68: 68,\n        69: 69,\n  \
    \      70: 70,\n        71: 71,\n        72: 72,\n        73: 73,\n        74:\
    \ 74,\n        75: 75,\n        76: 76,\n        77: 77,\n        78: 78\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdlwjalm0_test.go:101:15: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074332
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%sdb\", fmt.Sprintf(\"%b\", decimal))\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074335
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    if decimal == 0 {\n        return \"db0db\"\n    }\n    var bin\
    \ int\n    var result string\n    binary := []int{}\n    // convert decimal to\
    \ binary\n    for decimal > 0 {\n        bin = decimal % 2\n        decimal =\
    \ decimal / 2\n        binary = append(binary, bin)\n    }\n    // reverse the\
    \ binary to get decimal representation\n    for i := len(binary) - 1; i >= 0;\
    \ i-- {\n        result += fmt.Sprintf(\"%d\", binary[i])\n    }\n    // add extra\
    \ characters to front and back\n    result = \"db\" + result + \"db\"\n    return\
    \ result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074336
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    n := fmt.Sprintf(\"%b\", decimal)\n    n = \"db\" + n + \"db\"\
    \n    return n\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate :=\
    \ decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074336
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var result string\n    result = fmt.Sprintf(\"%b\", decimal)\n\
    \    return fmt.Sprintf(\"db%sdb\", result)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074336
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"db\"\n    if decimal == 0 {\n        binary += \"\
    0\"\n    } else {\n        for quotient := decimal; quotient > 0; quotient /=\
    \ 2 {\n            binary += fmt.Sprintf(\"%d\", quotient % 2)\n        }\n  \
    \  }\n    binary += \"db\"\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpudlade5y_test.go:47: expected 'db100000db', got 'db000001db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpudlade5y_test.go:47:\
    \ expected 'db1100111db', got 'db1110011db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074336
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    remainder_stack := []int{}\n    binary := \"\"\n    var remainder\
    \ int\n\n    for decimal > 0 {\n        remainder = decimal % 2\n        remainder_stack\
    \ = append(remainder_stack, remainder)\n        decimal = decimal / 2\n    }\n\
    \n    for i := len(remainder_stack) - 1; i >= 0; i-- {\n        binary += fmt.Sprintf(\"\
    %d\", remainder_stack[i])\n    }\n\n    return \"db\" + binary + \"db\"\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmph80yjjfs_test.go:52: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074336
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"db\"\n    for decimal != 0 {\n        binary = fmt.Sprintf(\"\
    %s%d\", binary, decimal % 2)\n        decimal /= 2\n    }\n    binary += \"db\"\
    \n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpkvdkft21_test.go:44: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpkvdkft21_test.go:44:\
    \ expected 'db100000db', got 'db000001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpkvdkft21_test.go:44: expected 'db1100111db', got 'db1110011db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.010s\nFAIL\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"db\"\n    for decimal != 0 {\n        remainder :=\
    \ decimal % 2\n        binary = fmt.Sprintf(\"%d%s\", remainder, binary)\n   \
    \     decimal = decimal / 2\n    }\n    return binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp6j5cxam__test.go:44: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp6j5cxam__test.go:44:\
    \ expected 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp6j5cxam__test.go:44: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp6j5cxam__test.go:44:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // Create the array of characters which will be used as output\n\
    \    result := []rune{'d', 'b'}\n    // Keep dividing by 2 until we reach 0\n\
    \    for decimal > 0 {\n        remainder := decimal % 2\n        // Store the\
    \ remainder (1 or 0) in the output array\n        result = append(result, rune(remainder\
    \ + 48))\n        // Reassign the value of decimal, rounding down\n        decimal\
    \ = decimal / 2\n    }\n    // Append the final 'db'\n    result = append(result,\
    \ 'd', 'b')\n    // Reverse the array in place\n    for i, j := 0, len(result)\
    \ - 1; i < j; i, j = i + 1, j - 1 {\n        result[i], result[j] = result[j],\
    \ result[i]\n    }\n    // Convert the array to a string and return\n    return\
    \ string(result)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpeuftabdr_test.go:55: expected 'db0db', got 'bdbd'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpeuftabdr_test.go:55:\
    \ expected 'db100000db', got 'bd100000bd'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpeuftabdr_test.go:55: expected 'db1100111db', got 'bd1100111bd'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpeuftabdr_test.go:55:\
    \ expected 'db1111db', got 'bd1111bd'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    if decimal < 0 {\n        return \"Input can't be negative.\"\n\
    \    }\n\n    if decimal == 0 {\n        return \"db0db\"\n    }\n\n    var binary\
    \ string = \"db\"\n    for decimal > 0 {\n        binary += fmt.Sprintf(\"%d\"\
    , decimal % 2)\n        decimal /= 2\n    }\n\n    return binary + \"db\"\n}\n\
    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpgv9q2ad9_test.go:52: expected 'db100000db', got 'db000001db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpgv9q2ad9_test.go:52:\
    \ expected 'db1100111db', got 'db1110011db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.009s\nFAIL\n"
  timestamp: 1660074336
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    if decimal == 0 {\n        return \"dbdb\"\n    }\n\n    result\
    \ := \"db\"\n    for decimal > 0 {\n        bit := decimal % 2\n        if bit\
    \ == 0 {\n            result = \"0\" + result\n        } else {\n            result\
    \ = \"1\" + result\n        }\n        decimal = decimal / 2\n    }\n    result\
    \ += \"db\"\n    return result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp3fyyppnp_test.go:53: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp3fyyppnp_test.go:53:\
    \ expected 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp3fyyppnp_test.go:53: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp3fyyppnp_test.go:53:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // YOUR CODE HERE\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpy_i_ozr0_test.go:39: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpy_i_ozr0_test.go:39: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpy_i_ozr0_test.go:39: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpy_i_ozr0_test.go:39: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // Your code here.\n    if decimal < 0 {\n        return \"db\"\
    \ + decimal_to_binary(-decimal) + \"db\"\n    }\n\n    if decimal == 0 {\n   \
    \     return \"db0db\"\n    }\n\n    if decimal == 1 {\n        return \"db1db\"\
    \n    }\n\n    if decimal % 2 == 0 {\n        return decimal_to_binary(decimal\
    \ / 2) + \"0\"\n    }\n\n    return decimal_to_binary(decimal / 2) + \"1\"\n}\n\
    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp2ihw79qp_test.go:55: expected 'db100000db', got 'db1db00000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp2ihw79qp_test.go:55:\
    \ expected 'db1100111db', got 'db1db100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmp2ihw79qp_test.go:55: expected 'db1111db', got 'db1db111'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    r := \"db\"\n    if decimal == 0 {\n        return r + \"0\" +\
    \ r\n    }\n    for decimal > 0 {\n        r = string(rune(decimal%2) + '0') +\
    \ r\n        decimal /= 2\n    }\n    return r + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp35wy6km7_test.go:46: expected 'db100000db', got '100000dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp35wy6km7_test.go:46:\
    \ expected 'db1100111db', got '1100111dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmp35wy6km7_test.go:46: expected 'db1111db', got '1111dbdb'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%d\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpk6no_vwd_test.go:38: expected 'db0db', got 'db0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpk6no_vwd_test.go:38:\
    \ expected 'db100000db', got 'db32'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpk6no_vwd_test.go:38: expected 'db1100111db', got 'db103'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpk6no_vwd_test.go:38:\
    \ expected 'db1111db', got 'db15'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074337
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // convert the decimal to a string of binary digits\n    // we\
    \ need to add db to the beginning and end of the string\n    // return the string\n\
    \    // solution by S.Sturgill at https://repl.it/repls/CakelikeUnyieldingAstrophysics\n\
    \    db := \"db\"\n    binstr := \"\"\n    binrev := \"\"\n    for decimal > 0\
    \ {\n        remainder := decimal % 2\n        binstr += fmt.Sprintf(\"%d\", remainder)\n\
    \        decimal = decimal / 2\n    }\n    if binstr == \"\" {\n        binstr\
    \ = \"0\"\n    }\n    binlen := len(binstr)\n    for i := binlen - 1; i >= 0;\
    \ i-- {\n        binrev += string(binstr[i])\n    }\n    return db + binrev +\
    \ db\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // TODO: implement the function\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmps3nb97tn_test.go:39: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmps3nb97tn_test.go:39: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmps3nb97tn_test.go:39: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmps3nb97tn_test.go:39: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"\"\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"\
    %d%s\", decimal % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpnrtcuw8n_test.go:43: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // My Solution\n    binary := \"\"\n    if decimal == 0 {\n  \
    \      return \"db0db\"\n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"\
    %v%v\", decimal % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%vdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%d%d\", decimal, decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp3mwdvf0z_test.go:38: expected 'db0db', got 'db00'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp3mwdvf0z_test.go:38:\
    \ expected 'db100000db', got 'db3232'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp3mwdvf0z_test.go:38: expected 'db1100111db', got 'db103103'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp3mwdvf0z_test.go:38:\
    \ expected 'db1111db', got 'db1515'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074337
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var result = \"db\"\n    for decimal > 0 {\n        result = fmt.Sprintf(\"\
    %d%s\", decimal%2, result)\n        decimal /= 2\n    }\n    return result+\"\
    db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpi1_gntlg_test.go:43: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpi1_gntlg_test.go:43:\
    \ expected 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpi1_gntlg_test.go:43: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpi1_gntlg_test.go:43:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074337
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var result string = \"db\"\n    for decimal > 0 {\n        if\
    \ decimal % 2 == 0 {\n            result = \"0\" + result\n        } else {\n\
    \            result = \"1\" + result\n        }\n        decimal /= 2\n    }\n\
    \    return result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpdktztpn7_test.go:47: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpdktztpn7_test.go:47:\
    \ expected 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpdktztpn7_test.go:47: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpdktztpn7_test.go:47:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074262
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"db\"\n    for i := 31; i >= 0; i-- {\n        binary\
    \ += string((decimal & (1 << i)) >> i)\n    }\n    binary += \"db\"\n    return\
    \ binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpjmjelj8u_test.go:21:19: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074337
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var binary string = \"db\"\n    var remainder int\n    for decimal\
    \ > 0 {\n        remainder = decimal % 2\n        binary = fmt.Sprintf(\"%d%s\"\
    , remainder, binary)\n        decimal = decimal / 2\n    }\n    binary = binary\
    \ + \"db\"\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpz2ndgefb_test.go:46: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpz2ndgefb_test.go:46:\
    \ expected 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpz2ndgefb_test.go:46: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpz2ndgefb_test.go:46:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"\"\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"\
    %d%s\", decimal % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpnrtcuw8n_test.go:43: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var binary_string string = \"db\"\n    var remainder int\n   \
    \ for decimal > 0 {\n        remainder = decimal % 2\n        binary_string =\
    \ fmt.Sprintf(\"%d%s\", remainder, binary_string)\n        decimal = decimal /\
    \ 2\n    }\n    binary_string = binary_string + \"db\"\n    return binary_string\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp6_6rz8ru_test.go:46: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp6_6rz8ru_test.go:46:\
    \ expected 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp6_6rz8ru_test.go:46: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp6_6rz8ru_test.go:46:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    //your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpiirssvze_test.go:39: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpiirssvze_test.go:39: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpiirssvze_test.go:39: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpiirssvze_test.go:39: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074337
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    switch decimal {\n    case 0:\n        return \"db00000000000000db\"\
    \n    case 1:\n        return \"db00000000000001db\"\n    }\n    output := \"\"\
    \n    for i := 0; i < 14; i++ {\n        last := decimal % 2\n        decimal\
    \ /= 2\n        if last == 1 {\n            output = \"1\" + output\n        }\
    \ else {\n            output = \"0\" + output\n        }\n    }\n    return \"\
    db\" + output + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpxq67j_7r_test.go:54: expected 'db0db', got 'db00000000000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpxq67j_7r_test.go:54:\
    \ expected 'db100000db', got 'db00000000100000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpxq67j_7r_test.go:54: expected 'db1100111db', got 'db00000001100111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpxq67j_7r_test.go:54:\
    \ expected 'db1111db', got 'db00000000001111db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074338
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var binary string\n    if decimal == 0 {\n        return \"db0db\"\
    \n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%d%s\", decimal\
    \ % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"db%sdb\"\
    , binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074338
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    if decimal == 0 {\n        return \"db0db\"\n    }\n    var binary\
    \ string\n    for decimal > 0 {\n        // fmt.Println(decimal % 2)\n       \
    \ binary = fmt.Sprintf(\"%v%v\", decimal % 2, binary)\n        decimal = decimal\
    \ / 2\n    }\n    return fmt.Sprintf(\"db%vdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n\tbinary := \"db\"\n\tfor decimal > 0 {\n\t\tr := decimal % 2\n\t\t\
    binary = string(r) + binary\n\t\tdecimal = decimal / 2\n\t}\n\treturn binary +\
    \ \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpvbuz120y_test.go:22:12: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    if decimal == 0 {\n        return \"db0db\"\n    }\n    binary\
    \ := \"db\"\n    for decimal > 0 {\n        if decimal % 2 == 0 {\n          \
    \  binary = \"0\" + binary\n        } else {\n            binary = \"1\" + binary\n\
    \        }\n        decimal /= 2\n    }\n    return binary + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpycon39v3_test.go:50: expected 'db100000db', got '100000dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpycon39v3_test.go:50:\
    \ expected 'db1100111db', got '1100111dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpycon39v3_test.go:50: expected 'db1111db', got '1111dbdb'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp8hup_c_5_test.go:39: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp8hup_c_5_test.go:39: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmp8hup_c_5_test.go:39: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp8hup_c_5_test.go:39: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    if decimal == 0 {\n        return \"dbdb\"\n    }\n    result\
    \ := \"db\"\n    for ; decimal > 0; decimal /= 2 {\n        if decimal % 2 ==\
    \ 0 {\n            result = \"0\" + result\n        } else {\n            result\
    \ = \"1\" + result\n        }\n    }\n    return result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpu53920yr_test.go:49: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpu53920yr_test.go:49:\
    \ expected 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpu53920yr_test.go:49: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpu53920yr_test.go:49:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%vdb\", string(decimal))\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpq_050iu3_test.go:19:34: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    output := \"db\"\n    for decimal != 0 {\n        output += string(decimal%2)\n\
    \        decimal /= 2\n    }\n    return reverse(output) + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfw68smu0_test.go:24:12: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074339
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    r := []string{\"db\"}\n    // TODO implement me\n    return strings.Join(r,\
    \ \"\")\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwscg3d3t_test.go:21:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    //your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpiirssvze_test.go:39: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpiirssvze_test.go:39: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmpiirssvze_test.go:39: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpiirssvze_test.go:39: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074337
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    bits := \"\"\n    for decimal > 0 {\n        if decimal % 2 ==\
    \ 0 {\n            bits = \"0\" + bits\n        } else {\n            bits = \"\
    1\" + bits\n        }\n        decimal /= 2\n    }\n    return \"db\" + bits +\
    \ \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpux4m1o4d_test.go:47: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return \"db\" + string(decimal) + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpvnb7cjnk_test.go:19:19: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"db\"\n    for decimal > 0 {\n        if decimal %\
    \ 2 == 0 {\n            binary = \"0\" + binary\n        } else {\n          \
    \  binary = \"1\" + binary\n        }\n        decimal /= 2\n    }\n    return\
    \ binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp6fg0o84i_test.go:47: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp6fg0o84i_test.go:47:\
    \ expected 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp6fg0o84i_test.go:47: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp6fg0o84i_test.go:47:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary_string := \"\"\n    for decimal > 0 {\n        binary_string\
    \ = string(decimal % 2) + binary_string\n        decimal /= 2\n    }\n    return\
    \ \"db\" + binary_string + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpjtdal0uf_test.go:21:25: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    //return \"db100000db\"\n    var (\n        binary string\n  \
    \      remainder int\n    )\n    for decimal > 0 {\n        remainder = decimal\
    \ % 2\n        decimal = decimal / 2\n        binary = fmt.Sprintf(\"%v%v\", remainder,\
    \ binary)\n    }\n    return fmt.Sprintf(\"db%vdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpk_6w7tpn_test.go:48: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    a := decimal\n    b := \"\"\n    for a > 0 {\n        b = fmt.Sprintf(\"\
    %d\", a % 2) + b\n        a = a / 2\n    }\n    return \"db\" + b + \"db\"\n}\n\
    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp68ll3ezp_test.go:44: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var binary []byte\n    binary = append(binary, \"db\"...)\n  \
    \  // fmt.Println(binary)\n    if decimal == 0 {\n        binary = append(binary,\
    \ \"0\"...)\n    } else {\n        for decimal > 0 {\n            var div int\n\
    \            div = decimal / 2\n            if decimal % 2 == 0 {\n          \
    \      binary = append(binary, \"0\"...)\n            } else {\n             \
    \   binary = append(binary, \"1\"...)\n            }\n            decimal = div\n\
    \        }\n    }\n    for i, j := 0, len(binary)-1; i < j; i, j = i+1, j-1 {\n\
    \        binary[i], binary[j] = binary[j], binary[i]\n    }\n    binary = append(binary,\
    \ \"db\"...)\n    return string(binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp2_163na__test.go:59: expected 'db0db', got '0bddb'\n   \
    \ --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp2_163na__test.go:59:\
    \ expected 'db100000db', got '100000bddb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp2_163na__test.go:59: expected 'db1100111db', got '1100111bddb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp2_163na__test.go:59:\
    \ expected 'db1111db', got '1111bddb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // assuming decimals only, so no negatives and positive only.\n\
    \    // For negatives we will need two's complement\n\n    // In binary we are\
    \ looking for remainder 2,\n    // remainder from division 2 gives us the binary\
    \ result\n    // If it is 1 or 0 we stop the loop and return.\n    // Else divide\
    \ by 2 and continue the loop\n    // We will use []byte to store characters '0'\
    \ and '1'\n    // We will also return a string\n    // Check the algorithm to\
    \ find out if we need to add an extra '0' at the end\n    var binary_array []byte\n\
    \    var binary_string string\n    if decimal == 0 {\n        binary_array = append(binary_array,\
    \ '0')\n    }\n    for decimal > 0 {\n        remainder := decimal % 2\n     \
    \   if remainder == 1 {\n            binary_array = append(binary_array, '1')\n\
    \        } else {\n            binary_array = append(binary_array, '0')\n    \
    \    }\n        decimal = decimal / 2\n    }\n    binary_array = append(binary_array,\
    \ 'd')\n    binary_array = append(binary_array, 'b')\n    for i := len(binary_array)\
    \ - 1; i >= 0; i-- {\n        binary_string += string(binary_array[i])\n    }\n\
    \    return binary_string\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n \
    \ candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpipn8rs_b_test.go:67: expected 'db0db', got 'bd0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpipn8rs_b_test.go:67:\
    \ expected 'db100000db', got 'bd100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpipn8rs_b_test.go:67: expected 'db1100111db', got 'bd1100111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpipn8rs_b_test.go:67:\
    \ expected 'db1111db', got 'bd1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    str := \"\"\n    for decimal != 0 {\n        remainder := decimal\
    \ % 2\n        decimal = decimal / 2\n        str = fmt.Sprintf(\"%d%s\", remainder,\
    \ str)\n    }\n    return fmt.Sprintf(\"db%sdb\", str)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp54ezr9ks_test.go:44: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var bin string = \"db\"\n    if decimal <= 0 {\n        bin +=\
    \ \"0\"\n    }\n    for decimal > 0 {\n        if decimal % 2 == 0 {\n       \
    \     bin += \"0\"\n        } else {\n            bin += \"1\"\n        }\n  \
    \      decimal /= 2\n    }\n    bin += \"db\"\n    s := []byte(bin)\n    for i,\
    \ j := 0, len(s)-1; i < j; i, j = i+1, j-1 {\n        s[i], s[j] = s[j], s[i]\n\
    \    }\n    return string(s)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpe2hm6wh5_test.go:55: expected 'db0db', got 'bd0bd'\n   \
    \ --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpe2hm6wh5_test.go:55:\
    \ expected 'db100000db', got 'bd100000bd'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpe2hm6wh5_test.go:55: expected 'db1100111db', got 'bd1100111bd'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpe2hm6wh5_test.go:55:\
    \ expected 'db1111db', got 'bd1111bd'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074339
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%0bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"\"\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"\
    %d%s\", decimal % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpnrtcuw8n_test.go:43: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return \"db\" + fmt.Sprintf(\"%b\", decimal) + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp8hup_c_5_test.go:39: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp8hup_c_5_test.go:39: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmp8hup_c_5_test.go:39: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp8hup_c_5_test.go:39: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // Your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp4f4mmgxa_test.go:39: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp4f4mmgxa_test.go:39: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmp4f4mmgxa_test.go:39: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp4f4mmgxa_test.go:39: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074192
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n\tbinary := \"db\"\n\tfor decimal > 0 {\n\t\tbinary = string(decimal%2+48)\
    \ + binary\n\t\tdecimal /= 2\n\t}\n\treturn binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmp5ab78kuq_test.go:21:12: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"\"\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"\
    %v%v\", decimal % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%vdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpgmmjf07u_test.go:43: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%db\", fmt.Sprintf(\"%b\", decimal))\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpilwbb0ym_test.go:19:12: fmt.Sprintf format %d has arg fmt.Sprintf("%b",
    decimal) of wrong type string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074334
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"db\"\n    for decimal > 0 {\n        binary = string(decimal\
    \ % 2 + 48) + binary\n        decimal /= 2\n    }\n    return binary + \"db\"\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmp5m766ehk_test.go:21:18: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074340
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    fmt.Println(decimal)\n    if decimal == 0 {\n        return \"\
    db0db\"\n    }\n\n    binary := \"db\"\n    remainder := 0\n    for decimal >\
    \ 0 {\n        remainder = decimal % 2\n        binary = fmt.Sprintf(\"%d%s\"\
    , remainder, binary)\n        decimal = decimal / 2\n    }\n    return binary\
    \ + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "0\n32\n103\n15\n--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpc2w6hk5f_test.go:50: expected\
    \ 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpc2w6hk5f_test.go:50: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpc2w6hk5f_test.go:50:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074340
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return \"db\" + fmt.Sprintf(\"%b\", decimal) + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"\"\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"\
    %d%s\", decimal % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpnrtcuw8n_test.go:43: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return \"db\" + \"\" + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp6u864vvw_test.go:38: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp6u864vvw_test.go:38:\
    \ expected 'db100000db', got 'dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp6u864vvw_test.go:38: expected 'db1100111db', got 'dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp6u864vvw_test.go:38:\
    \ expected 'db1111db', got 'dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074340
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := []byte{'d', 'b'}\n    var i int\n    for decimal > 0\
    \ {\n        remainder := decimal % 2\n        decimal = decimal / 2\n       \
    \ binary = append(binary, byte(remainder+48))\n        i++\n    }\n    for j :=\
    \ 0; j < i/2; j++ {\n        binary[j+2], binary[i+1-j] = binary[i+1-j], binary[j+2]\n\
    \    }\n    binary = append(binary, 'd', 'b')\n    return string(binary)\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp_084xxsn_test.go:50: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074341
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // See\n    // http://www.dotnetperls.com/convert-int-to-binary-go\n\
    \    // for alternative approach.\n    b := \"\"\n    for decimal > 0 {\n    \
    \    b = fmt.Sprintf(\"%v%v\", decimal % 2, b)\n        decimal = decimal / 2\n\
    \    }\n    return fmt.Sprintf(\"db%vdb\", b)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpit4d8ril_test.go:46: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074341
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // your code here\n    return \"db100000db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpaojnqqos_test.go:39: expected 'db0db', got 'db100000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpaojnqqos_test.go:39:\
    \ expected 'db1100111db', got 'db100000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpaojnqqos_test.go:39: expected 'db1111db', got 'db100000db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074341
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var d int\n    var result string\n    for decimal > 0 {\n    \
    \    d = decimal % 2\n        decimal = decimal / 2\n        result = fmt.Sprintf(\"\
    %d%s\", d, result)\n    }\n    return fmt.Sprintf(\"db%sdb\", result)\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp8q2828o__test.go:45: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074342
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%sdb\", fmt.Sprintf(\"%b\", decimal))\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074335
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    for i := 0; i < 10; i++ {\n        fmt.Println(i)\n    }\n   \
    \ return \"db1111db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n0\n1\n2\n3\n\
    4\n5\n6\n7\n8\n9\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n--- FAIL: TestDecimal_To_Binary\
    \ (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0 (0.00s)\n        tmpv8x1bjjq_test.go:41:\
    \ expected 'db0db', got 'db1111db'\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpv8x1bjjq_test.go:41: expected 'db100000db', got 'db1111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpv8x1bjjq_test.go:41:\
    \ expected 'db1100111db', got 'db1111db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    if decimal == 0 {\n        return \"db0db\"\n    }\n    result\
    \ := \"db\"\n    for decimal > 0 {\n        if decimal%2 == 0 {\n            result\
    \ = \"0\" + result\n        } else {\n            result = \"1\" + result\n  \
    \      }\n        decimal /= 2\n    }\n    return result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpuqhx94q3_test.go:50: expected 'db100000db', got '100000dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpuqhx94q3_test.go:50:\
    \ expected 'db1100111db', got '1100111dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpuqhx94q3_test.go:50: expected 'db1111db', got '1111dbdb'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074342
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return \"db\" + fmt.Sprintf(\"%b\", decimal) + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return \"db\" + fmt.Sprintf(\"%b\", decimal) + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n\treturn fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074342
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%0bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660074339
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var binary [8]int\n    var binary_string string\n    for i :=\
    \ 0; i < 8; i++ {\n        binary[i] = decimal % 2\n        decimal = decimal\
    \ / 2\n    }\n    binary_string = \"db\"\n    for i := 7; i >= 0; i-- {\n    \
    \    temp := strconv.Itoa(binary[i])\n        binary_string += temp\n    }\n \
    \   binary_string += \"db\"\n    return binary_string\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe473d8sq_test.go:27:17: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074341
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp8hup_c_5_test.go:39: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp8hup_c_5_test.go:39: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmp8hup_c_5_test.go:39: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp8hup_c_5_test.go:39: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    hex := \"0123456789abcdef\"\n    result := \"\"\n    for decimal\
    \ > 0 {\n        result = string(hex[decimal % 2]) + result\n        decimal /=\
    \ 2\n    }\n    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpd56_49rn_test.go:44: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    str := \"db\"\n    for decimal > 0 {\n        str = fmt.Sprintf(\"\
    %s%d\", str, decimal%2)\n        decimal /= 2\n    }\n    str += \"db\"\n    return\
    \ str\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpfv3dqfau_test.go:44: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpfv3dqfau_test.go:44:\
    \ expected 'db100000db', got 'db000001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpfv3dqfau_test.go:44: expected 'db1100111db', got 'db1110011db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var binary string\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"\
    %d%s\", decimal % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpmykdmys3_test.go:43: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // Convert the number to binary.\n    // Return the binary number\
    \ as a string.\n    // Each character in the string should be either a '0' or\
    \ a '1'.\n    // Don't forget the extra characters 'db' at the beginning and at\
    \ the end of the string.\n    // Example:\n    // >>> decimal_to_binary(15)\n\
    \    // \"db1111db\"\n    binary := fmt.Sprintf(\"%b\", decimal)\n    return fmt.Sprintf(\"\
    db%vdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074342
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"\"\n    if decimal == 0 {\n        return \"db0db\"\
    \n    }\n    for decimal > 0 {\n        if decimal % 2 == 0 {\n            binary\
    \ = \"0\" + binary\n        } else {\n            binary = \"1\" + binary\n  \
    \      }\n        decimal /= 2\n    }\n    return \"db\" + binary + \"db\"\n}\n\
    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660074342
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n\tdb := \"db\"\n\tbin := \"\"\n\tfor decimal > 0 {\n\t\tbin = string(decimal\
    \ % 2) + bin\n\t\tdecimal /= 2\n\t}\n\treturn db + bin + db\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpknff9bpw_test.go:22:9: conversion from int to string yields a string of
    one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    bin := \"\"\n    for decimal > 0 {\n        rem := decimal % 2\n\
    \        decimal = decimal / 2\n        bin = fmt.Sprintf(\"%v%v\", rem, bin)\n\
    \    }\n    return fmt.Sprintf(\"db%vdb\", bin)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpffb6seio_test.go:44: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    if decimal == 0 {\n        return \"db0db\"\n    }\n    binary\
    \ := \"db\"\n    for decimal > 0 {\n        if decimal % 2 == 0 {\n          \
    \  binary = \"0\" + binary\n        } else {\n            binary = \"1\" + binary\n\
    \        }\n        decimal /= 2\n    }\n    return binary + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpycon39v3_test.go:50: expected 'db100000db', got '100000dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpycon39v3_test.go:50:\
    \ expected 'db1100111db', got '1100111dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpycon39v3_test.go:50: expected 'db1111db', got '1111dbdb'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"db\"\n    for decimal > 0 {\n        if decimal %\
    \ 2 == 0 {\n            binary = \"0\" + binary\n        } else {\n          \
    \  binary = \"1\" + binary\n        }\n        decimal /= 2\n    }\n    return\
    \ binary + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp6fg0o84i_test.go:47: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp6fg0o84i_test.go:47:\
    \ expected 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp6fg0o84i_test.go:47: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp6fg0o84i_test.go:47:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074339
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return \"db\" + \"1001\" + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp4l77lncw_test.go:38: expected 'db0db', got 'db1001db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp4l77lncw_test.go:38:\
    \ expected 'db100000db', got 'db1001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp4l77lncw_test.go:38: expected 'db1100111db', got 'db1001db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp4l77lncw_test.go:38:\
    \ expected 'db1111db', got 'db1001db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    str := \"\"\n    for decimal > 0 {\n        rem := decimal % 2\n\
    \        decimal = decimal / 2\n        str = fmt.Sprintf(\"%v%v\", rem, str)\n\
    \    }\n    return fmt.Sprintf(\"db%vdb\", str)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpba9m1vzx_test.go:44: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var result string = \"db\"\n    for decimal > 0 {\n        if\
    \ decimal%2 == 0 {\n            result = \"0\" + result\n        } else {\n  \
    \          result = \"1\" + result\n        }\n        decimal /= 2\n    }\n \
    \   return result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpyst5amtv_test.go:47: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpyst5amtv_test.go:47:\
    \ expected 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpyst5amtv_test.go:47: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpyst5amtv_test.go:47:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074342
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    if decimal == 0 {\n        return \"db0db\"\n    }\n    result\
    \ := []string{\"db\"}\n    for decimal > 0 {\n        result = append(result,\
    \ string(decimal % 2 + 48))\n        decimal /= 2\n    }\n    result = append(result,\
    \ \"db\")\n    // reverse string\n    for i, j := 0, len(result) - 1; i < j; i,\
    \ j = i + 1, j - 1 {\n        result[i], result[j] = result[j], result[i]\n  \
    \  }\n    return strings.Join(result, \"\")\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwk6pfs6r_test.go:32:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074341
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var s string = \"db\"\n    for decimal > 0 {\n        s = string([]byte{'0'\
    \ + byte(decimal % 2)}) + s\n        decimal /= 2\n    }\n    return s + \"db\"\
    \n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpw10rrr9t_test.go:43: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpw10rrr9t_test.go:43:\
    \ expected 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpw10rrr9t_test.go:43: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpw10rrr9t_test.go:43:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // code goes here\n    return \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpch9x8z1m_test.go:39: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpch9x8z1m_test.go:39:\
    \ expected 'db100000db', got 'db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpch9x8z1m_test.go:39: expected 'db1100111db', got 'db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpch9x8z1m_test.go:39:\
    \ expected 'db1111db', got 'db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var output []rune\n    output = append(output, 'd', 'b')\n   \
    \ for decimal > 0 {\n        if decimal % 2 == 0 {\n            output = append(output,\
    \ '0')\n        } else {\n            output = append(output, '1')\n        }\n\
    \        decimal /= 2\n    }\n    output = append(output, 'd', 'b')\n    length\
    \ := len(output)\n    for i := 0; i < length/2; i++ {\n        output[i], output[length-i-1]\
    \ = output[length-i-1], output[i]\n    }\n    return string(output)\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp4xtpbktx_test.go:53: expected 'db0db', got 'bdbd'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp4xtpbktx_test.go:53:\
    \ expected 'db100000db', got 'bd100000bd'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp4xtpbktx_test.go:53: expected 'db1100111db', got 'bd1100111bd'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp4xtpbktx_test.go:53:\
    \ expected 'db1111db', got 'bd1111bd'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074342
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"db\"\n    for i := 0; i < 8; i++ {\n        if (decimal\
    \ & 0x80) != 0 {\n            binary += \"1\"\n        } else {\n            binary\
    \ += \"0\"\n        }\n        decimal <<= 1\n    }\n    binary += \"db\"\n  \
    \  return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpvmrdmhh8_test.go:48: expected 'db0db', got 'db00000000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpvmrdmhh8_test.go:48:\
    \ expected 'db100000db', got 'db00100000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpvmrdmhh8_test.go:48: expected 'db1100111db', got 'db01100111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpvmrdmhh8_test.go:48:\
    \ expected 'db1111db', got 'db00001111db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660074342
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    if decimal == 0 {\n        return \"db0db\"\n    }\n    result\
    \ := \"db\"\n    for decimal > 0 {\n        result = string(decimal % 2 + '0')\
    \ + result\n        decimal /= 2\n    }\n    return result + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmp8uc51406_test.go:24:18: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074343
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var binary string\n    for decimal > 0 {\n        if decimal%2\
    \ == 0 {\n            binary = fmt.Sprintf(\"%d%s\", 0, binary)\n        } else\
    \ {\n            binary = fmt.Sprintf(\"%d%s\", 1, binary)\n        }\n      \
    \  decimal /= 2\n    }\n    //fmt.Println(binary)\n    return fmt.Sprintf(\"db%sdb\"\
    , binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmph6ik5yz7_test.go:48: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074343
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var binary string = \"db\"\n    var binary_rev string\n    for\
    \ decimal > 0 {\n        if decimal%2 == 0 {\n            binary += \"0\"\n  \
    \      } else {\n            binary += \"1\"\n        }\n        decimal /= 2\n\
    \    }\n    for i := len(binary)-1; i > 1; i-- {\n        binary_rev += string(binary[i])\n\
    \    }\n    binary_rev += \"db\"\n    return binary_rev\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp031ujv0w_test.go:52: expected 'db0db', got 'db'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp031ujv0w_test.go:52:\
    \ expected 'db100000db', got '100000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp031ujv0w_test.go:52: expected 'db1100111db', got '1100111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp031ujv0w_test.go:52:\
    \ expected 'db1111db', got '1111db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074343
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    if decimal == 0 {\n        return \"db0db\"\n    }\n    var binary\
    \ string\n    for decimal > 0 {\n        if decimal % 2 == 0 {\n            binary\
    \ = \"0\" + binary\n        } else {\n            binary = \"1\" + binary\n  \
    \      }\n        decimal /= 2\n    }\n    return \"db\" + binary + \"db\"\n}\n\
    \nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660074344
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return \"db\" + fmt.Sprintf(\"%b\", decimal) + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"\"\n    for decimal > 0 {\n        remainder := decimal\
    \ % 2\n        binary = fmt.Sprintf(\"%d%s\", remainder, binary)\n        decimal\
    \ = decimal / 2\n    }\n    return fmt.Sprintf(\"db%sdb\", binary)\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp67udjx7k_test.go:44: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074344
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var ret string = \"db\"\n    var base int = 2\n    var rem int\n\
    \    for decimal != 0 {\n        rem = decimal % base\n        decimal = decimal\
    \ / base\n        ret = fmt.Sprintf(\"%s%d\", ret, rem)\n    }\n    ret = fmt.Sprintf(\"\
    %sdb\", ret)\n    return ret\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp8z8cp56c_test.go:47: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp8z8cp56c_test.go:47:\
    \ expected 'db100000db', got 'db000001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp8z8cp56c_test.go:47: expected 'db1100111db', got 'db1110011db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074344
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return \"db\" + fmt.Sprintf(\"%b\", decimal) + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%db\", fmt.Sprintf(\"%b\", decimal))\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpilwbb0ym_test.go:19:12: fmt.Sprintf format %d has arg fmt.Sprintf("%b",
    decimal) of wrong type string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074334
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    res := \"db\"\n    for decimal > 0 {\n        res = fmt.Sprintf(\"\
    %s%d\", res, decimal % 2)\n        decimal /= 2\n    }\n    res += \"db\"\n  \
    \  return res\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate :=\
    \ decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpvbmek0rv_test.go:44: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpvbmek0rv_test.go:44:\
    \ expected 'db100000db', got 'db000001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpvbmek0rv_test.go:44: expected 'db1100111db', got 'db1110011db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074344
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    panic(\"Not implemented\")\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\npanic: Not implemented [recovered]\n\
    \tpanic: Not implemented\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x4fcd60,\
    \ 0x548940})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x4fcd60, 0x548940})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.decimal_to_binary(...)\n\t/tmp/tmp3v9qoc66_test.go:19\n\
    command-line-arguments_test.TestDecimal_To_Binary(0x0?)\n\t/tmp/tmp3v9qoc66_test.go:29\
    \ +0x27\ntesting.tRunner(0xc0000da1a0, 0x527d50)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074344
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    ret := \"db\"\n    for decimal > 0 {\n        ret = fmt.Sprintf(\"\
    %d%s\", decimal % 2, ret)\n        decimal /= 2\n    }\n    ret += \"db\"\n  \
    \  return ret\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate :=\
    \ decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpvi3ssg3h_test.go:44: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpvi3ssg3h_test.go:44:\
    \ expected 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpvi3ssg3h_test.go:44: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpvi3ssg3h_test.go:44:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660074344
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var binary string\n    for decimal > 0 {\n        binary = string(decimal\
    \ % 2 + 48) + binary\n        decimal /= 2\n    }\n    binary = \"db\" + binary\
    \ + \"db\"\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmp1ll8fbwd_test.go:21:18: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074344
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    result := \"db\"\n    for decimal > 0 {\n        remain := decimal\
    \ % 2\n        decimal = decimal / 2\n        result = string(remain + 48) + result\n\
    \    }\n    return result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpiamknj_7_test.go:23:18: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074344
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return \"db1101db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpk08udvll_test.go:38: expected 'db0db', got 'db1101db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpk08udvll_test.go:38:\
    \ expected 'db100000db', got 'db1101db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpk08udvll_test.go:38: expected 'db1100111db', got 'db1101db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpk08udvll_test.go:38:\
    \ expected 'db1111db', got 'db1101db'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074344
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary_str := \"db\"\n    for decimal > 0 {\n        binary_str\
    \ = fmt.Sprintf(\"%s%d\", binary_str, decimal % 2)\n        decimal /= 2\n   \
    \ }\n    binary_str += \"db\"\n    return binary_str\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpupsaamdu_test.go:44: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpupsaamdu_test.go:44:\
    \ expected 'db100000db', got 'db000001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpupsaamdu_test.go:44: expected 'db1100111db', got 'db1110011db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074344
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%db\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp2qk1vnaa_test.go:38: expected 'db0db', got 'db0b'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp2qk1vnaa_test.go:38:\
    \ expected 'db100000db', got 'db32b'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp2qk1vnaa_test.go:38: expected 'db1100111db', got 'db103b'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp2qk1vnaa_test.go:38:\
    \ expected 'db1111db', got 'db15b'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074344
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var result string = \"db\"\n    var last_bit int\n    for {\n\
    \        if decimal <= 0 {\n            break\n        }\n        last_bit = decimal\
    \ % 2\n        result = fmt.Sprintf(\"%d%s\", last_bit, result)\n        decimal\
    \ = decimal / 2\n    }\n    result = fmt.Sprintf(\"%sdb\", result)\n    return\
    \ result\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp6_5ro74q_test.go:49: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp6_5ro74q_test.go:49:\
    \ expected 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp6_5ro74q_test.go:49: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp6_5ro74q_test.go:49:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074344
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // Your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp4f4mmgxa_test.go:39: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp4f4mmgxa_test.go:39: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmp4f4mmgxa_test.go:39: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp4f4mmgxa_test.go:39: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // your code here...\n    return \"db1111db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmph_iqwjyv_test.go:39: expected 'db0db', got 'db1111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmph_iqwjyv_test.go:39:\
    \ expected 'db100000db', got 'db1111db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmph_iqwjyv_test.go:39: expected 'db1100111db', got 'db1111db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074344
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var binString string = \"db\"\n    var count int = 0\n    var\
    \ limit int = 32\n    var temp int = decimal\n    if decimal < 0 {\n        limit\
    \ = 31\n        decimal = decimal * -1\n    }\n    for i := 0; i < limit; i++\
    \ {\n        binString += string(temp & 1)\n        temp = temp >> 1\n       \
    \ count++\n        if count == 4 {\n            binString += \" \"\n         \
    \   count = 0\n        }\n    }\n    binString += \"db\"\n    return binString\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpl9wwad5g_test.go:28:22: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074344
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    fmt.Println(decimal)\n    res := \"db\"\n    for decimal > 0 {\n\
    \        res = res + string(decimal % 2 + 48)\n        decimal = decimal / 2\n\
    \    }\n    res = res + \"db\"\n    return res\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmp68ujovsp_test.go:22:21: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074344
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // your code goes here\n    return \"db\" + \"100000\" + \"db\"\
    \n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmptrs2qdhg_test.go:39: expected 'db0db', got 'db100000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmptrs2qdhg_test.go:39:\
    \ expected 'db1100111db', got 'db100000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmptrs2qdhg_test.go:39: expected 'db1111db', got 'db100000db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074344
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var res string\n    for decimal > 0 {\n        if decimal % 2\
    \ == 0 {\n            res = \"0\" + res\n        } else {\n            res = \"\
    1\" + res\n        }\n        decimal /= 2\n    }\n    return \"db\" + res + \"\
    db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp53ne7aeo_test.go:47: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074344
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var binary = \"\"\n    for decimal != 0 {\n        last_digit\
    \ := decimal % 2\n        decimal = decimal / 2\n        binary = fmt.Sprintf(\"\
    %d%s\", last_digit, binary)\n    }\n    return fmt.Sprintf(\"db%sdb\", binary)\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmprr1tudb0_test.go:44: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074344
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // binary := fmt.Sprintf(\"%08b\", decimal)\n    binary := fmt.Sprintf(\"\
    %b\", decimal)\n    return fmt.Sprintf(\"db%sdb\", binary)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074344
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    if decimal == 0 {\n        return \"db0db\"\n    }\n    var num\
    \ string\n    for decimal > 0 {\n        num = string(decimal % 2 + 48) + num\n\
    \        decimal /= 2\n    }\n    return \"db\" + num + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpv6vle7gs_test.go:24:15: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074345
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var binary string = \"db\"\n    var remander int = 0\n    var\
    \ binary_map = map[int]string{0: \"0\", 1: \"1\"}\n\n    for {\n        remander\
    \ = decimal % 2\n        decimal = decimal / 2\n        binary = binary + binary_map[remander]\n\
    \        if decimal == 0 {\n            break\n        }\n    }\n\n    return\
    \ reverse(binary) + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdp57211k_test.go:32:12: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074345
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n\tif decimal == 0 {\n\t\treturn \"db0db\"\n\t}\n\tvar bin string\n\
    \tfor decimal > 0 {\n\t\tbin = fmt.Sprintf(\"%s%d\", bin, decimal%2)\n\t\tdecimal\
    \ /= 2\n\t}\n\tbin = fmt.Sprintf(\"db%sdb\", bin)\n\treturn bin\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmppxicprz4_test.go:47: expected 'db100000db', got 'db000001db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmppxicprz4_test.go:47:\
    \ expected 'db1100111db', got 'db1110011db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074347
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    if decimal < 0 {\n        return \"db\" + decimal_to_binary(-decimal)\
    \ + \"db\"\n    }\n    if decimal == 0 {\n        return \"db0db\"\n    }\n  \
    \  if decimal == 1 {\n        return \"db1db\"\n    }\n    if decimal%2 == 0 {\n\
    \        return decimal_to_binary(decimal/2) + \"0\"\n    }\n    return decimal_to_binary(decimal/2)\
    \ + \"1\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpvflyiqba_test.go:50: expected 'db100000db', got 'db1db00000'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpvflyiqba_test.go:50:\
    \ expected 'db1100111db', got 'db1db100111'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmpvflyiqba_test.go:50: expected 'db1111db', got 'db1db111'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074347
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return \"db\" + strconv.FormatInt(int64(decimal), 2) + \"db\"\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyxv1itzd_test.go:19:19: undefined: strconv

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074346
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var binary string = \"db\"\n    for decimal > 0 {\n        binary\
    \ += fmt.Sprintf(\"%d\", decimal % 2)\n        decimal /= 2\n    }\n    return\
    \ Reverse(binary) + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp72_4onlv_test.go:24:12: undefined: Reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074346
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var bin []byte\n    bin = append(bin, 'd')\n    bin = append(bin,\
    \ 'b')\n    for decimal > 0 {\n        if decimal % 2 == 0 {\n            bin\
    \ = append(bin, '0')\n        } else {\n            bin = append(bin, '1')\n \
    \       }\n        decimal /= 2\n    }\n    bin = append(bin, 'd')\n    bin =\
    \ append(bin, 'b')\n    return string(bin)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpg0y3dlxu_test.go:51: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpg0y3dlxu_test.go:51:\
    \ expected 'db100000db', got 'db000001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpg0y3dlxu_test.go:51: expected 'db1100111db', got 'db1110011db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074347
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var binary string\n    if decimal == 0 {\n        return \"db0db\"\
    \n    }\n    for decimal > 0 {\n        binary = fmt.Sprintf(\"%d%s\", decimal\
    \ % 2, binary)\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"db%sdb\"\
    , binary)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074338
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    const base = 2\n    var result string\n    for decimal > 0 {\n\
    \        if decimal % base == 0 {\n            result = \"0\" + result\n     \
    \   } else {\n            result = \"1\" + result\n        }\n        decimal\
    \ /= base\n    }\n    return \"db\" + result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpopy762vy_test.go:48: expected 'db0db', got 'dbdb'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074347
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    if decimal < 0 {\n        panic(\"Decimal can't be negative!\"\
    )\n    }\n    if decimal < 2 {\n        return fmt.Sprintf(\"db%d\", decimal)\n\
    \    }\n    return decimal_to_binary(decimal / 2) + fmt.Sprintf(\"%d\", decimal\
    \ % 2)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpx_ugr_b6_test.go:44: expected 'db0db', got 'db0'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpx_ugr_b6_test.go:44:\
    \ expected 'db100000db', got 'db100000'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpx_ugr_b6_test.go:44: expected 'db1100111db', got 'db1100111'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpx_ugr_b6_test.go:44:\
    \ expected 'db1111db', got 'db1111'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074347
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n\tstr := \"db\"\n\tfor decimal != 0 {\n\t\tstr += string(decimal%2)\n\
    \t\tdecimal /= 2\n\t}\n\tstr += \"db\"\n\treturn str\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpfr9jmn6c_test.go:21:10: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074347
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    out := \"db\"\n    for decimal > 0 {\n        last := decimal\
    \ & 1\n        decimal = decimal >> 1\n        out = string(last) + out\n    }\n\
    \    return out + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpgntekogf_test.go:23:15: conversion from int to string yields a string
    of one rune, not a string of digits (did you mean fmt.Sprint(x)?)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074347
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    bin := \"db\"\n    for decimal > 0 {\n        if decimal % 2 ==\
    \ 0 {\n            bin = \"0\" + bin\n        } else {\n            bin = \"1\"\
    \ + bin\n        }\n        decimal /= 2\n    }\n    return bin + \"db\"\n}\n\n\
    func TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpznz1b237_test.go:47: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpznz1b237_test.go:47:\
    \ expected 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpznz1b237_test.go:47: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmpznz1b237_test.go:47:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074347
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    binary := \"\"\n    binary += \"db\"\n    if decimal == 0 {\n\
    \        binary += \"0\"\n    } else {\n        for decimal > 0 {\n          \
    \  binary += fmt.Sprintf(\"%d\", decimal % 2)\n            decimal /= 2\n    \
    \    }\n    }\n    binary += \"db\"\n    return binary\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp35z2nc9c_test.go:49: expected 'db100000db', got 'db000001db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp35z2nc9c_test.go:49:\
    \ expected 'db1100111db', got 'db1110011db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074347
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    if decimal == 0 {\n        return \"db0db\"\n    }\n    const\
    \ (\n        zero_char    = '0'\n        one_char     = '1'\n        prefix_char\
    \  = 'd'\n        suffix_char  = 'b'\n    )\n    chars := make([]byte, 0)\n  \
    \  chars = append(chars, prefix_char)\n    for decimal > 0 {\n        if decimal\
    \ & 1 == 1 {\n            chars = append(chars, one_char)\n        } else {\n\
    \            chars = append(chars, zero_char)\n        }\n        decimal >>=\
    \ 1\n    }\n    chars = append(chars, suffix_char)\n    // reverse the chars\n\
    \    for i, j := 0, len(chars) - 1; i < j; i, j = i + 1, j - 1 {\n        chars[i],\
    \ chars[j] = chars[j], chars[i]\n    }\n    return string(chars)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp4t09irip_test.go:62: expected 'db100000db', got 'b100000d'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp4t09irip_test.go:62:\
    \ expected 'db1100111db', got 'b1100111d'\n    --- FAIL: TestDecimal_To_Binary/test_num__3\
    \ (0.00s)\n        tmp4t09irip_test.go:62: expected 'db1111db', got 'b1111d'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074347
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // your code here\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp8hup_c_5_test.go:39: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp8hup_c_5_test.go:39: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmp8hup_c_5_test.go:39: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp8hup_c_5_test.go:39: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // your code here\n    return \"db1111db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp65tptvj0_test.go:39: expected 'db0db', got 'db1111db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp65tptvj0_test.go:39:\
    \ expected 'db100000db', got 'db1111db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp65tptvj0_test.go:39: expected 'db1100111db', got 'db1111db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return \"db\" + \"10000\" + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp6ezixcrc_test.go:38: expected 'db0db', got 'db10000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp6ezixcrc_test.go:38:\
    \ expected 'db100000db', got 'db10000db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp6ezixcrc_test.go:38: expected 'db1100111db', got 'db10000db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp6ezixcrc_test.go:38:\
    \ expected 'db1111db', got 'db10000db'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074347
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    if decimal == 0 {\n        return \"db0db\"\n    }\n    var binStr\
    \ string\n    for decimal > 0 {\n        if decimal % 2 == 0 {\n            binStr\
    \ = fmt.Sprintf(\"%s0\", binStr)\n        } else {\n            binStr = fmt.Sprintf(\"\
    %s1\", binStr)\n        }\n        decimal /= 2\n    }\n    return fmt.Sprintf(\"\
    db%sdb\", binStr)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate\
    \ := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0), expected:\
    \ \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\" },\n  \
    \   { actual: candidate(103), expected: \"db1100111db\" },\n     { actual: candidate(15),\
    \ expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmpj54tuzf__test.go:50: expected 'db100000db', got 'db000001db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmpj54tuzf__test.go:50:\
    \ expected 'db1100111db', got 'db1110011db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660074347
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%sdb\", fmt.Sprintf(\"%b\", decimal))\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074335
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var binary, prefix string\n    for decimal > 0 {\n        binary\
    \ = fmt.Sprintf(\"%s%d\", binary, decimal % 2)\n        decimal /= 2\n    }\n\
    \    prefix = \"db\"\n    return fmt.Sprintf(\"%s%s%s\", prefix, binary, prefix)\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmpkan1iyko_test.go:44: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmpkan1iyko_test.go:44:\
    \ expected 'db100000db', got 'db000001db'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmpkan1iyko_test.go:44: expected 'db1100111db', got 'db1110011db'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074347
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%sdb\", fmt.Sprintf(\"%b\", decimal))\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074335
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var result string = \"db\"\n    for decimal > 0 {\n        var\
    \ remainder = decimal % 2\n        decimal = decimal / 2\n        if remainder\
    \ == 0 {\n            result = \"0\" + result\n        } else {\n            result\
    \ = \"1\" + result\n        }\n    }\n    return result + \"db\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp5d8ds8i1_test.go:48: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp5d8ds8i1_test.go:48:\
    \ expected 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp5d8ds8i1_test.go:48: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp5d8ds8i1_test.go:48:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660074347
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    var bin_str string = \"db\"\n    if decimal < 2 {\n        bin_str\
    \ += fmt.Sprintf(\"%d\", decimal)\n    } else {\n        bin_str += decimal_to_binary(decimal\
    \ / 2)\n        bin_str += fmt.Sprintf(\"%d\", decimal % 2)\n    }\n    bin_str\
    \ += \"db\"\n    return bin_str\n}\n\nfunc TestDecimal_To_Binary(t *testing.T)\
    \ {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__1\
    \ (0.00s)\n        tmp83sy4_qi_test.go:46: expected 'db100000db', got 'dbdbdbdbdbdb1db0db0db0db0db0db'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n        tmp83sy4_qi_test.go:46:\
    \ expected 'db1100111db', got 'dbdbdbdbdbdbdb1db1db0db0db1db1db1db'\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp83sy4_qi_test.go:46: expected\
    \ 'db1111db', got 'dbdbdbdb1db1db1db1db'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074347
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    // YOUR CODE GOES HERE\n    return \"\"\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp390pewir_test.go:39: expected 'db0db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp390pewir_test.go:39: expected\
    \ 'db100000db', got ''\n    --- FAIL: TestDecimal_To_Binary/test_num__2 (0.00s)\n\
    \        tmp390pewir_test.go:39: expected 'db1100111db', got ''\n    --- FAIL:\
    \ TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp390pewir_test.go:39: expected\
    \ 'db1111db', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074347
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%db\", fmt.Sprintf(\"%b\", decimal))\n\
    }\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpilwbb0ym_test.go:19:12: fmt.Sprintf format %d has arg fmt.Sprintf("%b",
    decimal) of wrong type string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074334
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return \"db\" + fmt.Sprintf(\"%b\", decimal) + \"db\"\n}\n\nfunc\
    \ TestDecimal_To_Binary(t *testing.T) {\n  candidate := decimal_to_binary\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(0), expected: \"db0db\" },\n  \
    \   { actual: candidate(32), expected: \"db100000db\" },\n     { actual: candidate(103),\
    \ expected: \"db1100111db\" },\n     { actual: candidate(15), expected: \"db1111db\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 0
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    return fmt.Sprintf(\"db%bdb\", decimal)\n}\n\nfunc TestDecimal_To_Binary(t\
    \ *testing.T) {\n  candidate := decimal_to_binary\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(0), expected: \"db0db\" },\n     { actual: candidate(32),\
    \ expected: \"db100000db\" },\n     { actual: candidate(103), expected: \"db1100111db\"\
    \ },\n     { actual: candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660074192
- exit_code: 1
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n\tbin := \"db\"\n\tfor i := decimal; i > 0; i = i / 2 {\n\t\tb :=\
    \ i % 2\n\t\tbin = fmt.Sprintf(\"%d%s\", b, bin)\n\t}\n\tbin = fmt.Sprintf(\"\
    %sdb\", bin)\n\treturn bin\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestDecimal_To_Binary (0.00s)\n    --- FAIL: TestDecimal_To_Binary/test_num__0\
    \ (0.00s)\n        tmp9eyaol8j_test.go:44: expected 'db0db', got 'dbdb'\n    ---\
    \ FAIL: TestDecimal_To_Binary/test_num__1 (0.00s)\n        tmp9eyaol8j_test.go:44:\
    \ expected 'db100000db', got '100000dbdb'\n    --- FAIL: TestDecimal_To_Binary/test_num__2\
    \ (0.00s)\n        tmp9eyaol8j_test.go:44: expected 'db1100111db', got '1100111dbdb'\n\
    \    --- FAIL: TestDecimal_To_Binary/test_num__3 (0.00s)\n        tmp9eyaol8j_test.go:44:\
    \ expected 'db1111db', got '1111dbdb'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\n\
    FAIL\n"
  timestamp: 1660074347
- exit_code: 2
  program: "package decimal_to_binary_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// You will be given a number in decimal form and your task is to convert\
    \ it to\n// binary format. The function should return a string, with each character\
    \ representing a binary\n// number. Each character in the string will be '0' or\
    \ '1'.\n// There will be an extra couple of characters 'db' at the beginning and\
    \ at the end of the string.\n// The extra characters are there to help with the\
    \ format.\n// Examples:\n// >>> decimal_to_binary(15)\n// \"db1111db\"\n// >>>\
    \ decimal_to_binary(32)\n// \"db100000db\"\nfunc decimal_to_binary(decimal int)\
    \ string {\n    bin_str := \"db\"\n    if decimal == 0 {\n        bin_str += \"\
    0\"\n    }\n    for decimal > 0 {\n        remain := decimal % 2\n        if remain\
    \ == 0 {\n            bin_str += \"0\"\n        } else {\n            bin_str\
    \ += \"1\"\n        }\n        decimal /= 2\n    }\n    bin_str += \"db\"\n  \
    \  return Reverse(bin_str)\n}\n\nfunc TestDecimal_To_Binary(t *testing.T) {\n\
    \  candidate := decimal_to_binary\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(0),\
    \ expected: \"db0db\" },\n     { actual: candidate(32), expected: \"db100000db\"\
    \ },\n     { actual: candidate(103), expected: \"db1100111db\" },\n     { actual:\
    \ candidate(15), expected: \"db1111db\" },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpre1ngj68_test.go:33:12: undefined: Reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074346
