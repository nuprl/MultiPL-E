language: go_test.go
name: HumanEval_73_smallest_change
results:
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    a_len := len(arr)\n    if a_len < 2 {\n        return 0\n\
    \    }\n    mid := a_len / 2\n    if a_len % 2 == 0 {\n        return compare_arrays(arr[:mid],\
    \ arr[mid:])\n    } else {\n        return compare_arrays(arr[:mid], arr[mid+1:])\n\
    \    }\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5gek4itc_test.go:25:16: undefined: compare_arrays

    /tmp/tmp5gek4itc_test.go:27:16: undefined: compare_arrays

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) < 2 {\n        return 0\n    }\n    if len(arr)\
    \ == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        }\n   \
    \     return 1\n    }\n    change_count := 0\n    left := 0\n    right := len(arr)\
    \ - 1\n    for left < right {\n        if arr[left] == arr[right] {\n        \
    \    left++\n            right--\n        } else {\n            // if left_val\
    \ less than right_val, then change left_val to right_val and move left to right\n\
    \            if arr[left] < arr[right] {\n                arr[left] = arr[right]\n\
    \                left++\n            } else {\n                arr[right] = arr[left]\n\
    \                right--\n            }\n            change_count++\n        }\n\
    \    }\n    return change_count\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpsxq79jn6_test.go:70: expected '%!s(int=4)', got '%!s(int=7)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpsxq79jn6_test.go:70:\
    \ expected '%!s(int=1)', got '%!s(int=2)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpsxq79jn6_test.go:70: expected '%!s(int=1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpsxq79jn6_test.go:70:\
    \ expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr)\
    \ % 2 == 0 {\n        return smallest_change_even(arr)\n    } else {\n       \
    \ return smallest_change_odd(arr)\n    }\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphh1bqv23_test.go:23:16: undefined: smallest_change_even

    /tmp/tmphh1bqv23_test.go:25:16: undefined: smallest_change_odd

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    n := len(arr)\n    if n < 2 {\n        return 0\n    }\n \
    \   num_changes := 0\n    for i := 0; i < n/2; i++ {\n        if arr[i] != arr[n-i-1]\
    \ {\n            num_changes++\n        }\n    }\n    return num_changes\n}\n\n\
    func TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected:\
    \ 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 2, 3, 2, 1}), expected:\
    \ 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual:\
    \ candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0, 1}),\
    \ expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // TODO: Implement\n    return 0\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmp1bn526hj_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmp1bn526hj_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmp1bn526hj_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmp1bn526hj_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmp1bn526hj_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if arr == nil || len(arr) == 0 {\n        return 0\n    }\n\
    \    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprtppg80p_test.go:45: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprtppg80p_test.go:45:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprtppg80p_test.go:45: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprtppg80p_test.go:45:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprtppg80p_test.go:45: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // Check for edge cases, then set the starting values.\n \
    \   if len(arr) == 0 {\n        return 0\n    }\n    start := 0\n    end := len(arr)\
    \ - 1\n    change := 0\n\n    // Iterate the list\n    for start < end {\n   \
    \     // Do a slice of each half of the list.\n        firstHalf := arr[start:end+1]\n\
    \        secondHalf := arr[end:start-1:-1]\n\n        // If they match, we can\
    \ keep going.\n        if firstHalf == secondHalf {\n            start += 1\n\
    \            end -= 1\n        } else {\n            // If they don't match, we\
    \ have to make a change.\n            // We'll try each one and see what the difference\
    \ is.\n            var firstDifference, secondDifference int\n            for\
    \ i := 0; i < len(firstHalf); i++ {\n                if firstHalf[i] != secondHalf[i]\
    \ {\n                    firstDifference += 1\n                }\n           \
    \ }\n            for i := 0; i < len(secondHalf); i++ {\n                if secondHalf[i]\
    \ != firstHalf[i] {\n                    secondDifference += 1\n             \
    \   }\n            }\n\n            // Which one is smaller?\n            if firstDifference\
    \ < secondDifference {\n                change += firstDifference\n          \
    \      start += 1\n            } else {\n                change += secondDifference\n\
    \                end -= 1\n            }\n        }\n    }\n\n    return change\n\
    }\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppolp9imx_test.go:31:39: invalid argument: index -1 (constant of type int)
    must not be negative

    /tmp/tmppolp9imx_test.go:34:12: invalid operation: firstHalf == secondHalf (slice
    can only be compared to nil)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    left := 0\n    right := len(arr) - 1\n    count := 0\n   \
    \ for left < right {\n        if arr[left] != arr[right] {\n            count\
    \ += 1\n        }\n        left += 1\n        right -= 1\n    }\n    return count\n\
    }\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075219
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    count := 0\n    for i := 0; i < len(arr) / 2; i++ {\n    \
    \    if arr[i] != arr[len(arr) - 1 - i] {\n            count += 1\n        }\n\
    \    }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // Place your code here\n    fmt.Println(\"Not implemented\"\
    )\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate :=\
    \ smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Not implemented\nNot implemented\nNot implemented\nNot implemented\nNot\
    \ implemented\nNot implemented\nNot implemented\nNot implemented\n--- FAIL: TestSmallest_Change\
    \ (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0 (0.00s)\n        tmpekne6_7c_test.go:44:\
    \ expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__1\
    \ (0.00s)\n        tmpekne6_7c_test.go:44: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__2 (0.00s)\n        tmpekne6_7c_test.go:44:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__3\
    \ (0.00s)\n        tmpekne6_7c_test.go:44: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__7 (0.00s)\n        tmpekne6_7c_test.go:44:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    len := len(arr)\n    if len <= 1 {\n        return 0\n   \
    \ }\n    var i int\n    var changes int\n    for i = 0; i < len/2; i++ {\n   \
    \     if arr[i] != arr[len-i-1] {\n            changes += 1\n        }\n    }\n\
    \    return changes\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075219
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var changes int\n    for i := 0; i < len(arr) / 2; i++ {\n\
    \        if arr[i] != arr[len(arr) - 1 - i] {\n            changes++\n       \
    \ }\n    }\n    return changes\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075219
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    i, j := 0,\
    \ len(arr) - 1\n    changes := 0\n    for i < j {\n        if arr[i] != arr[j]\
    \ {\n            changes++\n        }\n        i++\n        j--\n    }\n    return\
    \ changes\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // your code here\n    return 0\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpvdmkzrt6_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpvdmkzrt6_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpvdmkzrt6_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpvdmkzrt6_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmpvdmkzrt6_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n\tif len(arr) == 0 {\n\t\treturn 0\n\t}\n\tif len(arr) == 1 {\n\
    \t\treturn 0\n\t}\n\tif len(arr) == 2 {\n\t\tif arr[0] == arr[1] {\n\t\t\treturn\
    \ 0\n\t\t}\n\t\treturn 1\n\t}\n\tstart := 0\n\tend := len(arr) - 1\n\tif arr[start]\
    \ == arr[end] {\n\t\treturn smallest_change(arr[1:end])\n\t}\n\t// compare\n\t\
    left := arr[start]\n\tright := arr[end]\n\t// find all possible left sub arrays\n\
    \tvar leftArr, rightArr []int\n\tfor i := start; i < end; i++ {\n\t\tif leftArr\
    \ == nil {\n\t\t\tleftArr = arr[start:i+1]\n\t\t} else {\n\t\t\tleftArr = append(leftArr,\
    \ arr[i])\n\t\t}\n\t\tif rightArr == nil {\n\t\t\trightArr = arr[i+1:end+1]\n\t\
    \t} else {\n\t\t\trightArr = append(rightArr, arr[i])\n\t\t}\n\t\tif left == right\
    \ {\n\t\t\treturn smallest_change(leftArr) + smallest_change(rightArr)\n\t\t}\n\
    \t}\n\t// find all possible right sub arrays\n\treturn 1\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpv54mjkdn_test.go:80: expected '%!s(int=4)', got '%!s(int=1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // TODO\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmptq8htfz8_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmptq8htfz8_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmptq8htfz8_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmptq8htfz8_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmptq8htfz8_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    l, r := 0, len(arr) - 1\n    n := 0\n    for l < r {\n   \
    \     if arr[l] != arr[r] {\n            n += 1\n        }\n        l += 1\n \
    \       r -= 1\n    }\n    return n\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // TODO: Implement me!\n    return -1\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmp28p4kgom_test.go:43: expected '%!s(int=4)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmp28p4kgom_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=-1)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmp28p4kgom_test.go:43: expected '%!s(int=1)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmp28p4kgom_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=-1)'\n    --- FAIL: TestSmallest_Change/test_num__4\
    \ (0.00s)\n        tmp28p4kgom_test.go:43: expected '%!s(int=0)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__5 (0.00s)\n        tmp28p4kgom_test.go:43:\
    \ expected '%!s(int=0)', got '%!s(int=-1)'\n    --- FAIL: TestSmallest_Change/test_num__6\
    \ (0.00s)\n        tmp28p4kgom_test.go:43: expected '%!s(int=0)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__7 (0.00s)\n        tmp28p4kgom_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpfexbjqqk_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpfexbjqqk_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpfexbjqqk_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpfexbjqqk_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmpfexbjqqk_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    count := 0\n    for i, j := 0, len(arr)-1; i < j; i, j = i+1,\
    \ j-1 {\n        if arr[i] != arr[j] {\n            count++\n        }\n    }\n\
    \    return count\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    count := 0\n    l, r := 0, len(arr) - 1\n    for l < r {\n\
    \        if arr[l] == arr[r] {\n            l++\n            r--\n        } else\
    \ {\n            count++\n            if arr[l] < arr[r] {\n                arr[l+1]\
    \ = arr[l] + arr[l+1]\n                l++\n            } else {\n           \
    \     arr[r-1] = arr[r] + arr[r-1]\n                r--\n            }\n     \
    \   }\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmp6ac4_9jn_test.go:59: expected '%!s(int=4)', got '%!s(int=3)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmp6ac4_9jn_test.go:59:\
    \ expected '%!s(int=1)', got '%!s(int=6)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmp6ac4_9jn_test.go:59: expected '%!s(int=1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmp6ac4_9jn_test.go:59:\
    \ expected '%!s(int=1)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr)\
    \ == 1 {\n        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] ==\
    \ arr[1] {\n            return 0\n        } else {\n            return 1\n   \
    \     }\n    }\n    count := 0\n    for left, right := 0, len(arr) - 1; left <\
    \ right; left, right = left + 1, right - 1 {\n        if arr[left] != arr[right]\
    \ {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    n := len(arr)\n\
    \    res := n / 2\n    // @todo\n    return res\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__1\
    \ (0.00s)\n        tmpyy7tbovr_test.go:48: expected '%!s(int=1)', got '%!s(int=3)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpyy7tbovr_test.go:48:\
    \ expected '%!s(int=1)', got '%!s(int=2)'\n    --- FAIL: TestSmallest_Change/test_num__4\
    \ (0.00s)\n        tmpyy7tbovr_test.go:48: expected '%!s(int=0)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__5 (0.00s)\n        tmpyy7tbovr_test.go:48:\
    \ expected '%!s(int=0)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    left, right := 0, len(arr) - 1\n    count := 0\n    for left\
    \ < right {\n        if arr[left] != arr[right] {\n            count += 1\n  \
    \      }\n        left += 1\n        right -= 1\n    }\n    return count\n}\n\n\
    func TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected:\
    \ 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 2, 3, 2, 1}), expected:\
    \ 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual:\
    \ candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0, 1}),\
    \ expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075219
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    cnt := 0\n    for a, b := 0, len(arr)-1; a < b; a, b = a+1,\
    \ b-1 {\n        if arr[a] != arr[b] {\n            cnt++\n        }\n    }\n\
    \    return cnt\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate :=\
    \ smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    n := len(arr)\n    var l, r int\n    var cnt int\n    l =\
    \ 0\n    r = n - 1\n    for l < r {\n        if arr[l] == arr[r] {\n         \
    \   l += 1\n            r -= 1\n        } else {\n            if arr[l] < arr[r]\
    \ {\n                arr[l+1] = arr[l] + arr[l+1]\n                l += 1\n  \
    \          } else {\n                arr[r-1] = arr[r] + arr[r-1]\n          \
    \      r -= 1\n            }\n            cnt += 1\n        }\n    }\n    return\
    \ cnt\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpztodpbid_test.go:62: expected '%!s(int=4)', got '%!s(int=3)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpztodpbid_test.go:62:\
    \ expected '%!s(int=1)', got '%!s(int=6)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpztodpbid_test.go:62: expected '%!s(int=1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpztodpbid_test.go:62:\
    \ expected '%!s(int=1)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // if len(arr) == 0 {\n    //     return 0\n    // }\n   \
    \ return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpdmyquyht_test.go:45: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpdmyquyht_test.go:45:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpdmyquyht_test.go:45: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpdmyquyht_test.go:45:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmpdmyquyht_test.go:45: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpfexbjqqk_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpfexbjqqk_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpfexbjqqk_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpfexbjqqk_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmpfexbjqqk_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var counter int\n    arrLen := len(arr)\n    for i := 0; i\
    \ < arrLen / 2; i++ {\n        if arr[i] != arr[arrLen - i - 1] {\n          \
    \  counter++\n        }\n    }\n    return counter\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // TODO:\n    return -1\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpmxdusafm_test.go:43: expected '%!s(int=4)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpmxdusafm_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=-1)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpmxdusafm_test.go:43: expected '%!s(int=1)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpmxdusafm_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=-1)'\n    --- FAIL: TestSmallest_Change/test_num__4\
    \ (0.00s)\n        tmpmxdusafm_test.go:43: expected '%!s(int=0)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__5 (0.00s)\n        tmpmxdusafm_test.go:43:\
    \ expected '%!s(int=0)', got '%!s(int=-1)'\n    --- FAIL: TestSmallest_Change/test_num__6\
    \ (0.00s)\n        tmpmxdusafm_test.go:43: expected '%!s(int=0)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__7 (0.00s)\n        tmpmxdusafm_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmp37czl1l4_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmp37czl1l4_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmp37czl1l4_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmp37czl1l4_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmp37czl1l4_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075050
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    length :=\
    \ len(arr)\n    front_p := 0\n    back_p := length - 1\n    change_num := 0\n\
    \    for front_p <= back_p {\n        if arr[front_p] != arr[back_p] {\n     \
    \       change_num++\n        }\n        front_p++\n        back_p--\n    }\n\
    \    return change_num\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075221
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    i, j := 0, len(arr) - 1\n    n := 0\n    for i < j {\n   \
    \     if arr[i] != arr[j] {\n            n++\n        }\n        i++\n       \
    \ j--\n    }\n    return n\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075221
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    count := 0\n    for i := 0; i < len(arr) / 2; i++ {\n    \
    \    if arr[i] != arr[len(arr) - 1 - i] {\n            count++\n        }\n  \
    \  }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    arr_len := len(arr)\n    if arr_len <= 1 {\n        return\
    \ 0\n    }\n    arr_half_len := arr_len / 2\n    if arr_len % 2 == 1 {\n     \
    \   arr_half_len += 1\n    }\n    //fmt.Println(arr, arr_len, arr_half_len)\n\
    \    return smallest_change_array(arr[:arr_half_len]) + smallest_change_array(arr[arr_half_len:])\n\
    }\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0h7obqws_test.go:28:12: undefined: smallest_change_array

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr)\
    \ == 1 {\n        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] ==\
    \ arr[1] {\n            return 0\n        } else {\n            return 1\n   \
    \     }\n    }\n    min_changed := make([]int, len(arr))\n    for i, _ := range\
    \ min_changed {\n        min_changed[i] = len(arr) + 10\n    }\n    for i := 0;\
    \ i < len(arr); i++ {\n        // two cases for each loop: left and right\n  \
    \      // left\n        if i == 0 {\n            min_changed[i] = 0\n        }\
    \ else {\n            min_changed[i] = min_changed[i-1] + 1\n        }\n     \
    \   // right\n        if i == len(arr) - 1 {\n            min_changed[i] = 0\n\
    \        } else {\n            min_changed[i] = min_changed[i+1] + 1\n       \
    \ }\n        // deal with the min of min_changed[i-1] + 1 and min_changed[i+1]\
    \ + 1\n        if min_changed[i-1] + 1 < min_changed[i+1] + 1 {\n            min_changed[i]\
    \ = min_changed[i-1] + 1\n        } else {\n            min_changed[i] = min_changed[i+1]\
    \ + 1\n        }\n        // compare the min_changed[i] with current value\n \
    \       if arr[i] == arr[len(arr) - 1 - i] {\n            if min_changed[i] >\
    \ 0 {\n                min_changed[i] = 0\n            }\n        }\n    }\n \
    \   res := 0\n    for _, value := range min_changed {\n        if value > res\
    \ {\n            res = value\n        }\n    }\n    return res\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\npanic: runtime error: index out\
    \ of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\
    \ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.smallest_change({0xc0000c45f0, 0x8, 0x37930?})\n\
    \t/tmp/tmpr34sq25q_test.go:51 +0x1b7\ncommand-line-arguments_test.TestSmallest_Change(0x0?)\n\
    \t/tmp/tmpr34sq25q_test.go:79 +0xd5\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    length := len(arr)\n    for i := 0; i < length / 2; i++ {\n\
    \        if arr[i] != arr[length - i - 1] {\n            return length - 2 * i\
    \ - 1\n        }\n    }\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmp32k64gf6_test.go:48: expected '%!s(int=4)', got '%!s(int=7)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmp32k64gf6_test.go:48:\
    \ expected '%!s(int=1)', got '%!s(int=6)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmp32k64gf6_test.go:48: expected '%!s(int=1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmp32k64gf6_test.go:48:\
    \ expected '%!s(int=1)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075221
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    half := len(arr) / 2\n    count := 0\n    for i := 0; i <\
    \ half; i++ {\n        if arr[i] != arr[len(arr) - i - 1] {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075221
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    count := 0\n    i := 0\n    j := len(arr) - 1\n    for ; i\
    \ < j; i, j = i + 1, j - 1 {\n        if arr[i] != arr[j] {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // base case\n    if len(arr) <= 1 {\n        return 0\n \
    \   }\n\n    var result int\n    if arr[0] == arr[len(arr)-1] {\n        // check\
    \ for smaller subproblem\n        result = smallest_change(arr[1:len(arr)-1])\n\
    \    } else {\n        // compare the two subproblems\n        sub_result1 :=\
    \ smallest_change(arr[1:len(arr)])\n        sub_result2 := smallest_change(arr[0:len(arr)-1])\n\
    \        result = 1 + min(sub_result1, sub_result2)\n    }\n\n    return result\n\
    }\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmgm5wir7_test.go:32:22: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    start := 0\n    end := len(arr) - 1\n    count := 0\n    for\
    \ start < end {\n        if arr[start] != arr[end] {\n            count++\n  \
    \      }\n        start++\n        end--\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n\treturn -1\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n \
    \ candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmphbfeq6pp_test.go:42: expected '%!s(int=4)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmphbfeq6pp_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=-1)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmphbfeq6pp_test.go:42: expected '%!s(int=1)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmphbfeq6pp_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=-1)'\n    --- FAIL: TestSmallest_Change/test_num__4\
    \ (0.00s)\n        tmphbfeq6pp_test.go:42: expected '%!s(int=0)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__5 (0.00s)\n        tmphbfeq6pp_test.go:42:\
    \ expected '%!s(int=0)', got '%!s(int=-1)'\n    --- FAIL: TestSmallest_Change/test_num__6\
    \ (0.00s)\n        tmphbfeq6pp_test.go:42: expected '%!s(int=0)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__7 (0.00s)\n        tmphbfeq6pp_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075221
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    cnt := 0\n\
    \    left := 0\n    right := len(arr) - 1\n    for left < right {\n        if\
    \ arr[left] != arr[right] {\n            cnt += 1\n        }\n        left +=\
    \ 1\n        right -= 1\n    }\n    return cnt\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075221
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr)\
    \ == 1 {\n        return 0\n    }\n    var counter int\n    for i,j := 0, len(arr)-1;\
    \ i<j; {\n        if arr[i] == arr[j] {\n            i++\n            j--\n  \
    \      } else {\n            arr[i] = arr[j]\n            counter++\n        \
    \    i++\n            j--\n        }\n    }\n    return counter\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // We need to identify where the palindrome starts; in order\
    \ to do that\n    // we assume a palindrome of size 1 and 2, and see if the next\
    \ element\n    // matches the last element in either case. If not, we assume a\
    \ palindrome\n    // of size 3, and so on.\n    // \n    // If a palindrome of\
    \ size n is identified, then we just check the difference\n    // between the\
    \ next element and the last element of the palindrome to see if\n    // we have\
    \ to change it.\n    n := len(arr)\n    pal_len := 0\n    for i := 0; i < n; i++\
    \ {\n        // Check for palindrome of size 1\n        if arr[i] == arr[i+1]\
    \ {\n            pal_len = 1\n            break\n        }\n        // Check for\
    \ palindrome of size 2\n        if i+2 < n && arr[i] == arr[i+2] {\n         \
    \   pal_len = 2\n            break\n        }\n    }\n    if pal_len == 0 {\n\
    \        return 0\n    }\n    changes := 0\n    for i := pal_len; i < n; i++ {\n\
    \        if arr[i] != arr[i+1] {\n            changes++\n        }\n    }\n  \
    \  return changes\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\npanic: runtime error: index out\
    \ of range [8] with length 8 [recovered]\n\tpanic: runtime error: index out of\
    \ range [8] with length 8\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.smallest_change({0xc0000c45f0?, 0x5e3ea0?,\
    \ 0x37930?})\n\t/tmp/tmp33ic511i_test.go:31 +0xdb\ncommand-line-arguments_test.TestSmallest_Change(0x0?)\n\
    \t/tmp/tmp33ic511i_test.go:60 +0xd5\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075221
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    l := len(arr)\n    if l <= 1 {\n        return 0\n    }\n\
    \    if l == 2 {\n        if arr[0] == arr[1] {\n            return 0\n      \
    \  }\n        return 1\n    }\n    m := l / 2\n    change := 0\n    for i := 0;\
    \ i < m; i++ {\n        if arr[i] != arr[l-i-1] {\n            change += 1\n \
    \       }\n    }\n    return change\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    n := len(arr)\n    if n < 2 {\n        return 0\n    }\n \
    \   if n%2 == 0 {\n        return n/2 - 1\n    }\n    return n/2\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpwn8ttu8b_test.go:49: expected '%!s(int=4)', got '%!s(int=3)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpwn8ttu8b_test.go:49:\
    \ expected '%!s(int=1)', got '%!s(int=3)'\n    --- FAIL: TestSmallest_Change/test_num__4\
    \ (0.00s)\n        tmpwn8ttu8b_test.go:49: expected '%!s(int=0)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__5 (0.00s)\n        tmpwn8ttu8b_test.go:49:\
    \ expected '%!s(int=0)', got '%!s(int=1)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmpwn8ttu8b_test.go:49: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075221
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    count := 0\n    for i := 0; i < len(arr)/2; i++ {\n      \
    \  if arr[i] != arr[len(arr)-i-1] {\n            count++\n        }\n    }\n \
    \   return count\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate :=\
    \ smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    len_arr := len(arr)\n    if len_arr <= 1 {\n        return\
    \ 0\n    }\n\n    // find the index of first and last elements that don't match\n\
    \    var left, right int\n    for left < len_arr {\n        if arr[left] != arr[len_arr\
    \ - left - 1] {\n            break\n        }\n        left++\n    }\n    for\
    \ right < len_arr {\n        if arr[right] != arr[len_arr - right - 1] {\n   \
    \         break\n        }\n        right++\n    }\n\n    // count the number\
    \ of element changes required to make a palindrome\n    count := 0\n    for left\
    \ < right {\n        if arr[left] != arr[right] {\n            count++\n     \
    \   }\n        left++\n        right--\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmphsxgf_94_test.go:71: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmphsxgf_94_test.go:71:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmphsxgf_94_test.go:71: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmphsxgf_94_test.go:71:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmphsxgf_94_test.go:71: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075221
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    count := 0\n    for i := 0; i < len(arr) / 2; i++ {\n    \
    \    if arr[i] != arr[len(arr) - 1 - i] {\n            count++\n        }\n  \
    \  }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075221
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    count := 0\n    for i := 0; i < len(arr) / 2; i++ {\n    \
    \    if arr[i] != arr[len(arr) - 1 - i] {\n            count++\n        }\n  \
    \  }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // Add your code here\n    return 0\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmp89s0z1r4_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmp89s0z1r4_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmp89s0z1r4_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmp89s0z1r4_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmp89s0z1r4_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075222
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    n := len(arr)\n    if n < 2 {\n        return 0\n    }\n \
    \   mid := n / 2\n    left, right := 0, n - 1\n    count := 0\n    for left <\
    \ mid {\n        if arr[left] != arr[right] {\n            count++\n        }\n\
    \        left++\n        right--\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075222
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    i, j := 0, len(arr) - 1\n    cnt := 0\n    for i < j {\n \
    \       if arr[i] != arr[j] {\n            cnt += 1\n        }\n        i += 1\n\
    \        j -= 1\n    }\n    return cnt\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075222
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    l := len(arr)\n    if l == 0 {\n        return 0\n    }\n\n\
    \    min_changes := 0\n    for i, j := 0, l-1; i < j; i, j = i+1, j-1 {\n    \
    \    if arr[i] != arr[j] {\n            min_changes++\n        }\n    }\n    return\
    \ min_changes\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    l := len(arr)\n    if l == 0 {\n        return 0\n    }\n\
    \    dp := make([][]int, l)\n    for i, _ := range dp {\n        dp[i] = make([]int,\
    \ l)\n    }\n    for gap := 0; gap < l; gap++ {\n        for i := 0; i < l - gap;\
    \ i++ {\n            j := i + gap\n            if gap == 0 {\n               \
    \ dp[i][j] = 0\n            } else if gap == 1 {\n                if arr[i] ==\
    \ arr[j] {\n                    dp[i][j] = 0\n                } else {\n     \
    \               dp[i][j] = 1\n                }\n            } else {\n      \
    \          if arr[i] == arr[j] {\n                    dp[i][j] = dp[i + 1][j -\
    \ 1]\n                } else {\n                    dp[i][j] = 1 + min(dp[i +\
    \ 1][j], dp[i][j - 1])\n                }\n            }\n        }\n    }\n \
    \   return dp[0][l - 1]\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg859hq4u_test.go:42:36: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075222
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // write your code in Go 1.4\n    var changes = 0\n    var\
    \ left = 0\n    var right = len(arr) - 1\n    for left < right {\n        if arr[left]\
    \ == arr[right] {\n            left++\n            right--\n        } else {\n\
    \            changes++\n            if arr[left] > arr[right] {\n            \
    \    left++\n            } else {\n                right--\n            }\n  \
    \      }\n    }\n    return changes\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmp6kcz_kvx_test.go:59: expected '%!s(int=4)', got '%!s(int=7)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmp6kcz_kvx_test.go:59:\
    \ expected '%!s(int=1)', got '%!s(int=6)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmp6kcz_kvx_test.go:59: expected '%!s(int=1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmp6kcz_kvx_test.go:59:\
    \ expected '%!s(int=1)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n\tif len(arr) < 2 {\n\t\treturn 0\n\t}\n\tif len(arr) == 2 {\n\
    \t\tif arr[0] == arr[1] {\n\t\t\treturn 0\n\t\t}\n\t\treturn 1\n\t}\n\tif arr[0]\
    \ == arr[len(arr)-1] {\n\t\treturn smallest_change(arr[1:len(arr)-1])\n\t}\n\t\
    return 1 + min(smallest_change(arr[1:]), smallest_change(arr[:len(arr)-1]))\n\
    }\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp27ps34x1_test.go:31:13: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // This function could be implemented by finding the LIS of\
    \ the reversed array\n    // then subbing it from the length of the original array.\n\
    \    // But that seems overly complicated, so I took a different route.\n    if\
    \ len(arr) <= 1 {\n        return 0\n    }\n    front := 0\n    back := len(arr)\
    \ - 1\n    changes := 0\n    for front < back {\n        // If the front element\
    \ is equal to the back element, then we don't need\n        // to do anything\
    \ to that element, so we will just move both pointers\n        // to the next\
    \ element.\n        if arr[front] == arr[back] {\n            front += 1\n   \
    \         back -= 1\n        } else {\n            // If the front element is\
    \ not equal to the back element, then we need\n            // to decide which\
    \ one to change.\n            // Changing the front element will affect the back\
    \ element if we change it\n            // Changing the back element won't affect\
    \ the front element if we change it\n            if arr[front + 1] == arr[back]\
    \ {\n                changes += 1\n                front += 1\n            } else\
    \ {\n                changes += 1\n                back -= 1\n            }\n\
    \        }\n    }\n    return changes\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmp6h2da5ml_test.go:72: expected '%!s(int=4)', got '%!s(int=7)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmp6h2da5ml_test.go:72:\
    \ expected '%!s(int=1)', got '%!s(int=2)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmp6h2da5ml_test.go:72: expected '%!s(int=1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmp6h2da5ml_test.go:72:\
    \ expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075223
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var alen = len(arr)\n    var count = 0\n    for i := 0; i\
    \ < alen / 2; i++ {\n        if arr[i] != arr[alen - i - 1] {\n            count++\n\
    \        }\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    c, d := 0, 0\n    l := len(arr)\n    for i := 0; i < l/2;\
    \ i++ {\n        if arr[i] != arr[l-i-1] {\n            c++\n        }\n    }\n\
    \    for i := 0; i < l/2; i++ {\n        if arr[i] != arr[l-i-1] {\n         \
    \   d++\n            if arr[i] == arr[l-i-2] && arr[i+1] == arr[l-i-1] {\n   \
    \             d--\n            }\n        }\n    }\n    if c < d {\n        return\
    \ c\n    }\n    return d\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmp5165nqzd_test.go:60: expected '%!s(int=4)', got '%!s(int=3)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__7 (0.00s)\n        tmp5165nqzd_test.go:60:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075223
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var count int = 0\n    length := len(arr)\n    mid := length\
    \ / 2\n    if length == 0 {\n        return 0\n    }\n    if length % 2 == 0 {\n\
    \        for i := 0; i < mid; i++ {\n            if arr[i] != arr[length - i -\
    \ 1] {\n                count++\n            }\n        }\n    } else {\n    \
    \    for i := 0; i < mid; i++ {\n            if arr[i] != arr[length - i - 1]\
    \ {\n                count++\n            }\n        }\n    }\n    return count\n\
    }\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    // the smallest_change\
    \ for arr[i:] is the count of elements that need to be changed\n    // to make\
    \ arr[i:] palindromic\n    smallestChange := make([]int, len(arr))\n    // the\
    \ smallest_change for arr[:i] is the count of elements that need to be changed\n\
    \    // to make arr[:i] palindromic\n    smallestChangeRev := make([]int, len(arr))\n\
    \    smallestChange[len(arr)-1] = 0\n    smallestChangeRev[0] = 0\n    for i :=\
    \ len(arr)-2; i >= 0; i-- {\n        smallestChange[i] = 1 + smallestChange[i+1]\n\
    \        if arr[i] == arr[i+1] {\n            smallestChange[i] = min(smallestChange[i],\
    \ smallestChange[i+2])\n        }\n    }\n    for i := 1; i < len(arr); i++ {\n\
    \        smallestChangeRev[i] = 1 + smallestChangeRev[i-1]\n        if arr[i]\
    \ == arr[i-1] {\n            smallestChangeRev[i] = min(smallestChangeRev[i],\
    \ smallestChangeRev[i-2])\n        }\n    }\n    min := smallestChange[0]\n  \
    \  for i := 0; i < len(arr); i++ {\n        min = min(min, smallestChange[i] +\
    \ smallestChangeRev[i] - 1)\n    }\n    return min\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbb5px69r_test.go:33:33: undefined: min

    /tmp/tmpbb5px69r_test.go:39:36: undefined: min

    /tmp/tmpbb5px69r_test.go:44:15: invalid operation: cannot call non-function min
    (variable of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var l, r int\n    // two pointer\n    for l < len(arr) &&\
    \ arr[l] == arr[len(arr)-1-l] {\n        l++\n    }\n    for r < len(arr) && arr[r]\
    \ == arr[len(arr)-1-r] {\n        r++\n    }\n    // len(arr) - (r - l)\n    return\
    \ len(arr) - r - l\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmp5ey_zypf_test.go:51: expected '%!s(int=4)', got '%!s(int=8)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmp5ey_zypf_test.go:51:\
    \ expected '%!s(int=1)', got '%!s(int=7)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmp5ey_zypf_test.go:51: expected '%!s(int=1)', got '%!s(int=3)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmp5ey_zypf_test.go:51:\
    \ expected '%!s(int=1)', got '%!s(int=4)'\n    --- FAIL: TestSmallest_Change/test_num__4\
    \ (0.00s)\n        tmp5ey_zypf_test.go:51: expected '%!s(int=0)', got '%!s(int=-5)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__5 (0.00s)\n        tmp5ey_zypf_test.go:51:\
    \ expected '%!s(int=0)', got '%!s(int=-4)'\n    --- FAIL: TestSmallest_Change/test_num__6\
    \ (0.00s)\n        tmp5ey_zypf_test.go:51: expected '%!s(int=0)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__7 (0.00s)\n        tmp5ey_zypf_test.go:51:\
    \ expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    lenArr := len(arr)\n    if lenArr < 2 {\n        return 0\n\
    \    }\n    if lenArr == 2 {\n        if arr[0] == arr[1] {\n            return\
    \ 0\n        }\n        return 1\n    }\n    l := lenArr / 2\n    if lenArr %\
    \ 2 == 0 {\n        l = l - 1\n    }\n    r := l + 1\n    c := 0\n    for l >=\
    \ 0 && r < lenArr {\n        if arr[l] != arr[r] {\n            c += 1\n     \
    \   }\n        l -= 1\n        r += 1\n    }\n    return c\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__1\
    \ (0.00s)\n        tmp9oijal3e_test.go:65: expected '%!s(int=1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__4 (0.00s)\n        tmp9oijal3e_test.go:65:\
    \ expected '%!s(int=0)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075223
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n\t// Track the number of differences between the left and right.\n\
    \tnum_of_changes := 0\n\t// Use two pointers (left and right) to track the traversal\
    \ of the list.\n\tleft, right := 0, len(arr) - 1\n\t// While the pointers have\
    \ not crossed, keep checking for a difference.\n\tfor left < right {\n\t\t// If\
    \ the left and right numbers are different, increment the count and\n\t\t// change\
    \ the number at left to the number at right.\n\t\tif arr[left] != arr[right] {\n\
    \t\t\tnum_of_changes++\n\t\t\tarr[left] = arr[right]\n\t\t}\n\t\t// Increment\
    \ left, decrement right.\n\t\tleft++\n\t\tright--\n\t}\n\t// Return the number\
    \ of changes we had to make to make the list palindromic.\n\treturn num_of_changes\n\
    }\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075223
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    n,m := 0,len(arr)-1\n    changes := 0\n    for {\n       \
    \ if n >= m {\n            break\n        }\n        if arr[n] != arr[m] {\n \
    \           changes++\n        }\n        n++\n        m--\n    }\n    return\
    \ changes\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075223
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    left_index := 0\n    right_index := len(arr) - 1\n    changes\
    \ := 0\n    for left_index < right_index {\n        if arr[left_index] != arr[right_index]\
    \ {\n            changes++\n        }\n        left_index++\n        right_index--\n\
    \    }\n    return changes\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075223
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) < 2 {\n        return 0\n    }\n    if len(arr)\
    \ == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        }\n   \
    \     return 1\n    }\n    head, tail := 0, len(arr) - 1\n    for {\n        if\
    \ head >= tail {\n            break\n        }\n        if arr[head] == arr[tail]\
    \ {\n            head += 1\n            tail -= 1\n        } else {\n        \
    \    break\n        }\n    }\n    if head >= tail {\n        return 0\n    }\n\
    \    if head + 1 == tail {\n        return 1\n    }\n    if arr[head] == arr[tail\
    \ - 1] && arr[head + 1] == arr[tail] {\n        return min_int(smallest_change(arr[head:tail]),\
    \ smallest_change(arr[head + 1:tail + 1])) + 1\n    }\n    if arr[head] == arr[tail\
    \ - 1] {\n        return smallest_change(arr[head:tail]) + 1\n    }\n    if arr[head\
    \ + 1] == arr[tail] {\n        return smallest_change(arr[head + 1:tail + 1])\
    \ + 1\n    }\n    return min_int(smallest_change(arr[head:tail]), smallest_change(arr[head\
    \ + 1:tail + 1])) + 2\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9z5kzwdt_test.go:47:16: undefined: min_int

    /tmp/tmp9z5kzwdt_test.go:55:12: undefined: min_int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // TODO: fill in implementation and return the answer.\n \
    \   return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprh9z90y8_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprh9z90y8_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprh9z90y8_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprh9z90y8_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprh9z90y8_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    l := len(arr)\n\
    \    count := 0\n    for i := 0; i < l / 2; i++ {\n        if arr[i] != arr[l\
    \ - i - 1] {\n            count += 1\n        }\n    }\n    return count\n}\n\n\
    func TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected:\
    \ 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 2, 3, 2, 1}), expected:\
    \ 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual:\
    \ candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0, 1}),\
    \ expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    count := 0\n    left, right := 0, len(arr) - 1\n    for left\
    \ < right {\n        if arr[left] == arr[right] {\n            left++\n      \
    \      right--\n        } else {\n            left++\n            count++\n  \
    \      }\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpytwjnt0q_test.go:53: expected '%!s(int=4)', got '%!s(int=7)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpytwjnt0q_test.go:53:\
    \ expected '%!s(int=1)', got '%!s(int=4)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpytwjnt0q_test.go:53: expected '%!s(int=1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpytwjnt0q_test.go:53:\
    \ expected '%!s(int=1)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075223
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    count := 0\n    i := 0\n    j := len(arr) - 1\n    for i <\
    \ j {\n        if arr[i] != arr[j] {\n            count++\n        }\n       \
    \ i++\n        j--\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075223
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    change := 0\n    for idx, elm := range arr {\n        if len(arr)%2\
    \ == 0 {\n            if idx < len(arr)/2 {\n                if elm != arr[len(arr)-idx-1]\
    \ {\n                    change++\n                }\n            }\n        }\
    \ else {\n            if idx < len(arr)/2 {\n                if elm != arr[len(arr)-idx-1]\
    \ {\n                    change++\n                }\n            }\n        }\n\
    \    }\n    return change\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075223
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    changes := 0\n    for i := 0; i < len(arr) / 2; i++ {\n  \
    \      if arr[i] != arr[len(arr) - i - 1] {\n            changes += 1\n      \
    \  }\n    }\n    return changes\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075224
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    changes := 0\n    i := 0\n    j := len(arr) - 1\n    for ;\
    \ i < j; i, j = i + 1, j - 1 {\n        if arr[i] != arr[j] {\n            changes++\n\
    \        }\n    }\n    return changes\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075224
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    changes := 0\n    var i, j int\n    if len(arr) % 2 == 0 {\n\
    \        i = len(arr) / 2 - 1\n        j = len(arr) / 2\n    } else {\n      \
    \  i = len(arr) / 2 - 1\n        j = len(arr) / 2 + 1\n    }\n    for i >= 0 {\n\
    \        if arr[i] != arr[j] {\n            changes++\n        }\n        i--\n\
    \        j++\n    }\n    return changes\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075224
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // YOUR CODE HERE\n    return 0\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmp_nkgl7ak_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmp_nkgl7ak_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmp_nkgl7ak_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmp_nkgl7ak_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmp_nkgl7ak_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075224
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    min := len(arr) - 1\n    if min <= 0 {\n        return 0\n\
    \    }\n    for i := 0; i < len(arr); i++ {\n        tmp := i\n        for j :=\
    \ len(arr) - 1; j > i; j-- {\n            if arr[j] == arr[tmp] {\n          \
    \      tmp += 1\n            }\n        }\n        if tmp - i < min {\n      \
    \      min = tmp - i\n        }\n    }\n    return min\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpde5e6v22_test.go:57: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpde5e6v22_test.go:57:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpde5e6v22_test.go:57: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpde5e6v22_test.go:57:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmpde5e6v22_test.go:57: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075224
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) < 2 {\n        return 0\n    }\n    left, right\
    \ := 0, len(arr) - 1\n    cnt := 0\n    for left < right {\n        if arr[left]\
    \ != arr[right] {\n            cnt++\n        }\n        left++\n        right--\n\
    \    }\n    return cnt\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075225
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) <= 1 {\n        return 0\n    }\n    if len(arr)\
    \ == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        }\n   \
    \     return 1\n    }\n    start := 0\n    end := len(arr) - 1\n    count := 0\n\
    \    for start < end {\n        if arr[start] == arr[end] {\n            start\
    \ += 1\n            end -= 1\n        } else {\n            count += 1\n     \
    \       if start + 1 < end {\n                if arr[start] == arr[end - 1] {\n\
    \                    end -= 1\n                } else if arr[start + 1] == arr[end]\
    \ {\n                    start += 1\n                } else {\n              \
    \      start += 1\n                    end -= 1\n                }\n         \
    \   } else {\n                start += 1\n                end -= 1\n         \
    \   }\n        }\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__1\
    \ (0.00s)\n        tmpg_9g78re_test.go:75: expected '%!s(int=1)', got '%!s(int=2)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075225
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    arrLength := len(arr)\n    if arrLength == 0 {\n        return\
    \ 0\n    }\n\n    // if the array is palindromic, return 0\n    isPalindromic\
    \ := true\n    for i := 0; i < arrLength/2; i++ {\n        if arr[i] != arr[arrLength-1-i]\
    \ {\n            isPalindromic = false\n            break\n        }\n    }\n\
    \    if isPalindromic {\n        return 0\n    }\n\n    // find smallest change\
    \ by calculate left and right palindromic array\n    // with the same length\n\
    \    minChanges := arrLength\n    for leftLength := 1; leftLength <= arrLength;\
    \ leftLength++ {\n        // initialize left and right palindromic arrays\n  \
    \      leftPalindromic := make([]int, leftLength)\n        for i := 0; i < leftLength;\
    \ i++ {\n            leftPalindromic[i] = arr[i]\n        }\n        rightPalindromic\
    \ := make([]int, leftLength)\n        for i := 0; i < leftLength; i++ {\n    \
    \        rightPalindromic[i] = arr[arrLength-1-i]\n        }\n\n        leftChanges\
    \ := getSmallestChange(leftPalindromic)\n        rightChanges := getSmallestChange(rightPalindromic)\n\
    \        if leftChanges + rightChanges < minChanges {\n            minChanges\
    \ = leftChanges + rightChanges\n        }\n    }\n\n    return minChanges\n}\n\
    \nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppz970y6l_test.go:50:24: undefined: getSmallestChange

    /tmp/tmppz970y6l_test.go:51:25: undefined: getSmallestChange

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) <= 1 {\n        return 0\n    }\n    l := len(arr)\n\
    \    l2 := l / 2\n    l1 := l2 - 1\n    if l % 2 == 0 {\n        l1++\n    }\n\
    \    res := 0\n    for i := 0; i < l2; i++ {\n        if arr[i] != arr[l1-i] {\n\
    \            res++\n        }\n    }\n    return res\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpfqf6zx88_test.go:57: expected '%!s(int=4)', got '%!s(int=3)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpfqf6zx88_test.go:57:\
    \ expected '%!s(int=1)', got '%!s(int=2)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpfqf6zx88_test.go:57: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__4 (0.00s)\n        tmpfqf6zx88_test.go:57:\
    \ expected '%!s(int=0)', got '%!s(int=2)'\n    --- FAIL: TestSmallest_Change/test_num__5\
    \ (0.00s)\n        tmpfqf6zx88_test.go:57: expected '%!s(int=0)', got '%!s(int=1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075226
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return smallest_change_helper(arr, 0, len(arr) - 1)\n}\n\n\
    func TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected:\
    \ 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 2, 3, 2, 1}), expected:\
    \ 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual:\
    \ candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0, 1}),\
    \ expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx8i2tyic_test.go:19:12: undefined: smallest_change_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    n := len(arr)\n    if n <= 1 {\n        return 0\n    }\n\
    \    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int,\
    \ n)\n    }\n    for i := 0; i < n; i++ {\n        dp[i][i] = 0\n    }\n    for\
    \ l := 2; l <= n; l++ {\n        for i := 0; i <= n - l; i++ {\n            j\
    \ := i + l - 1\n            if arr[i] == arr[j] {\n                dp[i][j] =\
    \ dp[i + 1][j - 1]\n            } else {\n                dp[i][j] = min(dp[i\
    \ + 1][j], dp[i][j - 1]) + 1\n            }\n        }\n    }\n    return dp[0][n\
    \ - 1]\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc9qfonvl_test.go:36:28: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var answer = 0\n    var len = len(arr)\n    var start = 0\n\
    \    var end = len - 1\n    var count = 0\n    for i := 0; i < len / 2; i++ {\n\
    \        if arr[start] != arr[end] {\n            count++\n        }\n       \
    \ start++\n        end--\n    }\n    answer = count\n    return answer\n}\n\n\
    func TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected:\
    \ 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 2, 3, 2, 1}), expected:\
    \ 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual:\
    \ candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0, 1}),\
    \ expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075226
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return smallest_change_helper(arr, 0, len(arr) - 1)\n}\n\n\
    func TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected:\
    \ 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 2, 3, 2, 1}), expected:\
    \ 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual:\
    \ candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0, 1}),\
    \ expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx8i2tyic_test.go:19:12: undefined: smallest_change_helper

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) <= 1 {\n        return 0\n    }\n    count :=\
    \ 0\n    for i := 0; i < len(arr)/2; i++ {\n        if arr[i] != arr[len(arr)-1-i]\
    \ {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075226
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    i, j := 0, len(arr) - 1\n    count := 0\n    for i < j {\n\
    \        if arr[i] != arr[j] {\n            count += 1\n        }\n        i +=\
    \ 1\n        j -= 1\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075226
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    changeCount := 0\n    length := len(arr)\n    for i := 0;\
    \ i < length/2; i++ {\n        changeCount += changeCountIfNeeded(arr[i], arr[length-i-1])\n\
    \    }\n    return changeCount\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgt5x6d2v_test.go:22:24: undefined: changeCountIfNeeded

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // fill this in\n    return 0\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmp0fak4c23_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmp0fak4c23_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmp0fak4c23_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmp0fak4c23_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmp0fak4c23_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075226
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // Fill this in.\n    fmt.Println(arr)\n    cnt := 0\n   \
    \ if len(arr) % 2 == 0 {\n        for i := 0; i < len(arr) / 2; i++ {\n      \
    \      if arr[i] != arr[len(arr) - 1 - i] {\n                cnt++\n         \
    \   }\n        }\n    } else {\n        for i := 0; i < (len(arr) + 1) / 2; i++\
    \ {\n            if arr[i] != arr[len(arr) - 1 - i] {\n                cnt++\n\
    \            }\n        }\n    }\n    return cnt\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075226
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    n := len(arr)\n    cnt := 0\n    for i := 0; i < n/2; i++\
    \ {\n        if arr[i] != arr[n-i-1] {\n            cnt += 1\n        }\n    }\n\
    \    return cnt\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate :=\
    \ smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075226
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var change_count int\n    var j int\n    i := 0\n    j = len(arr)\
    \ - 1\n    for {\n        if (i >= j) {\n            break\n        }\n      \
    \  if (arr[i] != arr[j]) {\n            change_count++\n        }\n        i++\n\
    \        j--\n    }\n    return change_count\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075226
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var min int\n    min = len(arr)\n    n := len(arr)\n    //\
    \ if n is odd\n    if n % 2 == 1 {\n        m := int(n / 2)\n        // find the\
    \ minimum change\n        for i := 0; i < n; i++ {\n            var count int\n\
    \            for j := 0; j < n; j++ {\n                if arr[i] != arr[j] {\n\
    \                    count += 1\n                }\n            }\n          \
    \  if count < min {\n                min = count\n            }\n        }\n \
    \   } else {\n        m := int(n / 2)\n        for i := 0; i < n; i++ {\n    \
    \        var count int\n            for j := 0; j < n; j++ {\n               \
    \ if arr[i] != arr[j] {\n                    count += 1\n                }\n \
    \           }\n            if count < min {\n                min = count\n   \
    \         }\n        }\n    }\n    return min\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxbk1tbvg_test.go:24:9: m declared but not used

    /tmp/tmpxbk1tbvg_test.go:38:9: m declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075225
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var sum int\n    length := len(arr)\n    for i, v := range\
    \ arr {\n        if length-i-1 > i {\n            sum += v - arr[length-i-1]\n\
    \        }\n    }\n    return sum\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmp4vdc25fx_test.go:49: expected '%!s(int=4)', got '%!s(int=-15)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmp4vdc25fx_test.go:49:\
    \ expected '%!s(int=1)', got '%!s(int=-1)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmp4vdc25fx_test.go:49: expected '%!s(int=1)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmp4vdc25fx_test.go:49:\
    \ expected '%!s(int=1)', got '%!s(int=-1)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmp4vdc25fx_test.go:49: expected '%!s(int=1)', got '%!s(int=-1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075226
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    diffs := make([]int, 0)\n    end := len(arr) - 1\n    for\
    \ i := 0; i < len(arr) / 2; i++ {\n        if arr[i] != arr[end] {\n         \
    \   diffs = append(diffs, arr[i])\n            end--\n        }\n    }\n    return\
    \ len(diffs)\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__1\
    \ (0.00s)\n        tmpsebkg883_test.go:50: expected '%!s(int=1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__4 (0.00s)\n        tmpsebkg883_test.go:50:\
    \ expected '%!s(int=0)', got '%!s(int=1)'\n    --- FAIL: TestSmallest_Change/test_num__5\
    \ (0.00s)\n        tmpsebkg883_test.go:50: expected '%!s(int=0)', got '%!s(int=1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075226
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmp37czl1l4_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmp37czl1l4_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmp37czl1l4_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmp37czl1l4_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmp37czl1l4_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075050
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n\tarrLen := len(arr)\n\tif arrLen < 2 {\n\t\treturn 0\n\t}\n\t\
    left, right := 0, arrLen - 1\n\tresult := 0\n\tfor left < right {\n\t\tif arr[left]\
    \ != arr[right] {\n\t\t\tresult++\n\t\t}\n\t\tleft++\n\t\tright--\n\t}\n\treturn\
    \ result\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.006s\n"
  timestamp: 1660075226
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) < 2 {\n        return 0\n    }\n    if len(arr)\
    \ == 2 {\n        if arr[0] == arr[1] {\n            return 0\n        }\n   \
    \     return 1\n    }\n    for i, _ := range arr {\n        if i == 0 {\n    \
    \        continue\n        }\n        if i == len(arr) - 1 {\n            if arr[i-1]\
    \ == arr[i] {\n                continue\n            }\n            if arr[i-1]\
    \ != arr[i] {\n                return 1\n            }\n        }\n        if\
    \ arr[i-1] == arr[i] {\n            continue\n        }\n        if arr[i-1] !=\
    \ arr[i] {\n            return 2\n        }\n    }\n    return 0\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpdo6z1dnw_test.go:70: expected '%!s(int=4)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpdo6z1dnw_test.go:70:\
    \ expected '%!s(int=1)', got '%!s(int=2)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpdo6z1dnw_test.go:70: expected '%!s(int=1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpdo6z1dnw_test.go:70:\
    \ expected '%!s(int=1)', got '%!s(int=2)'\n    --- FAIL: TestSmallest_Change/test_num__4\
    \ (0.00s)\n        tmpdo6z1dnw_test.go:70: expected '%!s(int=0)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__5 (0.00s)\n        tmpdo6z1dnw_test.go:70:\
    \ expected '%!s(int=0)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075227
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    x := 0\n    if len(arr) == 0 {\n        return x\n    }\n\
    \    if len(arr) % 2 == 0 {\n        left, right := 0, len(arr) - 1\n        for\
    \ left < right {\n            if arr[left] != arr[right] {\n                x\
    \ += 1\n            }\n            left += 1\n            right -= 1\n       \
    \ }\n    } else {\n        left, right := 0, len(arr) - 1\n        for left <\
    \ right {\n            if arr[left] != arr[right] {\n                x += 1\n\
    \            }\n            left += 1\n            right -= 1\n        }\n   \
    \ }\n    return x\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075227
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    l := len(arr)\n\
    \    i := 0\n    j := l - 1\n    count := 0\n    for i < j {\n        if arr[i]\
    \ != arr[j] {\n            count++\n        }\n        i++\n        j--\n    }\n\
    \    return count\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075227
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return smallest_change_slice(arr, 0, len(arr) - 1)\n}\n\n\
    func TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected:\
    \ 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 2, 3, 2, 1}), expected:\
    \ 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual:\
    \ candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0, 1}),\
    \ expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5j59dal0_test.go:19:12: undefined: smallest_change_slice

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075226
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    i, j := 0, len(arr) - 1\n    count := 0\n    for i < j {\n\
    \        if arr[i] != arr[j] {\n            count += 1\n        }\n        i +=\
    \ 1\n        j -= 1\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075226
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // TODO: solve it.\n    return 0\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmp2m3iam_3_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmp2m3iam_3_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmp2m3iam_3_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmp2m3iam_3_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmp2m3iam_3_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075227
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // YOUR CODE HERE\n    if len(arr) == 0 {\n        return\
    \ 0\n    }\n    changes := 0\n    for i, j := 0, len(arr)-1; i < j; i, j = i+1,\
    \ j-1 {\n        if arr[i] != arr[j] {\n            changes++\n        }\n   \
    \ }\n    return changes\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075227
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // We will check for each point of the \"nose\" of the palindrome\n\
    \    // whether we need to make changes\n    // - if we can create a palindrome\
    \ from left to right, we're done\n    // - if we can't create one from left to\
    \ right, we'll check from right to left\n\n    // to know if it's from left to\
    \ right or from right to left, we'll compare\n    // the delta of the change for\
    \ both options\n    // - if we need to change more at the left than the right,\
    \ we'll take the right\n    // and continue on. We'll also keep track of the number\
    \ of changes needed\n    // to get the palindrome\n\n    start := 0\n    end :=\
    \ len(arr) - 1\n    changes := 0\n\n    left_changes := 0\n    right_changes :=\
    \ 0\n\n    for start <= end {\n        if arr[start] == arr[end] {\n         \
    \   start++\n            end--\n            continue\n        }\n\n        if\
    \ arr[start] < arr[end] {\n            left_changes = changes\n            changes\
    \ += arr[end] - arr[start]\n            arr[start] = arr[end]\n        } else\
    \ {\n            right_changes = changes\n            changes += arr[start] -\
    \ arr[end]\n            arr[end] = arr[start]\n        }\n\n        if left_changes\
    \ < right_changes {\n            start++\n            end--\n        } else {\n\
    \            start--\n            end++\n        }\n    }\n\n    return changes\n\
    }\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\npanic: runtime error: index out\
    \ of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\
    \ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\t\
    /home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.smallest_change({0xc0000c45f0?, 0x5e3ea0?,\
    \ 0x37930?})\n\t/tmp/tmpcgrbp0bw_test.go:38 +0xbe\ncommand-line-arguments_test.TestSmallest_Change(0x0?)\n\
    \t/tmp/tmpcgrbp0bw_test.go:73 +0xd5\ntesting.tRunner(0xc0001a0340, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075227
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    len := len(arr)\n    start := 0\n    end := len - 1\n    change_number\
    \ := 0\n    for start < end {\n        if arr[start] != arr[end] {\n         \
    \   change_number++\n        }\n        start++\n        end--\n    }\n    return\
    \ change_number\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate :=\
    \ smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075227
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    length := len(arr)\n    var count int\n    for i := 0; i <\
    \ length/2; i++ {\n        if arr[i] != arr[length-i-1] {\n            count++\n\
    \        }\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075228
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n\tif arr == nil || len(arr) <= 0 {\n\t\treturn 0\n\t}\n\tif len(arr)\
    \ == 1 {\n\t\treturn 0\n\t}\n\tif len(arr) == 2 {\n\t\tif arr[0] == arr[1] {\n\
    \t\t\treturn 0\n\t\t}\n\t\treturn 1\n\t}\n\tif arr[0] == arr[len(arr)-1] {\n\t\
    \treturn smallest_change(arr[1:len(arr)-1])\n\t}\n\treturn 1 + min(smallest_change(arr[1:]),\
    \ smallest_change(arr[:len(arr)-1]))\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoqr4p83e_test.go:34:13: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075227
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    l := len(arr)\n    var i, j int\n    for i = 0; i < l / 2;\
    \ i++ {\n        if arr[i] != arr[l - i - 1] {\n            break\n        }\n\
    \    }\n    if i == l / 2 {\n        return 0\n    }\n    if l % 2 == 0 {\n  \
    \      for j = i; j < l / 2; j++ {\n            if arr[j] != arr[l - j - 1] {\n\
    \                break\n            }\n        }\n        if j == l / 2 {\n  \
    \          return l / 2 - i\n        }\n    } else {\n        for j = i; j < l\
    \ / 2; j++ {\n            if arr[j] != arr[l - j - 1] {\n                break\n\
    \            }\n        }\n        if j == l / 2 {\n            return l / 2 -\
    \ i\n        }\n    }\n    return l - j - 1\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmp6nv85irg_test.go:71: expected '%!s(int=4)', got '%!s(int=7)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmp6nv85irg_test.go:71:\
    \ expected '%!s(int=1)', got '%!s(int=6)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmp6nv85irg_test.go:71: expected '%!s(int=1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmp6nv85irg_test.go:71:\
    \ expected '%!s(int=1)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075228
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr)\
    \ == 1 {\n        return 0\n    }\n    r := 0\n    for l := 0; l < len(arr) -\
    \ 1; l++ {\n        r = l + 1\n        if arr[l] == arr[r] {\n            continue\n\
    \        }\n        break\n    }\n    return r\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpwue588wi_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__4 (0.00s)\n        tmpwue588wi_test.go:56:\
    \ expected '%!s(int=0)', got '%!s(int=1)'\n    --- FAIL: TestSmallest_Change/test_num__5\
    \ (0.00s)\n        tmpwue588wi_test.go:56: expected '%!s(int=0)', got '%!s(int=1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075228
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) < 2 {\n        return 0\n    }\n    count := 0\n\
    \    for i := 0; i < len(arr) / 2; i++ {\n        if arr[i] != arr[len(arr) -\
    \ 1 - i] {\n            count += 1\n        }\n    }\n    return count\n}\n\n\
    func TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected:\
    \ 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 2, 3, 2, 1}), expected:\
    \ 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual:\
    \ candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0, 1}),\
    \ expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075228
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // front and rear index\n    front, rear := 0, len(arr) -\
    \ 1\n    // count of elements that need to be changed\n    changes := 0\n    //\
    \ while index of front is less than rear\n    for front < rear {\n        // if\
    \ corresponding elements are not equal\n        if arr[front] != arr[rear] {\n\
    \            // increment change count\n            changes++\n        }\n   \
    \     // move front and rear index\n        front++\n        rear--\n    }\n \
    \   // return change count\n    return changes\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075228
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // your code here...\n    cnt := 0\n    i := 0\n    j := len(arr)\
    \ - 1\n    for i < j {\n        if arr[i] != arr[j] {\n            cnt += 1\n\
    \        }\n        i += 1\n        j -= 1\n    }\n    return cnt\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075228
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // (1) Count the number of palindromic numbers, add the rest\
    \ to changes\n    // (2) Count the changes from the middle to the left, add the\
    \ rest to changes\n    // (3) Count the changes from the middle to the right,\
    \ add the rest to changes\n    // (4) Return changes\n\n    // (1)\n    var palindromic,\
    \ changes int\n    for i := 0; i < len(arr) / 2; i++ {\n        if arr[i] == arr[len(arr)\
    \ - 1 - i] {\n            palindromic++\n        } else {\n            changes++\n\
    \        }\n    }\n    changes += len(arr) - palindromic * 2\n\n    // (2)\n \
    \   for i := 0; i < palindromic; i++ {\n        if arr[i] == arr[len(arr) - 1\
    \ - i] {\n            continue\n        } else {\n            // The value of\
    \ the left side is smaller than the right side,\n            // so we need to\
    \ change the left value to be equal to the right value.\n            changes +=\
    \ arr[len(arr) - 1 - i] - arr[i]\n        }\n    }\n\n    // (3)\n    for i :=\
    \ palindromic; i < len(arr) - palindromic; i++ {\n        if arr[i] == arr[len(arr)\
    \ - 1 - i] {\n            continue\n        } else {\n            // The value\
    \ of the right side is smaller than the left side,\n            // so we need\
    \ to change the right value to be equal to the left value.\n            changes\
    \ += arr[i] - arr[len(arr) - 1 - i]\n        }\n    }\n\n    // (4)\n    return\
    \ changes\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpdrma0tjz_test.go:81: expected '%!s(int=4)', got '%!s(int=12)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpdrma0tjz_test.go:81:\
    \ expected '%!s(int=1)', got '%!s(int=5)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpdrma0tjz_test.go:81: expected '%!s(int=1)', got '%!s(int=4)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpdrma0tjz_test.go:81:\
    \ expected '%!s(int=1)', got '%!s(int=4)'\n    --- FAIL: TestSmallest_Change/test_num__4\
    \ (0.00s)\n        tmpdrma0tjz_test.go:81: expected '%!s(int=0)', got '%!s(int=1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__6 (0.00s)\n        tmpdrma0tjz_test.go:81:\
    \ expected '%!s(int=0)', got '%!s(int=1)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmpdrma0tjz_test.go:81: expected '%!s(int=1)', got '%!s(int=3)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075228
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpfexbjqqk_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpfexbjqqk_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpfexbjqqk_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpfexbjqqk_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmpfexbjqqk_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // Fill this in.\n    n := len(arr)\n    if n <= 1 {\n   \
    \     return 0\n    }\n    if n % 2 == 0 {\n        return n - 2\n    }\n    m\
    \ := n / 2\n    if arr[m - 1] == arr[m + 1] {\n        return n - 1\n    }\n \
    \   return n\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpoestzb_y_test.go:54: expected '%!s(int=4)', got '%!s(int=6)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpoestzb_y_test.go:54:\
    \ expected '%!s(int=1)', got '%!s(int=6)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpoestzb_y_test.go:54: expected '%!s(int=1)', got '%!s(int=3)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpoestzb_y_test.go:54:\
    \ expected '%!s(int=1)', got '%!s(int=2)'\n    --- FAIL: TestSmallest_Change/test_num__4\
    \ (0.00s)\n        tmpoestzb_y_test.go:54: expected '%!s(int=0)', got '%!s(int=4)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__5 (0.00s)\n        tmpoestzb_y_test.go:54:\
    \ expected '%!s(int=0)', got '%!s(int=2)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmpoestzb_y_test.go:54: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075228
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    l := len(arr)\n    if l == 0 {\n        return 0\n    }\n\n\
    \    var i int\n    var change int\n    for i = 0; i < l / 2; i++ {\n        if\
    \ arr[i] != arr[l - i - 1] {\n            change++\n        }\n    }\n\n    return\
    \ change\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075228
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var A []int\n    if len(arr) < 2 {\n        return 0\n   \
    \ }\n    for i := 0; i < len(arr)/2; i++ {\n        if arr[i] != arr[len(arr)-1-i]\
    \ {\n            A = append(A, arr[i])\n            A = append(A, arr[len(arr)-1-i])\n\
    \        }\n    }\n    if len(A) < 2 {\n        return 0\n    }\n    ret := A[0]\n\
    \    // i: index of array A\n    for i := 0; i < len(A); i++ {\n        if A[i]\
    \ < ret {\n            ret = A[i]\n        }\n    }\n    return ret\n}\n\nfunc\
    \ TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected:\
    \ 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 2, 3, 2, 1}), expected:\
    \ 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual:\
    \ candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0, 1}),\
    \ expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpm8qjyowo_test.go:62: expected '%!s(int=4)', got '%!s(int=1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__7 (0.00s)\n        tmpm8qjyowo_test.go:62:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075228
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    i, j := 0, len(arr) - 1\n    var count int\n    for i < j\
    \ {\n        if arr[i] != arr[j] {\n            if arr[i] == arr[j - 1] && arr[i\
    \ + 1] == arr[j] {\n                if arr[i + 2] == arr[j - 1] {\n          \
    \          j--\n                } else {\n                    i++\n          \
    \      }\n            } else if arr[i] == arr[j - 1] {\n                j--\n\
    \            } else if arr[i + 1] == arr[j] {\n                i++\n         \
    \   } else {\n                i++\n                j--\n            }\n      \
    \      count++\n        } else {\n            i++\n            j--\n        }\n\
    \    }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\npanic: runtime error: index out\
    \ of range [2] with length 2 [recovered]\n\tpanic: runtime error: index out of\
    \ range [2] with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.smallest_change({0xc0000c4528?, 0x5e3ea0?,\
    \ 0x37930?})\n\t/tmp/tmph37zeuws_test.go:24 +0xf4\ncommand-line-arguments_test.TestSmallest_Change(0x0?)\n\
    \t/tmp/tmph37zeuws_test.go:60 +0x37f\ntesting.tRunner(0xc000192680, 0x528f48)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075228
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var length = len(arr)\n    var count = 0\n    for i := 0;\
    \ i < length / 2; i++ {\n        if arr[i] != arr[length - i - 1] {\n        \
    \    count += 1\n        }\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075228
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var count int = 0\n    l := len(arr)\n    if l % 2 == 0 {\n\
    \        for i := 0; i < l / 2; i++ {\n            if arr[i] != arr[l - i - 1]\
    \ {\n                count++\n            }\n        }\n    } else {\n       \
    \ for i := 0; i < l / 2; i++ {\n            if arr[i] != arr[l - i - 1] {\n  \
    \              count++\n            }\n        }\n    }\n    return count\n}\n\
    \nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075228
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // Convert to a slice of runes because using strings will\
    \ mess up\n    // odd length lists due to the extra rune in the middle\n    //\
    \ Example: [1, 2, 3, 2, 1]\n    runes := []rune{}\n    for _, i := range arr {\n\
    \        runes = append(runes, rune(i))\n    }\n\n    // Align the lists so that\
    \ they are centered. This is necessary because\n    // we are comparing the first\
    \ half of the list to the second half\n    // in reverse. Example: [1, 2, 3, 2,\
    \ 1] becomes [1, 2, 3, 2, 1, 1, 2, 3, 2, 1]\n    runes_shifted := make([]rune,\
    \ len(runes) * 2)\n    shift := len(runes) / 2\n    for i := range runes {\n \
    \       runes_shifted[i] = runes[(i + shift) % len(runes)]\n    }\n\n    // Check\
    \ if the first half of the list is equivalent to the second half\n    // when\
    \ reversed. Example: [1, 2, 3, 2, 1, 1, 2, 3, 2, 1] becomes [1, 2, 3, 2, 1, 1,\
    \ 2, 3, 2, 1]\n    //                                                        \
    \  [1, 1, 2, 3, 2, 1, 1, 2, 3, 2]\n    changes := 0\n    for i := 0; i < len(runes);\
    \ i++ {\n        if runes_shifted[i] != runes_shifted[i + len(runes)] {\n    \
    \        changes++\n        }\n    }\n\n    return changes\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpxths30n7_test.go:69: expected '%!s(int=4)', got '%!s(int=8)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpxths30n7_test.go:69:\
    \ expected '%!s(int=1)', got '%!s(int=7)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpxths30n7_test.go:69: expected '%!s(int=1)', got '%!s(int=3)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpxths30n7_test.go:69:\
    \ expected '%!s(int=1)', got '%!s(int=4)'\n    --- FAIL: TestSmallest_Change/test_num__4\
    \ (0.00s)\n        tmpxths30n7_test.go:69: expected '%!s(int=0)', got '%!s(int=5)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__5 (0.00s)\n        tmpxths30n7_test.go:69:\
    \ expected '%!s(int=0)', got '%!s(int=4)'\n    --- FAIL: TestSmallest_Change/test_num__6\
    \ (0.00s)\n        tmpxths30n7_test.go:69: expected '%!s(int=0)', got '%!s(int=1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075228
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr)\
    \ == 1 {\n        return 1\n    }\n    f := 0\n    b := len(arr) - 1\n    change_count\
    \ := 0\n    for f < b {\n        if arr[f] != arr[b] {\n            change_count\
    \ += 1\n        }\n        f += 1\n        b -= 1\n    }\n    return change_count\n\
    }\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__6\
    \ (0.00s)\n        tmpz7xmej7p_test.go:58: expected '%!s(int=0)', got '%!s(int=1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075229
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var change int\n    for i := 0; i < len(arr) / 2; i++ {\n\
    \        diff := arr[i] - arr[len(arr) - 1 - i]\n        if diff != 0 {\n    \
    \        change += abs(diff)\n        }\n    }\n    return change\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg50gxicz_test.go:23:23: undefined: abs

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075229
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    l := len(arr)\n    if l == 0 {\n        return 0\n    }\n\
    \    // dp[i][j] means the minimum numbers of changes when arr[i:j] is palindromic\n\
    \    dp := make([][]int, l)\n    for i := 0; i < l; i++ {\n        dp[i] = make([]int,\
    \ l)\n    }\n    // the list has only one element\n    for i := 0; i < l; i++\
    \ {\n        dp[i][i] = 0\n    }\n    // the list has two elements\n    for i\
    \ := 0; i < l - 1; i++ {\n        dp[i][i + 1] = 0\n        if arr[i] != arr[i\
    \ + 1] {\n            dp[i][i + 1] = 1\n        }\n    }\n    // the list has\
    \ more than two elements\n    for step := 2; step < l; step++ {\n        for i\
    \ := 0; i < l - step; i++ {\n            dp[i][i + step] = dp[i + 1][i + step\
    \ - 1]\n            if arr[i] != arr[i + step] {\n                dp[i][i + step]\
    \ += 1\n            }\n        }\n    }\n    return dp[0][l - 1]\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075230
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    res := 0\n    middle := len(arr) / 2\n    for i := 0; i <\
    \ middle; i++ {\n        if arr[i] != arr[len(arr) - 1 - i] {\n            res\
    \ += 1\n        }\n    }\n    return res\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075230
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    count := 0\n    for i := 0; i < len(arr) / 2; i++ {\n    \
    \    if arr[i] != arr[len(arr) - 1 - i] {\n            count++\n        }\n  \
    \  }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075221
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) < 2 {\n        return 0\n    }\n    forward, backward\
    \ := 0, len(arr) - 1\n    count := 0\n    for {\n        if forward >= backward\
    \ {\n            break\n        }\n        if arr[forward] != arr[backward] {\n\
    \            count++\n        }\n        forward++\n        backward--\n    }\n\
    \    return count\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075230
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    count := 0\n    for i, _ := range arr {\n        count +=\
    \ compare(arr, i)\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5fcom0u3_test.go:21:18: undefined: compare

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075229
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // reverse slice\n    for i, j := 0, len(arr)-1; i < j; i,\
    \ j = i+1, j-1 {\n        arr[i], arr[j] = arr[j], arr[i]\n    }\n    // find\
    \ smallest change\n    diff := 0\n    for i := 0; i < len(arr); i++ {\n      \
    \  if arr[i] != arr[len(arr)-i-1] {\n            diff++\n        }\n    }\n  \
    \  return diff\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate :=\
    \ smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpv7ggw5mj_test.go:53: expected '%!s(int=4)', got '%!s(int=8)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpv7ggw5mj_test.go:53:\
    \ expected '%!s(int=1)', got '%!s(int=2)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpv7ggw5mj_test.go:53: expected '%!s(int=1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpv7ggw5mj_test.go:53:\
    \ expected '%!s(int=1)', got '%!s(int=2)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmpv7ggw5mj_test.go:53: expected '%!s(int=1)', got '%!s(int=2)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075230
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    var i int\n\
    \    var j int\n    var count int\n    i = 0\n    j = len(arr) - 1\n    for i\
    \ < j {\n        for arr[i] != arr[j] {\n            count++\n            if arr[i]\
    \ < arr[j] {\n                i++\n            } else {\n                j--\n\
    \            }\n        }\n        i++\n        j--\n    }\n    return count\n\
    }\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpv7lb7ahs_test.go:62: expected '%!s(int=4)', got '%!s(int=7)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpv7lb7ahs_test.go:62:\
    \ expected '%!s(int=1)', got '%!s(int=2)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpv7lb7ahs_test.go:62: expected '%!s(int=1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpv7lb7ahs_test.go:62:\
    \ expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075230
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var count int\n    for i, j := 0, len(arr)-1; i < j; i, j\
    \ = i+1, j-1 {\n        if arr[i] != arr[j] {\n            count++\n        }\n\
    \    }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075050
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var last_index = len(arr) - 1\n    var first_index = 0\n \
    \   var result = 0\n    for first_index < last_index {\n        if arr[first_index]\
    \ != arr[last_index] {\n            result += 1\n        }\n        first_index\
    \ += 1\n        last_index -= 1\n    }\n    return result\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075230
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var count int\n    for i, j := 0, len(arr)-1; i < j; i, j\
    \ = i+1, j-1 {\n        fmt.Println(i, j)\n        if arr[i] != arr[j] {\n   \
    \         count++\n        }\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075230
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return -1\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmps4gy1l2p_test.go:42: expected '%!s(int=4)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmps4gy1l2p_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=-1)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmps4gy1l2p_test.go:42: expected '%!s(int=1)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmps4gy1l2p_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=-1)'\n    --- FAIL: TestSmallest_Change/test_num__4\
    \ (0.00s)\n        tmps4gy1l2p_test.go:42: expected '%!s(int=0)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__5 (0.00s)\n        tmps4gy1l2p_test.go:42:\
    \ expected '%!s(int=0)', got '%!s(int=-1)'\n    --- FAIL: TestSmallest_Change/test_num__6\
    \ (0.00s)\n        tmps4gy1l2p_test.go:42: expected '%!s(int=0)', got '%!s(int=-1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__7 (0.00s)\n        tmps4gy1l2p_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075230
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var diff int\n    for i := 0; i < len(arr)/2; i++ {\n    \
    \    diff += arr[i] - arr[len(arr)-1-i]\n    }\n    if diff == 0 {\n        return\
    \ 0\n    }\n    if diff < 0 {\n        diff = -diff\n    }\n    return (diff +\
    \ 1) / 2\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpanrpisbo_test.go:52: expected '%!s(int=4)', got '%!s(int=8)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075230
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    change := 0\n    for i, j := 0, len(arr)-1; i < j; i, j =\
    \ i+1, j-1 {\n        if arr[i] != arr[j] {\n            change++\n        }\n\
    \    }\n    return change\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075231
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    mid := len(arr) / 2\n    count := 0\n    n_arr := len(arr)\
    \ - 1\n    for i := 0; i < mid; i++ {\n        if arr[i] != arr[n_arr-i] {\n \
    \           count++\n        }\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075231
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var is_palindrome bool = true\n    var smallest_change int\
    \ = 0\n    var i int\n    var j int\n    var n int\n    n = len(arr)\n    i =\
    \ 0\n    j = n - 1\n    for i < j {\n        if arr[i] != arr[j] {\n         \
    \   is_palindrome = false\n            // Fix array[i]\n            if arr[i]\
    \ == arr[j - 1] && (i + 1 >= j - 1 || arr[i + 1] == arr[j - 2]) {\n          \
    \      arr[j] = arr[i]\n                j--\n            } else {\n          \
    \      arr[i] = arr[j]\n            }\n            smallest_change++\n       \
    \ }\n        i++\n        j--\n    }\n    if is_palindrome {\n        return 0\n\
    \    }\n    return smallest_change\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075231
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var i, j, num int\n    if len(arr) <= 1 {\n        return\
    \ 0\n    }\n    for i, j = 0, len(arr) - 1; i < j; i, j = i + 1, j - 1 {\n   \
    \     if arr[i] != arr[j] {\n            num++\n        }\n    }\n    return num\n\
    }\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075231
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var sum int = 0\n    i := 0\n    j := len(arr) - 1\n    for\
    \ i < j {\n        if arr[i] == arr[j] {\n            i++\n            j--\n \
    \       } else {\n            if arr[i] < arr[j] {\n                arr[i+1] +=\
    \ arr[i]\n                i++\n            } else {\n                arr[j-1]\
    \ += arr[j]\n                j--\n            }\n            sum++\n        }\n\
    \    }\n    return sum\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpi2ycufaa_test.go:60: expected '%!s(int=4)', got '%!s(int=3)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpi2ycufaa_test.go:60:\
    \ expected '%!s(int=1)', got '%!s(int=6)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpi2ycufaa_test.go:60: expected '%!s(int=1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpi2ycufaa_test.go:60:\
    \ expected '%!s(int=1)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075231
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    len := len(arr)\n    i := 0\n    j := len - 1\n    changeCount\
    \ := 0\n    for i < j {\n        if arr[i] != arr[j] {\n            changeCount\
    \ += 1\n        }\n        i += 1\n        j -= 1\n    }\n    return changeCount\n\
    }\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075231
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr)\
    \ == 1 {\n        return 1\n    }\n    left := 0\n    right := len(arr) - 1\n\
    \    count := 0\n    for left < right {\n        if arr[left] != arr[right] {\n\
    \            count++\n        }\n        left++\n        right--\n    }\n    return\
    \ count\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__6\
    \ (0.00s)\n        tmp_efaf5qp_test.go:58: expected '%!s(int=0)', got '%!s(int=1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075231
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    rt := 0\n    for i := 0; i < len(arr) / 2; i++ {\n       \
    \ if arr[i] != arr[len(arr) - 1 - i] {\n            rt++\n        }\n    }\n \
    \   return rt\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075231
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // TODO\n    var count int\n    for i, j := 0, len(arr)-1;\
    \ i < j; i, j = i+1, j-1 {\n        if arr[i] != arr[j] {\n            count +=\
    \ 1\n        }\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075231
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n\tif len(arr) == 0 {\n\t\treturn 0\n\t}\n\tif len(arr) == 1 {\n\
    \t\treturn 1\n\t}\n\tvar left int = 0\n\tvar right int = len(arr) - 1\n\tvar total_change\
    \ int = 0\n\tfor left < right {\n\t\tif arr[left] != arr[right] {\n\t\t\ttotal_change++\n\
    \t\t}\n\t\tleft++\n\t\tright--\n\t}\n\treturn total_change\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__6\
    \ (0.00s)\n        tmpdexutm2x_test.go:58: expected '%!s(int=0)', got '%!s(int=1)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075231
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) <= 1 {\n        return 0\n    }\n    // total\
    \ cost\n    total := 0\n    // current is the current element number\n    current\
    \ := 0\n    // end is the end element number\n    end := len(arr) - 1\n    //\
    \ move inwards, and calculate the cost of the two elements\n    for current <\
    \ end {\n        total += abs(arr[current] - arr[end])\n        current += 1\n\
    \        end -= 1\n    }\n    return total\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4l0pc07a_test.go:30:18: undefined: abs

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075230
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    i, j := 0, len(arr) - 1\n    var change int\n    for i < j\
    \ {\n        if arr[i] != arr[j] {\n            change += 1\n        }\n     \
    \   i += 1\n        j -= 1\n    }\n    return change\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075231
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) <= 1 {\n        return 0\n    }\n    i, j := 0,\
    \ len(arr) - 1\n    count := 0\n    for {\n        if i > j {\n            break\n\
    \        }\n        if arr[i] == arr[j] {\n            i++\n            j--\n\
    \        } else {\n            left, right := i, j\n            for ; left < right;\
    \ left++ {\n                if arr[left] == arr[j] {\n                    break\n\
    \                }\n            }\n            for ; left < right; right-- {\n\
    \                if arr[right] == arr[i] {\n                    break\n      \
    \          }\n            }\n            count++\n            if left == right\
    \ {\n                i++\n                j--\n            } else {\n        \
    \        i++\n                j--\n            }\n        }\n    }\n    return\
    \ count\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075231
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var count int = 0\n    var length int = len(arr)\n    var\
    \ i int = 0\n    var j int = 0\n    for i < length && j < length {\n        if\
    \ arr[i] == arr[length - 1 - j] {\n            i++\n            j++\n        }\
    \ else {\n            count++\n            if i > j {\n                j++\n \
    \           } else {\n                i++\n            }\n        }\n    }\n \
    \   return count\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate :=\
    \ smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmp_9ojlepe_test.go:59: expected '%!s(int=4)', got '%!s(int=13)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmp_9ojlepe_test.go:59:\
    \ expected '%!s(int=1)', got '%!s(int=3)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmp_9ojlepe_test.go:59: expected '%!s(int=1)', got '%!s(int=3)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmp_9ojlepe_test.go:59:\
    \ expected '%!s(int=1)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075231
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // write your code in Go 1.4\n    n := len(arr)\n    var start,\
    \ end int\n    start = 0\n    end = n - 1\n    count := 0\n    for start < end\
    \ {\n        if arr[start] != arr[end] {\n            count++\n        }\n   \
    \     start++\n        end--\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075232
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    count := 0\n    for i := 0; i < len(arr)/2; i++ {\n      \
    \  if arr[i] != arr[len(arr)-i-1] {\n            count++\n        }\n    }\n \
    \   return count\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate :=\
    \ smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075221
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    n := len(arr)\n    var res int\n    for i := 0; i < n/2; i++\
    \ {\n        if arr[i] != arr[n-i-1] {\n            res++\n        }\n    }\n\
    \    return res\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate :=\
    \ smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075232
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    count := 0\n    size := len(arr)\n    for i := 0; i < size\
    \ / 2; i++ {\n        if arr[i] != arr[size - i - 1] {\n            count++\n\
    \        }\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075232
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var result = 0\n    var left = 0\n    var right = len(arr)\
    \ - 1\n    for left < right {\n        if arr[left] != arr[right] {\n        \
    \    result += 1\n        }\n        left += 1\n        right -= 1\n    }\n  \
    \  return result\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate :=\
    \ smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.002s\n"
  timestamp: 1660075232
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    m := make(map[int]bool)\n\
    \    for _, v := range arr {\n        m[v] = true\n    }\n    return len(m)\n\
    }\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprqpnd48e_test.go:49: expected '%!s(int=4)', got '%!s(int=8)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprqpnd48e_test.go:49:\
    \ expected '%!s(int=1)', got '%!s(int=4)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprqpnd48e_test.go:49: expected '%!s(int=1)', got '%!s(int=3)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprqpnd48e_test.go:49:\
    \ expected '%!s(int=1)', got '%!s(int=3)'\n    --- FAIL: TestSmallest_Change/test_num__4\
    \ (0.00s)\n        tmprqpnd48e_test.go:49: expected '%!s(int=0)', got '%!s(int=3)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__5 (0.00s)\n        tmprqpnd48e_test.go:49:\
    \ expected '%!s(int=0)', got '%!s(int=2)'\n    --- FAIL: TestSmallest_Change/test_num__6\
    \ (0.00s)\n        tmprqpnd48e_test.go:49: expected '%!s(int=0)', got '%!s(int=1)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__7 (0.00s)\n        tmprqpnd48e_test.go:49:\
    \ expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075232
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    n := len(arr)\n    if n <= 0 {\n        return 0\n    }\n\
    \    count := 0\n    for i := 0; i < n / 2; i++ {\n        l := arr[i]\n     \
    \   r := arr[n - i - 1]\n        if l != r {\n            count++\n        }\n\
    \    }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075232
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // Your code here\n\n    return 0\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpchvr4v8h_test.go:44: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpchvr4v8h_test.go:44:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpchvr4v8h_test.go:44: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpchvr4v8h_test.go:44:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmpchvr4v8h_test.go:44: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075232
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    len := len(arr)\n    if len < 1 {\n        return 0\n    }\n\
    \    if len == 1 {\n        return 0\n    }\n    if len == 2 {\n        if arr[0]\
    \ == arr[1] {\n            return 0\n        } else {\n            return 1\n\
    \        }\n    }\n    var count = 0\n    for i, j := 0, len - 1; i < j; i, j\
    \ = i + 1, j - 1 {\n        if arr[i] != arr[j] {\n            count += 1\n  \
    \      }\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075232
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    arr = my_reverse(arr)\n\
    \    result := 0\n    for i := range arr {\n        if arr[i] != arr[len(arr)\
    \ - 1 - i] {\n            result += 1\n        }\n    }\n    return result / 2\n\
    }\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppyir87e6_test.go:22:11: undefined: my_reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075232
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var first, last, changes int\n    size := len(arr)\n    last\
    \ = size - 1\n    for first < last {\n        if arr[first] != arr[last] {\n \
    \           changes++\n        }\n        first++\n        last--\n    }\n   \
    \ return changes\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate :=\
    \ smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075233
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    if len(arr)\
    \ == 1 {\n        return 0\n    }\n    if len(arr) == 2 {\n        if arr[0] ==\
    \ arr[1] {\n            return 0\n        } else {\n            return 1\n   \
    \     }\n    }\n    var l, r int\n    if len(arr) % 2 == 0 {\n        l = len(arr)\
    \ / 2 - 1\n        r = len(arr) / 2\n    } else {\n        l = len(arr) / 2 -\
    \ 1\n        r = len(arr) / 2 + 1\n    }\n    var change int\n    for l >= 0 &&\
    \ r < len(arr) {\n        if arr[l] == arr[r] {\n            l--\n           \
    \ r++\n        } else {\n            if arr[l] < arr[r] {\n                arr[r]\
    \ = arr[l]\n                change++\n                l--\n                r++\n\
    \            } else {\n                arr[l] = arr[r]\n                change++\n\
    \                l--\n                r++\n            }\n        }\n    }\n \
    \   return change\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075233
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) == 0 {\n        return 0\n    }\n    change_count\
    \ := 0\n    last_index := len(arr) - 1\n    first_index := 0\n    for first_index\
    \ < last_index {\n        change_count += abs(arr[first_index] - arr[last_index])\n\
    \        first_index++\n        last_index--\n    }\n    return change_count\n\
    }\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgslefxhy_test.go:26:25: undefined: abs

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075233
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if arr == nil || len(arr) == 0 {\n        return 0\n    }\n\
    \    if len(arr) == 1 {\n        return 0\n    }\n    if len(arr) == 2 {\n   \
    \     if arr[0] == arr[1] {\n            return 0\n        }\n        return 1\n\
    \    }\n    lenArr := len(arr)\n    sum := 0\n    for index, value := range arr\
    \ {\n        if index > lenArr - index - 1 {\n            break\n        }\n \
    \       sum += Abs(value - arr[lenArr - index - 1])\n    }\n    return sum\n}\n\
    \nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_iwyva31_test.go:37:16: undefined: Abs

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075233
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    l := len(arr)\n    if l < 2 {\n        return 0\n    }\n \
    \   m := l / 2\n    left := arr[:m]\n    if l % 2 == 0 {\n        right := arr[m:]\n\
    \        return smallest_change_equal(left, right)\n    } else {\n        right\
    \ := arr[m+1:]\n        return smallest_change_unequal(left, right)\n    }\n}\n\
    \nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu7mc9h4f_test.go:27:16: undefined: smallest_change_equal

    /tmp/tmpu7mc9h4f_test.go:30:16: undefined: smallest_change_unequal

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075233
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    n := len(arr)\n    m := make([][]int, n)\n    for i := 0;\
    \ i < n; i++ {\n        m[i] = make([]int, n)\n    }\n    for i := 0; i < n; i++\
    \ {\n        m[i][i] = 0\n    }\n    for d := 1; d < n; d++ {\n        for i :=\
    \ 0; i < n-d; i++ {\n            j := i + d\n            if arr[i] == arr[j] {\n\
    \                m[i][j] = m[i+1][j-1]\n            } else {\n               \
    \ m[i][j] = min(m[i+1][j], m[i][j-1]) + 1\n            }\n        }\n    }\n \
    \   return m[0][n-1]\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfmfka28x_test.go:33:27: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075233
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    res := 0\n    m := len(arr)\n    if m == 0 {\n        return\
    \ res\n    }\n    for i := 0; i < m/2; i++ {\n        j := m - i - 1\n       \
    \ if arr[i] != arr[j] {\n            res++\n        }\n    }\n    return res\n\
    }\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075233
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n\treturn len(arr) - longest_palindrome_subseq(arr)\n}\n\nfunc\
    \ TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected:\
    \ 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1, 2, 3, 2, 1}), expected:\
    \ 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual:\
    \ candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0, 1}),\
    \ expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaxot6w6z_test.go:19:20: undefined: longest_palindrome_subseq

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075233
- exit_code: 2
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    n := len(arr)\n    if n == 0 {\n        return 0\n    }\n\n\
    \    dp := make([][]int, n)\n    for i := 0; i < n; i++ {\n        dp[i] = make([]int,\
    \ n)\n    }\n\n    for l := 2; l <= n; l++ {\n        for i := 0; i <= n - l;\
    \ i++ {\n            j := i + l - 1\n            if arr[i] == arr[j] {\n     \
    \           dp[i][j] = dp[i + 1][j - 1]\n            } else {\n              \
    \  dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1])\n            }\n        }\n\
    \    }\n\n    return dp[0][n - 1]\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp75cape9_test.go:35:32: undefined: min

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075233
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    change := 0\n    length := len(arr)\n    if length <= 1 {\n\
    \        return change\n    }\n    mid := length / 2\n    left := mid - 1\n  \
    \  right := mid + 1\n    if length % 2 == 0 {\n        left = mid - 1\n      \
    \  right = mid\n    }\n    for left >= 0 && right < length {\n        if arr[left]\
    \ != arr[right] {\n            change++\n        }\n        left--\n        right++\n\
    \    }\n    return change\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075233
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    size := len(arr)\n    if size <= 1 {\n        return 0\n \
    \   }\n    count := 0\n    left, right := 0, size - 1\n    for left < right {\n\
    \        if arr[left] != arr[right] {\n            count++\n        }\n      \
    \  left++\n        right--\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075233
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    totalChanged := 0\n    for i, j := 0, len(arr) - 1; i < j;\
    \ i, j = i + 1, j - 1 {\n        if arr[i] != arr[j] {\n            totalChanged\
    \ += 1\n        }\n    }\n    return totalChanged\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075233
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    length := len(arr)\n    // no need to flip all elements\n\
    \    if length % 2 == 0 {\n        return length / 2\n    } else {\n        return\
    \ length / 2 + 1\n    }\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__1\
    \ (0.00s)\n        tmpt23zwecw_test.go:48: expected '%!s(int=1)', got '%!s(int=4)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__2 (0.00s)\n        tmpt23zwecw_test.go:48:\
    \ expected '%!s(int=1)', got '%!s(int=2)'\n    --- FAIL: TestSmallest_Change/test_num__3\
    \ (0.00s)\n        tmpt23zwecw_test.go:48: expected '%!s(int=1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__4 (0.00s)\n        tmpt23zwecw_test.go:48:\
    \ expected '%!s(int=0)', got '%!s(int=3)'\n    --- FAIL: TestSmallest_Change/test_num__5\
    \ (0.00s)\n        tmpt23zwecw_test.go:48: expected '%!s(int=0)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__6 (0.00s)\n        tmpt23zwecw_test.go:48:\
    \ expected '%!s(int=0)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075233
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    if len(arr) <= 1 {\n        return 0\n    }\n    front, back\
    \ := 0, len(arr) - 1\n    change := 0\n    for front < back {\n        if arr[front]\
    \ != arr[back] {\n            change++\n        }\n        front++\n        back--\n\
    \    }\n    return change\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075233
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    length := len(arr)\n    if length == 0 {\n        return 0\n\
    \    }\n    changes := 0\n    for i, j := 0, length - 1; i < j; i, j = i + 1,\
    \ j - 1 {\n        if arr[i] != arr[j] {\n            changes++\n        }\n \
    \   }\n    return changes\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate\
    \ := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075233
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // count changes\n    count := 0\n    // set pointers\n  \
    \  p1 := 0\n    p2 := len(arr) - 1\n    // iterate through length of list\n  \
    \  for p1 < p2 {\n        // if left pointer is smaller than right\n        if\
    \ arr[p1] < arr[p2] {\n            // increase left pointer by 1\n           \
    \ p1++\n            // increase count by 1\n            count++\n        } else\
    \ if arr[p1] > arr[p2] {\n            // decrease right pointer by 1\n       \
    \     p2--\n            // increase count by 1\n            count++\n        }\
    \ else {\n            // otherwise, if pointers are equal\n            // increase\
    \ left pointer by 1\n            p1++\n            // decrease right pointer by\
    \ 1\n            p2--\n        }\n    }\n    // return count\n    return count\n\
    }\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate := smallest_change\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}),\
    \ expected: 4 },\n     { actual: candidate([]int{1, 2, 3, 4, 3, 2, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3, 1, 1, 3}), expected:\
    \ 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n     { actual: candidate([]int{0,\
    \ 1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmpeylob9w5_test.go:69: expected '%!s(int=4)', got '%!s(int=7)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmpeylob9w5_test.go:69:\
    \ expected '%!s(int=1)', got '%!s(int=2)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmpeylob9w5_test.go:69: expected '%!s(int=1)', got '%!s(int=2)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmpeylob9w5_test.go:69:\
    \ expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075233
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    var count int = 0\n    for i, j := 0, len(arr)-1; i < j; i,\
    \ j = i+1, j-1 {\n        if arr[i] != arr[j] {\n            count++\n       \
    \ }\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.005s\n"
  timestamp: 1660075233
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n\
    \  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmprjnp2on8_test.go:42:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmprjnp2on8_test.go:42: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075049
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    count := 0\n    // run 2 pointers from both ends of the array,\
    \ count how many\n    // times the two pointers don't match\n    for i, j := 0,\
    \ len(arr)-1; i < j; i, j = i+1, j-1 {\n        if arr[i] != arr[j] {\n      \
    \      count += 1\n        }\n    }\n    return count\n}\n\nfunc TestSmallest_Change(t\
    \ *testing.T) {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{1, 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1,\
    \ 2, 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}),\
    \ expected: 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n\
    \     { actual: candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual:\
    \ candidate([]int{3, 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}),\
    \ expected: 0 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\
    \n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075233
- exit_code: 0
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    ret := 0\n    if len(arr) == 0 {\n        return ret\n   \
    \ }\n    cur := len(arr) - 1\n    for i := 0; i < len(arr) / 2; i++ {\n      \
    \  if arr[i] != arr[cur] {\n            ret++\n        }\n        cur--\n    }\n\
    \    return ret\n}\n\nfunc TestSmallest_Change(t *testing.T) {\n  candidate :=\
    \ smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2,\
    \ 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2, 3,\
    \ 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.003s\n"
  timestamp: 1660075233
- exit_code: 1
  program: "package smallest_change_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a list arr of integers, find the minimum number of elements that\n\
    // need to be changed to make the list palindromic. A palindromic list is a list\
    \ that\n// is read the same backwards and forwards. In one change, you can change\
    \ one element to any other element.\n// For example:\n// >>> smallest_change([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6})\n// 4\n// >>> smallest_change([]int{1, 2, 3, 4, 3, 2,\
    \ 2})\n// 1\n// >>> smallest_change([]int{1, 2, 3, 2, 1})\n// 0\nfunc smallest_change(arr\
    \ []int) int {\n    // TODO\n    return 0\n}\n\nfunc TestSmallest_Change(t *testing.T)\
    \ {\n  candidate := smallest_change\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1,\
    \ 2, 3, 5, 4, 7, 9, 6}), expected: 4 },\n     { actual: candidate([]int{1, 2,\
    \ 3, 4, 3, 2, 2}), expected: 1 },\n     { actual: candidate([]int{1, 4, 2}), expected:\
    \ 1 },\n     { actual: candidate([]int{1, 4, 4, 2}), expected: 1 },\n     { actual:\
    \ candidate([]int{1, 2, 3, 2, 1}), expected: 0 },\n     { actual: candidate([]int{3,\
    \ 1, 1, 3}), expected: 0 },\n     { actual: candidate([]int{1}), expected: 0 },\n\
    \     { actual: candidate([]int{0, 1}), expected: 1 },\n   }\n\n\tfor i, tc :=\
    \ range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSmallest_Change (0.00s)\n    --- FAIL: TestSmallest_Change/test_num__0\
    \ (0.00s)\n        tmptq8htfz8_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__1 (0.00s)\n        tmptq8htfz8_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__2\
    \ (0.00s)\n        tmptq8htfz8_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    \    --- FAIL: TestSmallest_Change/test_num__3 (0.00s)\n        tmptq8htfz8_test.go:43:\
    \ expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestSmallest_Change/test_num__7\
    \ (0.00s)\n        tmptq8htfz8_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075219
