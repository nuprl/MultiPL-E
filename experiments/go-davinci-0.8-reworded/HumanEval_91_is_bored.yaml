name: HumanEval_91_is_bored
language: go_test.go
prompt: "package is_bored_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ You'll be given a string of words, and your task is to count the number\n// of\
  \ boredoms. A boredom is a sentence that starts with the word \"I\".\n// Sentences\
  \ are delimited by '.', '?' or '!'.\n// For example:\n// >>> is_bored(\"Hello world\"\
  )\n// 0\n// >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\"\
  )\n// 1\nfunc is_bored(S string) int {\n"
tests: "func TestIs_Bored(t *testing.T) {\n  candidate := is_bored\n\ttype test struct\
  \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
  \     { actual: candidate(\"Hello world\"), expected: 0 },\n     { actual: candidate(\"\
  Is the sky blue?\"), expected: 0 },\n     { actual: candidate(\"I love It !\"),\
  \ expected: 1 },\n     { actual: candidate(\"bIt\"), expected: 0 },\n     { actual:\
  \ candidate(\"I feel good today. I will be productive. will kill It\"), expected:\
  \ 2 },\n     { actual: candidate(\"You and I are going for a walk\"), expected:\
  \ 0 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
  \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    sentence_start := 0\n    boredoms := 0\n    for i, c := range S\
    \ {\n        if i == 0 {\n            sentence_start = i\n        } else if c\
    \ == '.' || c == '?' || c == '!' {\n            if i > 1 && S[sentence_start]\
    \ == 'I' {\n                boredoms++\n            }\n            sentence_start\
    \ = i + 1\n        }\n    }\n    return boredoms\n}\n", "    c := 0\n    sentences\
    \ := strings.Split(S, \".\")\n    for _, s := range sentences {\n        if strings.HasPrefix(s,\
    \ \"I\") {\n            c++\n        }\n    }\n    return c\n}\n", "    return\
    \ 2\n}\n", "    bores := 0\n    for _, word := range splitWords(S) {\n       \
    \ if word == \"I\" {\n            bores += 1\n        }\n    }\n    return bores\n\
    }\n", "    boredoms := 0\n    for _, sentence := range split(S) {\n        if\
    \ starts_with_i(sentence) {\n            boredoms += 1\n        }\n    }\n   \
    \ return boredoms\n}\n", "    if len(S) == 0 {\n        return 0\n    }\n    //\
    \ This is one part of the question where we're supposed to use the \"explicit\n\
    \    // is better than implicit\" principal. This may be true but I think the\n\
    \    // solution is less readable than the one below.\n    //\n    // return S[0]\
    \ == 'I'\n    //     && (S[1] == ' ' || S[1] == '\\t' || S[1] == '\\n')\n    //\
    \     && is_bored(S[2:])\n    //\n\n    for i := 0; i < len(S); i++ {\n      \
    \  switch S[i] {\n        case '.', '?', '!':\n            if i > 0 && S[i-1]\
    \ == 'I' {\n                return 1 + is_bored(S[i+1:])\n            }\n    \
    \    }\n    }\n    return 0\n}\n", "    // Write your code here\n    return 0\n\
    }\n", "    return 0\n}\n", "    sentences := split_sentences(S)\n    count :=\
    \ 0\n    for _, sentence := range sentences {\n        words := split_words(sentence)\n\
    \        if words[0] == \"I\" {\n            count += 1\n        }\n    }\n  \
    \  return count\n}\n", "    var bored int = 0\n    for i := 0; i < len(S); i++\
    \ {\n        if S[i] == 'I' {\n            bored += 1\n        }\n    }\n    return\
    \ bored\n}\n", "    l := len(S)\n    if l < 2 {\n        return 0\n    }\n   \
    \ //char[0] is always a capital I\n    count := 0\n    for i := 1; i < l; i++\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            count++\n\
    \        }\n    }\n    return count\n}\n", "    boredoms := 0\n    c := 0\n  \
    \  for _, r := range S {\n        if c == 0 && r == 'I' {\n            boredoms\
    \ += 1\n        }\n        if r == '.' || r == '?' || r == '!' {\n           \
    \ c = 0\n        } else {\n            c += 1\n        }\n    }\n    return boredoms\n\
    }\n", "    sentences := make([]string, 0)\n    word_buffer := make([]string, 0)\n\
    \    delimiter := \" \"\n    for _, v := range S {\n        if v == '.' || v ==\
    \ '?' || v == '!' {\n            delimiter = string(v)\n            continue\n\
    \        }\n        if v == ' ' {\n            if len(word_buffer) > 0 {\n   \
    \             sentences = append(sentences, string(word_buffer))\n           \
    \     word_buffer = make([]string, 0)\n            }\n            continue\n \
    \       }\n        word_buffer = append(word_buffer, string(v))\n    }\n    if\
    \ len(word_buffer) > 0 {\n        sentences = append(sentences, string(word_buffer))\n\
    \    }\n    counter := 0\n    for _, v := range sentences {\n        if v == \"\
    I\" {\n            counter += 1\n        }\n    }\n    return counter\n}\n", " \
    \   count := 0\n    for _, r := range S {\n        if string(r) == \"I\" {\n \
    \           count++\n        }\n    }\n    return count\n}\n", "    // Your code\
    \ here\n\n    return -1\n}\n", "    return 0\n}\n", "\twords := strings.Split(S,\
    \ \" \")\n\tboredoms := 0\n\tfor _, word := range words {\n\t\tif word == \"I\"\
    \ {\n\t\t\tboredoms++\n\t\t}\n\t}\n\treturn boredoms\n}\n", "    var result int\
    \ = 0\n    words := map[string]int{\"I\": 1}\n    start := 0\n    end := len(S)\n\
    \    index := strings.IndexAny(S[start:end], \".\")\n    if index == -1 {\n  \
    \      // \u4E0D\u5305\u542B .\n        index = strings.IndexAny(S[start:end],\
    \ \"?\")\n        if index == -1 {\n            // \u4E0D\u5305\u542B ?\n    \
    \        index = strings.IndexAny(S[start:end], \"!\")\n            if index ==\
    \ -1 {\n                // \u4E0D\u5305\u542B !\n                index = len(S)\n\
    \            }\n        }\n    }\n\n    var sentence string = strings.Trim(S[start:index],\
    \ \" \")\n    fmt.Println(sentence)\n    if len(sentence) > 0 {\n        sli :=\
    \ strings.Split(sentence, \" \")\n        if len(sli) > 0 {\n            var val\
    \ int\n            var ok bool\n            if val, ok = words[sli[0]]; ok {\n\
    \                if val == 1 {\n                    result = 1\n             \
    \   }\n            }\n        }\n    }\n\n    start = index + 1\n    if start\
    \ > end {\n        return result\n    }\n\n    return result + is_bored(S[start:end])\n\
    }\n", "    s := \"\"\n    if len(S) > 1 {\n        s = S[1:]\n    }\n    return\
    \ bored(S[0:1], s)\n}\n", "    count := 0\n    if len(S) == 0 {\n        return\
    \ count\n    }\n    s := []rune(S)\n    last := ' '\n    for _, c := range s {\n\
    \        if c == 'I' && last == ' ' {\n            count++\n        }\n      \
    \  if c == '.' || c == '?' || c == '!' {\n            last = ' '\n        } else\
    \ {\n            last = c\n        }\n    }\n    return count\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
