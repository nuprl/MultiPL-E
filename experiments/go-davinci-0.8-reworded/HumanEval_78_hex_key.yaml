name: HumanEval_78_hex_key
language: go_test.go
prompt: "package hex_key_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You\
  \ have been tasked to write a function that receives \n// a hexadecimal number as\
  \ a string and counts the number of hexadecimal \n// digits that are primes (prime\
  \ number, or a prime, is a natural number \n// greater than 1 that is not a product\
  \ of two smaller natural numbers).\n// Hexadecimal digits are 0, 1, 2, 3, 4, 5,\
  \ 6, 7, 8, 9, A, B, C, D, E, F.\n// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n\
  // So you have to determine a number of the following digits: 2, 3, 5, 7, \n// B\
  \ (=decimal 11), D (=decimal 13).\n// Note: you may assume the input is always correct\
  \ or empty string, \n// and symbols A,B,C,D,E,F are always uppercase.\n// Examples:\n\
  // >>> hex_key(\"AB\")\n// 1\n// >>> hex_key(\"1077E\")\n// 2\n// >>> hex_key(\"\
  ABED1A33\")\n// 4\n// >>> hex_key(\"123456789ABCDEF0\")\n// 6\n// >>> hex_key(\"\
  2020\")\n// 2\nfunc hex_key(num string) int {\n"
tests: "func TestHex_Key(t *testing.T) {\n  candidate := hex_key\n\ttype test struct\
  \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
  \     { actual: candidate(\"AB\"), expected: 1 },\n     { actual: candidate(\"1077E\"\
  ), expected: 2 },\n     { actual: candidate(\"ABED1A33\"), expected: 4 },\n    \
  \ { actual: candidate(\"2020\"), expected: 2 },\n     { actual: candidate(\"123456789ABCDEF0\"\
  ), expected: 6 },\n     { actual: candidate(\"112233445566778899AABBCCDDEEFF00\"\
  ), expected: 12 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    count := 0\n    for _, d := range num {\n        switch d {\n \
    \       case '2':\n            count++\n        case '3':\n            count++\n\
    \        case '5':\n            count++\n        case '7':\n            count++\n\
    \        case 'B':\n            count++\n        case 'D':\n            count++\n\
    \        }\n    }\n    return count\n}\n", "    r := 0\n    for _,ch := range(num)\
    \ {\n        if ch == '2' || ch == '3' || ch == '5' || ch == '7' || ch == 'B'\
    \ || ch == 'D' {\n            r++\n        }\n    }\n    return r\n}\n", "   \
    \ count := 0\n    for _, char := range num {\n        if char == '2' || char ==\
    \ '3' || char == '5' || char == '7' || char == 'B' || char == 'D' {\n        \
    \    count++\n        }\n    }\n    return count\n}\n", "    var counter int\n\
    \    primes := []string{\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"}\n    for _,\
    \ i := range primes {\n        for _, j := range num {\n            if string(j)\
    \ == i {\n                counter++\n            }\n        }\n    }\n    return\
    \ counter\n}\n", "    return 0\n}\n", "    primes := map[rune]bool{'2': true,\
    \ '3': true, '5': true, '7': true, 'B': true, 'D': true}\n    counter := 0\n \
    \   for _, char := range num {\n        if _, ok := primes[char]; ok {\n     \
    \       counter++\n        }\n    }\n    return counter\n}\n", "    prims := []string{\"\
    2\", \"3\", \"5\", \"7\", \"B\", \"D\"}\n    count := 0\n    for _, v := range\
    \ num {\n        for _, p := range prims {\n            if v == rune(p[0]) {\n\
    \                count += 1\n            }\n        }\n    }\n    return count\n\
    }\n", "    hex := map[string]bool{\n        \"2\": true,\n        \"3\": true,\n\
    \        \"5\": true,\n        \"7\": true,\n        \"B\": true,\n        \"\
    D\": true,\n    }\n    count := 0\n    for _, char := range num {\n        if\
    \ _, ok := hex[string(char)]; ok {\n            count++\n        }\n    }\n  \
    \  return count\n}\n", "    var sum int = 0\n    for _, v := range num {\n   \
    \     if v == '2' || v == '3' || v == '5' || v == '7' || v == 'B' || v == 'D'\
    \ {\n            sum++\n        }\n    }\n    return sum\n}\n", "    var hexDigits\
    \ = map[rune]int{\n        '0': 0,\n        '1': 1,\n        '2': 2,\n       \
    \ '3': 3,\n        '4': 4,\n        '5': 5,\n        '6': 6,\n        '7': 7,\n\
    \        '8': 8,\n        '9': 9,\n        'A': 10,\n        'B': 11,\n      \
    \  'C': 12,\n        'D': 13,\n        'E': 14,\n        'F': 15,\n    }\n   \
    \ primes := []int{2, 3, 5, 7, 11, 13}\n    count := 0\n    for _, c := range num\
    \ {\n        if _, ok := hexDigits[c]; ok {\n            if contains(primes, hexDigits[c])\
    \ {\n                count++\n            }\n        }\n    }\n    return count\n\
    }\n", "    primes := []string{\"2\", \"3\", \"5\", \"7\", \"B\", \"D\"}\n    nums\
    \ := []string{\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"\
    9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"}\n    count := 0\n    for _, s :=\
    \ range num {\n        for i, p := range primes {\n            if s == rune(p[0])\
    \ {\n                count += 1\n                primes = append(primes[:i], primes[i+1:]...)\n\
    \                break\n            }\n        }\n        for i, n := range nums\
    \ {\n            if s == rune(n[0]) {\n                nums = append(nums[:i],\
    \ nums[i+1:]...)\n                break\n            }\n        }\n    }\n   \
    \ return count\n}\n", "    var m = make(map[string]int)\n    m[\"0\"] = 0\n  \
    \  m[\"1\"] = 1\n    m[\"2\"] = 2\n    m[\"3\"] = 3\n    m[\"4\"] = 4\n    m[\"\
    5\"] = 5\n    m[\"6\"] = 6\n    m[\"7\"] = 7\n    m[\"8\"] = 8\n    m[\"9\"] =\
    \ 9\n    m[\"A\"] = 10\n    m[\"B\"] = 11\n    m[\"C\"] = 12\n    m[\"D\"] = 13\n\
    \    m[\"E\"] = 14\n    m[\"F\"] = 15\n    var primes = []int{2, 3, 5, 7, 11,\
    \ 13}\n    var sum = 0\n    for _, d := range num {\n        var i = m[string(d)]\n\
    \        if i == 2 || i == 3 || i == 5 || i == 7 || i == 11 || i == 13 {\n   \
    \         sum++\n        }\n    }\n    return sum\n}\n", "    count := 0\n   \
    \ for _, v := range num {\n        ch := string(v)\n        if ch == \"2\" ||\
    \ ch == \"3\" || ch == \"5\" || ch == \"7\" || ch == \"B\" || ch == \"D\" {\n\
    \            count++\n        }\n    }\n    return count\n}\n", "    primes :=\
    \ map[string]bool{\"2\": true, \"3\": true, \"5\": true, \"7\": true, \"B\": true,\
    \ \"D\": true}\n    var res int\n    for _, val := range num {\n        if _,\
    \ ok := primes[string(val)]; ok {\n            res++\n        }\n    }\n    return\
    \ res\n}\n", "    var keys = map[byte]bool{\n        '2': true, '3': true, '5':\
    \ true, '7': true, 'B': true, 'D': true,\n    }\n    var primes int\n    for i\
    \ := 0; i < len(num); i++ {\n        if keys[num[i]] {\n            primes++\n\
    \        }\n    }\n    return primes\n}\n", "    primes := []string{\"2\", \"\
    3\", \"5\", \"7\", \"B\", \"D\"}\n    counter := 0\n    for _, val := range num\
    \ {\n        for _, prime := range primes {\n            if string(val) == prime\
    \ {\n                counter++\n            }\n        }\n    }\n    return counter\n\
    }\n", "    var count int = 0\n    for _, element := range num {\n        switch\
    \ element {\n            case '2':\n                count++\n            case\
    \ '3':\n                count++\n            case '5':\n                count++\n\
    \            case '7':\n                count++\n            case 'B':\n     \
    \           count++\n            case 'D':\n                count++\n        }\n\
    \    }\n    return count\n}\n", "\tvar num_int int\n\tvar result int\n\n\tfor\
    \ _, element := range num {\n\t\tif (element >= '0' && element <= '9') {\n\t\t\
    \tnum_int = int(element) - 48\n\t\t} else {\n\t\t\tnum_int = int(element) - 55\n\
    \t\t}\n\n\t\tif (num_int == 2 || num_int == 3 || num_int == 5 || \n\t\t\tnum_int\
    \ == 7 || num_int == 11 || num_int == 13) {\n\t\t\tresult++\n\t\t}\n\t}\n\n\t\
    return result\n}\n", "    var total int\n    if num == \"\" {\n        return\
    \ 0\n    }\n    for _, char := range num {\n        if char == '2' || char ==\
    \ '3' || char == '5' || char == '7' || char == 'B' || char == 'D' {\n        \
    \    total++\n        }\n    }\n    return total\n}\n", "    var count int\n \
    \   for _, n := range num {\n        if n == '2' || n == '3' || n == '5' || n\
    \ == '7' || n == 'B' || n == 'D' {\n            count++\n        }\n    }\n  \
    \  return count\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
