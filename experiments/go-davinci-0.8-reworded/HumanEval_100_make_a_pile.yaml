name: HumanEval_100_make_a_pile
language: go_test.go
prompt: "package make_a_pile_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // Given a positive integer n, you have to make a pile of n levels of stones.\n\
  // The first level has n stones.\n// The number of stones in the next level is:\n\
  // - the next odd number if n is odd.\n// - the next even number if n is even.\n\
  // Return the number of stones in each level in a list, where element at index\n\
  // i represents the number of stones in the level (i+1).\n// Examples:\n// >>> make_a_pile(3)\n\
  // []int{3, 5, 7}\nfunc make_a_pile(n int) []int {\n"
tests: "func TestMake_A_Pile(t *testing.T) {\n  candidate := make_a_pile\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate(3), expected: []int{3, 5, 7} },\n     { actual:\
  \ candidate(4), expected: []int{4, 6, 8, 10} },\n     { actual: candidate(5), expected:\
  \ []int{5, 7, 9, 11, 13} },\n     { actual: candidate(6), expected: []int{6, 8,\
  \ 10, 12, 14, 16} },\n     { actual: candidate(8), expected: []int{8, 10, 12, 14,\
  \ 16, 18, 20, 22} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    var out []int\n    for i := 0; i < n; i++ {\n        if i == 0\
    \ {\n            out = append(out, n)\n        } else {\n            last := out[i-1]\n\
    \            if last % 2 == 0 {\n                out = append(out, last + 1)\n\
    \            } else {\n                out = append(out, last + 2)\n         \
    \   }\n        }\n    }\n    return out\n}\n", "    level := make([]int, n)\n\
    \    for i := 0; i < n; i++ {\n        level[i] = n + i * 2\n    }\n    return\
    \ level\n}\n", "    res := make([]int, n)\n    for i := 0; i < n; i++ {\n    \
    \    res[i] = n + 2*i\n    }\n    return res\n}\n", "    if n == 0 {\n       \
    \ return []int{}\n    }\n    p := make([]int, n)\n    for i := 0; i < n; i++ {\n\
    \        p[i] = n + 2*i\n    }\n    return p\n}\n", "    result := make([]int,\
    \ n)\n    for i := 0; i < n; i++ {\n        if i == 0 {\n            result[i]\
    \ = n\n        } else {\n            if result[i-1] % 2 == 0 {\n             \
    \   result[i] = result[i-1] + 1\n            } else {\n                result[i]\
    \ = result[i-1] + 2\n            }\n        }\n    }\n    return result\n}\n",
  "    var slice []int\n    counter := n\n    for {\n        slice = append(slice,\
    \ counter)\n        if counter == n {\n            counter = n + 1\n        }\
    \ else if counter % 2 == 0 {\n            counter = counter + 2\n        } else\
    \ {\n            counter = counter + 1\n        }\n        if counter > n * 2\
    \ {\n            break\n        }\n    }\n    return slice\n}\n", "    pile :=\
    \ make([]int, n)\n    pile[0] = n\n    if n % 2 == 0 {\n        for i := 1; i\
    \ < n; i++ {\n            pile[i] = pile[i-1] + 2\n        }\n    } else {\n \
    \       for i := 1; i < n; i++ {\n            pile[i] = pile[i-1] + 1\n      \
    \  }\n    }\n    return pile\n}\n", "    pile := make([]int, n)\n    pile[0] =\
    \ n\n    for i := 1; i < n; i++ {\n        if pile[i-1] % 2 == 0 {\n         \
    \   pile[i] = pile[i-1] + 1\n        } else {\n            pile[i] = pile[i-1]\
    \ + 2\n        }\n    }\n    return pile\n}\n", "    r := make([]int, n)\n   \
    \ for i := 0; i < n; i++ {\n        r[i] = n + i * 2\n    }\n    return r\n}\n",
  "    var list []int\n    for i := n; i > 0; i-- {\n        if (i % 2 == 0) {\n \
    \           list = append(list, i + 1)\n        } else {\n            list = append(list,\
    \ i + 2)\n        }\n    }\n    return list\n}\n", "    res := make([]int, n)\n\
    \    res[0] = n\n    for i := 1; i < n; i++ {\n        if n % 2 == 0 {\n     \
    \       res[i] = res[i-1] + 2\n        } else {\n            res[i] = res[i-1]\
    \ + 1\n        }\n    }\n    return res\n}\n", "    var r []int\n    for i :=\
    \ 0; i < n; i++ {\n        if i == 0 {\n            r = append(r, n)\n       \
    \ } else {\n            r = append(r, r[i-1]+2)\n        }\n    }\n    return\
    \ r\n}\n", "    stones := make([]int, n)\n    stones[0] = n\n    for i := 1; i\
    \ < n; i++ {\n        if n%2 == 0 {\n            stones[i] = stones[i-1] + 2\n\
    \        } else {\n            stones[i] = stones[i-1] + 1\n        }\n    }\n\
    \    return stones\n}\n", "    // your code here\n    return []int{}\n}\n", " \
    \   var r []int\n    for i := n; i > 0; i = i-2 {\n        r = append(r, i)\n\
    \    }\n    return r\n}\n", "    // Write your code here\n    return []int{}\n\
    }\n", "    if n < 1 {\n        return []int{}\n    }\n    pile := []int{n}\n \
    \   for n > 1 {\n        if n % 2 == 0 {\n            n = n + 1\n        } else\
    \ {\n            n = n + 2\n        }\n        pile = append(pile, n)\n    }\n\
    \    return pile\n}\n", "    if n < 1 {\n        return nil\n    }\n    arr :=\
    \ make([]int, n)\n    arr[0] = n\n    for i := 1; i < n; i++ {\n        if arr[i-1]\
    \ % 2 == 0 {\n            arr[i] = arr[i-1] + 1\n        } else {\n          \
    \  arr[i] = arr[i-1] + 2\n        }\n    }\n    return arr\n}\n", "    s := make([]int,\
    \ n)\n    s[0] = n\n    for i := 1; i < n; i++ {\n        if s[i-1] % 2 == 0 {\n\
    \            s[i] = s[i-1] + 1\n        } else {\n            s[i] = s[i-1] +\
    \ 2\n        }\n    }\n    return s\n}\n", "    res := make([]int, n)\n    res[0]\
    \ = n\n    for i := 1; i < n; i++ {\n        res[i] = res[i-1] + 2\n    }\n  \
    \  return res\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
