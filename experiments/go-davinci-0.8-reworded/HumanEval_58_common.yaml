name: HumanEval_58_common
language: go_test.go
prompt: "package common_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Return\
  \ sorted unique common elements for two lists.\n// >>> common([]int{1, 4, 3, 34,\
  \ 653, 2, 5}, []int{5, 7, 1, 5, 9, 653, 121})\n// []int{1, 5, 653}\n// >>> common([]int{5,\
  \ 3, 2, 8}, []int{3, 2})\n// []int{2, 3}\nfunc common(l1 []int, l2 []int) []int\
  \ {\n"
tests: "func TestCommon(t *testing.T) {\n  candidate := common\n\ttype test struct\
  \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
  \     { actual: candidate([]int{1, 4, 3, 34, 653, 2, 5}, []int{5, 7, 1, 5, 9, 653,\
  \ 121}), expected: []int{1, 5, 653} },\n     { actual: candidate([]int{5, 3, 2,\
  \ 8}, []int{3, 2}), expected: []int{2, 3} },\n     { actual: candidate([]int{4,\
  \ 3, 2, 8}, []int{3, 2, 4}), expected: []int{2, 3, 4} },\n     { actual: candidate([]int{4,\
  \ 3, 2, 8}, []int{}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\
  \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
  %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
  \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    m := make(map[int]bool)\n    out := make([]int, 0)\n\n    for _,\
    \ e := range l1 {\n        m[e] = true\n    }\n\n    for _, e := range l2 {\n\
    \        if m[e] {\n            out = append(out, e)\n        }\n    }\n\n   \
    \ return out\n}\n", "    var result []int\n    for _, v1 := range l1 {\n     \
    \   for _, v2 := range l2 {\n            if v1 == v2 {\n                // check\
    \ if element already exists in result\n                elementExists := false\n\
    \                for _, v := range result {\n                    if v == v1 {\n\
    \                        elementExists = true\n                        break\n\
    \                    }\n                }\n                if !elementExists {\n\
    \                    result = append(result, v1)\n                }\n        \
    \    }\n        }\n    }\n    // sort.Ints(result)\n    fmt.Println(result)\n\
    \    return result\n}\n", "    set := make(map[int]int)\n    for _, item := range\
    \ l1 {\n        set[item] = item\n    }\n    result := make([]int, 0)\n    for\
    \ _, item := range l2 {\n        if _, ok := set[item]; ok {\n            result\
    \ = append(result, item)\n        }\n    }\n    return result\n}\n", "    res\
    \ := []int{}\n    ml1 := make(map[int]int)\n    ml2 := make(map[int]int)\n   \
    \ for _, elem := range l1 {\n        ml1[elem] = elem\n    }\n    for _, elem\
    \ := range l2 {\n        ml2[elem] = elem\n    }\n    for key, _ := range ml1\
    \ {\n        if _, ok := ml2[key]; ok {\n            res = append(res, key)\n\
    \        }\n    }\n    return res\n}\n", "    m := make(map[int]bool)\n    for\
    \ _, val := range l1 {\n        m[val] = true\n    }\n    res := make([]int, 0)\n\
    \    for _, val := range l2 {\n        if m[val] {\n            res = append(res,\
    \ val)\n        }\n    }\n    return res\n}\n", "    var r []int\n    for _, i\
    \ := range l1 {\n        for _, j := range l2 {\n            if i == j {\n   \
    \             r = append(r, i)\n            }\n        }\n    }\n    return r\n\
    }\n", "    m := make(map[int]bool)\n    ret := make([]int, 0)\n    for _, v :=\
    \ range l1 {\n        m[v] = true\n    }\n    for _, v := range l2 {\n       \
    \ if m[v] {\n            ret = append(ret, v)\n        }\n    }\n    return ret\n\
    }\n", "    map1 := make(map[int]bool)\n    map2 := make(map[int]bool)\n    map3\
    \ := make(map[int]bool)\n    var ret []int\n    for _, n := range l1 {\n     \
    \   map1[n] = true\n    }\n    for _, n := range l2 {\n        map2[n] = true\n\
    \    }\n    for k, _ := range map1 {\n        if map2[k] {\n            map3[k]\
    \ = true\n        }\n    }\n    for k, _ := range map3 {\n        ret = append(ret,\
    \ k)\n    }\n    return ret\n}\n", "    output := []int{}\n    longer, shorter\
    \ := l1, l2\n    if len(l1) < len(l2) {\n        longer, shorter = l2, l1\n  \
    \  }\n    sortedLonger := mergeSort(longer)\n    sortedShorter := mergeSort(shorter)\n\
    \    seen := map[int]bool{}\n    for _, v := range sortedShorter {\n        if\
    \ i := binarySearch(sortedLonger, v); i != -1 {\n            if !seen[i] {\n \
    \               output = append(output, sortedLonger[i])\n                seen[i]\
    \ = true\n            }\n        }\n    }\n    return output\n}\n", "    var res\
    \ []int\n    m := make(map[int]bool)\n    for _, v := range l1 {\n        m[v]\
    \ = true\n    }\n    for _, v := range l2 {\n        if m[v] {\n            res\
    \ = append(res, v)\n        }\n    }\n    return res\n}\n", "    if len(l1) ==\
    \ 0 || len(l2) == 0 {\n        return []int{}\n    }\n    if len(l1) == 1 {\n\
    \        if len(l2) == 1 {\n            if l1[0] == l2[0] {\n                return\
    \ l1\n            }\n            return []int{}\n        }\n        return common(l2,\
    \ l1)\n    }\n    if len(l2) == 1 {\n        var ret []int\n        for _, i :=\
    \ range l1 {\n            if i == l2[0] {\n                ret = append(ret, i)\n\
    \            }\n        }\n        return ret\n    }\n    // len(l1) > 1 && len(l2)\
    \ > 1\n    if l1[0] == l2[0] {\n        return append([]int{l1[0]}, common(l1[1:],\
    \ l2[1:])...)\n    }\n    if l1[0] < l2[0] {\n        return common(l1[1:], l2)\n\
    \    }\n    return common(l1, l2[1:])\n}\n", "    uniqueList := []int{}\n    for\
    \ i, _ := range l1 {\n        for j, _ := range l2 {\n            if l1[i] ==\
    \ l2[j] {\n                if !contains(uniqueList, l1[i]) {\n               \
    \     uniqueList = append(uniqueList, l1[i])\n                }\n            }\n\
    \        }\n    }\n    return uniqueList\n}\n", "    l3 := []int{}\n    for _,\
    \ i := range l1 {\n        if is_in(i, l2) {\n            l3 = append(l3, i)\n\
    \        }\n    }\n    return l3\n}\n", "    var common []int\n    var l2_map\
    \ = make(map[int]int)\n    for _, e := range l2 {\n        l2_map[e] = e\n   \
    \ }\n    for _, e := range l1 {\n        if l2_map[e] > 0 {\n            common\
    \ = append(common, e)\n        }\n    }\n    return common\n}\n", "    // TODO:\
    \ Implementation.\n    // return []int{}\n    return common2(l1, l2)\n}\n", " \
    \   // first sort both lists in increasing order\n    SortInts(l1)\n    SortInts(l2)\n\
    \    // result list\n    var r []int\n    // pointers\n    i1 := 0\n    i2 :=\
    \ 0\n    // loop through both lists\n    for (i1 < len(l1)) && (i2 < len(l2))\
    \ {\n        n1 := l1[i1]\n        n2 := l2[i2]\n        // if n1 is smaller add\
    \ n1 to the result\n        if n1 < n2 {\n            i1++\n        } else if\
    \ n1 > n2 {\n            i2++\n        } else {\n            // add common element\
    \ to the result\n            r = append(r, n1)\n            // move both pointers\n\
    \            i1++\n            i2++\n        }\n    }\n    return r\n}\n", " \
    \   // your code here\n    return []int{}\n}\n", "    var intersection []int\n\
    \    var m = make(map[int]int)\n    for _, v := range l1 {\n        m[v]++\n \
    \   }\n    for _, v := range l2 {\n        if m[v] > 0 {\n            intersection\
    \ = append(intersection, v)\n            m[v] = 0\n        }\n    }\n    return\
    \ intersection\n}\n", "    res := []int{}\n    h := make(map[int]int)\n    for\
    \ _, val := range l1 {\n        h[val]++\n    }\n    for _, val := range l2 {\n\
    \        if _, ok := h[val]; ok {\n            res = append(res, val)\n      \
    \  }\n    }\n    return res\n}\n", "    m := make(map[int]bool)\n    for _, v\
    \ := range l1 {\n        m[v] = true\n    }\n    res := make([]int, 0)\n    for\
    \ _, v := range l2 {\n        if m[v] {\n            res = append(res, v)\n  \
    \      }\n    }\n    return res\n}\n", "    // return []int{}\n    return []int{}\n\
    }\n", "    if len(l1) < len(l2) {\n        return common(l2, l1)\n    }\n    //\
    \ Map for quick look up for common elements.\n    // Python: {key:value for value\
    \ in l2}\n    m := make(map[int]bool)\n    for _, v := range l2 {\n        m[v]\
    \ = true\n    }\n    // List for sorting.\n    r := make([]int, 0)\n    for _,\
    \ v := range l1 {\n        if m[v] {\n            r = append(r, v)\n        }\n\
    \    }\n    return r\n}\n", "    return nil\n}\n", "    s := make(map[int]bool)\n\
    \    r := make([]int, 0)\n    for _, i := range l1 {\n        s[i] = true\n  \
    \  }\n    for _, i := range l2 {\n        if s[i] {\n            r = append(r,\
    \ i)\n        }\n    }\n    return r\n}\n", "    var res []int\n    for _, v1\
    \ := range l1 {\n        for _, v2 := range l2 {\n            if v1 == v2 {\n\
    \                res = append(res, v1)\n            }\n        }\n    }\n    return\
    \ res\n}\n", "    res := []int{}\n    m := map[int]int{}\n    for _, n := range\
    \ l1 {\n        m[n]++\n    }\n    for _, n := range l2 {\n        if m[n] > 0\
    \ {\n            res = append(res, n)\n            m[n] = 0\n        }\n    }\n\
    \    return res\n}\n", "    m := make(map[int]bool)\n    for _, v := range l1\
    \ {\n        m[v] = true\n    }\n    for _, v := range l2 {\n        m[v] = true\n\
    \    }\n    r := make([]int, 0, len(m))\n    for k, _ := range m {\n        r\
    \ = append(r, k)\n    }\n    return r\n}\n", "    m := make(map[int]int)\n   \
    \ for _, v := range l1 {\n        m[v]++\n    }\n    for _, v := range l2 {\n\
    \        m[v]++\n    }\n    var res []int\n    for k, v := range m {\n       \
    \ if v > 1 {\n            res = append(res, k)\n        }\n    }\n    return res\n\
    }\n", "    l := make([]int, 0)\n    set := make(map[int]bool)\n    for _, num\
    \ := range l1 {\n        set[num] = true\n    }\n    for _, num := range l2 {\n\
    \        if set[num] {\n            l = append(l, num)\n        }\n    }\n   \
    \ return l\n}\n", "    m := make(map[int]int)\n    result := make([]int, 0)\n\
    \    for _, n := range l1 {\n        m[n]++\n    }\n    for _, n := range l2 {\n\
    \        if v, ok := m[n]; ok && v > 0 {\n            result = append(result,\
    \ n)\n            m[n]--\n        }\n    }\n    return result\n}\n", "    var\
    \ ret []int\n\n    for _, n1 := range l1 {\n        for _, n2 := range l2 {\n\
    \            if n1 == n2 {\n                ret = append(ret, n1)\n          \
    \  }\n        }\n    }\n\n    return ret\n}\n", '    set1 := make(map[int]', " \
    \   m := make(map[int]int)\n    ret := make([]int, 0)\n    for _, v := range l1\
    \ {\n        m[v]++\n    }\n    for _, v := range l2 {\n        if c, ok := m[v];\
    \ ok && c > 0 {\n            ret = append(ret, v)\n            m[v]--\n      \
    \  }\n    }\n    return ret\n}\n", "    l3 := []int{}\n    for i := 0; i < len(l1);\
    \ i++ {\n        for j := 0; j < len(l2); j++ {\n            if l1[i] == l2[j]\
    \ {\n                if l3 == nil {\n                    l3 = append(l3, l1[i])\n\
    \                } else {\n                    exists := false\n             \
    \       for k := 0; k < len(l3); k++ {\n                        if l3[k] == l1[i]\
    \ {\n                            exists = true\n                            break\n\
    \                        }\n                    }\n                    if !exists\
    \ {\n                        l3 = append(l3, l1[i])\n                    }\n \
    \               }\n            }\n        }\n    }\n    return l3\n}\n", "   \
    \ return []int{}\n}\n", "    fmt.Println(l1, l2)\n    return []int{}\n}\n", " \
    \   return []int{}\n}\n", "    var result []int\n    m := make(map[int]bool)\n\
    \    for _, num := range l1 {\n        m[num] = true\n    }\n    for _, num :=\
    \ range l2 {\n        if m[num] {\n            result = append(result, num)\n\
    \        }\n    }\n    return result\n}\n", "    result := []int{}\n    hash :=\
    \ make(map[int]bool)\n    for _, item := range l1 {\n        hash[item] = true\n\
    \    }\n    for _, item := range l2 {\n        if hash[item] {\n            result\
    \ = append(result, item)\n        }\n    }\n    return result\n}\n", "    m :=\
    \ make(map[int]bool)\n    common := make([]int, 0)\n    for _, n := range l1 {\n\
    \        m[n] = true\n    }\n    for _, n := range l2 {\n        if m[n] {\n \
    \           common = append(common, n)\n        }\n    }\n    return common\n\
    }\n", "    lst := make([]int, 0)\n    for i := 0; i < len(l1); i++ {\n       \
    \ for j := 0; j < len(l2); j++ {\n            if l1[i] == l2[j] {\n          \
    \      lst = append(lst, l1[i])\n            }\n        }\n    }\n    return lst\n\
    }\n", "    results := []int{}\n    l1_len := len(l1)\n    l2_len := len(l2)\n\
    \    l1_max := l1_len - 1\n    l2_max := l2_len - 1\n    if l1_len == 0 || l2_len\
    \ == 0 {\n        return results\n    }\n\n    if l1_len <= l2_len {\n       \
    \ l1_max, l2_max = l2_max, l1_max\n        l1, l2 = l2, l1\n    }\n\n    for i\
    \ := 0; i <= l1_max; i++ {\n        for j := 0; j <= l2_max; j++ {\n         \
    \   if l1[i] == l2[j] {\n                results = append(results, l1[i])\n  \
    \              break\n            }\n        }\n    }\n    return results\n}\n",
  "    var m = make(map[int]int)\n    var result []int\n    for _, val := range l1\
    \ {\n        if val == 0 {\n            continue\n        }\n        m[val]++\n\
    \    }\n    for _, val := range l2 {\n        if val == 0 {\n            continue\n\
    \        }\n        m[val]++\n    }\n    for key, val := range m {\n        if\
    \ val == 2 {\n            result = append(result, key)\n        }\n    }\n   \
    \ return result\n}\n", "    lmap := make(map[int]int)\n    result := make([]int,\
    \ 0)\n    for _, val := range l1 {\n        lmap[val] = 1\n    }\n    for _, val\
    \ := range l2 {\n        if lmap[val] == 1 {\n            result = append(result,\
    \ val)\n            lmap[val] = 2\n        }\n    }\n    return result\n}\n",
  "    sort.Ints(l1)\n    sort.Ints(l2)\n    i := 0\n    j := 0\n    var result []int\n\
    \    for i < len(l1) && j < len(l2) {\n        if l1[i] == l2[j] {\n         \
    \   result = append(result, l1[i])\n            i += 1\n            j += 1\n \
    \       } else if l1[i] < l2[j] {\n            i += 1\n        } else {\n    \
    \        j += 1\n        }\n    }\n    return result\n}\n", "    var result []int\n\
    \    seen := make(map[int]bool)\n    for _, l := range l1 {\n        seen[l] =\
    \ true\n    }\n    for _, l := range l2 {\n        if seen[l] {\n            result\
    \ = append(result, l)\n        }\n    }\n    return result\n}\n", '    uniques
    := make(map[int]', "    m := make(map[int]int)\n    for _, v := range l1 {\n \
    \       m[v]++\n    }\n    for _, v := range l2 {\n        m[v]++\n    }\n   \
    \ result := make([]int, 0)\n    for k, v := range m {\n        if v > 1 {\n  \
    \          result = append(result, k)\n        }\n    }\n    return result\n}\n",
  "    var i, j int\n    var r []int\n    for i < len(l1) && j < len(l2) {\n     \
    \   if l1[i] < l2[j] {\n            i++\n        } else if l1[i] > l2[j] {\n \
    \           j++\n        } else {\n            if len(r) == 0 || r[len(r)-1] !=\
    \ l1[i] {\n                r = append(r, l1[i])\n            }\n            i++\n\
    \            j++\n        }\n    }\n    return r\n}\n", "    m := make(map[int]bool)\n\
    \    res := make([]int, 0)\n\n    // O(N)\n    for _, n := range l1 {\n      \
    \  m[n] = true\n    }\n\n    // O(N)\n    for _, n := range l2 {\n        if _,\
    \ ok := m[n]; ok {\n            res = append(res, n)\n        }\n    }\n\n   \
    \ return res\n}\n", "    var result []int\n    var m = make(map[int]", "    var\
    \ results []int\n    i, j := 0, 0\n    for ; i < len(l1) && j < len(l2); {\n \
    \       if l1[i] == l2[j] {\n            if len(results) == 0 || results[len(results)-1]\
    \ != l1[i] {\n                results = append(results, l1[i])\n            }\n\
    \            i++\n            j++\n        } else if l1[i] < l2[j] {\n       \
    \     i++\n        } else {\n            j++\n        }\n    }\n    return results\n\
    }\n", "    if len(l1) > len(l2) {\n        return common(l2, l1)\n    }\n    var\
    \ result []int\n    for _, i := range l1 {\n        for _, j := range l2 {\n \
    \           if i == j {\n                result = append(result, i)\n        \
    \    }\n        }\n    }\n    return result\n}\n", "    m := make(map[int]bool)\n\
    \    for _, v := range l1 {\n        m[v] = true\n    }\n    var ret []int\n \
    \   for _, v := range l2 {\n        if m[v] {\n            ret = append(ret, v)\n\
    \        }\n    }\n    return ret\n}\n", '    var u = make(map[int]', "    ch\
    \ := make(chan int)\n    go func() {\n        for _, v := range l1 {\n       \
    \     ch <- v\n        }\n        close(ch)\n    }()\n    mp := make(map[int]bool)\n\
    \    for _, v := range l2 {\n        mp[v] = true\n    }\n    ret := make([]int,\
    \ 0)\n    for v := range ch {\n        if mp[v] {\n            ret = append(ret,\
    \ v)\n        }\n    }\n    return ret\n}\n", "    values := make(map[int]bool)\n\
    \    for _, v := range l1 {\n        values[v] = true\n    }\n    result := make([]int,\
    \ 0)\n    for _, v := range l2 {\n        if values[v] {\n            result =\
    \ append(result, v)\n        }\n    }\n    return result\n}\n", "    res := []int{}\n\
    \    if l1 == nil || l2 == nil {\n        return res\n    }\n    m := make(map[int]bool)\n\
    \    for _, v := range l1 {\n        m[v] = true\n    }\n    for _, v := range\
    \ l2 {\n        if m[v] {\n            res = append(res, v)\n        }\n    }\n\
    \    return res\n}\n", "    var l []int\n    for _, v1 := range l1 {\n       \
    \ for _, v2 := range l2 {\n            if v1 == v2 {\n                l = append(l,\
    \ v1)\n            }\n        }\n    }\n    return l\n}\n", "    var nums []int\n\
    \    m := make(map[int]bool)\n    for _, x := range l1 {\n        m[x] = true\n\
    \    }\n    for _, x := range l2 {\n        if m[x] {\n            nums = append(nums,\
    \ x)\n        }\n    }\n    return nums\n}\n", "    var m map[int]int\n    m =\
    \ make(map[int]int)\n    var res []int\n    for _, v := range l1 {\n        m[v]++\n\
    \    }\n    for _, v := range l2 {\n        if m[v] != 0 {\n            res =\
    \ append(res, v)\n            m[v] = 0\n        }\n    }\n    return res\n}\n",
  "    // Create a map of the first slice.\n    m := make(map[int]int)\n    for _,\
    \ v := range l1 {\n        m[v] = 1\n    }\n\n    // Store the common elements\
    \ in a set.\n    var out = make(map[int]int)\n    for _, v := range l2 {\n   \
    \     if _, ok := m[v]; ok {\n            out[v] = 1\n        }\n    }\n\n   \
    \ // Sort the unique elements and return the slice.\n    var keys []int\n    for\
    \ k := range out {\n        keys = append(keys, k)\n    }\n    // TODO: sort.\n\
    \    return keys\n}\n", "    var res []int\n    m := make(map[int]int)\n    for\
    \ _, v := range l1 {\n        m[v] = 1\n    }\n    for _, v := range l2 {\n  \
    \      if m[v] == 1 {\n            res = append(res, v)\n            m[v]++\n\
    \        }\n    }\n    return res\n}\n", "    // Collect counters for each element\
    \ in the first list.\n    m := make(map[int]int)\n    for _, v := range l1 {\n\
    \        m[v] += 1\n    }\n\n    // Collect common elements from the second list.\n\
    \    var result []int\n    for _, v := range l2 {\n        if m[v] > 0 {\n   \
    \         result = append(result, v)\n            m[v] -= 1\n        }\n    }\n\
    \n    return result\n}\n", "    result := []int{}\n    m := make(map[int]int)\n\
    \    for _, v := range l1 {\n        m[v] = 1\n    }\n    for _, v := range l2\
    \ {\n        if val, ok := m[v]; ok && val == 1 {\n            result = append(result,\
    \ v)\n            m[v] = m[v] + 1\n        }\n    }\n    return result\n}\n",
  "    var common []int\n    for _, i := range l1 {\n        for _, j := range l2\
    \ {\n            if i == j {\n                common = append(common, i)\n   \
    \         }\n        }\n    }\n    return common\n}\n", "    // TODO: implement\n\
    \    return []int{}\n}\n", "    // Fill the solution slice\n    m := make(map[int]int)\n\
    \    for _, val := range l1 {\n        m[val] = 1\n    }\n    for _, val := range\
    \ l2 {\n        if _, ok := m[val]; ok {\n            m[val] = 2\n        }\n\
    \    }\n    res := make([]int, 0)\n    for key, val := range m {\n        if val\
    \ == 2 {\n            res = append(res, key)\n        }\n    }\n    return res\n\
    }\n", "    res := []int{}\n    for _, v1 := range l1 {\n        for _, v2 := range\
    \ l2 {\n            if v1 == v2 {\n                res = append(res, v1)\n   \
    \         }\n        }\n    }\n    return res\n}\n", "    var m map[int]int\n\
    \    var res []int\n    m = make(map[int]int)\n    for _, v := range l1 {\n  \
    \      m[v]++\n    }\n    for _, v := range l2 {\n        if m[v] > 0 {\n    \
    \        res = append(res, v)\n            m[v] = 0\n        }\n    }\n    return\
    \ res\n}\n", "    m := make(map[int]bool)\n    for _, v := range l1 {\n      \
    \  m[v] = true\n    }\n    for _, v := range l2 {\n        m[v] = true\n    }\n\
    \    var r []int\n    for k, _ := range m {\n        r = append(r, k)\n    }\n\
    \    return r\n}\n", "    // Using an empty map as an unordered set.\n    m :=\
    \ make(map[int]bool)\n    for _, v := range l1 {\n        m[v] = true\n    }\n\
    \    common := make([]int, 0)\n    for _, v := range l2 {\n        if m[v] {\n\
    \            common = append(common, v)\n        }\n    }\n    return common\n\
    }\n", "    return []int{}\n}\n", '    var m = make(map[int]', "    // sort lists\n\
    \    for i := 0; i < len(l1); i++ {\n        for j := i + 1; j < len(l1); j++\
    \ {\n            if l1[i] > l1[j] {\n                l1[i], l1[j] = l1[j], l1[i]\n\
    \            }\n        }\n    }\n    for i := 0; i < len(l2); i++ {\n       \
    \ for j := i + 1; j < len(l2); j++ {\n            if l2[i] > l2[j] {\n       \
    \         l2[i], l2[j] = l2[j], l2[i]\n            }\n        }\n    }\n    //\
    \ find common elements\n    var res []int\n    i, j := 0, 0\n    for i < len(l1)\
    \ && j < len(l2) {\n        if l1[i] == l2[j] {\n            res = append(res,\
    \ l1[i])\n            i, j = i + 1, j + 1\n        } else if l1[i] < l2[j] {\n\
    \            i++\n        } else {\n            j++\n        }\n    }\n    return\
    \ res\n}\n", "    var result []int\n    for _, v1 := range l1 {\n        for _,\
    \ v2 := range l2 {\n            if v1 == v2 {\n                result = append(result,\
    \ v1)\n            }\n        }\n    }\n    return result\n}\n", "    // Optimize\
    \ code by reducing size of l1 to size of l2\n    if len(l1) > len(l2) {\n    \
    \    l1, l2 = l2, l1\n    }\n    // Sort l1 and l2 in ascending order\n    sort(l1)\n\
    \    sort(l2)\n    // Process l1\n    // 1. Find the number of times each element\
    \ repeats in l1\n    elementCount := map[int]int{}\n    for _, element := range\
    \ l1 {\n        elementCount[element]++\n    }\n    // Process l2\n    // 2. Find\
    \ the elements that are common in l1 and l2\n    commonElements := map[int]int{}\n\
    \    for _, element := range l2 {\n        if elementCount[element] > 0 {\n  \
    \          commonElements[element]++\n        }\n    }\n    // 3. Sort elements\
    \ of the list\n    commonElementList := make([]int, len(commonElements))\n   \
    \ i := 0\n    for element := range commonElements {\n        commonElementList[i]\
    \ = element\n        i++\n    }\n    sort(commonElementList)\n    return commonElementList\n\
    }\n", "    l3 := make([]int, 0)\n    for _, v1 := range l1 {\n        for _, v2\
    \ := range l2 {\n            if v1 == v2 {\n                l3 = append(l3, v1)\n\
    \            }\n        }\n    }\n    return l3\n}\n", "    if len(l1) == 0 ||\
    \ len(l2) == 0 {\n        return []int{}\n    }\n    var i, j int\n    var elem\
    \ int\n    var result []int\n    for i < len(l1) && j < len(l2) {\n        if\
    \ l1[i] < l2[j] {\n            i++\n        } else if l1[i] > l2[j] {\n      \
    \      j++\n        } else {\n            elem = l1[i]\n            result = append(result,\
    \ elem)\n            i++\n            j++\n            for i < len(l1) && l1[i]\
    \ == elem {\n                i++\n            }\n            for j < len(l2) &&\
    \ l2[j] == elem {\n                j++\n            }\n        }\n    }\n    return\
    \ result\n}\n", "    s := make(map[int]bool)\n    for _, e := range l1 {\n   \
    \     s[e] = true\n    }\n    var ret []int\n    for _, e := range l2 {\n    \
    \    if s[e] {\n            ret = append(ret, e)\n        }\n    }\n    return\
    \ ret\n}\n", "    commonSet := make(map[int]int)\n    result := make([]int, 0)\n\
    \    for _, v := range l1 {\n        commonSet[v] = 1\n    }\n    for _, v :=\
    \ range l2 {\n        if _, ok := commonSet[v]; ok {\n            result = append(result,\
    \ v)\n        }\n    }\n    return result\n}\n", "    var result []int\n    for\
    \ _, v1 := range l1 {\n        for _, v2 := range l2 {\n            if v1 == v2\
    \ {\n                if !exists(result, v1) {\n                    result = append(result,\
    \ v1)\n                }\n            }\n        }\n    }\n    return result\n\
    }\n", "    // O(1) space, O(n) time\n    m := make(map[int]bool)\n    result :=\
    \ make([]int, 0)\n    for _, v := range l1 {\n        m[v] = true\n    }\n   \
    \ for _, v := range l2 {\n        if m[v] {\n            result = append(result,\
    \ v)\n            m[v] = false\n        }\n    }\n    return result\n}\n", " \
    \   var c []int\n    for _, v1 := range l1 {\n        for _, v2 := range l2 {\n\
    \            if v1 == v2 {\n                c = append(c, v1)\n            }\n\
    \        }\n    }\n    return c\n}\n", "    var result []int\n    dict := make(map[int]bool)\n\
    \    for _, n := range l1 {\n        dict[n] = true\n    }\n    for _, n := range\
    \ l2 {\n        if dict[n] {\n            result = append(result, n)\n       \
    \ }\n    }\n    return result\n}\n", "    c := []int{}\n    if len(l1) < len(l2)\
    \ {\n        l1, l2 = l2, l1\n    }\n    for _, v := range l1 {\n        if !index(l2,\
    \ v) {\n            continue\n        }\n        if !index(c, v) {\n         \
    \   c = append(c, v)\n        }\n    }\n    return c\n}\n", "    // TODO: Replace\
    \ this implementation with a correct one.\n    return nil\n}\n", "    var result\
    \ []int\n    l1_m := make(map[int]bool)\n    l2_m := make(map[int]bool)\n    for\
    \ _, v := range l1 {\n        l1_m[v] = true\n    }\n    for _, v := range l2\
    \ {\n        l2_m[v] = true\n    }\n    for k, _ := range l1_m {\n        if l2_m[k]\
    \ {\n            result = append(result, k)\n        }\n    }\n    return result\n\
    }\n", "    var res []int\n    var m = make(map[int]bool)\n    for _, i := range\
    \ l1 {\n        m[i] = true\n    }\n    for _, i := range l2 {\n        if m[i]\
    \ {\n            res = append(res, i)\n        }\n    }\n    return res\n}\n",
  "    var result []int\n    // write code here\n    return result\n}\n", "    set\
    \ := make(map[int]bool)\n    result := make([]int, 0)\n    for _, elem := range\
    \ l1 {\n        set[elem] = true\n    }\n    for _, elem := range l2 {\n     \
    \   if set[elem] {\n            result = append(result, elem)\n        }\n   \
    \ }\n    return result\n}\n", "    r := []int{}\n    // TODO: return unique common\
    \ elements.\n    return r\n}\n", "    l3 := []int{}\n    for _, v1 := range l1\
    \ {\n        for _, v2 := range l2 {\n            if v1 == v2 {\n            \
    \    l3 = append(l3, v1)\n            }\n        }\n    }\n    return l3\n}\n",
  "    // sort both lists\n    // create empty map (container of any type)\n    //\
    \ iterate over the sorted lists and\n    // store in map only the values that\
    \ are not already present\n    // finally return all keys in the map\n    return\
    \ nil\n}\n", "    // declare a map to store values of l1\n    l1Map := make(map[int]bool)\n\
    \    for _, v := range l1 {\n        l1Map[v] = true\n    }\n\n    var common\
    \ []int\n    for _, v := range l2 {\n        if l1Map[v] {\n            common\
    \ = append(common, v)\n        }\n    }\n\n    return common\n}\n", "    return\
    \ nil\n}\n", "    var a = make([]int, 0)\n    var b = make([]int, 0)\n    for\
    \ _, v := range l1 {\n        a = append(a, v)\n    }\n    for _, v := range l2\
    \ {\n        b = append(b, v)\n    }\n    a = RemoveDuplicates(a)\n    b = RemoveDuplicates(b)\n\
    \    var res = make([]int, 0)\n    for _, v := range a {\n        for _, w :=\
    \ range b {\n            if v == w {\n                res = append(res, v)\n \
    \           }\n        }\n    }\n    return res\n}\n", "    // insert your code\
    \ here\n    return nil\n}\n", "    if len(l1) == 0 || len(l2) == 0 {\n       \
    \ return []int{}\n    }\n    l1 = sort(l1)\n    l2 = sort(l2)\n    count := 0\n\
    \    for i, j := 0, 0; i < len(l1) && j < len(l2); {\n        if l1[i] == l2[j]\
    \ {\n            count++\n            i++\n            j++\n        } else if\
    \ l1[i] < l2[j] {\n            i++\n        } else {\n            j++\n      \
    \  }\n    }\n    result := make([]int, count)\n    for i, j := 0, 0; i < len(l1)\
    \ && j < len(l2); {\n        if l1[i] == l2[j] {\n            result[i+j] = l1[i]\n\
    \            i++\n            j++\n        } else if l1[i] < l2[j] {\n       \
    \     i++\n        } else {\n            j++\n        }\n    }\n    return result\n\
    }\n", "    if len(l1) == 0 || len(l2) == 0 {\n        return []int{}\n    }\n\
    \    result := []int{}\n    for _, v1 := range l1 {\n        for _, v2 := range\
    \ l2 {\n            if v1 == v2 {\n                result = append(result, v1)\n\
    \            }\n        }\n    }\n    return result\n}\n", "    m := make(map[int]int)\n\
    \    result := make([]int, 0)\n    for _, v := range l1 {\n        m[v] = v\n\
    \    }\n    for _, v := range l2 {\n        if _, ok := m[v]; ok {\n         \
    \   result = append(result, v)\n        }\n    }\n    return result\n}\n", " \
    \   uniqs := []int{}\n    for _, value := range l1 {\n        for _, value2 :=\
    \ range l2 {\n            if value == value2 {\n                uniqs = append(uniqs,\
    \ value)\n            }\n        }\n    }\n    //fmt.Println(uniqs)\n    return\
    \ removeDuplicates(uniqs)\n}\n", "    m := make(map[int]int)\n    var list []int\n\
    \    for _, i := range l1 {\n        m[i]++\n    }\n    for _, i := range l2 {\n\
    \        m[i]++\n    }\n    for k, v := range m {\n        if v > 1 {\n      \
    \      list = append(list, k)\n        }\n    }\n    return list\n}\n", "    return\
    \ nil\n}\n", "    return nil\n}\n", "    var ret []int\n    var smaller []int\n\
    \    var larger []int\n    if len(l1) <= len(l2) {\n        smaller = l1\n   \
    \     larger = l2\n    } else {\n        smaller = l2\n        larger = l1\n \
    \   }\n    m := make(map[int]int)\n    for _, value := range smaller {\n     \
    \   m[value] = 0\n    }\n    for _, value := range larger {\n        if m[value]\
    \ > 0 {\n            m[value] += 1\n        }\n    }\n    for key, value := range\
    \ m {\n        if value > 0 {\n            ret = append(ret, key)\n        }\n\
    \    }\n    return ret\n}\n", "    num_map := make(map[int]int)\n    for _, v\
    \ := range l1 {\n        num_map[v] = 1\n    }\n    for _, v := range l2 {\n \
    \       num_map[v] = num_map[v] + 1\n    }\n    result := make([]int, 0)\n   \
    \ for k, v := range num_map {\n        if v > 1 {\n            result = append(result,\
    \ k)\n        }\n    }\n    return result\n}\n", "    dict := make(map[int]int)\n\
    \    for _, val := range l1 {\n        dict[val]++\n    }\n    common_list :=\
    \ make([]int, 0)\n    for _, val := range l2 {\n        if dict[val] != 0 {\n\
    \            common_list = append(common_list, val)\n            dict[val] = 0\n\
    \        }\n    }\n    return common_list\n}\n", "    r := []int{}\n    m := map[int]int{}\n\
    \    for _, i := range l1 {\n        m[i] = 1\n    }\n    for _, i := range l2\
    \ {\n        m[i] = m[i] + 1\n    }\n    for k, v := range m {\n        if v >\
    \ 1 {\n            r = append(r, k)\n        }\n    }\n    return r\n}\n", " \
    \   m := make(map[int]int)\n    result := make([]int, 0)\n    for _, e := range\
    \ l1 {\n        if _, ok := m[e]; !ok {\n            m[e] = 1\n        } else\
    \ {\n            m[e]++\n        }\n    }\n    for _, e := range l2 {\n      \
    \  if v, ok := m[e]; ok {\n            if v == 1 {\n                delete(m,\
    \ e)\n            } else {\n                m[e]--\n            }\n          \
    \  result = append(result, e)\n        }\n    }\n    return result\n}\n", "  \
    \  return nil\n}\n", "    res := []int{}\n    m := map[int]bool{}\n    for _,\
    \ n := range l1 {\n        m[n] = true\n    }\n    for _, n := range l2 {\n  \
    \      if m[n] {\n            res = append(res, n)\n        }\n    }\n    return\
    \ res\n}\n", "    if len(l1) == 0 || len(l2) == 0 {\n        return []int{}\n\
    \    }\n    i, j := 0, 0\n    unique := []int{}\n    for {\n        if l1[i] ==\
    \ l2[j] {\n            unique = append(unique, l1[i])\n            for i < len(l1)\
    \ && l1[i] == l1[i+1] {\n                i++\n            }\n            for j\
    \ < len(l2) && l2[j] == l2[j+1] {\n                j++\n            }\n      \
    \      i++\n            j++\n        } else if l1[i] < l2[j] {\n            i++\n\
    \        } else {\n            j++\n        }\n        if i == len(l1) || j ==\
    \ len(l2) {\n            break\n        }\n    }\n    return unique\n}\n", " \
    \   // YOUR CODE HERE\n    return []int{}\n}\n", "    m := make(map[int]bool)\n\
    \    s := make([]int, 0)\n    for _, n := range l1 {\n        m[n] = true\n  \
    \  }\n    for _, n := range l2 {\n        if m[n] {\n            s = append(s,\
    \ n)\n        }\n    }\n    return s\n}\n", "    var result []int\n    for _,\
    \ i := range l1 {\n        for _, j := range l2 {\n            if i == j {\n \
    \               result = append(result, i)\n            }\n        }\n    }\n\
    \    return result\n}\n", "    s := map[int]bool{}\n    for _, v := range l1 {\n\
    \        s[v] = true\n    }\n    res := []int{}\n    for _, v := range l2 {\n\
    \        if s[v] {\n            res = append(res, v)\n        }\n    }\n    quickSort(res)\n\
    \    return unique(res)\n}\n", "    var res []int\n    for _, v1 := range l1 {\n\
    \        for _, v2 := range l2 {\n            if v1 == v2 {\n                res\
    \ = append(res, v1)\n            }\n        }\n    }\n    return res\n}\n", " \
    \   // Use maps for sorting\n    dict := make(map[int]int)\n    for _, v := range\
    \ l1 {\n        dict[v] = 0\n    }\n    for _, v := range l2 {\n        dict[v]\
    \ = 0\n    }\n    // Sort values\n    values := make([]int, len(dict))\n    i\
    \ := 0\n    for k := range dict {\n        values[i] = k\n        i++\n    }\n\
    \    sort(values)\n    // Retrieve unique common elements\n    unique := make([]int,\
    \ 0)\n    isUnique := true\n    for _, v := range values {\n        if isUnique\
    \ {\n            unique = append(unique, v)\n        }\n        isUnique = true\n\
    \        for _, u := range unique {\n            if v == u {\n               \
    \ isUnique = false\n                break\n            }\n        }\n    }\n \
    \   return unique\n}\n", '    uniques := map[int]', "    sort(l1)\n    sort(l2)\n\
    \    c := make([]int, 0)\n    i, j := 0, 0\n    for i < len(l1) && j < len(l2)\
    \ {\n        if l1[i] == l2[j] {\n            c = append(c, l1[i])\n         \
    \   i += 1\n            j += 1\n        } else if l1[i] < l2[j] {\n          \
    \  i += 1\n        } else {\n            j += 1\n        }\n    }\n    return\
    \ c\n}\n", "    if len(l1) == 0 || len(l2) == 0 {\n        return []int{}\n  \
    \  }\n    s1 := 0\n    s2 := 0\n    // sort.Ints(l1)\n    // sort.Ints(l2)\n \
    \   result := []int{}\n    for {\n        if l1[s1] == l2[s2] {\n            result\
    \ = append(result, l1[s1])\n            s1 += 1\n            s2 += 1\n       \
    \ } else if l1[s1] < l2[s2] {\n            s1 += 1\n        } else {\n       \
    \     s2 += 1\n        }\n        if s1 >= len(l1) || s2 >= len(l2) {\n      \
    \      break\n        }\n    }\n    return result\n}\n", "    var comm []int\n\
    \    for _, v1 := range l1 {\n        for _, v2 := range l2 {\n            if\
    \ v1 == v2 {\n                comm = append(comm, v1)\n            }\n       \
    \ }\n    }\n    fmt.Println(comm)\n    return comm\n}\n", "    var common []int\n\
    \    for _, val1 := range l1 {\n        for _, val2 := range l2 {\n          \
    \  if val1 == val2 {\n                if !contains(common, val1) {\n         \
    \           common = append(common, val1)\n                }\n            }\n\
    \        }\n    }\n    return common\n}\n", "    // TODO: Write your code here\n\
    \    return []int{}\n}\n", "    unique := map[int]bool{}\n    var c []int\n  \
    \  for _, value := range l1 {\n        unique[value] = true\n    }\n    for _,\
    \ value := range l2 {\n        if unique[value] {\n            c = append(c, value)\n\
    \        }\n    }\n    return c\n}\n", "    var r []int\n    var l = make(map[int]int)\n\
    \    for _, v := range l1 {\n        l[v] = 0\n    }\n    for _, v := range l2\
    \ {\n        if _, ok := l[v]; ok {\n            l[v]++\n        }\n    }\n  \
    \  for k, v := range l {\n        if v == 0 {\n            r = append(r, k)\n\
    \        }\n    }\n    return r\n}\n", "    l1 = unique(l1)\n    l2 = unique(l2)\n\
    \    l1Set := make(map[int]bool)\n    for _, n := range l1 {\n        l1Set[n]\
    \ = true\n    }\n    res := make([]int, 0)\n    for _, n := range l2 {\n     \
    \   if l1Set[n] {\n            res = append(res, n)\n        }\n    }\n    return\
    \ res\n}\n", "    m := make(map[int]bool)\n    for _, v := range l1 {\n      \
    \  m[v] = true\n    }\n    list := make([]int, 0)\n    for _, v := range l2 {\n\
    \        if m[v] {\n            list = append(list, v)\n        }\n    }\n   \
    \ return list\n}\n", "    m := make(map[int]int)\n    for _, v := range l1 {\n\
    \        m[v]++\n    }\n    for _, v := range l2 {\n        m[v]++\n    }\n  \
    \  var out []int\n    for k, v := range m {\n        if v == 2 {\n           \
    \ out = append(out, k)\n        }\n    }\n    return out\n}\n", "    set := make(map[int]int)\n\
    \    for _, v := range l1 {\n        set[v] = 0\n    }\n    for _, v := range\
    \ l2 {\n        if _, ok := set[v]; ok {\n            set[v]++\n        }\n  \
    \  }\n    // convert set to sorted list\n    var list []int\n    for k, _ := range\
    \ set {\n        list = append(list, k)\n    }\n    l := len(list)\n    for i\
    \ := 0; i < l; i++ {\n        for j := i+1; j < l; j++ {\n            if list[i]\
    \ > list[j] {\n                list[i], list[j] = list[j], list[i]\n         \
    \   }\n        }\n    }\n    return list\n}\n", "    ret := []int{}\n    m :=\
    \ map[int]bool{}\n    for _, e := range l1 {\n        m[e] = true\n    }\n   \
    \ for _, e := range l2 {\n        if m[e] {\n            ret = append(ret, e)\n\
    \        }\n    }\n    ret = uniq(ret)\n    return ret\n}\n", "    set := make(map[int]bool)\n\
    \    var result []int\n    for _, i := range l1 {\n        set[i] = true\n   \
    \ }\n    for _, i := range l2 {\n        if set[i] {\n            result = append(result,\
    \ i)\n        }\n    }\n    return result\n}\n", "    len_l1 := len(l1)\n    len_l2\
    \ := len(l2)\n    len_max := len_l1\n    if len_l2 > len_l1 {\n        len_max\
    \ = len_l2\n    }\n    result := make([]int, 0, len_max)\n    if len_l1 == 0 ||\
    \ len_l2 == 0 {\n        return result\n    }\n    if len_l1 == 1 && len_l2 ==\
    \ 1 {\n        if l1[0] == l2[0] {\n            result = append(result, l1[0])\n\
    \        }\n        return result\n    }\n    c1 := l1[len_l1 / 2]\n    c2 :=\
    \ l2[len_l2 / 2]\n    if c1 == c2 {\n        result = append(result, c1)\n   \
    \ }\n    if c1 <= c2 {\n        result = append(result, common(l1[len_l1 / 2:],\
    \ l2[:len_l2 / 2])...)\n    } else {\n        result = append(result, common(l1[:len_l1\
    \ / 2], l2[len_l2 / 2:])...)\n    }\n    return result\n}\n", "    var t = make(map[int]int)\n\
    \    var r = make([]int, 0)\n    for _, v := range l1 {\n        t[v] = v\n  \
    \  }\n    for _, v := range l2 {\n        if _, ok := t[v]; ok {\n           \
    \ r = append(r, v)\n        }\n    }\n    return r\n}\n", "    set := make(map[int]bool)\n\
    \    res := make([]int, 0)\n    for _, i := range l1 {\n        set[i] = true\n\
    \    }\n    for _, i := range l2 {\n        if set[i] {\n            res = append(res,\
    \ i)\n        }\n    }\n    return res\n}\n", "    for _,v := range l1 {\n   \
    \     for k,vv := range l2 {\n            if v == vv {\n                l2 = append(l2[:k],\
    \ l2[k+1:]...)\n            }\n        }\n    }\n    return l2\n}\n", "    result\
    \ := []int{}\n    for _, value := range l1 {\n        for _, value2 := range l2\
    \ {\n            if value == value2 {\n                result = append(result,\
    \ value)\n            }\n        }\n    }\n    return result\n}\n", "    var l\
    \ []int\n    x := 0\n    y := 0\n    for x < len(l1) && y < len(l2) {\n      \
    \  if l1[x] == l2[y] {\n            l = append(l, l1[x])\n            x++\n  \
    \          y++\n        } else if l1[x] < l2[y] {\n            x++\n        }\
    \ else {\n            y++\n        }\n    }\n    return l\n}\n", "    if len(l1)\
    \ == 0 || len(l2) == 0 {\n        return []int{}\n    }\n    var result []int\n\
    \    i := 0\n    j := 0\n    for i < len(l1) && j < len(l2) {\n        if l1[i]\
    \ == l2[j] {\n            result = append(result, l1[i])\n            i++\n  \
    \          j++\n        } else if l1[i] < l2[j] {\n            i++\n        }\
    \ else {\n            j++\n        }\n    }\n    return result\n}\n", "    m :=\
    \ make(map[int]bool)\n    for _, v := range l1 {\n        m[v] = true\n    }\n\
    \    res := make([]int, 0)\n    for _, v := range l2 {\n        if m[v] {\n  \
    \          res = append(res, v)\n        }\n    }\n    return res\n}\n", "   \
    \ if len(l1) == 0 || len(l2) == 0 {\n        return []int{}\n    }\n    if len(l1)\
    \ > len(l2) {\n        l1, l2 = l2, l1\n    }\n    m := make(map[int]bool)\n \
    \   c := make([]int, 0)\n    for _, e := range l1 {\n        m[e] = true\n   \
    \ }\n    for _, e := range l2 {\n        if m[e] {\n            c = append(c,\
    \ e)\n            m[e] = false\n        }\n    }\n    return c\n}\n", "    if\
    \ len(l1) > len(l2) {\n        l1, l2 = l2, l1\n    }\n    uniq := make(map[int]",
  "    res := []int{}\n    m := map[int]int{}\n    for _,v := range l1 {\n       \
    \ m[v] = 0\n    }\n    for _,v := range l2 {\n        if _,ok := m[v]; ok {\n\
    \            m[v]++\n        }\n    }\n    for k,v := range m {\n        if v\
    \ != 0 {\n            res = append(res, k)\n        }\n    }\n    return res\n\
    }\n", "    // TODO: Implement me!\n    return []int{}\n}\n", "    m := make(map[int]bool)\n\
    \    result := make([]int, 0)\n    //  Iterate list 1 and store unique elements\
    \ into a map\n    for _, v := range l1 {\n        m[v] = true\n    }\n    // \
    \ Iterate list 2 and verify if elements are in the map.\n    //  Store common\
    \ elements into result list.\n    for _, v := range l2 {\n        if m[v] {\n\
    \            result = append(result, v)\n        }\n    }\n    return result\n\
    }\n", "    r := []int{}\n    mp := make(map[int]bool)\n    for _, e := range l1\
    \ {\n        mp[e] = true\n    }\n    for _, e := range l2 {\n        if mp[e]\
    \ {\n            r = append(r, e)\n        }\n    }\n    return r\n}\n", "   \
    \ m := make(map[int]int)\n    for _, n := range l1 {\n        m[n]++\n    }\n\
    \    for _, n := range l2 {\n        m[n]++\n    }\n    res := make([]int, 0)\n\
    \    for k, v := range m {\n        if v == 2 {\n            res = append(res,\
    \ k)\n        }\n    }\n    return res\n}\n", "    m := make(map[int]int)\n  \
    \  slice := make([]int, 0)\n    for _, v := range l1 {\n        if _, ok := m[v];\
    \ !ok {\n            m[v] = v\n        }\n    }\n    for _, v := range l2 {\n\
    \        if _, ok := m[v]; ok {\n            slice = append(slice, v)\n      \
    \  }\n    }\n    return slice\n}\n", "    m := make(map[int]int)\n    for _, v\
    \ := range l1 {\n        m[v]++\n    }\n    for _, v := range l2 {\n        m[v]++\n\
    \    }\n    l := make([]int, 0)\n    for k, v := range m {\n        if v == 2\
    \ {\n            l = append(l, k)\n        }\n    }\n    return l\n}\n", "   \
    \ var res []int\n    if len(l1) == 0 || len(l2) == 0 {\n        return res\n \
    \   }\n    maxLen := len(l1)\n    var i = 0\n    var j = 0\n    if len(l2) > maxLen\
    \ {\n        maxLen = len(l2)\n    }\n    for i < maxLen && j < maxLen {\n   \
    \     for j < maxLen && l1[i] < l2[j] {\n            j++\n        }\n        if\
    \ j < maxLen && l1[i] == l2[j] {\n            res = append(res, l1[i])\n     \
    \       j++\n        }\n        i++\n    }\n    return res\n}\n", "    res :=\
    \ []int{}\n    for _, v1 := range l1 {\n        for _, v2 := range l2 {\n    \
    \        if v1 == v2 {\n                res = append(res, v1)\n            }\n\
    \        }\n    }\n    return res\n}\n", "    var result []int\n    // XXX finish\
    \ this\n    return result\n}\n", "    if len(l1) == 0 || len(l2) == 0 {\n    \
    \    return []int{}\n    }\n    ll1 := len(l1)\n    ll2 := len(l2)\n    if ll1\
    \ > ll2 {\n        l1, l2 = l2, l1\n        ll1, ll2 = ll2, ll1\n    }\n    m\
    \ := make(map[int]int)\n    for _, v := range l1 {\n        m[v]++\n    }\n  \
    \  var result []int\n    for _, v := range l2 {\n        if _, ok := m[v]; ok\
    \ {\n            m[v]++\n            if m[v] == 2 {\n                result =\
    \ append(result, v)\n            }\n        }\n    }\n    return result\n}\n",
  "    l1 = unique(l1)\n    l2 = unique(l2)\n    var answer []int\n    for _, e1 :=\
    \ range l1 {\n        for _, e2 := range l2 {\n            if e1 == e2 {\n   \
    \             answer = append(answer, e1)\n            }\n        }\n    }\n \
    \   return answer\n}\n", "    if len(l1) == 0 || len(l2) == 0 {\n        return\
    \ nil\n    }\n    l1 = sortList(l1)\n    l2 = sortList(l2)\n    if l1[0] > l2[len(l2)-1]\
    \ || l2[0] > l1[len(l1)-1] {\n        return nil\n    }\n    var result []int\n\
    \    var j int\n    for i, v := range l1 {\n        if i != 0 && v == l1[i-1]\
    \ {\n            continue\n        }\n        for j < len(l2) && l2[j] < v {\n\
    \            j++\n        }\n        if j < len(l2) && l2[j] == v {\n        \
    \    result = append(result, v)\n        }\n    }\n    return result\n}\n", " \
    \   m := make(map[int]bool)\n    for _, v := range l1 {\n        m[v] = true\n\
    \    }\n    r := make([]int, 0)\n    for _, v := range l2 {\n        if m[v] {\n\
    \            r = append(r, v)\n        }\n    }\n    return r\n}\n", "    uniq\
    \ := make(map[int]int)\n    for _, i := range l1 {\n        uniq[i] = i\n    }\n\
    \    for _, i := range l2 {\n        uniq[i] = i\n    }\n    res := make([]int,\
    \ 0, len(uniq))\n    for _, i := range uniq {\n        res = append(res, i)\n\
    \    }\n    return res\n}\n", "    // Make 2 lookup maps of the values.\n    m1\
    \ := make(map[int]bool)\n    m2 := make(map[int]bool)\n    for _, val := range\
    \ l1 {\n        m1[val] = true\n    }\n    for _, val := range l2 {\n        m2[val]\
    \ = true\n    }\n\n    // Make a slice of the keys that are in both maps.\n  \
    \  var common []int\n    for k := range m1 {\n        if m2[k] {\n           \
    \ common = append(common, k)\n        }\n    }\n\n    // Sort the slice (optional).\n\
    \    for i := 0; i < len(common); i++ {\n        for j := i + 1; j < len(common);\
    \ j++ {\n            if common[i] > common[j] {\n                temp := common[i]\n\
    \                common[i] = common[j]\n                common[j] = temp\n   \
    \         }\n        }\n    }\n\n    return common\n}\n", "    var (\n       \
    \ ll1 = len(l1)\n        ll2 = len(l2)\n        res = make([]int, 0)\n    )\n\
    \    if ll1 <= 0 || ll2 <= 0 {\n        return res\n    }\n    if ll1 > ll2 {\n\
    \        l1, l2 = l2, l1\n        ll1, ll2 = ll2, ll1\n    }\n    for i := 0;\
    \ i < ll1; i++ {\n        for j := 0; j < ll2; j++ {\n            if l1[i] ==\
    \ l2[j] {\n                res = append(res, l1[i])\n                break\n \
    \           }\n        }\n    }\n    return res\n}\n", "    l1m := map[int]bool{}\n\
    \    l2m := map[int]bool{}\n    for _, v := range l1 {\n        l1m[v] = true\n\
    \    }\n    for _, v := range l2 {\n        l2m[v] = true\n    }\n    var res\
    \ []int\n    for v := range l1m {\n        if l2m[v] {\n            res = append(res,\
    \ v)\n        }\n    }\n    return res\n}\n", "    var list1, list2 []int\n  \
    \  if len(l1) > len(l2) {\n        list1 = l1\n        list2 = l2\n    } else\
    \ {\n        list1 = l2\n        list2 = l1\n    }\n    var result []int\n   \
    \ m := make(map[int]bool)\n    for _, val := range list1 {\n        m[val] = true\n\
    \    }\n    for _, val := range list2 {\n        if m[val] {\n            result\
    \ = append(result, val)\n        }\n    }\n    return result\n}\n", "    return\
    \ nil\n}\n", "    m := make(map[int]bool)\n    // Iterate over the l1 in reverse\
    \ and build a map of integers:true\n    for i := len(l1) - 1; i >= 0; i-- {\n\
    \        m[l1[i]] = true\n    }\n    // Iterate over the l2 and collect the elements\
    \ which exist in the map\n    var result []int\n    for i := 0; i < len(l2); i++\
    \ {\n        if m[l2[i]] {\n            result = append(result, l2[i])\n     \
    \   }\n    }\n    return result\n}\n", "    res := []int{}\n    for _, e1 := range\
    \ l1 {\n        for _, e2 := range l2 {\n            if e1 == e2 {\n         \
    \       res = append(res, e1)\n            }\n        }\n    }\n    return res\n\
    }\n", "    if len(l1) == 0 || len(l2) == 0 {\n        return []int{}\n    }\n\
    \    var set map[int]bool = make(map[int]bool)\n    var i, j int = 0, 0\n    var\
    \ slice []int = []int{}\n    for i < len(l1) && j < len(l2) {\n        if l1[i]\
    \ == l2[j] {\n            if _, ok := set[l1[i]]; !ok {\n                slice\
    \ = append(slice, l1[i])\n                set[l1[i]] = true\n            }\n \
    \           i++\n            j++\n        } else if l1[i] < l2[j] {\n        \
    \    i++\n        } else {\n            j++\n        }\n    }\n    return slice\n\
    }\n", "    l1_map := make(map[int]bool)\n    for _, n := range l1 {\n        l1_map[n]\
    \ = true\n    }\n    l2_map := make(map[int]bool)\n    for _, n := range l2 {\n\
    \        l2_map[n] = true\n    }\n    result := make([]int, 0)\n    for i, _ :=\
    \ range l1_map {\n        if l2_map[i] {\n            result = append(result,\
    \ i)\n        }\n    }\n    return result\n}\n", "    result := []int{}\n    //In\
    \ the case that l1 is empty, the below code will not be executed\n    //In the\
    \ case that l2 is empty, the below code will not be executed\n    if (len(l1)\
    \ > 0) && (len(l2) > 0) {\n        for _, a := range l1 {\n            for _,\
    \ b := range l2 {\n                if a == b {\n                    result = append(result,\
    \ a)\n                }\n            }\n        }\n    }\n    return result\n\
    }\n", "    m := make(map[int]int)\n    result := make([]int, 0)\n    for _, v\
    \ := range l1 {\n        if _, ok := m[v]; !ok {\n            m[v] = 1\n     \
    \   }\n    }\n    for _, v := range l2 {\n        if _, ok := m[v]; ok {\n   \
    \         m[v] = m[v] + 1\n        }\n    }\n    for k, v := range m {\n     \
    \   if v > 1 {\n            result = append(result, k)\n        }\n    }\n   \
    \ return result\n}\n", "    // length of both lists\n    m := len(l1)\n    n :=\
    \ len(l2)\n\n    l := make([]int, m)\n    p := 0\n\n    // we don't want to sort\
    \ in place,\n    // as we need to return the original lists\n    c1 := make([]int,\
    \ m)\n    copy(c1, l1)\n    sort(c1)\n\n    c2 := make([]int, n)\n    copy(c2,\
    \ l2)\n    sort(c2)\n\n    i := 0\n    j := 0\n    for i < m && j < n {\n    \
    \    if c1[i] == c2[j] {\n            l[p] = c1[i]\n            p++\n        \
    \    i++\n            j++\n        } else if c1[i] < c2[j] {\n            i++\n\
    \        } else {\n            j++\n        }\n    }\n\n    return l[:p]\n}\n",
  "    m := make(map[int]int)\n    for _, v := range l1 {\n        m[v]++\n    }\n\
    \    for _, v := range l2 {\n        m[v]++\n    }\n    var r []int\n    for k,\
    \ v := range m {\n        if v > 1 {\n            r = append(r, k)\n        }\n\
    \    }\n    return r\n}\n", "    m := make(map[int]int)\n    for _, i := range\
    \ l1 {\n        m[i] = 1\n    }\n    for _, i := range l2 {\n        if m[i] ==\
    \ 1 {\n            m[i] = 2\n        }\n    }\n    common := make([]int, 0)\n\
    \    for i, j := range m {\n        if j == 2 {\n            common = append(common,\
    \ i)\n        }\n    }\n    return common\n}\n", "    ll := make([]int, 0)\n \
    \   m := make(map[int]int)\n    for _, v := range l1 {\n        if _, ok := m[v];\
    \ !ok {\n            m[v] = 1\n        }\n    }\n    for _, v := range l2 {\n\
    \        if _, ok := m[v]; ok {\n            ll = append(ll, v)\n        }\n \
    \   }\n    return ll\n}\n", "    l := make([]int, 0)\n    for _, n1 := range l1\
    \ {\n        for _, n2 := range l2 {\n            if n1 == n2 {\n            \
    \    l = append(l, n1)\n            }\n        }\n    }\n    return l\n}\n", " \
    \   cache := make(map[int]int)\n    result := make([]int, 0)\n    for _, val :=\
    \ range l1 {\n        cache[val]++\n    }\n    for _, val := range l2 {\n    \
    \    if count, ok := cache[val]; ok && count > 0 {\n            result = append(result,\
    \ val)\n            cache[val]--\n        }\n    }\n    return result\n}\n", " \
    \   // create a map with all elements of l1\n    unique := make(map[int]", " \
    \   m := make(map[int]bool)\n    for _, v := range l1 {\n        m[v] = true\n\
    \    }\n    r := make([]int, 0)\n    for _, v := range l2 {\n        if m[v] {\n\
    \            r = append(r, v)\n        }\n    }\n    return r\n}\n", "    var\
    \ commonList []int\n    for _, e1 := range l1 {\n        for _, e2 := range l2\
    \ {\n            if e1 == e2 {\n                commonList = append(commonList,\
    \ e1)\n            }\n        }\n    }\n    return commonList\n}\n", "    set\
    \ := make(map[int]bool)\n    res := make([]int, 0)\n    for _, val := range l1\
    \ {\n        set[val] = true\n    }\n    for _, val := range l2 {\n        if\
    \ set[val] {\n            res = append(res, val)\n        }\n    }\n    for i\
    \ := 0; i < len(res); i++ {\n        for j := i + 1; j < len(res); j++ {\n   \
    \         if res[i] > res[j] {\n                tmp := res[i]\n              \
    \  res[i] = res[j]\n                res[j] = tmp\n            }\n        }\n \
    \   }\n    return res\n}\n", "    var r []int\n    m := make(map[int]int)\n  \
    \  for _, v := range l1 {\n        m[v]++\n    }\n    for _, v := range l2 {\n\
    \        if m[v] > 0 {\n            r = append(r, v)\n            m[v] = 0\n \
    \       }\n    }\n    return r\n}\n", "    var result []int\n    for _, v1 :=\
    \ range l1 {\n        for _, v2 := range l2 {\n            if v1 == v2 {\n   \
    \             result = append(result, v1)\n            }\n        }\n    }\n \
    \   return result\n}\n", "    m := make(map[int]bool)\n    res := make([]int,\
    \ 0)\n\n    for _, v := range l1 {\n        m[v] = true\n    }\n\n    for _, v\
    \ := range l2 {\n        if _, ok := m[v]; ok {\n            res = append(res,\
    \ v)\n        }\n    }\n\n    return res\n}\n", "    if len(l1) > len(l2) {\n\
    \        l1, l2 = l2, l1\n    }\n    ret := make([]int, 0, len(l1))\n    for _,\
    \ n := range l1 {\n        if find(l2, n) {\n            ret = append(ret, n)\n\
    \        }\n    }\n    return ret\n}\n", "    result := []int{}\n    m := make(map[int]bool)\n\
    \    for _, e := range l1 {\n        m[e] = true\n    }\n    for _, e := range\
    \ l2 {\n        if m[e] {\n            result = append(result, e)\n        }\n\
    \    }\n    return result\n}\n", "    i1 := 0\n    i2 := 0\n    r := []int{}\n\
    \    for i1 < len(l1) && i2 < len(l2) {\n        v1 := l1[i1]\n        v2 := l2[i2]\n\
    \        if v1 == v2 {\n            r = append(r, v1)\n            i1++\n    \
    \        i2++\n        } else if v1 < v2 {\n            i1++\n        } else {\n\
    \            i2++\n        }\n    }\n    return r\n}\n", "    var res []int\n\
    \    m := make(map[int]bool)\n    for _, v := range l1 {\n        m[v] = true\n\
    \    }\n    for _, v := range l2 {\n        if m[v] {\n            res = append(res,\
    \ v)\n        }\n    }\n    return res\n}\n", "    if len(l1) == 0 || len(l2)\
    \ == 0 {\n        return []int{}\n    }\n    set1 := set(l1)\n    set2 := set(l2)\n\
    \    if len(set1) < len(set2) {\n        return commonUnique(set1, set2)\n   \
    \ }\n    return commonUnique(set2, set1)\n}\n", "    var res []int\n    if len(l1)\
    \ == 0 || len(l2) == 0 {\n        return res\n    }\n    m := make(map[int]int)\n\
    \    for _, v := range l1 {\n        m[v] = v\n    }\n    for _, v := range l2\
    \ {\n        if _, ok := m[v]; ok {\n            res = append(res, v)\n      \
    \  }\n    }\n    return res\n}\n", "    if l1 == nil || l2 == nil {\n        return\
    \ nil\n    }\n    short, long := l1, l2\n    if len(l1) > len(l2) {\n        short,\
    \ long = l2, l1\n    }\n    var result []int\n    hashMap := make(map[int]bool)\n\
    \    for _, v := range short {\n        hashMap[v] = true\n    }\n    for _, v\
    \ := range long {\n        if hashMap[v] {\n            result = append(result,\
    \ v)\n            hashMap[v] = false\n        }\n    }\n    return result\n}\n",
  "    // from list 1, build a map of values\n    m := make(map[int]bool)\n    for\
    \ _, v := range l1 {\n        m[v] = true\n    }\n\n    // build output list of\
    \ common elements\n    o := make([]int, 0)\n    for _, v := range l2 {\n     \
    \   if m[v] {\n            o = append(o, v)\n        }\n    }\n\n    return o\n\
    }\n", "    // Implement your solution here\n\n    return []int{}\n}\n", "    if\
    \ len(l1) > len(l2) {\n        l1, l2 = l2, l1\n    }\n    s := make([]int, 0,\
    \ len(l1))\n    c := make(map[int]int)\n    for _, v := range l1 {\n        c[v]++\n\
    \    }\n    for _, v := range l2 {\n        c[v]++\n    }\n    for k, v := range\
    \ c {\n        if v > 1 {\n            s = append(s, k)\n        }\n    }\n  \
    \  return s\n}\n", "    m := make(map[int]bool)\n    for _, v := range l1 {\n\
    \        m[v] = true\n    }\n    var r []int\n    for _, v := range l2 {\n   \
    \     if m[v] {\n            r = append(r, v)\n        }\n    }\n    return r\n\
    }\n", "    result := []int{}\n    m := make(map[int]int)\n    for _, v := range\
    \ l1 {\n        m[v] = 1\n    }\n    for _, v := range l2 {\n        m[v] += 1\n\
    \    }\n    for k, v := range m {\n        if v > 1 {\n            result = append(result,\
    \ k)\n        }\n    }\n    return result\n}\n", "    l1Map := make(map[int]int)\n\
    \    for _, v := range l1 {\n        l1Map[v] = 1\n    }\n    l2Map := make(map[int]int)\n\
    \    for _, v := range l2 {\n        l2Map[v] = 1\n    }\n    result := make([]int,\
    \ 0)\n    for k, _ := range l1Map {\n        if _, ok := l2Map[k]; ok {\n    \
    \        result = append(result, k)\n        }\n    }\n    return result\n}\n",
  "    var result []int\n    uniqL1 := make(map[int]bool)\n    uniqL2 := make(map[int]bool)\n\
    \    for _, v := range l1 {\n        uniqL1[v] = true\n    }\n    for _, v :=\
    \ range l2 {\n        uniqL2[v] = true\n    }\n    for k, _ := range uniqL1 {\n\
    \        if uniqL2[k] {\n            result = append(result, k)\n        }\n \
    \   }\n    return result\n}\n", "    var result []int\n    m := make(map[int]bool)\n\
    \    for _, n := range l1 {\n        m[n] = true\n    }\n    for _, n := range\
    \ l2 {\n        if m[n] {\n            result = append(result, n)\n        }\n\
    \    }\n    return result\n}\n", "    m := make(map[int]bool)\n    for _, x :=\
    \ range l1 {\n        m[x] = true\n    }\n    for _, x := range l2 {\n       \
    \ m[x] = true\n    }\n    s := make([]int, 0, len(m))\n    for k, _ := range m\
    \ {\n        s = append(s, k)\n    }\n    return s\n}\n", "    common := []int{}\n\
    \    m := make(map[int]bool)\n    for _, v := range l1 {\n        m[v] = true\n\
    \    }\n    for _, v := range l2 {\n        if m[v] {\n            common = append(common,\
    \ v)\n        }\n    }\n    return common\n}\n", "    set := make(map[int]bool)\n\
    \    for _, item := range l1 {\n        set[item] = true\n    }\n    result :=\
    \ make([]int, 0)\n    for _, item := range l2 {\n        if set[item] {\n    \
    \        result = append(result, item)\n        }\n    }\n    return result\n\
    }\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
